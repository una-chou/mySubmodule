var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var _a, _b, _c;
import * as BABYLON$1 from "@babylonjs/core";
import { Color3 as Color3$1, SceneLoader, DataReader, RuntimeError as RuntimeError$1, ErrorCodes as ErrorCodes$1, NodeMaterial, ParticleHelper, GUID, MeshBuilder, CubeTexture, StandardMaterial, Texture as Texture$1 } from "@babylonjs/core";
import * as BABYLONGUI from "@babylonjs/gui";
import { Control } from "@babylonjs/gui";
import { GLTFFileLoader } from "@babylonjs/loaders";
import axios from "axios";
var Easing = {
  Linear: {
    None: function(amount) {
      return amount;
    }
  },
  Quadratic: {
    In: function(amount) {
      return amount * amount;
    },
    Out: function(amount) {
      return amount * (2 - amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount;
      }
      return -0.5 * (--amount * (amount - 2) - 1);
    }
  },
  Cubic: {
    In: function(amount) {
      return amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount + 2);
    }
  },
  Quartic: {
    In: function(amount) {
      return amount * amount * amount * amount;
    },
    Out: function(amount) {
      return 1 - --amount * amount * amount * amount;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount;
      }
      return -0.5 * ((amount -= 2) * amount * amount * amount - 2);
    }
  },
  Quintic: {
    In: function(amount) {
      return amount * amount * amount * amount * amount;
    },
    Out: function(amount) {
      return --amount * amount * amount * amount * amount + 1;
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return 0.5 * amount * amount * amount * amount * amount;
      }
      return 0.5 * ((amount -= 2) * amount * amount * amount * amount + 2);
    }
  },
  Sinusoidal: {
    In: function(amount) {
      return 1 - Math.cos(amount * Math.PI / 2);
    },
    Out: function(amount) {
      return Math.sin(amount * Math.PI / 2);
    },
    InOut: function(amount) {
      return 0.5 * (1 - Math.cos(Math.PI * amount));
    }
  },
  Exponential: {
    In: function(amount) {
      return amount === 0 ? 0 : Math.pow(1024, amount - 1);
    },
    Out: function(amount) {
      return amount === 1 ? 1 : 1 - Math.pow(2, -10 * amount);
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      if ((amount *= 2) < 1) {
        return 0.5 * Math.pow(1024, amount - 1);
      }
      return 0.5 * (-Math.pow(2, -10 * (amount - 1)) + 2);
    }
  },
  Circular: {
    In: function(amount) {
      return 1 - Math.sqrt(1 - amount * amount);
    },
    Out: function(amount) {
      return Math.sqrt(1 - --amount * amount);
    },
    InOut: function(amount) {
      if ((amount *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - amount * amount) - 1);
      }
      return 0.5 * (Math.sqrt(1 - (amount -= 2) * amount) + 1);
    }
  },
  Elastic: {
    In: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return -Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
    },
    Out: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      return Math.pow(2, -10 * amount) * Math.sin((amount - 0.1) * 5 * Math.PI) + 1;
    },
    InOut: function(amount) {
      if (amount === 0) {
        return 0;
      }
      if (amount === 1) {
        return 1;
      }
      amount *= 2;
      if (amount < 1) {
        return -0.5 * Math.pow(2, 10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI);
      }
      return 0.5 * Math.pow(2, -10 * (amount - 1)) * Math.sin((amount - 1.1) * 5 * Math.PI) + 1;
    }
  },
  Back: {
    In: function(amount) {
      var s = 1.70158;
      return amount * amount * ((s + 1) * amount - s);
    },
    Out: function(amount) {
      var s = 1.70158;
      return --amount * amount * ((s + 1) * amount + s) + 1;
    },
    InOut: function(amount) {
      var s = 1.70158 * 1.525;
      if ((amount *= 2) < 1) {
        return 0.5 * (amount * amount * ((s + 1) * amount - s));
      }
      return 0.5 * ((amount -= 2) * amount * ((s + 1) * amount + s) + 2);
    }
  },
  Bounce: {
    In: function(amount) {
      return 1 - Easing.Bounce.Out(1 - amount);
    },
    Out: function(amount) {
      if (amount < 1 / 2.75) {
        return 7.5625 * amount * amount;
      } else if (amount < 2 / 2.75) {
        return 7.5625 * (amount -= 1.5 / 2.75) * amount + 0.75;
      } else if (amount < 2.5 / 2.75) {
        return 7.5625 * (amount -= 2.25 / 2.75) * amount + 0.9375;
      } else {
        return 7.5625 * (amount -= 2.625 / 2.75) * amount + 0.984375;
      }
    },
    InOut: function(amount) {
      if (amount < 0.5) {
        return Easing.Bounce.In(amount * 2) * 0.5;
      }
      return Easing.Bounce.Out(amount * 2 - 1) * 0.5 + 0.5;
    }
  }
};
var now;
if (typeof self === "undefined" && typeof process !== "undefined" && process.hrtime) {
  now = function() {
    var time = process.hrtime();
    return time[0] * 1e3 + time[1] / 1e6;
  };
} else if (typeof self !== "undefined" && self.performance !== void 0 && self.performance.now !== void 0) {
  now = self.performance.now.bind(self.performance);
} else if (Date.now !== void 0) {
  now = Date.now;
} else {
  now = function() {
    return new Date().getTime();
  };
}
var now$1 = now;
var Group = function() {
  function Group2() {
    this._tweens = {};
    this._tweensAddedDuringUpdate = {};
  }
  Group2.prototype.getAll = function() {
    var _this = this;
    return Object.keys(this._tweens).map(function(tweenId) {
      return _this._tweens[tweenId];
    });
  };
  Group2.prototype.removeAll = function() {
    this._tweens = {};
  };
  Group2.prototype.add = function(tween) {
    this._tweens[tween.getId()] = tween;
    this._tweensAddedDuringUpdate[tween.getId()] = tween;
  };
  Group2.prototype.remove = function(tween) {
    delete this._tweens[tween.getId()];
    delete this._tweensAddedDuringUpdate[tween.getId()];
  };
  Group2.prototype.update = function(time, preserve) {
    if (time === void 0) {
      time = now$1();
    }
    if (preserve === void 0) {
      preserve = false;
    }
    var tweenIds = Object.keys(this._tweens);
    if (tweenIds.length === 0) {
      return false;
    }
    while (tweenIds.length > 0) {
      this._tweensAddedDuringUpdate = {};
      for (var i = 0; i < tweenIds.length; i++) {
        var tween = this._tweens[tweenIds[i]];
        var autoStart = !preserve;
        if (tween && tween.update(time, autoStart) === false && !preserve) {
          delete this._tweens[tweenIds[i]];
        }
      }
      tweenIds = Object.keys(this._tweensAddedDuringUpdate);
    }
    return true;
  };
  return Group2;
}();
var Interpolation = {
  Linear: function(v, k) {
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);
    var fn = Interpolation.Utils.Linear;
    if (k < 0) {
      return fn(v[0], v[1], f);
    }
    if (k > 1) {
      return fn(v[m], v[m - 1], m - f);
    }
    return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);
  },
  Bezier: function(v, k) {
    var b = 0;
    var n = v.length - 1;
    var pw = Math.pow;
    var bn = Interpolation.Utils.Bernstein;
    for (var i = 0; i <= n; i++) {
      b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
    }
    return b;
  },
  CatmullRom: function(v, k) {
    var m = v.length - 1;
    var f = m * k;
    var i = Math.floor(f);
    var fn = Interpolation.Utils.CatmullRom;
    if (v[0] === v[m]) {
      if (k < 0) {
        i = Math.floor(f = m * (1 + k));
      }
      return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);
    } else {
      if (k < 0) {
        return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
      }
      if (k > 1) {
        return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
      }
      return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);
    }
  },
  Utils: {
    Linear: function(p0, p1, t) {
      return (p1 - p0) * t + p0;
    },
    Bernstein: function(n, i) {
      var fc = Interpolation.Utils.Factorial;
      return fc(n) / fc(i) / fc(n - i);
    },
    Factorial: function() {
      var a = [1];
      return function(n) {
        var s = 1;
        if (a[n]) {
          return a[n];
        }
        for (var i = n; i > 1; i--) {
          s *= i;
        }
        a[n] = s;
        return s;
      };
    }(),
    CatmullRom: function(p0, p1, p2, p3, t) {
      var v0 = (p2 - p0) * 0.5;
      var v1 = (p3 - p1) * 0.5;
      var t2 = t * t;
      var t3 = t * t2;
      return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
  }
};
var Sequence = function() {
  function Sequence2() {
  }
  Sequence2.nextId = function() {
    return Sequence2._nextId++;
  };
  Sequence2._nextId = 0;
  return Sequence2;
}();
var mainGroup = new Group();
var Tween = function() {
  function Tween2(_object, _group) {
    if (_group === void 0) {
      _group = mainGroup;
    }
    this._object = _object;
    this._group = _group;
    this._isPaused = false;
    this._pauseStart = 0;
    this._valuesStart = {};
    this._valuesEnd = {};
    this._valuesStartRepeat = {};
    this._duration = 1e3;
    this._initialRepeat = 0;
    this._repeat = 0;
    this._yoyo = false;
    this._isPlaying = false;
    this._reversed = false;
    this._delayTime = 0;
    this._startTime = 0;
    this._easingFunction = Easing.Linear.None;
    this._interpolationFunction = Interpolation.Linear;
    this._chainedTweens = [];
    this._onStartCallbackFired = false;
    this._id = Sequence.nextId();
    this._isChainStopped = false;
    this._goToEnd = false;
  }
  Tween2.prototype.getId = function() {
    return this._id;
  };
  Tween2.prototype.isPlaying = function() {
    return this._isPlaying;
  };
  Tween2.prototype.isPaused = function() {
    return this._isPaused;
  };
  Tween2.prototype.to = function(properties, duration) {
    this._valuesEnd = Object.create(properties);
    if (duration !== void 0) {
      this._duration = duration;
    }
    return this;
  };
  Tween2.prototype.duration = function(d) {
    this._duration = d;
    return this;
  };
  Tween2.prototype.start = function(time) {
    if (this._isPlaying) {
      return this;
    }
    this._group && this._group.add(this);
    this._repeat = this._initialRepeat;
    if (this._reversed) {
      this._reversed = false;
      for (var property in this._valuesStartRepeat) {
        this._swapEndStartRepeatValues(property);
        this._valuesStart[property] = this._valuesStartRepeat[property];
      }
    }
    this._isPlaying = true;
    this._isPaused = false;
    this._onStartCallbackFired = false;
    this._isChainStopped = false;
    this._startTime = time !== void 0 ? typeof time === "string" ? now$1() + parseFloat(time) : time : now$1();
    this._startTime += this._delayTime;
    this._setupProperties(this._object, this._valuesStart, this._valuesEnd, this._valuesStartRepeat);
    return this;
  };
  Tween2.prototype._setupProperties = function(_object, _valuesStart, _valuesEnd, _valuesStartRepeat) {
    for (var property in _valuesEnd) {
      var startValue = _object[property];
      var startValueIsArray = Array.isArray(startValue);
      var propType = startValueIsArray ? "array" : typeof startValue;
      var isInterpolationList = !startValueIsArray && Array.isArray(_valuesEnd[property]);
      if (propType === "undefined" || propType === "function") {
        continue;
      }
      if (isInterpolationList) {
        var endValues = _valuesEnd[property];
        if (endValues.length === 0) {
          continue;
        }
        endValues = endValues.map(this._handleRelativeValue.bind(this, startValue));
        _valuesEnd[property] = [startValue].concat(endValues);
      }
      if ((propType === "object" || startValueIsArray) && startValue && !isInterpolationList) {
        _valuesStart[property] = startValueIsArray ? [] : {};
        for (var prop in startValue) {
          _valuesStart[property][prop] = startValue[prop];
        }
        _valuesStartRepeat[property] = startValueIsArray ? [] : {};
        this._setupProperties(startValue, _valuesStart[property], _valuesEnd[property], _valuesStartRepeat[property]);
      } else {
        if (typeof _valuesStart[property] === "undefined") {
          _valuesStart[property] = startValue;
        }
        if (!startValueIsArray) {
          _valuesStart[property] *= 1;
        }
        if (isInterpolationList) {
          _valuesStartRepeat[property] = _valuesEnd[property].slice().reverse();
        } else {
          _valuesStartRepeat[property] = _valuesStart[property] || 0;
        }
      }
    }
  };
  Tween2.prototype.stop = function() {
    if (!this._isChainStopped) {
      this._isChainStopped = true;
      this.stopChainedTweens();
    }
    if (!this._isPlaying) {
      return this;
    }
    this._group && this._group.remove(this);
    this._isPlaying = false;
    this._isPaused = false;
    if (this._onStopCallback) {
      this._onStopCallback(this._object);
    }
    return this;
  };
  Tween2.prototype.end = function() {
    this._goToEnd = true;
    this.update(Infinity);
    return this;
  };
  Tween2.prototype.pause = function(time) {
    if (time === void 0) {
      time = now$1();
    }
    if (this._isPaused || !this._isPlaying) {
      return this;
    }
    this._isPaused = true;
    this._pauseStart = time;
    this._group && this._group.remove(this);
    return this;
  };
  Tween2.prototype.resume = function(time) {
    if (time === void 0) {
      time = now$1();
    }
    if (!this._isPaused || !this._isPlaying) {
      return this;
    }
    this._isPaused = false;
    this._startTime += time - this._pauseStart;
    this._pauseStart = 0;
    this._group && this._group.add(this);
    return this;
  };
  Tween2.prototype.stopChainedTweens = function() {
    for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
      this._chainedTweens[i].stop();
    }
    return this;
  };
  Tween2.prototype.group = function(group) {
    this._group = group;
    return this;
  };
  Tween2.prototype.delay = function(amount) {
    this._delayTime = amount;
    return this;
  };
  Tween2.prototype.repeat = function(times) {
    this._initialRepeat = times;
    this._repeat = times;
    return this;
  };
  Tween2.prototype.repeatDelay = function(amount) {
    this._repeatDelayTime = amount;
    return this;
  };
  Tween2.prototype.yoyo = function(yoyo) {
    this._yoyo = yoyo;
    return this;
  };
  Tween2.prototype.easing = function(easingFunction) {
    this._easingFunction = easingFunction;
    return this;
  };
  Tween2.prototype.interpolation = function(interpolationFunction) {
    this._interpolationFunction = interpolationFunction;
    return this;
  };
  Tween2.prototype.chain = function() {
    var tweens = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      tweens[_i] = arguments[_i];
    }
    this._chainedTweens = tweens;
    return this;
  };
  Tween2.prototype.onStart = function(callback) {
    this._onStartCallback = callback;
    return this;
  };
  Tween2.prototype.onUpdate = function(callback) {
    this._onUpdateCallback = callback;
    return this;
  };
  Tween2.prototype.onRepeat = function(callback) {
    this._onRepeatCallback = callback;
    return this;
  };
  Tween2.prototype.onComplete = function(callback) {
    this._onCompleteCallback = callback;
    return this;
  };
  Tween2.prototype.onStop = function(callback) {
    this._onStopCallback = callback;
    return this;
  };
  Tween2.prototype.update = function(time, autoStart) {
    if (time === void 0) {
      time = now$1();
    }
    if (autoStart === void 0) {
      autoStart = true;
    }
    if (this._isPaused)
      return true;
    var property;
    var elapsed;
    var endTime = this._startTime + this._duration;
    if (!this._goToEnd && !this._isPlaying) {
      if (time > endTime)
        return false;
      if (autoStart)
        this.start(time);
    }
    this._goToEnd = false;
    if (time < this._startTime) {
      return true;
    }
    if (this._onStartCallbackFired === false) {
      if (this._onStartCallback) {
        this._onStartCallback(this._object);
      }
      this._onStartCallbackFired = true;
    }
    elapsed = (time - this._startTime) / this._duration;
    elapsed = this._duration === 0 || elapsed > 1 ? 1 : elapsed;
    var value = this._easingFunction(elapsed);
    this._updateProperties(this._object, this._valuesStart, this._valuesEnd, value);
    if (this._onUpdateCallback) {
      this._onUpdateCallback(this._object, elapsed);
    }
    if (elapsed === 1) {
      if (this._repeat > 0) {
        if (isFinite(this._repeat)) {
          this._repeat--;
        }
        for (property in this._valuesStartRepeat) {
          if (!this._yoyo && typeof this._valuesEnd[property] === "string") {
            this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
          }
          if (this._yoyo) {
            this._swapEndStartRepeatValues(property);
          }
          this._valuesStart[property] = this._valuesStartRepeat[property];
        }
        if (this._yoyo) {
          this._reversed = !this._reversed;
        }
        if (this._repeatDelayTime !== void 0) {
          this._startTime = time + this._repeatDelayTime;
        } else {
          this._startTime = time + this._delayTime;
        }
        if (this._onRepeatCallback) {
          this._onRepeatCallback(this._object);
        }
        return true;
      } else {
        if (this._onCompleteCallback) {
          this._onCompleteCallback(this._object);
        }
        for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
          this._chainedTweens[i].start(this._startTime + this._duration);
        }
        this._isPlaying = false;
        return false;
      }
    }
    return true;
  };
  Tween2.prototype._updateProperties = function(_object, _valuesStart, _valuesEnd, value) {
    for (var property in _valuesEnd) {
      if (_valuesStart[property] === void 0) {
        continue;
      }
      var start = _valuesStart[property] || 0;
      var end = _valuesEnd[property];
      var startIsArray = Array.isArray(_object[property]);
      var endIsArray = Array.isArray(end);
      var isInterpolationList = !startIsArray && endIsArray;
      if (isInterpolationList) {
        _object[property] = this._interpolationFunction(end, value);
      } else if (typeof end === "object" && end) {
        this._updateProperties(_object[property], start, end, value);
      } else {
        end = this._handleRelativeValue(start, end);
        if (typeof end === "number") {
          _object[property] = start + (end - start) * value;
        }
      }
    }
  };
  Tween2.prototype._handleRelativeValue = function(start, end) {
    if (typeof end !== "string") {
      return end;
    }
    if (end.charAt(0) === "+" || end.charAt(0) === "-") {
      return start + parseFloat(end);
    } else {
      return parseFloat(end);
    }
  };
  Tween2.prototype._swapEndStartRepeatValues = function(property) {
    var tmp = this._valuesStartRepeat[property];
    var endValue = this._valuesEnd[property];
    if (typeof endValue === "string") {
      this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(endValue);
    } else {
      this._valuesStartRepeat[property] = this._valuesEnd[property];
    }
    this._valuesEnd[property] = tmp;
  };
  return Tween2;
}();
Sequence.nextId;
var TWEEN = mainGroup;
TWEEN.getAll.bind(TWEEN);
TWEEN.removeAll.bind(TWEEN);
TWEEN.add.bind(TWEEN);
TWEEN.remove.bind(TWEEN);
var update = TWEEN.update.bind(TWEEN);
class Manager {
  constructor(onComplete, onError, onProgress) {
    this._total = 0;
    this._finished = 0;
    this._taskList = [];
    this._isStart = false;
    this._currentIndex = 0;
    this.onComplete = onComplete;
    this.onError = onError;
    this.onProgress = onProgress;
  }
  start() {
    if (this._isStart) {
      return;
    }
    this._isStart = true;
    this._total = this._taskList.reduce((total, task) => {
      return total + task.total;
    }, 0);
    this.next();
  }
  next() {
    if (this._finished === this._total) {
      this.onComplete();
    }
    const task = this._taskList[this._currentIndex];
    if (task) {
      task.onComplete(() => {
        this._currentIndex++;
        this.next();
      });
      task.onError(() => {
        this.onError();
      });
      task.onProgress(() => {
        this._finished++;
        this.onProgress(this.getProgress());
      });
      task.start();
    }
  }
  getProgress() {
    if (this._total === 0 && this._finished === 0) {
      return 0;
    } else {
      return this._finished / this._total;
    }
  }
  add(task) {
    this._taskList.push(task);
    return this;
  }
}
class Task {
  constructor(loader, options) {
    this._total = 0;
    this._finished = 0;
    this._infoList = [];
    this._currentIndex = 0;
    this._options = { async: true, reload: 3 };
    this._isStart = false;
    this._options = __spreadValues(__spreadValues({}, this._options), options);
    this._loader = loader;
  }
  add(info) {
    this._infoList.push({ reload: 0, info });
  }
  onComplete(callBack) {
    this._onComplete = callBack;
  }
  onError(callBack) {
    this._onError = callBack;
  }
  onProgress(callBack) {
    this._onProgress = callBack;
  }
  start() {
    if (this._isStart) {
      return;
    }
    this._isStart = true;
    this._total = this._infoList.length;
    if (this._options.async) {
      this.next();
    } else {
      this._infoList.forEach((info) => {
        this.execute(info);
      });
    }
  }
  get total() {
    return this._infoList.length;
  }
  execute(infoWarp) {
    return this._loader(infoWarp.info).then(() => {
      this._finished++;
      this._onProgress && this._onProgress(this._finished);
      this.next();
    }, () => {
      infoWarp.reload++;
      this.next(infoWarp);
    });
  }
  next(infoWarp) {
    if (this._finished === this._total) {
      this._onComplete && this._onComplete();
      return;
    }
    let info;
    if (infoWarp) {
      const currentInfo = infoWarp;
      if (currentInfo.reload > this._options.reload) {
        info = currentInfo;
      } else {
        this._onError && this._onError();
        info = this._infoList[this._currentIndex++];
      }
    } else {
      if (!this._options.async) {
        return;
      } else {
        info = this._infoList[this._currentIndex++];
      }
    }
    this.execute(info);
  }
}
function createCamera(scene) {
  const camera = new BABYLON$1.ArcRotateCamera("camera", 0, 0, 10, BABYLON$1.Vector3.Zero(), scene);
  camera.checkCollisions = false;
  camera.wheelPrecision = 50;
  camera.lowerBetaLimit = 0.1;
  camera.upperBetaLimit = Math.PI * 0.5 - 0.1;
  return camera;
}
function createLight(scene) {
  const light1 = new BABYLON$1.HemisphericLight("light1", new BABYLON$1.Vector3(0, 1, 0), scene);
  light1.diffuse = new Color3$1(1, 1, 1).toLinearSpace();
  light1.groundColor = new Color3$1(0.7, 0.7, 0.7);
  light1.intensity = 1;
  return {
    light1
  };
}
var AVATAR_ANIMATION_ENUM = /* @__PURE__ */ ((AVATAR_ANIMATION_ENUM2) => {
  AVATAR_ANIMATION_ENUM2["NONE"] = "None";
  AVATAR_ANIMATION_ENUM2["IDLE"] = "Avatar_Idle";
  AVATAR_ANIMATION_ENUM2["RUN"] = "Avatar_Running";
  AVATAR_ANIMATION_ENUM2["WALK"] = "Avatar_Walking";
  AVATAR_ANIMATION_ENUM2["WAVE"] = "Avatar_Waving";
  return AVATAR_ANIMATION_ENUM2;
})(AVATAR_ANIMATION_ENUM || {});
class ControllerAttribute {
  constructor(option) {
    this.walkSpeed = 2;
    this.runSpeed = 4;
    this.distanceLimit = 4;
    this.betaDefault = Math.PI * 45 / 180;
    this.betaMax = Math.PI * 90 / 180;
    this.betaMin = Math.PI * 10 / 180;
    this.cameraDistDefault = 30;
    this.cameraMaxDist = 200;
    this.cameraMinDist = 3;
    this.angularSensibility = 3;
    this.zoomInOutSpeed = 1;
    this.xOffset = 0;
    this.yOffset = 0;
    this.zOffset = 0;
    this.cameraFollowAmount = 5e-3;
    this.houseOpacity = 0.15;
    this.houseObstacleList = [];
    this.lockStep = 1;
    this.maxSteps = 60;
    this.lookSpeed = 1;
    if (option) {
      Object.assign(this, option);
    }
  }
}
const baseUrlString$1 = "https://meta.gotin.online/assets/";
class PointerMesh {
  constructor(name2, size, scene) {
    this._scene = scene;
    this._pointerMesh = BABYLON$1.CreateDisc(name2, { radius: 0.1, tessellation: 64 }, scene);
    this._pointerMesh.position.y = 1;
    const mat = new BABYLON$1.StandardMaterial("discMat");
    const texture = new BABYLON$1.Texture(baseUrlString$1 + "game_porsche/controller/disc.png");
    mat.opacityTexture = texture;
    mat.emissiveColor = new BABYLON$1.Color3(1, 1, 1);
    this._pointerMesh.billboardMode = BABYLON$1.Mesh.BILLBOARDMODE_ALL;
    this._pointerMesh.material = mat;
    this._pointerMesh.setEnabled(false);
    this._pointerMesh.renderingGroupId = 1;
  }
  setEnabled(state) {
    this._pointerMesh.setEnabled(state);
  }
  scaleByTime(time) {
    if (time < 2) {
      this._pointerMesh.scaling.x = time < 0.5 ? Math.abs(Math.sin(time * 10)) + 0.2 : 1;
      this._pointerMesh.scaling.y = time < 0.5 ? Math.abs(Math.sin(time * 10)) + 0.2 : 1;
      this._pointerMesh.scaling.z = time < 0.5 ? Math.abs(Math.sin(time * 10)) + 0.2 : 1;
    }
  }
  setPosition(position) {
    this._pointerMesh.position.copyFrom(position);
  }
  dispose() {
    this._scene.removeMesh(this._pointerMesh);
    this._pointerMesh.dispose();
  }
}
class PointController {
  constructor(scene, camera, player, locateBox, animationStateMachine, config) {
    this._targetPoint = null;
    this._speed = 0.05;
    this._pointerMeshTime = 0;
    this._targetDistance = 0;
    this._leftMouseDown = false;
    this._leftMouseMove = false;
    this._pointerDownTime = 0;
    this._rayCheckTime = 0;
    this._lastFrameTime = 0;
    this._clickHandler = (pointerInfo) => {
      if (pointerInfo.event.button === 0) {
        if (pointerInfo.type === BABYLON$1.PointerEventTypes.POINTERDOWN) {
          this._leftMouseDown = true;
        } else if (pointerInfo.type === BABYLON$1.PointerEventTypes.POINTERUP) {
          this._leftMouseDown = false;
          this._pointerDownTime = 0;
        }
      }
      if (this._leftMouseDown && pointerInfo.type === BABYLON$1.PointerEventTypes.POINTERMOVE) {
        this._leftMouseMove = true;
      } else if (!this._leftMouseDown) {
        this._leftMouseMove = false;
      }
      if (pointerInfo.event.button === 2) {
        return;
      }
      const pickResult = this._scene.pick(this._scene.pointerX, this._scene.pointerY, void 0);
      if (pickResult && pickResult.pickedMesh) {
        const pickedMeshName = pickResult.pickedMesh.name;
        if (pickedMeshName !== "C_Ground") {
          return;
        }
      }
      if (pickResult && pickResult.pickedPoint) {
        if (pointerInfo.type === BABYLON$1.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0 || this._leftMouseDown && this._leftMouseMove) {
          this._pointerMesh.setEnabled(true);
          this._pointerMesh.setPosition(pickResult.pickedPoint.add(new BABYLON$1.Vector3(0, 0.1, 0)));
          this._targetPoint = pickResult.pickedPoint;
          this._targetPoint.y = 0;
          this._targetDistance = BABYLON$1.Vector3.Distance(pickResult.pickedPoint, this._player.root.position);
        }
      }
    };
    this.update = () => {
      var _a2, _b2, _c2;
      const time = this._scene.getEngine().getDeltaTime() / 1e3;
      this._pointerMeshTime += time;
      this._locateBox.position.copyFrom(this._player.root.position);
      this._pointerMesh.scaleByTime(this._pointerMeshTime);
      if (this._leftMouseDown && this._leftMouseMove) {
        this._pointerDownTime += time;
      }
      if (!this._targetPoint) {
        (_a2 = this._animationFuc) == null ? void 0 : _a2.startAnimation(AVATAR_ANIMATION_ENUM.IDLE);
        this._resetSpeed();
        this._lastFrameTime = 0;
        return;
      }
      const direction = this._targetPoint.subtract(this._player.root.position);
      direction.y = 0;
      if (direction.length() <= 0.1) {
        (_b2 = this._animationFuc) == null ? void 0 : _b2.startAnimation(AVATAR_ANIMATION_ENUM.IDLE);
        this._resetSpeed();
        this._lastFrameTime = 0;
        return;
      }
      this._setVerticalPos();
      direction.normalize();
      const playerRoot = this._player.root;
      playerRoot.checkCollisions = true;
      const rq = this._locateBox.rotationQuaternion;
      if (this._lastFrameTime === 0) {
        this._lastFrameTime = Date.now();
      }
      const deltaTime = (Date.now() - this._lastFrameTime) / 1e3;
      if (deltaTime < 1e-3) {
        return;
      }
      if (time > 1) {
        this._clearTarget();
        return;
      }
      const incrementV = 0.15;
      if (rq) {
        const currentQuat = BABYLON$1.Quaternion.FromLookDirectionLH(this._player.root.forward, BABYLON$1.Vector3.Up());
        const targetQuat = BABYLON$1.Quaternion.FromLookDirectionLH(direction, BABYLON$1.Vector3.Up());
        BABYLON$1.Quaternion.SmoothToRef(currentQuat, targetQuat, 0.1, 1, this._tempQuat);
        this._tempQuat.toEulerAnglesToRef(this._tempRotation);
        playerRoot.rotation.y = this._tempRotation.y + Math.PI;
        playerRoot.moveWithCollisions(new BABYLON$1.Vector3(direction.x, 0, direction.z).scale(this._speed * deltaTime));
        if (!this._targetPoint) {
          return;
        }
        const offset = BABYLON$1.Vector3.Distance(new BABYLON$1.Vector3(playerRoot.position.x, 0, playerRoot.position.z), new BABYLON$1.Vector3(this._targetPoint.x, 0, this._targetPoint.z));
        this._rayCheckTime += time;
        if (this._rayCheckTime > 0.5 && this._checkIfCollision()) {
          this._clearTarget();
          this._rayCheckTime = 0;
          return;
        }
        if (this._pointerDownTime > 2) {
          this._speed = this._controllerAttribute.runSpeed;
          (_c2 = this._animationFuc) == null ? void 0 : _c2.startAnimation(AVATAR_ANIMATION_ENUM.RUN);
        } else {
          if (this._targetDistance > 4) {
            this._speed = this._speed < this._controllerAttribute.runSpeed ? this._speed += incrementV : this._controllerAttribute.runSpeed;
            if (this._animationFuc) {
              if (this._speed > this._controllerAttribute.walkSpeed) {
                this._animationFuc.startAnimation(AVATAR_ANIMATION_ENUM.RUN);
              } else {
                this._animationFuc.startAnimation(AVATAR_ANIMATION_ENUM.WALK);
              }
            }
          } else if (offset > 0.2) {
            this._speed = this._controllerAttribute.walkSpeed;
            if (this._animationFuc) {
              this._animationFuc.startAnimation(AVATAR_ANIMATION_ENUM.WALK);
            }
          }
          if (offset < 0.2) {
            this._targetPoint = null;
            if (this._animationFuc) {
              this._animationFuc.startAnimation(AVATAR_ANIMATION_ENUM.IDLE);
            }
            this._resetSpeed();
            this._pointerMesh.setEnabled(false);
            this._lastFrameTime = 0;
          }
        }
      }
      this._lastFrameTime = Date.now();
    };
    this._scene = scene;
    this._player = player;
    this._tempQuat = BABYLON$1.Quaternion.Identity();
    this._controllerAttribute = new ControllerAttribute(config);
    this._locateBox = locateBox;
    this._locateBox.scaling = new BABYLON$1.Vector3(0.5, 4, 0.5);
    this._locateBox.rotationQuaternion = BABYLON$1.Quaternion.Identity();
    this._locateBox.rotation.y = 0;
    this._locateBox.visibility = 0.3;
    this._locateBox.rotationQuaternion = BABYLON$1.Quaternion.Identity();
    this._locateBox.lookAt(new BABYLON$1.Vector3(0, 0, 0));
    this._tempRotation = new BABYLON$1.Vector3();
    this.isEnabledCameraRotation = false;
    this._pointerMesh = new PointerMesh("c_pointMesh", 0.2, scene);
    this._animationFuc = animationStateMachine;
  }
  attachPlayer() {
    if (!this._pointerObservable) {
      const observable = this._scene.onPointerObservable.add(this._clickHandler);
      if (observable) {
        this._pointerObservable = observable;
      }
    }
  }
  detachPlayer() {
    if (this._pointerObservable) {
      this._scene.onPointerObservable.remove(this._pointerObservable);
      this._pointerObservable = void 0;
    }
    this._clearTarget();
  }
  _checkIfCollision() {
    var _a2;
    const ray = new BABYLON$1.Ray(this._player.root.position.add(this._player.root.forward.clone().scale(0.5)), this._player.root.forward, 0.2);
    const pickInfo = ray.intersectsMeshes(this._scene.meshes.filter((mesh) => mesh.checkCollisions));
    if ((_a2 = pickInfo[0]) == null ? void 0 : _a2.pickedMesh) {
      return true;
    } else {
      return false;
    }
  }
  _setVerticalPos() {
    const ray = new BABYLON$1.Ray(this._player.root.position, BABYLON$1.Vector3.Down(), 100);
    const ground = this._scene.getMeshByName("C_Ground");
    if (ground instanceof BABYLON$1.Mesh) {
      const info = ray.intersectsMesh(ground);
      const point = info.pickedPoint;
      this._player.root.position.y = point && point.y >= 0.3 ? point.y + 1.3 : 1.3;
    }
  }
  _clearTarget() {
    this._targetPoint = null;
    this._pointerMesh.setEnabled(false);
    this._lastFrameTime = 0;
  }
  _resetSpeed() {
    this._speed = 0.05;
  }
  getCurrentDistance() {
    if (this._targetPoint) {
      return BABYLON$1.Vector3.Distance(this._targetPoint.multiplyByFloats(1, 0, 1), this._player.root.position.multiplyByFloats(1, 0, 1));
    } else {
      return 0;
    }
  }
  getPlayerState() {
    var _a2;
    if (this._animationFuc) {
      return (_a2 = this._animationFuc) == null ? void 0 : _a2.getCurrentAnimation();
    } else {
      return AVATAR_ANIMATION_ENUM.IDLE;
    }
  }
  dispose() {
    this._pointerMesh.dispose();
  }
}
class PcController {
  constructor(scene, camera, player, locateBox, animationStateMachine, config) {
    this._keyDirection = null;
    this._targetPoint = null;
    this._speed = 0.05;
    this._pointerMeshTime = 0;
    this._leftMouseDown = false;
    this._leftMouseMove = false;
    this._pointerDownTime = 0;
    this._rayCheckTime = 0;
    this._lastFrameTime = 0;
    this._keydownHandler = (kbInfo) => {
      if (kbInfo.type === BABYLON$1.KeyboardEventTypes.KEYDOWN) {
        this.keyState[kbInfo.event.key.toLowerCase()] = true;
      } else {
        this.keyState[kbInfo.event.key.toLowerCase()] = false;
      }
      this._keyDirection = null;
      if (!this.keyState.a && !this.keyState.w && !this.keyState.s && !this.keyState.d) {
        this._speed = this._controllerAttribute.walkSpeed * 0.1;
      }
      if (this.keyState.w) {
        this._keyDirection = BABYLON$1.Vector3.Forward();
      }
      if (this.keyState.s) {
        this._keyDirection = BABYLON$1.Vector3.Backward();
      }
      if (this.keyState.a) {
        this._keyDirection = BABYLON$1.Vector3.Left();
      }
      if (this.keyState.d) {
        this._keyDirection = BABYLON$1.Vector3.Right();
      }
      if (this.keyState.w && this.keyState.a) {
        this._keyDirection = BABYLON$1.Vector3.Forward().addInPlace(BABYLON$1.Vector3.Left()).normalize();
      }
      if (this.keyState.w && this.keyState.d) {
        this._keyDirection = BABYLON$1.Vector3.Forward().addInPlace(BABYLON$1.Vector3.Right()).normalize();
      }
      if (this.keyState.s && this.keyState.a) {
        this._keyDirection = BABYLON$1.Vector3.Backward().addInPlace(BABYLON$1.Vector3.Left()).normalize();
      }
      if (this.keyState.s && this.keyState.d) {
        this._keyDirection = BABYLON$1.Vector3.Backward().addInPlace(BABYLON$1.Vector3.Right()).normalize();
      }
      if (this.keyState.shift) {
        this._speed = this._speed < 0.2 ? this._speed + 1e-3 : this._controllerAttribute.runSpeed;
      }
    };
    this._clickHandler = (pointerInfo) => {
      if (pointerInfo.event.button === 0) {
        if (pointerInfo.type === BABYLON$1.PointerEventTypes.POINTERDOWN) {
          this._leftMouseDown = true;
        } else if (pointerInfo.type === BABYLON$1.PointerEventTypes.POINTERUP) {
          this._leftMouseDown = false;
          this._pointerDownTime = 0;
        }
      }
      if (this._leftMouseDown && pointerInfo.type === BABYLON$1.PointerEventTypes.POINTERMOVE) {
        this._leftMouseMove = true;
      } else if (!this._leftMouseDown) {
        this._leftMouseMove = false;
      }
      if (pointerInfo.event.button === 2) {
        return;
      }
      const pickResult = this._scene.pick(this._scene.pointerX, this._scene.pointerY, void 0);
      if (pickResult && pickResult.pickedMesh) {
        const pickedMeshName = pickResult.pickedMesh.name;
        if (pickedMeshName !== "C_Ground") {
          return;
        }
      }
      if (pickResult && pickResult.pickedPoint) {
        if (pointerInfo.type === BABYLON$1.PointerEventTypes.POINTERDOWN && pointerInfo.event.button === 0 || this._leftMouseDown && this._leftMouseMove) {
          this._pointerMesh.setEnabled(true);
          this._pointerMesh.setPosition(pickResult.pickedPoint.add(new BABYLON$1.Vector3(0, 0.1, 0)));
          this._targetPoint = pickResult.pickedPoint;
          this._targetPoint.y = 0;
          this._updateTargetByClick(this._targetPoint);
        }
      }
    };
    this.update = () => {
      var _a2, _b2, _c2, _d, _e, _f, _g, _h;
      let hasKeyDown = false;
      if (this.keyState.a || this.keyState.d || this.keyState.w || this.keyState.s) {
        hasKeyDown = true;
      } else {
        hasKeyDown = false;
      }
      const playerRoot = this._player.root;
      playerRoot.checkCollisions = true;
      if (this._lastFrameTime === 0) {
        this._lastFrameTime = Date.now();
      }
      const time = (Date.now() - this._lastFrameTime) / 1e3;
      if (time < 1e-3) {
        return;
      }
      if (time > 0.2) {
        this._clearTarget();
      }
      this._setVerticalPos();
      this.keyState.w && (this.keyTimeState.tw += time);
      this.keyState.a && (this.keyTimeState.ta += time);
      this.keyState.s && (this.keyTimeState.ts += time);
      this.keyState.d && (this.keyTimeState.td += time);
      !this.keyState.w && (this.keyTimeState.tw = 0);
      !this.keyState.a && (this.keyTimeState.ta = 0);
      !this.keyState.s && (this.keyTimeState.ts = 0);
      !this.keyState.d && (this.keyTimeState.td = 0);
      const incrementV = 0.15;
      if (hasKeyDown) {
        this.isEnabledCameraRotation = false;
        this._targetPoint = null;
        this._pointerMesh.setEnabled(false);
        this._locateBox.position.copyFrom(this._player.root.position);
        if (this._keyDirection) {
          this._updateTargetByKeyboard(this._keyDirection);
        }
        if (this._targetDistance > 0) {
          playerRoot.moveWithCollisions(this._targetDirection.scale(this._speed * time).multiplyByFloats(1, 0, 1));
          let isOverTime = false;
          Object.entries(this.keyTimeState).forEach(([k, v]) => {
            if (v > 1.5) {
              isOverTime = true;
            }
          });
          if (isOverTime) {
            this._speed = this._speed < this._controllerAttribute.runSpeed ? this._speed + incrementV : this._controllerAttribute.runSpeed;
          } else {
            this._speed = this._speed < this._controllerAttribute.walkSpeed ? this._speed + incrementV : this._controllerAttribute.walkSpeed;
          }
          if (isOverTime) {
            (_a2 = this._animationStateMachine) == null ? void 0 : _a2.startAnimation(AVATAR_ANIMATION_ENUM.RUN);
          } else {
            (_b2 = this._animationStateMachine) == null ? void 0 : _b2.startAnimation(AVATAR_ANIMATION_ENUM.WALK);
          }
        } else {
          (_c2 = this._animationStateMachine) == null ? void 0 : _c2.startAnimation(AVATAR_ANIMATION_ENUM.IDLE);
          this._resetSpeed();
        }
        if (this._targetDistance > 0.03) {
          const rq = this._locateBox.rotationQuaternion;
          if (rq) {
            this._tempQuat.copyFrom(rq);
            const tempAngle = new BABYLON$1.Vector3();
            rq.toEulerAnglesToRef(tempAngle);
            this._locateBox.lookAt(this._targetBall);
            BABYLON$1.Quaternion.SmoothToRef(this._tempQuat, rq, 0.1, 1, rq);
            if (playerRoot) {
              rq.toEulerAnglesToRef(this._tempRotation);
              playerRoot.rotation.y = this._tempRotation.y;
            }
          }
        }
      } else if (this._targetPoint) {
        this._targetBall.copyFrom(this._targetPoint);
        this._targetBall.y = this._locateBox.position.y;
        this._pointerMeshTime += time;
        this._rayCheckTime += time;
        if (this._leftMouseDown && this._leftMouseMove) {
          this._pointerDownTime += time;
        }
        this._locateBox.position.copyFrom(this._player.root.position);
        this._locateBox.rotation.copyFrom(this._player.root.rotation);
        this._player.root.rotationQuaternion && ((_d = this._locateBox.rotationQuaternion) == null ? void 0 : _d.copyFrom(this._player.root.rotationQuaternion));
        this._pointerMesh.scaleByTime(this._pointerMeshTime);
        if (!this._targetPoint) {
          (_e = this._animationStateMachine) == null ? void 0 : _e.startAnimation(AVATAR_ANIMATION_ENUM.IDLE);
          this._resetSpeed();
          return;
        }
        const direction = this._targetPoint.subtract(this._player.root.position);
        direction.y = 0;
        if (direction.length() <= 0.1) {
          (_f = this._animationStateMachine) == null ? void 0 : _f.startAnimation(AVATAR_ANIMATION_ENUM.IDLE);
          this._resetSpeed();
          return;
        }
        direction.normalize();
        const rq = this._locateBox.rotationQuaternion;
        if (rq) {
          const currentQuat = BABYLON$1.Quaternion.FromLookDirectionLH(this._player.root.forward, BABYLON$1.Vector3.Up());
          const targetQuat = BABYLON$1.Quaternion.FromLookDirectionLH(direction, BABYLON$1.Vector3.Up());
          BABYLON$1.Quaternion.SmoothToRef(currentQuat, targetQuat, 0.1, 1, this._tempQuat);
          this._tempQuat.toEulerAnglesToRef(this._tempRotation);
          playerRoot.rotation.y = this._tempRotation.y + Math.PI;
          if (this._rayCheckTime > 0.5 && this._checkIfCollision()) {
            this._clearTarget();
            this._rayCheckTime = 0;
            return;
          }
          playerRoot.moveWithCollisions(new BABYLON$1.Vector3(direction.x, 0, direction.z).scale(this._speed * time).multiplyByFloats(1, 0, 1));
          const offset = BABYLON$1.Vector3.Distance(new BABYLON$1.Vector3(playerRoot.position.x, 0, playerRoot.position.z), new BABYLON$1.Vector3(this._targetPoint.x, 0, this._targetPoint.z));
          if (this._pointerDownTime > 2) {
            this._speed = this._controllerAttribute.runSpeed;
            (_g = this._animationStateMachine) == null ? void 0 : _g.startAnimation(AVATAR_ANIMATION_ENUM.RUN);
          } else {
            if (offset < 0.2) {
              this._pointerMeshTime = 0;
              this._targetPoint = null;
              if (this._animationStateMachine) {
                this._animationStateMachine.startAnimation(AVATAR_ANIMATION_ENUM.IDLE);
              }
              this._resetSpeed();
              this._pointerMesh.setEnabled(false);
            }
            if (this._targetDistance > 4) {
              this._speed = this._speed < this._controllerAttribute.runSpeed ? this._speed += incrementV : this._controllerAttribute.runSpeed;
              if (this._animationStateMachine) {
                if (offset > 0.2) {
                  this._animationStateMachine.startAnimation(AVATAR_ANIMATION_ENUM.RUN);
                }
              }
            } else if (offset > 0.2) {
              this._speed = this._controllerAttribute.walkSpeed;
              if (this._animationStateMachine) {
                this._animationStateMachine.startAnimation(AVATAR_ANIMATION_ENUM.WALK);
              }
            }
          }
        }
        this._locateBox.lookAt(this._targetBall);
        const rotateQuat = this._locateBox.rotationQuaternion;
        const tempRo = new BABYLON$1.Vector3();
        rotateQuat == null ? void 0 : rotateQuat.toEulerAnglesToRef(tempRo);
      } else {
        (_h = this._animationStateMachine) == null ? void 0 : _h.startAnimation(AVATAR_ANIMATION_ENUM.IDLE);
        this._resetSpeed();
      }
      this._lastFrameTime = Date.now();
    };
    this._scene = scene;
    this._camera = camera;
    this._player = player;
    player.root.isPickable = false;
    this._camera.keysLeft = [];
    this._camera.keysRight = [];
    this._camera.keysUp = [];
    this._camera.keysDown = [];
    this._controllerAttribute = new ControllerAttribute(config);
    this._speed = this._controllerAttribute.walkSpeed * 0.1;
    this._tempQuat = BABYLON$1.Quaternion.Identity();
    this._locateBox = locateBox;
    this._locateBox.scaling = new BABYLON$1.Vector3(0.5, 4, 0.5);
    this._locateBox.rotation.y = this._player.root.rotation.y;
    this._locateBox.rotationQuaternion = BABYLON$1.Quaternion.FromEulerVector(this._player.root.rotation);
    this._locateBox.visibility = 0.3;
    this._tempRotation = new BABYLON$1.Vector3();
    this.isEnabledCameraRotation = false;
    this._moveDirection = BABYLON$1.Vector3.Forward();
    this._moveTarget = new BABYLON$1.Vector3();
    this._targetDirection = new BABYLON$1.Vector3();
    this._targetPosition = new BABYLON$1.Vector3();
    this._initPosition = new BABYLON$1.Vector3();
    this._targetBall = new BABYLON$1.Vector3();
    this._targetDistance = 0;
    this._animationStateMachine = animationStateMachine;
    this._pointerMesh = new PointerMesh("c_pointMesh", 0.2, scene);
    this.keyState = {
      w: false,
      s: false,
      a: false,
      d: false,
      shift: false
    };
    this.keyTimeState = {
      tw: 0,
      ts: 0,
      ta: 0,
      td: 0
    };
    this._keyDirection = null;
  }
  attachPlayer() {
    if (!this._keyboardObservable) {
      const observable = this._scene.onKeyboardObservable.add(this._keydownHandler);
      if (observable) {
        this._keyboardObservable = observable;
      }
    }
    if (!this._pointerObservable) {
      const observable = this._scene.onPointerObservable.add(this._clickHandler);
      if (observable) {
        this._pointerObservable = observable;
      }
    }
  }
  detachPlayer() {
    if (this._keyboardObservable) {
      this._scene.onKeyboardObservable.remove(this._keyboardObservable);
      this._keyboardObservable = void 0;
    }
    if (this._pointerObservable) {
      this._scene.onPointerObservable.remove(this._pointerObservable);
      this._pointerObservable = void 0;
    }
    this._clearTarget();
  }
  dispose() {
    this._pointerMesh.dispose();
  }
  _updateTargetByKeyboard(axis) {
    this._camera.getDirectionToRef(axis, this._moveDirection);
    this._moveDirection.y = 0;
    this._moveTarget.copyFrom(this._locateBox.position).addInPlace(this._moveDirection.normalize().scale(0.2));
    this._updateTargetByClick(this._moveTarget);
  }
  _updateTargetByClick(targetPosition) {
    this._targetPosition.copyFrom(targetPosition);
    this._targetBall.copyFrom(this._targetPosition);
    this._initPosition.copyFrom(this._locateBox.position);
    this._targetDistance = BABYLON$1.Vector3.Distance(this._targetPosition, this._initPosition);
    this._targetDirection = this._targetPosition.subtract(this._initPosition);
    this._targetDirection = BABYLON$1.Vector3.Normalize(this._targetDirection);
  }
  _clearTarget() {
    this._targetPoint = null;
    this._pointerMesh.setEnabled(false);
    this.keyState.a = false;
    this.keyState.w = false;
    this.keyState.s = false;
    this.keyState.d = false;
    this.keyState.shift = false;
  }
  _checkIfCollision() {
    var _a2;
    const ray = new BABYLON$1.Ray(this._player.root.position.add(this._player.root.forward.clone().scale(0.5)), this._player.root.forward, 0.2);
    const pickInfo = ray.intersectsMeshes(this._scene.meshes.filter((mesh) => mesh.checkCollisions));
    if ((_a2 = pickInfo[0]) == null ? void 0 : _a2.pickedMesh) {
      return true;
    } else {
      return false;
    }
  }
  _setVerticalPos() {
    const ray = new BABYLON$1.Ray(this._player.root.position, BABYLON$1.Vector3.Down(), 100);
    const ground = this._scene.getMeshByName("C_Ground");
    if (ground instanceof BABYLON$1.Mesh) {
      const info = ray.intersectsMesh(ground);
      const point = info.pickedPoint;
      this._player.root.position.y = point && point.y >= 0.3 ? point.y + 1.3 : 1.3;
    }
  }
  _resetSpeed() {
    this._speed = 0.05;
  }
  getCurrentDistance() {
    if (this._targetPoint) {
      return BABYLON$1.Vector3.Distance(this._targetPoint.multiplyByFloats(1, 0, 1), this._player.root.position.multiplyByFloats(1, 0, 1));
    } else {
      return 0;
    }
  }
}
var CONTROLLER_TYPE_ENUM = /* @__PURE__ */ ((CONTROLLER_TYPE_ENUM2) => {
  CONTROLLER_TYPE_ENUM2[CONTROLLER_TYPE_ENUM2["POINT"] = 0] = "POINT";
  CONTROLLER_TYPE_ENUM2[CONTROLLER_TYPE_ENUM2["KEYBOARD"] = 1] = "KEYBOARD";
  CONTROLLER_TYPE_ENUM2[CONTROLLER_TYPE_ENUM2["PC"] = 2] = "PC";
  return CONTROLLER_TYPE_ENUM2;
})(CONTROLLER_TYPE_ENUM || {});
class CameraController {
  constructor(scene, camera, player, controller, config) {
    this._time = 0;
    this._cameraProperty = null;
    this._adleRunTime = 0;
    this._cameraAdleDelayTime = 3;
    this._cameraY = 0;
    this._cameraRay = new BABYLON$1.Ray(new BABYLON$1.Vector3(), new BABYLON$1.Vector3(), 100);
    this.update = () => {
      var _a2, _b2;
      const time = this._scene.getEngine().getDeltaTime();
      const idleWeight = (_b2 = (_a2 = this._player.asset) == null ? void 0 : _a2.animationGroups.find((ani) => ani.name === AVATAR_ANIMATION_ENUM.IDLE)) == null ? void 0 : _b2.animatables[0].weight;
      const isAdlePlaying = idleWeight === 1;
      if (isAdlePlaying) {
        this._adleRunTime += time * 1e-3;
      } else {
        this._adleRunTime = 0;
      }
      this.checkHouseObstacleAndProcess();
      if (this._cameraState === 0) {
        if (this._controllerType === CONTROLLER_TYPE_ENUM.PC) {
          this._cameraProperty = null;
          this._camera.target.x = this._player.root.position.x;
          this._camera.target.y = this._player.root.position.y + this._cameraY;
          this._camera.target.z = this._player.root.position.z;
        } else if (this._controller.getCurrentDistance() > 0.1) {
          this.delayCamera(time);
        }
      } else if (isAdlePlaying && this._adleRunTime > this._cameraAdleDelayTime) {
        this._camera.target.x = this._player.root.position.x;
        this._camera.target.y = this._player.root.position.y + this._cameraY;
        this._camera.target.z = this._player.root.position.z;
        !this._cameraProperty && (this._cameraProperty = this.getCameraState(this._camera));
        if (!this._cameraProperty || !this._cameraProperty.alpha || !this._cameraProperty.beta) {
          return;
        }
        const alpha = this._cameraProperty.alpha;
        const beta = this._cameraProperty.beta;
        this.moveCameraFreeStyle(this._camera, alpha, beta);
      }
    };
    this._scene = scene;
    this._camera = camera;
    this._player = player;
    this._controllerAttribute = new ControllerAttribute(config);
    this._cameraY = this._controllerAttribute.yOffset;
    this._controller = controller;
  }
  attachControl(option = {}) {
    this._camera.attachControl(true, false, 3);
    this._camera.inputs.attached.pointers.buttons = [2];
    if (option.camera) {
      this.setCameraState(option.camera);
    }
  }
  detachControl() {
    this._camera.detachControl();
  }
  dispose() {
  }
  thirdPersonCamera(controllerType) {
    this._camera.lowerRadiusLimit = this._controllerAttribute.cameraMinDist;
    this._camera.upperRadiusLimit = this._controllerAttribute.cameraMaxDist;
    this._camera.upperBetaLimit = this._controllerAttribute.betaMax;
    this._camera.lowerBetaLimit = this._controllerAttribute.betaMin;
    this._camera.alpha = this._player.root.rotation.y - Math.PI * 0.5;
    this._camera.beta = this._controllerAttribute.betaDefault;
    this._cameraState = 0;
    this._controllerType = controllerType;
    this._camera.angularSensibilityX = this._controllerAttribute.angularSensibility;
    this._camera.wheelDeltaPercentage = this._controllerAttribute.zoomInOutSpeed;
  }
  firstPersonCamera() {
    this._cameraState = 1;
    this._camera.lowerRadiusLimit = 0.1;
    this._camera.upperRadiusLimit = 0.1;
    this._camera.upperBetaLimit = Math.PI * 0.5 + 0.5;
    this._camera.setPosition(new BABYLON$1.Vector3(0, this._cameraY, 0));
    this._camera.beta = Math.PI * 0.5;
  }
  delayCamera(time) {
    this._time += time;
    const camDir = this._player.root.position.clone().subtract(this._camera.position).normalize();
    const playerDir = this._player.root.forward.clone().normalize();
    const dotResult = BABYLON$1.Vector3.Dot(camDir, playerDir);
    if (this._time > 1) {
      const toPlayerPosition = new BABYLON$1.Vector3();
      toPlayerPosition.copyFrom(this._player.root.position);
      toPlayerPosition.y += this._cameraY;
      const forwardDir = new BABYLON$1.Vector3().copyFrom(this._player.root.forward);
      const dirVector = forwardDir.normalize().scale(this._controllerAttribute.cameraDistDefault * -1 / Math.sin(this._camera.beta));
      const cameraTargetPos = this._player.root.position.clone().addInPlace(new BABYLON$1.Vector3(0, 1, 0)).add(dirVector);
      this._camera.target.x = this._player.root.position.x;
      this._camera.target.y = this._player.root.position.y + this._cameraY;
      this._camera.target.z = this._player.root.position.z;
      const angle = BABYLON$1.Vector3.GetAngleBetweenVectors(this._camera.getForwardRay().direction.multiplyByFloats(1, 0, 1), forwardDir.multiplyByFloats(1, 0, 1), new BABYLON$1.Vector3(0, 1, 0));
      if (BABYLON$1.Vector3.Distance(this._camera.position, cameraTargetPos) > 0.1 && dotResult > -0.8) {
        this._cameraProperty = null;
        this._camera.alpha = BABYLON$1.Scalar.Lerp(this._camera.alpha, this._camera.alpha - angle, this._controllerAttribute.cameraFollowAmount);
      }
      this._time = 0;
    }
  }
  getCameraState(camera) {
    return {
      alpha: camera.alpha,
      beta: camera.beta,
      radius: camera.radius,
      target: camera.target
    };
  }
  setCameraState(state) {
    Object.prototype.hasOwnProperty.call(state, "alpha") && typeof state.alpha === "number" && (this._camera.alpha = state.alpha);
    Object.prototype.hasOwnProperty.call(state, "beta") && typeof state.beta === "number" && (this._camera.beta = state.beta);
    Object.prototype.hasOwnProperty.call(state, "radius") && typeof state.radius === "number" && (this._camera.radius = state.radius);
    state.target && (state.target instanceof BABYLON$1.AbstractMesh || state.target instanceof BABYLON$1.Vector3) && this._camera.setTarget(state.target);
  }
  moveCameraFreeStyle(camera, startAlpha, startBeta) {
    const time = this._adleRunTime;
    const offsetAlpha = Math.sin((time - this._cameraAdleDelayTime) * 0.1) * 0.1;
    const offsetBeta = Math.sin((time - this._cameraAdleDelayTime) * 0.1) * 0.02;
    camera.alpha = startAlpha + offsetAlpha;
    camera.beta = startBeta + offsetBeta;
  }
  checkHouseObstacleAndProcess() {
    this._cameraRay.origin = this._player.root.position.clone();
    this._cameraRay.direction = this._camera.position.clone().subtract(this._cameraRay.origin).normalize();
    this._controllerAttribute.houseObstacleList.forEach((name2) => {
      const houseMesh = this._scene.getMeshByName(name2);
      const pickInfo = houseMesh && this._cameraRay.intersectsMesh(houseMesh, true);
      if (houseMesh) {
        if (pickInfo == null ? void 0 : pickInfo.pickedMesh) {
          houseMesh.visibility = BABYLON$1.Scalar.Lerp(houseMesh.visibility, this._controllerAttribute.houseOpacity, 0.03);
        } else {
          houseMesh.visibility = 1;
        }
      }
    });
  }
}
class AnimationStateMachine {
  constructor(scene, player) {
    var _a2;
    this._weightFactor = 0.02;
    this._animationMap = /* @__PURE__ */ new Map();
    this.onWeightUpdate = () => {
      if (this._currentAnimation) {
        this._currentAnimation.weight = BABYLON$1.Scalar.Clamp(this._currentAnimation.weight + this._weightFactor, 0, 1);
        this._currentAnimation.animation.setWeightForAllAnimatables(this._currentAnimation.weight);
      }
      this._animationMap.forEach((animation) => {
        if (this._currentAnimation !== animation) {
          animation.weight = BABYLON$1.Scalar.Clamp(animation.weight - this._weightFactor, 0, 1);
          animation.animation.setWeightForAllAnimatables(animation.weight);
        }
      });
      if (this._currentAnimation && this._currentAnimation.weight === 1) {
        this._scene.onBeforeAnimationsObservable.removeCallback(this.onWeightUpdate);
      }
    };
    this._scene = scene;
    this._player = player;
    (_a2 = this._player.asset) == null ? void 0 : _a2.animationGroups.forEach((animation) => {
      this._animationMap.set(animation.name, {
        name: animation.name,
        animation,
        weight: 0
      });
      animation.start(true);
      animation.setWeightForAllAnimatables(0);
    });
  }
  startAnimation(name2) {
    var _a2;
    if (this._currentAnimation === this._animationMap.get(name2)) {
      return;
    } else {
      const nextAni = this._animationMap.get(name2);
      if (nextAni && this._currentAnimation) {
        nextAni.animation.syncAllAnimationsWith(null);
        this._currentAnimation.animation.syncAllAnimationsWith(null);
        const currentAni = (_a2 = this._currentAnimation) == null ? void 0 : _a2.animation.animatables[0];
        const currentFrame = currentAni.masterFrame;
        const normalizeRatio = currentFrame / (currentAni.toFrame - currentAni.fromFrame);
        const nextAniFrame = (nextAni.animation.to - nextAni.animation.from) * normalizeRatio;
        if (nextAni.name !== AVATAR_ANIMATION_ENUM.IDLE) {
          this._currentAnimation.animation.syncAllAnimationsWith(nextAni.animation.animatables[0]);
          nextAni.animation.reset();
          nextAni.animation.goToFrame(nextAniFrame);
          nextAni.animation.animatables.forEach((ani) => {
            ani.target.rotationQuaternion && (ani.target.rotationQuaternion = ani.target.rotationQuaternion.clone());
          });
        }
      }
      this._scene.onBeforeAnimationsObservable.removeCallback(this.onWeightUpdate);
      this._currentAnimation = this._animationMap.get(name2);
      this._scene.onBeforeAnimationsObservable.add(this.onWeightUpdate);
    }
  }
  getCurrentAnimation() {
    if (this._currentAnimation) {
      return this._currentAnimation.name;
    } else {
      return AVATAR_ANIMATION_ENUM.IDLE;
    }
  }
  dispose() {
  }
}
var PLATFORM_ENUM = /* @__PURE__ */ ((PLATFORM_ENUM2) => {
  PLATFORM_ENUM2[PLATFORM_ENUM2["PC"] = 0] = "PC";
  PLATFORM_ENUM2[PLATFORM_ENUM2["MOBILE"] = 1] = "MOBILE";
  return PLATFORM_ENUM2;
})(PLATFORM_ENUM || {});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n) {
  var f = n.default;
  if (typeof f == "function") {
    var a = function() {
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var platform = { exports: {} };
/*!
 * Platform.js v1.3.6
 * Copyright 2014-2020 Benjamin Tan
 * Copyright 2011-2013 John-David Dalton
 * Available under MIT license
 */
(function(module2, exports2) {
  (function() {
    var objectTypes = {
      "function": true,
      "object": true
    };
    var root2 = objectTypes[typeof window] && window || this;
    var freeExports2 = exports2;
    var freeModule2 = module2 && !module2.nodeType && module2;
    var freeGlobal2 = freeExports2 && freeModule2 && typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal2 && (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2 || freeGlobal2.self === freeGlobal2)) {
      root2 = freeGlobal2;
    }
    var maxSafeInteger = Math.pow(2, 53) - 1;
    var reOpera = /\bOpera/;
    var objectProto2 = Object.prototype;
    var hasOwnProperty2 = objectProto2.hasOwnProperty;
    var toString = objectProto2.toString;
    function capitalize(string) {
      string = String(string);
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function cleanupOS(os, pattern, label) {
      var data = {
        "10.0": "10",
        "6.4": "10 Technical Preview",
        "6.3": "8.1",
        "6.2": "8",
        "6.1": "Server 2008 R2 / 7",
        "6.0": "Server 2008 / Vista",
        "5.2": "Server 2003 / XP 64-bit",
        "5.1": "XP",
        "5.01": "2000 SP1",
        "5.0": "2000",
        "4.0": "NT",
        "4.90": "ME"
      };
      if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\d.]+$/.exec(os)])) {
        os = "Windows " + data;
      }
      os = String(os);
      if (pattern && label) {
        os = os.replace(RegExp(pattern, "i"), label);
      }
      os = format(os.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]);
      return os;
    }
    function each(object, callback) {
      var index = -1, length = object ? object.length : 0;
      if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
        while (++index < length) {
          callback(object[index], index, object);
        }
      } else {
        forOwn(object, callback);
      }
    }
    function format(string) {
      string = trim(string);
      return /^(?:webOS|i(?:OS|P))/.test(string) ? string : capitalize(string);
    }
    function forOwn(object, callback) {
      for (var key in object) {
        if (hasOwnProperty2.call(object, key)) {
          callback(object[key], key, object);
        }
      }
    }
    function getClassOf(value) {
      return value == null ? capitalize(value) : toString.call(value).slice(8, -1);
    }
    function isHostType(object, property) {
      var type = object != null ? typeof object[property] : "number";
      return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object[property] : true);
    }
    function qualify(string) {
      return String(string).replace(/([ -])(?!$)/g, "$1?");
    }
    function reduce(array, callback) {
      var accumulator = null;
      each(array, function(value, index) {
        accumulator = callback(accumulator, value, index, array);
      });
      return accumulator;
    }
    function trim(string) {
      return String(string).replace(/^ +| +$/g, "");
    }
    function parse(ua) {
      var context = root2;
      var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";
      if (isCustomContext) {
        context = ua;
        ua = null;
      }
      var nav = context.navigator || {};
      var userAgent = nav.userAgent || "";
      ua || (ua = userAgent);
      var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString.toString());
      var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
      var java = /\bJava/.test(javaClass) && context.java;
      var rhino = java && getClassOf(context.environment) == enviroClass;
      var alpha = java ? "a" : "\u03B1";
      var beta = java ? "b" : "\u03B2";
      var doc = context.document || {};
      var opera = context.operamini || context.opera;
      var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
      var data;
      var arch = ua;
      var description = [];
      var prerelease = null;
      var useFeatures = ua == userAgent;
      var version = useFeatures && opera && typeof opera.version == "function" && opera.version();
      var isSpecialCasedOS;
      var layout = getLayout([
        { "label": "EdgeHTML", "pattern": "Edge" },
        "Trident",
        { "label": "WebKit", "pattern": "AppleWebKit" },
        "iCab",
        "Presto",
        "NetFront",
        "Tasman",
        "KHTML",
        "Gecko"
      ]);
      var name2 = getName([
        "Adobe AIR",
        "Arora",
        "Avant Browser",
        "Breach",
        "Camino",
        "Electron",
        "Epiphany",
        "Fennec",
        "Flock",
        "Galeon",
        "GreenBrowser",
        "iCab",
        "Iceweasel",
        "K-Meleon",
        "Konqueror",
        "Lunascape",
        "Maxthon",
        { "label": "Microsoft Edge", "pattern": "(?:Edge|Edg|EdgA|EdgiOS)" },
        "Midori",
        "Nook Browser",
        "PaleMoon",
        "PhantomJS",
        "Raven",
        "Rekonq",
        "RockMelt",
        { "label": "Samsung Internet", "pattern": "SamsungBrowser" },
        "SeaMonkey",
        { "label": "Silk", "pattern": "(?:Cloud9|Silk-Accelerated)" },
        "Sleipnir",
        "SlimBrowser",
        { "label": "SRWare Iron", "pattern": "Iron" },
        "Sunrise",
        "Swiftfox",
        "Vivaldi",
        "Waterfox",
        "WebPositive",
        { "label": "Yandex Browser", "pattern": "YaBrowser" },
        { "label": "UC Browser", "pattern": "UCBrowser" },
        "Opera Mini",
        { "label": "Opera Mini", "pattern": "OPiOS" },
        "Opera",
        { "label": "Opera", "pattern": "OPR" },
        "Chromium",
        "Chrome",
        { "label": "Chrome", "pattern": "(?:HeadlessChrome)" },
        { "label": "Chrome Mobile", "pattern": "(?:CriOS|CrMo)" },
        { "label": "Firefox", "pattern": "(?:Firefox|Minefield)" },
        { "label": "Firefox for iOS", "pattern": "FxiOS" },
        { "label": "IE", "pattern": "IEMobile" },
        { "label": "IE", "pattern": "MSIE" },
        "Safari"
      ]);
      var product = getProduct([
        { "label": "BlackBerry", "pattern": "BB10" },
        "BlackBerry",
        { "label": "Galaxy S", "pattern": "GT-I9000" },
        { "label": "Galaxy S2", "pattern": "GT-I9100" },
        { "label": "Galaxy S3", "pattern": "GT-I9300" },
        { "label": "Galaxy S4", "pattern": "GT-I9500" },
        { "label": "Galaxy S5", "pattern": "SM-G900" },
        { "label": "Galaxy S6", "pattern": "SM-G920" },
        { "label": "Galaxy S6 Edge", "pattern": "SM-G925" },
        { "label": "Galaxy S7", "pattern": "SM-G930" },
        { "label": "Galaxy S7 Edge", "pattern": "SM-G935" },
        "Google TV",
        "Lumia",
        "iPad",
        "iPod",
        "iPhone",
        "Kindle",
        { "label": "Kindle Fire", "pattern": "(?:Cloud9|Silk-Accelerated)" },
        "Nexus",
        "Nook",
        "PlayBook",
        "PlayStation Vita",
        "PlayStation",
        "TouchPad",
        "Transformer",
        { "label": "Wii U", "pattern": "WiiU" },
        "Wii",
        "Xbox One",
        { "label": "Xbox 360", "pattern": "Xbox" },
        "Xoom"
      ]);
      var manufacturer = getManufacturer({
        "Apple": { "iPad": 1, "iPhone": 1, "iPod": 1 },
        "Alcatel": {},
        "Archos": {},
        "Amazon": { "Kindle": 1, "Kindle Fire": 1 },
        "Asus": { "Transformer": 1 },
        "Barnes & Noble": { "Nook": 1 },
        "BlackBerry": { "PlayBook": 1 },
        "Google": { "Google TV": 1, "Nexus": 1 },
        "HP": { "TouchPad": 1 },
        "HTC": {},
        "Huawei": {},
        "Lenovo": {},
        "LG": {},
        "Microsoft": { "Xbox": 1, "Xbox One": 1 },
        "Motorola": { "Xoom": 1 },
        "Nintendo": { "Wii U": 1, "Wii": 1 },
        "Nokia": { "Lumia": 1 },
        "Oppo": {},
        "Samsung": { "Galaxy S": 1, "Galaxy S2": 1, "Galaxy S3": 1, "Galaxy S4": 1 },
        "Sony": { "PlayStation": 1, "PlayStation Vita": 1 },
        "Xiaomi": { "Mi": 1, "Redmi": 1 }
      });
      var os = getOS([
        "Windows Phone",
        "KaiOS",
        "Android",
        "CentOS",
        { "label": "Chrome OS", "pattern": "CrOS" },
        "Debian",
        { "label": "DragonFly BSD", "pattern": "DragonFly" },
        "Fedora",
        "FreeBSD",
        "Gentoo",
        "Haiku",
        "Kubuntu",
        "Linux Mint",
        "OpenBSD",
        "Red Hat",
        "SuSE",
        "Ubuntu",
        "Xubuntu",
        "Cygwin",
        "Symbian OS",
        "hpwOS",
        "webOS ",
        "webOS",
        "Tablet OS",
        "Tizen",
        "Linux",
        "Mac OS X",
        "Macintosh",
        "Mac",
        "Windows 98;",
        "Windows "
      ]);
      function getLayout(guesses) {
        return reduce(guesses, function(result, guess) {
          return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
        });
      }
      function getManufacturer(guesses) {
        return reduce(guesses, function(result, value, key) {
          return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) && key;
        });
      }
      function getName(guesses) {
        return reduce(guesses, function(result, guess) {
          return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
        });
      }
      function getOS(guesses) {
        return reduce(guesses, function(result, guess) {
          var pattern = guess.pattern || qualify(guess);
          if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
            result = cleanupOS(result, pattern, guess.label || guess);
          }
          return result;
        });
      }
      function getProduct(guesses) {
        return reduce(guesses, function(result, guess) {
          var pattern = guess.pattern || qualify(guess);
          if (!result && (result = RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua) || RegExp("\\b" + pattern + " *\\w+-[\\w]*", "i").exec(ua) || RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))) {
            if ((result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
              result[0] += " " + result[1];
            }
            guess = guess.label || guess;
            result = format(result[0].replace(RegExp(pattern, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
          }
          return result;
        });
      }
      function getVersion(patterns) {
        return reduce(patterns, function(result, pattern) {
          return result || (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] || null;
        });
      }
      function toStringPlatform() {
        return this.description || "";
      }
      layout && (layout = [layout]);
      if (/\bAndroid\b/.test(os) && !product && (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
        product = trim(data[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
      }
      if (manufacturer && !product) {
        product = getProduct([manufacturer]);
      } else if (manufacturer && product) {
        product = product.replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ").replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
      }
      if (data = /\bGoogle TV\b/.exec(product)) {
        product = data[0];
      }
      if (/\bSimulator\b/i.test(ua)) {
        product = (product ? product + " " : "") + "Simulator";
      }
      if (name2 == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
        description.push("running in Turbo/Uncompressed mode");
      }
      if (name2 == "IE" && /\blike iPhone OS\b/.test(ua)) {
        data = parse(ua.replace(/like iPhone OS/, ""));
        manufacturer = data.manufacturer;
        product = data.product;
      } else if (/^iP/.test(product)) {
        name2 || (name2 = "Safari");
        os = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
      } else if (name2 == "Konqueror" && /^Linux\b/i.test(os)) {
        os = "Kubuntu";
      } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name2) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os) && /^Chrome/.test(name2) && /\bVersion\//i.test(ua)) {
        name2 = "Android Browser";
        os = /\bAndroid\b/.test(os) ? os : "Android";
      } else if (name2 == "Silk") {
        if (!/\bMobi/i.test(ua)) {
          os = "Android";
          description.unshift("desktop mode");
        }
        if (/Accelerated *= *true/i.test(ua)) {
          description.unshift("accelerated");
        }
      } else if (name2 == "UC Browser" && /\bUCWEB\b/.test(ua)) {
        description.push("speed mode");
      } else if (name2 == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
        description.push("identifying as Firefox " + data[1]);
      } else if (name2 == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
        os || (os = "Firefox OS");
        product || (product = data[1]);
      } else if (!name2 || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name2))) {
        if (name2 && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
          name2 = null;
        }
        if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
          name2 = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + " Browser";
        }
      } else if (name2 == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
        description.push("Chromium " + data);
      }
      if (!version) {
        version = getVersion([
          "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
          "Version",
          qualify(name2),
          "(?:Firefox|Minefield|NetFront)"
        ]);
      }
      if (data = layout == "iCab" && parseFloat(version) > 3 && "WebKit" || /\bOpera\b/.test(name2) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua) && (os == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name2) && "NetFront") {
        layout = [data];
      }
      if (name2 == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
        name2 += " Mobile";
        os = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
        description.unshift("desktop mode");
      } else if (/\bWPDesktop\b/i.test(ua)) {
        name2 = "IE Mobile";
        os = "Windows Phone 8.x";
        description.unshift("desktop mode");
        version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
      } else if (name2 != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
        if (name2) {
          description.push("identifying as " + name2 + (version ? " " + version : ""));
        }
        name2 = "IE";
        version = data[1];
      }
      if (useFeatures) {
        if (isHostType(context, "global")) {
          if (java) {
            data = java.lang.System;
            arch = data.getProperty("os.arch");
            os = os || data.getProperty("os.name") + " " + data.getProperty("os.version");
          }
          if (rhino) {
            try {
              version = context.require("ringo/engine").version.join(".");
              name2 = "RingoJS";
            } catch (e) {
              if ((data = context.system) && data.global.system == context.system) {
                name2 = "Narwhal";
                os || (os = data[0].os || null);
              }
            }
            if (!name2) {
              name2 = "Rhino";
            }
          } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
            if (typeof data.versions == "object") {
              if (typeof data.versions.electron == "string") {
                description.push("Node " + data.versions.node);
                name2 = "Electron";
                version = data.versions.electron;
              } else if (typeof data.versions.nw == "string") {
                description.push("Chromium " + version, "Node " + data.versions.node);
                name2 = "NW.js";
                version = data.versions.nw;
              }
            }
            if (!name2) {
              name2 = "Node.js";
              arch = data.arch;
              os = data.platform;
              version = /[\d.]+/.exec(data.version);
              version = version ? version[0] : null;
            }
          }
        } else if (getClassOf(data = context.runtime) == airRuntimeClass) {
          name2 = "Adobe AIR";
          os = data.flash.system.Capabilities.os;
        } else if (getClassOf(data = context.phantom) == phantomClass) {
          name2 = "PhantomJS";
          version = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
        } else if (typeof doc.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
          version = [version, doc.documentMode];
          if ((data = +data[1] + 4) != version[1]) {
            description.push("IE " + version[1] + " mode");
            layout && (layout[1] = "");
            version[1] = data;
          }
          version = name2 == "IE" ? String(version[1].toFixed(1)) : version[0];
        } else if (typeof doc.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name2)) {
          description.push("masking as " + name2 + " " + version);
          name2 = "IE";
          version = "11.0";
          layout = ["Trident"];
          os = "Windows";
        }
        os = os && format(os);
      }
      if (version && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && "a")) {
        prerelease = /b/i.test(data) ? "beta" : "alpha";
        version = version.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
      }
      if (name2 == "Fennec" || name2 == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os)) {
        name2 = "Firefox Mobile";
      } else if (name2 == "Maxthon" && version) {
        version = version.replace(/\.[\d.]+/, ".x");
      } else if (/\bXbox\b/i.test(product)) {
        if (product == "Xbox 360") {
          os = null;
        }
        if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
          description.unshift("mobile mode");
        }
      } else if ((/^(?:Chrome|IE|Opera)$/.test(name2) || name2 && !product && !/Browser|Mobi/.test(name2)) && (os == "Windows CE" || /Mobi/i.test(ua))) {
        name2 += " Mobile";
      } else if (name2 == "IE" && useFeatures) {
        try {
          if (context.external === null) {
            description.unshift("platform preview");
          }
        } catch (e) {
          description.unshift("embedded");
        }
      } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version)) {
        data = [data, /BB10/.test(ua)];
        os = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
        version = null;
      } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name2) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name2 == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os) || name2 == "IE" && (os && !/^Win/.test(os) && version > 5.5 || /\bWindows XP\b/.test(os) && version > 8 || version == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse.call(forOwn, ua.replace(reOpera, "") + ";")) && data.name) {
        data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
        if (reOpera.test(name2)) {
          if (/\bIE\b/.test(data) && os == "Mac OS") {
            os = null;
          }
          data = "identify" + data;
        } else {
          data = "mask" + data;
          if (operaClass) {
            name2 = format(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
          } else {
            name2 = "Opera";
          }
          if (/\bIE\b/.test(data)) {
            os = null;
          }
          if (!useFeatures) {
            version = null;
          }
        }
        layout = ["Presto"];
        description.push(data);
      }
      if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
        data = [parseFloat(data.replace(/\.(\d)$/, ".0$1")), data];
        if (name2 == "Safari" && data[1].slice(-1) == "+") {
          name2 = "WebKit Nightly";
          prerelease = "alpha";
          version = data[1].slice(0, -1);
        } else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
          version = null;
        }
        data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
        if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
          layout = ["Blink"];
        }
        if (!useFeatures || !likeChrome && !data[1]) {
          layout && (layout[1] = "like Safari");
          data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : "12");
        } else {
          layout && (layout[1] = "like Chrome");
          data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
        }
        layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
        if (name2 == "Safari" && (!version || parseInt(version) > 45)) {
          version = data;
        } else if (name2 == "Chrome" && /\bHeadlessChrome/i.test(ua)) {
          description.unshift("headless");
        }
      }
      if (name2 == "Opera" && (data = /\bzbov|zvav$/.exec(os))) {
        name2 += " ";
        description.unshift("desktop mode");
        if (data == "zvav") {
          name2 += "Mini";
          version = null;
        } else {
          name2 += "Mobile";
        }
        os = os.replace(RegExp(" *" + data + "$"), "");
      } else if (name2 == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
        description.unshift("desktop mode");
        name2 = "Chrome Mobile";
        version = null;
        if (/\bOS X\b/.test(os)) {
          manufacturer = "Apple";
          os = "iOS 4.3+";
        } else {
          os = null;
        }
      } else if (/\bSRWare Iron\b/.test(name2) && !version) {
        version = getVersion("Chrome");
      }
      if (version && version.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf("/" + data + "-") > -1) {
        os = trim(os.replace(data, ""));
      }
      if (os && os.indexOf(name2) != -1 && !RegExp(name2 + " OS").test(os)) {
        os = os.replace(RegExp(" *" + qualify(name2) + " *"), "");
      }
      if (layout && !/\b(?:Avant|Nook)\b/.test(name2) && (/Browser|Lunascape|Maxthon/.test(name2) || name2 != "Safari" && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name2) && layout[1])) {
        (data = layout[layout.length - 1]) && description.push(data);
      }
      if (description.length) {
        description = ["(" + description.join("; ") + ")"];
      }
      if (manufacturer && product && product.indexOf(manufacturer) < 0) {
        description.push("on " + manufacturer);
      }
      if (product) {
        description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
      }
      if (os) {
        data = / ([\d.+]+)$/.exec(os);
        isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == "/";
        os = {
          "architecture": 32,
          "family": data && !isSpecialCasedOS ? os.replace(data[0], "") : os,
          "version": data ? data[1] : null,
          "toString": function() {
            var version2 = this.version;
            return this.family + (version2 && !isSpecialCasedOS ? " " + version2 : "") + (this.architecture == 64 ? " 64-bit" : "");
          }
        };
      }
      if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
        if (os) {
          os.architecture = 64;
          os.family = os.family.replace(RegExp(" *" + data), "");
        }
        if (name2 && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
          description.unshift("32-bit");
        }
      } else if (os && /^OS X/.test(os.family) && name2 == "Chrome" && parseFloat(version) >= 39) {
        os.architecture = 64;
      }
      ua || (ua = null);
      var platform3 = {};
      platform3.description = ua;
      platform3.layout = layout && layout[0];
      platform3.manufacturer = manufacturer;
      platform3.name = name2;
      platform3.prerelease = prerelease;
      platform3.product = product;
      platform3.ua = ua;
      platform3.version = name2 && version;
      platform3.os = os || {
        "architecture": null,
        "family": null,
        "version": null,
        "toString": function() {
          return "null";
        }
      };
      platform3.parse = parse;
      platform3.toString = toStringPlatform;
      if (platform3.version) {
        description.unshift(version);
      }
      if (platform3.name) {
        description.unshift(name2);
      }
      if (os && name2 && !(os == String(os).split(" ")[0] && (os == name2.split(" ")[0] || product))) {
        description.push(product ? "(" + os + ")" : "on " + os);
      }
      if (description.length) {
        platform3.description = description.join(" ");
      }
      return platform3;
    }
    var platform2 = parse();
    if (freeExports2 && freeModule2) {
      forOwn(platform2, function(value, key) {
        freeExports2[key] = value;
      });
    } else {
      root2.platform = platform2;
    }
  }).call(commonjsGlobal);
})(platform, platform.exports);
const PlatformDetector = {
  os: (_a = platform.exports.os) == null ? void 0 : _a.family,
  osVersion: (_b = platform.exports.os) == null ? void 0 : _b.version,
  osArchitecture: ((_c = platform.exports.os) == null ? void 0 : _c.architecture) + "-bit",
  browser: platform.exports.name,
  browserVersion: platform.exports.version
};
class PlatformUtil {
  static getBrowser() {
    if (PlatformDetector.browser) {
      return PlatformDetector.browser;
    }
    return "unknown";
  }
  static getOS() {
    if (PlatformDetector.os) {
      return PlatformDetector.os;
    }
    return "unknown";
  }
  static getOSVersion() {
    if (PlatformDetector.osVersion) {
      return PlatformDetector.osVersion;
    }
    return "unknown";
  }
  static getDevice() {
    const os = PlatformDetector.os;
    if (typeof os === "string") {
      if (os.toLowerCase() === "ios") {
        if (platform.exports.product) {
          return platform.exports.product;
        }
      }
      if (os.toLowerCase() === "android") {
        if (platform.exports.product) {
          return platform.exports.product;
        }
        if (platform.exports.manufacturer) {
          return platform.exports.manufacturer;
        }
      }
    }
    return "unknown";
  }
  static isMobile() {
    const os = PlatformDetector.os;
    if (typeof os === "string") {
      const system = os.toLowerCase();
      switch (system) {
        case "ios":
          return true;
        case "android":
          return true;
        default:
          return false;
      }
    } else {
      return false;
    }
  }
  static isAndroid() {
    var _a2;
    const os = (_a2 = PlatformDetector.os) == null ? void 0 : _a2.toLocaleLowerCase();
    return os === "android";
  }
  static isIOS() {
    var _a2;
    const os = (_a2 = PlatformDetector.os) == null ? void 0 : _a2.toLocaleLowerCase();
    return os === "ios";
  }
}
class Controller {
  constructor(scene, camera, player, config) {
    this._isEnabledUpdate = true;
    this._controlAttribute = new ControllerAttribute();
    this._updateHandler = () => {
      var _a2, _b2, _c2;
      if (this._isEnabledUpdate) {
        (_a2 = this._pointController) == null ? void 0 : _a2.update();
        (_b2 = this._keyboardController) == null ? void 0 : _b2.update();
        (_c2 = this._cameraController) == null ? void 0 : _c2.update();
      }
    };
    this._scene = scene;
    this._camera = camera;
    this._player = player;
    this._platform = PlatformUtil.isMobile() ? PLATFORM_ENUM.MOBILE : PLATFORM_ENUM.PC;
    if (config) {
      this._controlAttribute = new ControllerAttribute(config);
    }
    this._locateBox = BABYLON$1.MeshBuilder.CreateBox("c_playerBox", {}, this._scene);
    this._locateBox.isVisible = false;
    if (this._player.asset) {
      this._animationState = new AnimationStateMachine(this._scene, this._player);
    }
    switch (this._platform) {
      case PLATFORM_ENUM.MOBILE:
        this._pointController = new PointController(this._scene, this._camera, this._player, this._locateBox, this._animationState, config);
        this._cameraController = new CameraController(this._scene, this._camera, this._player, this._pointController, this._controlAttribute);
        this._cameraController.thirdPersonCamera(CONTROLLER_TYPE_ENUM.POINT);
        break;
      case PLATFORM_ENUM.PC:
        this._keyboardController = new PcController(this._scene, this._camera, this._player, this._locateBox, this._animationState, config);
        this._cameraController = new CameraController(this._scene, this._camera, this._player, this._keyboardController, this._controlAttribute);
        this._cameraController.thirdPersonCamera(CONTROLLER_TYPE_ENUM.PC);
        break;
    }
  }
  attachControl(option = {}) {
    var _a2, _b2, _c2, _d;
    this._isEnabledUpdate = true;
    const controllerType = this._platform === PLATFORM_ENUM.MOBILE ? CONTROLLER_TYPE_ENUM.POINT : CONTROLLER_TYPE_ENUM.PC;
    (_a2 = this._cameraController) == null ? void 0 : _a2.thirdPersonCamera(controllerType);
    (_b2 = this._cameraController) == null ? void 0 : _b2.attachControl(option);
    (_c2 = this._pointController) == null ? void 0 : _c2.attachPlayer();
    (_d = this._keyboardController) == null ? void 0 : _d.attachPlayer();
    this._scene.registerAfterRender(this._updateHandler);
  }
  detachControl() {
    var _a2, _b2, _c2, _d;
    this._isEnabledUpdate = false;
    (_a2 = this._cameraController) == null ? void 0 : _a2.detachControl();
    (_b2 = this._pointController) == null ? void 0 : _b2.detachPlayer();
    (_c2 = this._keyboardController) == null ? void 0 : _c2.detachPlayer();
    this._scene.unregisterAfterRender(this._updateHandler);
    (_d = this._animationState) == null ? void 0 : _d.startAnimation(AVATAR_ANIMATION_ENUM.IDLE);
  }
  getPointController() {
    return this._pointController;
  }
  getCameraState() {
    var _a2;
    return (_a2 = this._cameraController) == null ? void 0 : _a2.getCameraState(this._camera);
  }
  getDefaultCameraState() {
    return new ControllerAttribute();
  }
  setCameraState(state) {
    var _a2;
    (_a2 = this._cameraController) == null ? void 0 : _a2.setCameraState(state);
  }
  checkObstacleAndProcess() {
    var _a2;
    (_a2 = this._cameraController) == null ? void 0 : _a2.checkHouseObstacleAndProcess();
  }
  stopPlayer() {
    var _a2, _b2;
    (_a2 = this._pointController) == null ? void 0 : _a2._clearTarget();
    (_b2 = this._keyboardController) == null ? void 0 : _b2._clearTarget();
  }
  dispose() {
    var _a2, _b2, _c2, _d;
    this.detachControl();
    (_a2 = this._pointController) == null ? void 0 : _a2.dispose();
    (_b2 = this._keyboardController) == null ? void 0 : _b2.dispose();
    (_c2 = this._cameraController) == null ? void 0 : _c2.dispose();
    (_d = this._animationState) == null ? void 0 : _d.dispose();
    this._locateBox.dispose();
  }
}
const ConfigController = {
  v1: 2.5,
  v2: 8,
  L0: 4,
  a_default: 70,
  a_max: 85,
  b_max: 35,
  L_default: 10,
  L_max: 150,
  L_min: 5,
  v3: 5,
  v4: 1,
  x_offset: 0,
  y_offset: 3,
  z_offset: 0,
  righting: 1,
  x: 0.578,
  y: 1.3,
  z: 12.317,
  orientation: 180,
  houseOpacity: 0.15
};
const loading = (baseUrlString2) => {
  return {
    logo: {
      url: baseUrlString2 + "game_njcb/loading/title.svg",
      mobile: {
        top: 130,
        width: 276,
        height: 51,
        zIndex: 11,
        verticalAlignment: Control.VERTICAL_ALIGNMENT_CENTER
      },
      pc: {
        top: 130 * 2,
        width: 276 * 2,
        height: 51 * 2,
        zIndex: 11,
        verticalAlignment: Control.VERTICAL_ALIGNMENT_CENTER
      }
    },
    progressText: {
      mobile: {
        top: 12,
        fontSize: 24,
        color: "#E70013",
        zIndex: 11,
        textVerticalAlignment: Control.VERTICAL_ALIGNMENT_CENTER
      },
      pc: {
        top: 12,
        fontSize: 24 * 2,
        color: "#E70013",
        zIndex: 11,
        textVerticalAlignment: Control.VERTICAL_ALIGNMENT_CENTER
      }
    },
    loadingProgressBackground: {
      url: baseUrlString2 + "game_njcb/loading/loading_progress_background.svg",
      mobile: {
        top: 12,
        width: 130,
        height: 130,
        zIndex: 11,
        verticalAlignment: Control.VERTICAL_ALIGNMENT_CENTER
      },
      pc: {
        top: 12,
        width: 130 * 2,
        height: 130 * 2,
        zIndex: 11,
        verticalAlignment: Control.VERTICAL_ALIGNMENT_CENTER
      }
    },
    loadingSuccessButton: {
      url: baseUrlString2 + "game_njcb/loading/loading_success_button.svg",
      mobile: {
        top: 12,
        width: 48,
        height: 48,
        zIndex: 11,
        verticalAlignment: Control.VERTICAL_ALIGNMENT_CENTER
      },
      pc: {
        top: 12,
        width: 48 * 2,
        height: 48 * 2,
        zIndex: 11,
        verticalAlignment: Control.VERTICAL_ALIGNMENT_CENTER
      }
    },
    bottom: {
      url: baseUrlString2 + "game_njcb/loading/logo.svg",
      mobile: {
        top: -50.69,
        width: 130,
        height: 36,
        zIndex: 11,
        verticalAlignment: Control.VERTICAL_ALIGNMENT_BOTTOM
      },
      pc: {
        top: -50.69,
        width: 130,
        height: 36,
        zIndex: 11,
        verticalAlignment: Control.VERTICAL_ALIGNMENT_BOTTOM
      }
    },
    background: {
      url: baseUrlString2 + "game_njcb/loading/njcb_loading_background.png",
      mobile: {
        height: "100%",
        width: "100%",
        thickness: 0,
        background: "#ffffff",
        zIndex: 10
      },
      pc: {
        height: "100%",
        width: "100%",
        thickness: 0,
        background: "#ffffff",
        zIndex: 10
      }
    }
  };
};
const baseUrlString = "/";
const ConfigAsset = {
  avatar: {
    model: {
      rootUrl: baseUrlString + "game_njcb/avatar/",
      file: "Avatar.glb"
    },
    texture: baseUrlString + "game_njcb/avatar/Avatar_Texture.jpg",
    titleView: {
      activeImageUrl: "./game_njcb/icon/ic_egg_duck_bang.png",
      defaultImageUrl: ""
    }
  },
  loading: loading(baseUrlString),
  showGround: {
    rootUrl: baseUrlString + "game_njcb/scene/S_NanJingYinHangScene/",
    file: "S_NanJinScene.gltf",
    texture: {
      test: "test"
    }
  },
  collisionGround: {
    rootUrl: baseUrlString + "game_njcb/scene/",
    file: "C_NanJingYinHang.glb"
  },
  interactGround: {
    rootUrl: baseUrlString + "game_njcb/scene/",
    file: "I_NanJingYinHang.glb"
  },
  sound: {
    bgm: {
      tag: "bgm",
      url: baseUrlString + "game_njcb/sound/njyh_bgm.mp3"
    },
    duck: {
      tag: "sound_duck",
      url: baseUrlString + "game_njcb/sound/njyh_caidanya_refresh.mp3"
    },
    button: {
      bgmOn: baseUrlString + "game_porsche/button/bgm_on.png",
      bgmOff: baseUrlString + "game_porsche/button/bgm_off.png"
    }
  },
  duck: {
    model: {
      rootUrl: baseUrlString + "game_njcb/scene/",
      file: "New_duck_animation.glb"
    },
    texture: baseUrlString + "game_njcb/scene/Duck_Texture.png"
  },
  pondDuck: {
    model: {
      rootUrl: baseUrlString + "game_njcb/scene/",
      file: "Duck_no_feet.glb"
    },
    texture: baseUrlString + "game_njcb/scene/Duck_Texture.png"
  },
  paintedEggshellDuck: {
    rootUrl: baseUrlString + "game_njcb/painted_eggshell_duck/",
    file: "CaiDanYa.glb"
  },
  clouds: {
    rootUrl: baseUrlString + "game_njcb/scene/Clouds/",
    file: "Clouds.gltf"
  },
  guangGaoYa: {
    rootUrl: baseUrlString + "game_njcb/scene/GuangGaoYa/",
    file: "GuangGaoYa.gltf"
  }
};
const AvatarAssetOptionsDefault = {
  staticMeshes: ["Basics_Head"],
  dynamicMeshes: ["Basics_Pants_1", "Basics_Shirt_1", "Basics_Hair_1"]
};
class Avatar {
  constructor(scene, avatarAsset, avatarTextureUrl) {
    this._scene = scene;
    this._avatarAsset = avatarAsset;
    this._avatarMaterial = new BABYLON$1.StandardMaterial("avatar", scene);
    this._avatarMaterial.specularColor = new Color3$1(0.1, 0.1, 0.1);
    this._avatarMaterial.specularPower = 128;
    this._avatarMaterial.backFaceCulling = false;
    const avatarTexture = new BABYLON$1.Texture(avatarTextureUrl, scene);
    avatarTexture.vScale = -1;
    this._avatarMaterial.diffuseTexture = avatarTexture;
  }
  getAvatarMaterial() {
    return this._avatarMaterial;
  }
  getAvatarAsset() {
    return this._avatarAsset;
  }
  CreateAvatar(name2, titleTextString, titleViewUrl, options) {
    const rootHeight = 2;
    const root2 = this._createRoot(name2, rootHeight);
    options = options ? options : AvatarAssetOptionsDefault;
    const cloneAsset = this._cloneAvatarAsset(this._avatarAsset, name2, options);
    cloneAsset.meshes[0].parent = root2;
    cloneAsset.meshes[0].position.y = -1.1;
    const res = {
      name: name2,
      rootHeight,
      root: root2,
      asset: cloneAsset
    };
    if (titleTextString || titleViewUrl) {
      res.billboard = this._createBillboard(name2, rootHeight, root2, titleViewUrl == null ? void 0 : titleViewUrl.titlePickable);
    }
    if (titleTextString && res.billboard) {
      res.titleText = this._createTitleText(titleTextString, res.billboard.texture);
    }
    if (titleViewUrl && res.billboard) {
      res.titleView = this._createTitleView(titleViewUrl, res.billboard.texture);
    }
    return res;
  }
  _createBillboard(name2, rootHeight, root2, titlePickable) {
    const scale = 2;
    const radio = 2;
    const w = 0.5 * radio * scale;
    const h = 0.5 * scale;
    const billboard = BABYLON$1.MeshBuilder.CreatePlane(name2, { width: w, height: h }, this._scene);
    billboard.billboardMode = BABYLON$1.AbstractMesh.BILLBOARDMODE_ALL;
    billboard.position.y = rootHeight * 0.43 + h * 0.63;
    billboard.parent = root2;
    const textureResolution = 512;
    const billboardTexutre = BABYLONGUI.AdvancedDynamicTexture.CreateForMesh(billboard, textureResolution * radio, textureResolution);
    const billboardMaterial = new BABYLON$1.StandardMaterial(name2, this._scene);
    billboardMaterial.diffuseTexture = billboardTexutre;
    billboardMaterial.emissiveColor = new BABYLON$1.Color3(1, 1, 1);
    billboardMaterial.alpha = 1;
    billboard.material = billboardMaterial;
    billboardMaterial.specularColor = BABYLON$1.Color3.Red();
    const isPickable = titlePickable !== void 0 ? titlePickable : true;
    billboard.isPickable = isPickable;
    return { mesh: billboard, texture: billboardTexutre };
  }
  _createTitleView(titleViewUrl, billboardTexutre) {
    const grid = new BABYLONGUI.Grid();
    grid.width = 1;
    grid.height = 1;
    grid.addColumnDefinition(1);
    grid.addRowDefinition(0.5);
    billboardTexutre.addControl(grid);
    const imgActive = new BABYLONGUI.Image(name + "imgActive", titleViewUrl.activeImageUrl);
    imgActive.stretch = BABYLONGUI.Image.STRETCH_UNIFORM;
    imgActive.width = 0.5;
    imgActive.height = 0.5;
    imgActive.isVisible = false;
    grid.addControl(imgActive, 0, 0);
    const imageDefault = new BABYLONGUI.Image(name + "defaultActive", titleViewUrl.defaultImageUrl);
    imageDefault.stretch = BABYLONGUI.Image.STRETCH_UNIFORM;
    imageDefault.width = 0.5;
    imageDefault.height = 0.5;
    grid.addControl(imageDefault, 0, 0);
    return grid;
  }
  _createTitleText(titleTextString, billboardTexutre) {
    const textBlock = new BABYLONGUI.TextBlock();
    textBlock.text = titleTextString;
    textBlock.textWrapping = BABYLONGUI.TextWrapping.Ellipsis;
    textBlock.color = "white";
    textBlock.fontFamily = "monospace";
    textBlock.fontWeight = "bold";
    textBlock.fontSizeInPixels = 120;
    textBlock.top = 190;
    billboardTexutre.addControl(textBlock);
    return textBlock;
  }
  _createRoot(text, rootHeight) {
    const root2 = BABYLON$1.MeshBuilder.CreateBox(text, { width: rootHeight * 0.7 * 0.5, height: rootHeight, depth: rootHeight * 0.25 }, this._scene);
    root2.checkCollisions = true;
    const rootMaterial = new BABYLON$1.StandardMaterial(text, this._scene);
    rootMaterial.alpha = 0;
    root2.material = rootMaterial;
    return root2;
  }
  _cloneAvatarAsset(assetContainer, prefix, options) {
    const cloneAssetContainer = new BABYLON$1.AssetContainer();
    const cloneSkeleton = assetContainer.skeletons[0].clone(prefix + "_" + assetContainer.skeletons[0].name);
    const cloneAnimationGroupIdle = new BABYLON$1.AnimationGroup(AVATAR_ANIMATION_ENUM.IDLE, this._scene);
    const cloneAnimationGroupWalk = new BABYLON$1.AnimationGroup(AVATAR_ANIMATION_ENUM.WALK, this._scene);
    const cloneAnimationGroupRun = new BABYLON$1.AnimationGroup(AVATAR_ANIMATION_ENUM.RUN, this._scene);
    const cloneAnimationGroupWave = new BABYLON$1.AnimationGroup(AVATAR_ANIMATION_ENUM.WAVE, this._scene);
    try {
      for (let i = 0; i < cloneSkeleton.bones.length; i++) {
        const transformNode = cloneSkeleton.bones[i].getTransformNode();
        if (transformNode) {
          const cloneTransformNode = transformNode.clone(prefix + "_" + transformNode.name, null);
          if (cloneTransformNode) {
            cloneSkeleton.bones[i].linkTransformNode(cloneTransformNode);
            for (let j = 0; j < transformNode.animations.length; j++) {
              cloneTransformNode.animations.push(transformNode.animations[j]);
            }
            if (cloneTransformNode.animations.length >= 12) {
              cloneAnimationGroupIdle.addTargetedAnimation(cloneTransformNode.animations[0], cloneTransformNode);
              cloneAnimationGroupIdle.addTargetedAnimation(cloneTransformNode.animations[1], cloneTransformNode);
              cloneAnimationGroupIdle.addTargetedAnimation(cloneTransformNode.animations[2], cloneTransformNode);
              cloneAnimationGroupRun.addTargetedAnimation(cloneTransformNode.animations[3], cloneTransformNode);
              cloneAnimationGroupRun.addTargetedAnimation(cloneTransformNode.animations[4], cloneTransformNode);
              cloneAnimationGroupRun.addTargetedAnimation(cloneTransformNode.animations[5], cloneTransformNode);
              cloneAnimationGroupWalk.addTargetedAnimation(cloneTransformNode.animations[6], cloneTransformNode);
              cloneAnimationGroupWalk.addTargetedAnimation(cloneTransformNode.animations[7], cloneTransformNode);
              cloneAnimationGroupWalk.addTargetedAnimation(cloneTransformNode.animations[8], cloneTransformNode);
              cloneAnimationGroupWave.addTargetedAnimation(cloneTransformNode.animations[9], cloneTransformNode);
              cloneAnimationGroupWave.addTargetedAnimation(cloneTransformNode.animations[10], cloneTransformNode);
              cloneAnimationGroupWave.addTargetedAnimation(cloneTransformNode.animations[11], cloneTransformNode);
            }
          }
        }
      }
    } catch (e) {
      console.error("Error: _cloneAvatarAsset", e);
    }
    cloneAssetContainer.animationGroups.push(cloneAnimationGroupIdle, cloneAnimationGroupRun, cloneAnimationGroupWalk, cloneAnimationGroupWave);
    cloneAssetContainer.animationGroups[0].play(true);
    const cloneRoot = assetContainer.meshes[0].clone(prefix + "_" + assetContainer.meshes[0].name, null, true);
    if (cloneRoot) {
      cloneRoot.isPickable = false;
      cloneAssetContainer.meshes.push(cloneRoot);
    }
    for (let i = 0; i < assetContainer.meshes.length; i++) {
      const originMesh = assetContainer.meshes[i];
      const meshName = originMesh.name;
      const isStaticMesh = options.staticMeshes.indexOf(meshName) >= 0;
      const isDynamicMesh = options.dynamicMeshes.indexOf(meshName) >= 0;
      if (isStaticMesh || isDynamicMesh) {
        const cloneMesh = originMesh.clone(prefix + "_" + meshName, null, true);
        if (cloneMesh) {
          cloneMesh.parent = cloneRoot;
          cloneMesh.isPickable = false;
          cloneMesh.checkCollisions = false;
          cloneMesh.skeleton = cloneSkeleton;
          cloneAssetContainer.meshes.push(cloneMesh);
          cloneMesh.material = this._avatarMaterial;
        }
      }
    }
    return cloneAssetContainer;
  }
}
function mitt(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
class Emitter {
  constructor(emitter) {
    this._isOnwer = true;
    if (emitter) {
      this._emitter = emitter;
      this._isOnwer = false;
    } else {
      this._emitter = mitt();
    }
    this._listeners = /* @__PURE__ */ new Map();
  }
  on(event, listener) {
    var _a2;
    if (this._listeners.has(event)) {
      (_a2 = this._listeners.get(event)) == null ? void 0 : _a2.push(listener);
    } else {
      this._listeners.set(event, [listener]);
    }
    this._emitter.on(event, listener);
  }
  emit(event, data) {
    this._emitter.emit(event, data);
  }
  off(event, listener) {
    if (this._listeners.has(event)) {
      const listeners = this._listeners.get(event);
      if (listeners) {
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
          this._emitter.off(event, listener);
        }
      }
    }
  }
  dispose() {
    if (this._isOnwer) {
      this._emitter.all.clear();
    } else {
      this._listeners.forEach((listeners, event) => {
        listeners.forEach((listener) => {
          this._emitter.off(event, listener);
        });
      });
    }
    this._listeners.clear();
  }
}
var NjcbEventEnum = /* @__PURE__ */ ((NjcbEventEnum2) => {
  NjcbEventEnum2["ChangeDuck"] = "changeDuck";
  NjcbEventEnum2["RiseDuck"] = "riseDuck";
  NjcbEventEnum2["ChangeRole"] = "changeRole";
  NjcbEventEnum2["NPC_START"] = "npcStart";
  NjcbEventEnum2["NPC_END"] = "npcEnd";
  NjcbEventEnum2["START_GUID"] = "startGuide";
  NjcbEventEnum2["END_GUID"] = "endGuide";
  NjcbEventEnum2["GET_CONFIG"] = "getConfig";
  NjcbEventEnum2["SCENE_ENTER"] = "3dEnter";
  NjcbEventEnum2["WRONG_NET_WORK"] = "wrongNetwork";
  NjcbEventEnum2["Open_Account"] = "openAccount";
  NjcbEventEnum2["Wrong_Account"] = "wrongAccount";
  NjcbEventEnum2["SHOW_DUCK_DIALOG"] = "showDuckDialog";
  NjcbEventEnum2["HIDDEN_DUCK_DIALOG"] = "hideDuckDialog";
  NjcbEventEnum2["GET_DUCK"] = "getDuck";
  NjcbEventEnum2["UPDATE_HOME"] = "updateHome";
  NjcbEventEnum2["CAMERA_START"] = "cameraStart";
  NjcbEventEnum2["CAMERA_END"] = "cameraEnd";
  NjcbEventEnum2["SHOW_DUCK_POPUP"] = "showDuckPopup";
  NjcbEventEnum2["HIDE_DUCK_POPUP"] = "hideDuckPopup";
  return NjcbEventEnum2;
})(NjcbEventEnum || {});
const HouseObstacleList = ["House_1", "House_2", "House_3", "House_4", "House_5", "House_6", "House_7", "Ya_Mesh"];
function GetControlAttributeByConfig(configController) {
  const configAttribute = new ControllerAttribute();
  const rateScale = 1;
  const sensityScale = 1e3;
  const zoomScale = 0.01;
  configAttribute.walkSpeed = configController.v1 * rateScale;
  configAttribute.runSpeed = configController.v2 * rateScale;
  configAttribute.betaDefault = configController.a_default * Math.PI / 180;
  configAttribute.angularSensibility = configAttribute.angularSensibility * sensityScale;
  configAttribute.zoomInOutSpeed = configAttribute.zoomInOutSpeed * zoomScale;
  configAttribute.houseObstacleList = HouseObstacleList;
  if (configController.L_default >= 15 && configController.L_default <= 60) {
    configAttribute.cameraDistDefault = configController.L_default;
  } else if (configController.L_default > 60) {
    configAttribute.cameraDistDefault = 60;
  } else {
    configAttribute.cameraDistDefault = 15;
  }
  if (configController.y_offset >= 0 && configController.y_offset <= 6) {
    configAttribute.yOffset = configController.y_offset;
  } else if (configController.y_offset > 6) {
    configAttribute.yOffset = 6;
  } else {
    configAttribute.yOffset = 0;
  }
  return configAttribute;
}
class SoundUtil {
  constructor() {
    console.warn("SoundUtil has NO constructor");
  }
  static isBackgroundMusicPlaying() {
    if (this._currentBGM) {
      return this._currentBGM.isPlaying;
    }
    return false;
  }
  static playSoundEffect(name2) {
    const sound = this._getSoundEffect(name2);
    if (sound) {
      if (sound.isReady()) {
        sound.play();
      }
    }
  }
  static playBackgroundMusic(name2) {
    const sound = this._getSoundEffect(name2);
    if (sound) {
      if (this._currentBGM) {
        if (this._currentBGM !== sound) {
          this._currentBGM.stop();
        }
      }
      if (sound.isReady()) {
        sound.play();
        this._currentBGM = sound;
      }
    }
  }
  static stopBackgroundMusic() {
    if (this._currentBGM) {
      this._currentBGM.stop();
      this._currentBGM = null;
    }
  }
  static pauseBackgroundMusic() {
    if (this._currentBGM && this._currentBGM.isPlaying) {
      this._currentBGM.pause();
    }
  }
  static clear() {
    var _a2, _b2;
    if (this._currentBGM) {
      if (this._currentBGM.isPaused || this._currentBGM.isPlaying) {
        this._currentBGM.stop();
      }
      this._currentBGM = null;
    }
    (_a2 = this._cache) == null ? void 0 : _a2.forEach((v) => {
      v.dispose();
    });
    (_b2 = this._cache) == null ? void 0 : _b2.clear();
  }
  static loadSoundEffect(name2, path) {
    if (!this._cache.has(name2)) {
      const sound = new BABYLON$1.Sound(name2, path, null, null, { autoplay: false, loop: false });
      this._cache.set(name2, sound);
    }
  }
  static loadBackgroundMusic(name2, path, readyToPlayCallback, option = void 0) {
    if (!this._cache.has(name2)) {
      const volume = (option == null ? void 0 : option.volume) ? option.volume : 1;
      const sound = new BABYLON$1.Sound(name2, path, null, readyToPlayCallback, { autoplay: false, loop: true, volume });
      this._cache.set(name2, sound);
    }
  }
  static _getSoundEffect(name2) {
    if (name2 === null || name2 === void 0 || name2.length === 0) {
      return null;
    }
    if (this._cache !== null && this._cache.has(name2)) {
      const ret = this._cache.get(name2);
      if (ret !== void 0) {
        return ret;
      }
    }
    return null;
  }
  static setVolume(volume) {
    var _a2;
    if (volume > 1) {
      volume = 1;
    }
    if (volume < 0) {
      volume = 0;
    }
    (_a2 = BABYLON$1.Engine.audioEngine) == null ? void 0 : _a2.setGlobalVolume(volume);
  }
  static getVolume() {
    const audioEngine = BABYLON$1.Engine.audioEngine;
    if (audioEngine) {
      return audioEngine.getGlobalVolume();
    }
    return -1;
  }
}
SoundUtil._cache = /* @__PURE__ */ new Map();
SoundUtil._currentBGM = null;
const ConfigBgm = {
  defaultVolume: 0.45
};
const _SoundManager = class {
  constructor() {
    this._IsBgmOnWhenRunning = true;
    this._bgmState = 0;
    this._waitToPlayBGM = false;
    this._voiceInfo = {
      bgmUrl: "",
      duckUrl: ""
    };
    if (BABYLON$1.Engine.audioEngine) {
      BABYLON$1.Engine.audioEngine.useCustomUnlockedButton = true;
    } else {
      alert("No audio engine detected");
    }
  }
  static getInstance() {
    if (this._instance === void 0) {
      this._instance = new _SoundManager();
    }
    return this._instance;
  }
  loadAll(ui, voiceConfig = void 0) {
    this._bgmState = 1;
    this._bgmIcon = this._createBackgroundMusicIcon(ui);
    this._parseVoiceInfo(voiceConfig);
    SoundUtil.loadBackgroundMusic(ConfigAsset.sound.bgm.tag, this._voiceInfo.bgmUrl, () => {
      SoundUtil.setVolume(1);
      this._bgmState = 2;
      if (this._waitToPlayBGM) {
        this.showSoundIconAndPlay();
      }
    }, { volume: ConfigBgm.defaultVolume });
    SoundUtil.loadSoundEffect(ConfigAsset.sound.duck.tag, this._voiceInfo.duckUrl);
  }
  showSoundIconAndPlay() {
    if (this._bgmState === 2) {
      SoundUtil.playBackgroundMusic(ConfigAsset.sound.bgm.tag);
      this._bgmState = 3;
      if (this._bgmIcon) {
        this._refreshBGMButtonUI(this._bgmIcon, true);
      }
    } else {
      this._waitToPlayBGM = true;
    }
  }
  rest() {
    if (this._bgmState === 3) {
      this._bgmState = 4;
      SoundUtil.pauseBackgroundMusic();
    }
  }
  resume() {
    if (this._bgmState === 4) {
      this._bgmState = 3;
      if (this._IsBgmOnWhenRunning) {
        SoundUtil.playBackgroundMusic(ConfigAsset.sound.bgm.tag);
      }
    }
  }
  playDuckSoundEffect() {
    if (this._IsBgmOnWhenRunning && this._bgmState === 3) {
      SoundUtil.playSoundEffect(ConfigAsset.sound.duck.tag);
    }
  }
  clear() {
    _SoundManager._instance = void 0;
    SoundUtil.clear();
  }
  _createBackgroundMusicIcon(ui) {
    const dpr = window.devicePixelRatio;
    const isMobile = PlatformUtil.isMobile();
    const icon = new BABYLONGUI.Image();
    icon.isVisible = true;
    icon.isPointerBlocker = true;
    icon.onPointerClickObservable.add(() => {
      const playing = this._IsBgmOnWhenRunning;
      if (playing) {
        SoundUtil.pauseBackgroundMusic();
        this._IsBgmOnWhenRunning = false;
      } else {
        SoundUtil.playBackgroundMusic(ConfigAsset.sound.bgm.tag);
        this._IsBgmOnWhenRunning = true;
      }
      this._refreshBGMButtonUI(icon, !playing);
    });
    icon.horizontalAlignment = BABYLONGUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
    icon.verticalAlignment = BABYLONGUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
    if (isMobile) {
      icon.width = 24 * dpr + "px";
      icon.height = 24 * dpr + "px";
      icon.top = -34 * dpr + "px";
      icon.left = 16 * dpr + "px";
    } else {
      icon.width = 24 * dpr + "px";
      icon.height = 24 * dpr + "px";
      icon.top = -34 * dpr + "px";
      icon.left = 16 * dpr + "px";
    }
    ui.addControl(icon);
    return icon;
  }
  _refreshBGMButtonUI(icon, isPlaying) {
    if (icon) {
      if (isPlaying) {
        icon.source = ConfigAsset.sound.button.bgmOn;
      } else {
        icon.source = ConfigAsset.sound.button.bgmOff;
      }
    }
  }
  _parseVoiceInfo(voiceConfig) {
    if (voiceConfig instanceof Array) {
      voiceConfig.forEach((item) => {
        if (item.id === 70001) {
          this._voiceInfo.duckUrl = item.path + item.name;
        } else if (item.id === 70002) {
          this._voiceInfo.bgmUrl = item.path + item.name;
        }
      });
    }
  }
};
let SoundManager = _SoundManager;
SoundManager._instance = void 0;
const origin$1 = {
  scale: 1
};
const target$1 = {
  scale: 1.3
};
const npcTitleViewAnimationMap$1 = {};
function NpcTitleViewBigAnimation$1(mesh) {
  const tweenOutHot = npcTitleViewAnimationMap$1[mesh.uniqueId];
  if (tweenOutHot && tweenOutHot.isPlaying()) {
    tweenOutHot.stop();
  }
  const tweenInHot = getInHotTween$1();
  npcTitleViewAnimationMap$1[mesh.uniqueId] = tweenInHot;
  tweenInHot.start().onUpdate((obj, elapsed) => {
    mesh.scaling.set(obj.scale, obj.scale, obj.scale);
  }).onStop(() => {
    removeTweenFormMap$1(mesh.uniqueId, tweenInHot);
  }).onComplete(() => {
    removeTweenFormMap$1(mesh.uniqueId, tweenInHot);
  });
}
function removeTweenFormMap$1(id, tween) {
  if (npcTitleViewAnimationMap$1[id] === tween) {
    npcTitleViewAnimationMap$1[id] = null;
  }
}
const inHotTweenPool$1 = [];
function getInHotTween$1() {
  let tweenInHot = inHotTweenPool$1.find((tween) => !tween.isPlaying());
  if (!tweenInHot) {
    tweenInHot = new Tween(Object.assign({}, origin$1)).to(Object.assign({}, target$1)).easing(Easing.Quadratic.InOut).duration(300);
    inHotTweenPool$1.push(tweenInHot);
  }
  return tweenInHot;
}
function CreatePlayer(avatar) {
  const titleOption = {
    activeImageUrl: ConfigAsset.avatar.titleView.activeImageUrl,
    defaultImageUrl: ConfigAsset.avatar.titleView.defaultImageUrl,
    titlePickable: false
  };
  const player = avatar.CreateAvatar("player", void 0, titleOption);
  player.root.position.set(ConfigController.x, ConfigController.y, ConfigController.z);
  player.root.rotation.y = ConfigController.orientation / 180 * Math.PI;
  player.root.isPickable = false;
  player.root.checkCollisions = true;
  return player;
}
function ChangeActiveImageVisible(player, isVisible) {
  if (player.titleView) {
    if (isVisible) {
      player.titleView.children[0].isVisible = true;
      player.titleView.children[1].isVisible = false;
      player.billboard && NpcTitleViewBigAnimation$1(player.billboard.mesh);
    } else {
      player.titleView.children[0].isVisible = false;
      player.titleView.children[1].isVisible = true;
    }
  }
}
function UpdateAvatarAssetOption(prefix, player, avatar, options) {
  var _a2, _b2;
  const cachedSkeleton = (_a2 = player.asset.meshes.find((mesh) => {
    return mesh.name.endsWith("Basics_Head");
  })) == null ? void 0 : _a2.skeleton;
  const allDynamicMesh = [];
  options.dynamicMeshes.forEach((item) => {
    allDynamicMesh.push(item);
  });
  const assetContainer = player.asset;
  for (let i = 0; i < assetContainer.meshes.length; i++) {
    const targetMesh = assetContainer.meshes[i];
    const meshName = targetMesh.name;
    const originMeshName = meshName.replace(prefix + "_", "");
    if (originMeshName.startsWith("Basics_")) {
      if ((_b2 = options.staticMeshes) == null ? void 0 : _b2.includes(originMeshName)) {
        targetMesh.setEnabled(true);
        continue;
      }
      const index = allDynamicMesh.indexOf(originMeshName);
      if (index >= 0) {
        targetMesh.setEnabled(true);
        allDynamicMesh.splice(index, 1);
      } else {
        targetMesh.setEnabled(false);
      }
    }
  }
  if (allDynamicMesh.length > 0) {
    const playerRoot = assetContainer.meshes[0];
    const originContainer = avatar.getAvatarAsset();
    originContainer.meshes.forEach((mesh) => {
      if (allDynamicMesh.includes(mesh.name)) {
        const meshName = mesh.name;
        const cloneMesh = mesh.clone(prefix + "_" + mesh.name, null, true);
        if (cloneMesh) {
          cloneMesh.setEnabled(true);
          cloneMesh.setParent(playerRoot);
          cloneMesh.isPickable = false;
          cloneMesh.position.set(0, 0, 0);
          cloneMesh.rotation.set(0, 0, 0);
          cloneMesh.checkCollisions = false;
          cloneMesh.skeleton = cachedSkeleton;
          cloneMesh.material = avatar.getAvatarMaterial().clone(prefix + "_ma_" + meshName);
          assetContainer.meshes.push(cloneMesh);
        }
      }
    });
  }
}
function ShowGround(scene, showGroundAsset) {
  var _a2;
  const groundAssetContainer = showGroundAsset == null ? void 0 : showGroundAsset.asset;
  if (!groundAssetContainer) {
    return;
  }
  groundAssetContainer.addAllToScene();
  for (let i = 0; i < groundAssetContainer.meshes.length; i++) {
    groundAssetContainer.meshes[i].isPickable = false;
    groundAssetContainer.meshes[i].checkCollisions = false;
  }
  (_a2 = showGroundAsset.asset) == null ? void 0 : _a2.materials.find((mat) => {
    if (mat.name === "M_ShuYe") {
      mat.transparencyMode = 3;
    }
  });
}
function CollisionGround(scene, collisionGroundAsset) {
  const collisionAsset = collisionGroundAsset == null ? void 0 : collisionGroundAsset.asset;
  if (!collisionAsset) {
    return;
  }
  collisionAsset.addAllToScene();
  const material = new BABYLON$1.StandardMaterial("collision", scene);
  material.alpha = 0;
  for (let i = 0; i < collisionAsset.meshes.length; i++) {
    collisionAsset.meshes[i].isPickable = false;
    collisionAsset.meshes[i].checkCollisions = true;
    const oldmaterial = collisionAsset.meshes[i].material;
    oldmaterial == null ? void 0 : oldmaterial.dispose();
    collisionAsset.meshes[i].material = material;
    if (collisionAsset.meshes[i].name === "C_Ground") {
      collisionAsset.meshes[i].isPickable = true;
    }
  }
}
class AssetLoadingView {
  constructor(scene, ui, assetManager, options, onEnter) {
    this._isShow = false;
    this._dpr = window.devicePixelRatio;
    this._sleeptime = 0;
    this._pxList = ["top", "left", "width", "height", "fontSize", "padding", "margin", "borderWidth", "borderRadius"];
    this._platform = PlatformUtil.isMobile() ? "mobile" : "pc";
    this._updateHandler = () => {
      const progress = this._assetManager.getProgress() * 100;
      this._progressText.text = progress.toFixed(0) + "%";
      if (progress === 100) {
        this._sleeptime += 0.3;
        if (this._sleeptime > 2) {
          this._scene.unregisterBeforeRender(this._updateHandler);
          this._ui.removeControl(this._progressText);
          this._ui.addControl(this._completeButton);
        }
      }
    };
    this._scene = scene;
    this._ui = ui;
    this._assetManager = assetManager;
    this._progressText = new BABYLONGUI.TextBlock();
    this.merageProps(this._progressText, options.progressText[this._platform]);
    this._completeButton = BABYLONGUI.Button.CreateImageOnlyButton("", options.loadingSuccessButton.url);
    this._completeButton.thickness = 0;
    this.merageProps(this._completeButton, options.loadingSuccessButton[this._platform]);
    this._completeButton.onPointerClickObservable.add(() => {
      this.hide();
      onEnter();
    });
    this._progressBackgroundImage = new BABYLONGUI.Image("", options.loadingProgressBackground.url);
    this.merageProps(this._progressBackgroundImage, options.loadingProgressBackground[this._platform]);
    this._mainKVImage = new BABYLONGUI.Image("", options.background.url);
    this._mainKVImage.horizontalAlignment = BABYLONGUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
    this._mainKVImage.verticalAlignment = BABYLONGUI.Control.VERTICAL_ALIGNMENT_TOP;
    this._mainKVImage.stretch = 0;
    this._mainKVImage.width = 1;
    this._mainKVImage.onImageLoadedObservable.add(() => {
      this.show();
      this._mainKVImage.height = this._mainKVImage.imageHeight / this._mainKVImage.imageWidth * window.innerWidth * window.devicePixelRatio + "px";
    });
    this._bg = this._createBg(options);
  }
  dispose() {
  }
  show() {
    if (this._isShow) {
      return;
    }
    this._ui.addControl(this._progressText);
    this._ui.addControl(this._bg);
    this._ui.addControl(this._progressBackgroundImage);
    this._scene.registerBeforeRender(this._updateHandler);
    this._isShow = true;
  }
  hide() {
    if (!this._isShow) {
      return;
    }
    this._ui.removeControl(this._progressText);
    this._ui.removeControl(this._completeButton);
    this._ui.removeControl(this._progressBackgroundImage);
    this._ui.removeControl(this._bg);
    this._scene.unregisterBeforeRender(this._updateHandler);
    this._isShow = false;
  }
  unitFix(key, value, dpr = true) {
    if (typeof value === "number" && this._pxList.indexOf(key) > -1) {
      return dpr ? value * this._dpr + "px" : value + "px";
    } else {
      return value;
    }
  }
  merageProps(control, options = {}) {
    for (const key in options) {
      if (Object.prototype.hasOwnProperty.call(options, key)) {
        control[key] = this.unitFix(key, options[key]);
      }
    }
  }
  _createBg(options) {
    const bg = new BABYLONGUI.Rectangle();
    this.merageProps(bg, options.background[this._platform]);
    const logoblock = new BABYLONGUI.Image("", options.logo.url);
    this.merageProps(logoblock, options.logo[this._platform]);
    bg.addControl(this._mainKVImage);
    bg.addControl(logoblock);
    const bottomblock = new BABYLONGUI.Image("", options.bottom.url);
    this.merageProps(bottomblock, options.bottom[this._platform]);
    bg.addControl(bottomblock);
    return bg;
  }
}
const assetLoader = (scene) => {
  return (asset) => {
    return new Promise((resolve, reject) => {
      SceneLoader.LoadAssetContainer(asset.rootUrl, asset.file, scene, (container) => {
        asset.asset = container;
        resolve(container);
      }, null, () => {
        reject();
      });
    });
  };
};
const fnLoader = () => {
  return (callback) => {
    return new Promise((resolve, reject) => {
      try {
        callback();
        resolve("finish");
      } catch (error) {
        reject(error);
      }
    });
  };
};
const axiosInstance = axios.create({
  headers: {
    withCredentials: false
  }
});
const config_loader = (path, config) => {
  return (file) => {
    return axiosInstance.get(path + file).then((res) => {
      const data = res.data.data;
      if (file.includes("scattered") || file.includes("scattered1")) {
        config[file.replace(".json", "")] = data.reduce((acc, item) => {
          acc[item.key] = item.value;
          return acc;
        }, {});
      } else {
        config[file.replace(".json", "")] = data;
      }
      return res;
    });
  };
};
const ConfigNpc = [
  {
    name: "P1",
    position: { x: -3.087, y: 1.3, z: 32.3 },
    yRotation: -10,
    tableId: 50001
  },
  {
    name: "P2",
    position: { x: -25.7609, y: 1.3, z: -17.147 },
    yRotation: -39.11,
    tableId: 50002
  },
  {
    name: "P3",
    position: { x: -36.935, y: 1.3, z: -15.467 },
    yRotation: 32,
    tableId: 50003
  },
  {
    name: "P4",
    position: { x: -34.077, y: 1.3, z: -4.451 },
    yRotation: 0,
    tableId: 50004
  },
  {
    name: "N1",
    position: { x: 0.517, y: 1.3, z: 7.998 },
    yRotation: 0,
    tableId: 50005
  },
  {
    name: "N2",
    position: { x: -11.201, y: 1.3, z: 10.887 },
    yRotation: -58,
    tableId: 50006
  },
  {
    name: "N3",
    position: { x: -13.688, y: 1.3, z: 5.31 },
    yRotation: -68,
    tableId: 50007
  },
  {
    name: "N4",
    position: { x: -0.998, y: 1.3, z: -14.957 },
    yRotation: 0,
    tableId: 50008
  },
  {
    name: "N5",
    position: { x: 23.052, y: 1.3, z: -6.751 },
    yRotation: -50,
    tableId: 50009
  },
  {
    name: "N6",
    position: { x: -6.862, y: 1.3, z: -29.035 },
    yRotation: -50,
    tableId: 50010
  },
  {
    name: "N7",
    position: { x: 21.9, y: 1.3, z: -12.6 },
    yRotation: 0,
    tableId: 50011,
    pathData: [
      [61.7, 0, -1214.7],
      [-784.24, 0, -965.77],
      [-1452.33, 0, -394.88],
      [-1428.36, 0, 503.65],
      [-1092.51, -0, 1333.23],
      [-217.36, -0, 1617.86],
      [874.96, -0, 1531.59],
      [1398.81, -0, 848.85],
      [1576.75, 0, -110.25],
      [571.85, 0, -1020.24]
    ]
  },
  {
    name: "N8",
    position: { x: 9.695, y: 1.3, z: -11.479 },
    yRotation: -15,
    tableId: 50012
  },
  {
    name: "A1",
    position: { x: -21.51, y: 1.3, z: -9.66 },
    yRotation: 0,
    tableId: 50013
  },
  {
    name: "A2",
    position: { x: -14.2, y: 1.3, z: 21.47 },
    yRotation: 0,
    tableId: 50014
  },
  {
    name: "A3",
    position: { x: 6.86, y: 1.3, z: 22.63 },
    yRotation: 0,
    tableId: 50015
  },
  {
    name: "A4",
    position: { x: 25.02, y: 1.3, z: -2.11 },
    yRotation: 0,
    tableId: 50016
  },
  {
    name: "A5",
    position: { x: 4.18, y: 1.3, z: -21.62 },
    yRotation: 0,
    tableId: 50017
  },
  {
    name: "A6",
    position: { x: -26.28, y: 1.3, z: -34.56 },
    yRotation: 0,
    tableId: 50018
  },
  {
    name: "A7",
    position: { x: -40.6, y: 1.3, z: 34.55 },
    yRotation: 0,
    tableId: 50019
  }
];
const origin = {
  scale: 1
};
const target = {
  scale: 1.3
};
const npcTitleViewAnimationMap = {};
function NpcTitleViewBigAnimation(mesh) {
  const tweenOutHot = npcTitleViewAnimationMap[mesh.uniqueId];
  if (tweenOutHot && tweenOutHot.isPlaying()) {
    tweenOutHot.stop();
  }
  const tweenInHot = getInHotTween();
  npcTitleViewAnimationMap[mesh.uniqueId] = tweenInHot;
  tweenInHot.start().onUpdate((obj, elapsed) => {
    mesh.scaling.set(obj.scale, obj.scale, obj.scale);
  }).onStop(() => {
    removeTweenFormMap(mesh.uniqueId, tweenInHot);
  }).onComplete(() => {
    removeTweenFormMap(mesh.uniqueId, tweenInHot);
  });
}
function NpcTitleViewSmallAnimation(mesh) {
  const tweenInHot = npcTitleViewAnimationMap[mesh.uniqueId];
  if (tweenInHot && tweenInHot.isPlaying()) {
    tweenInHot.stop();
  }
  const tweenOutHot = getOutHotTween();
  npcTitleViewAnimationMap[mesh.uniqueId] = tweenOutHot;
  tweenOutHot.start().onUpdate((obj, elapsed) => {
    mesh.scaling.set(obj.scale, obj.scale, obj.scale);
  }).onStop(() => {
    removeTweenFormMap(mesh.uniqueId, tweenOutHot);
  }).onComplete(() => {
    removeTweenFormMap(mesh.uniqueId, tweenOutHot);
  });
}
function removeTweenFormMap(id, tween) {
  if (npcTitleViewAnimationMap[id] === tween) {
    npcTitleViewAnimationMap[id] = null;
  }
}
const inHotTweenPool = [];
function getInHotTween() {
  let tweenInHot = inHotTweenPool.find((tween) => !tween.isPlaying());
  if (!tweenInHot) {
    tweenInHot = new Tween(Object.assign({}, origin)).to(Object.assign({}, target)).easing(Easing.Quadratic.InOut).duration(300);
    inHotTweenPool.push(tweenInHot);
  }
  return tweenInHot;
}
const outHotTweenPool = [];
function getOutHotTween() {
  let tweenOutHot = outHotTweenPool.find((tween) => !tween.isPlaying());
  if (!tweenOutHot) {
    tweenOutHot = new Tween(Object.assign({}, target)).to(Object.assign({}, origin)).easing(Easing.Quadratic.InOut).duration(300);
    outHotTweenPool.push(tweenOutHot);
  }
  return tweenOutHot;
}
function NpcLookAtPlayer(scene, npc, player, hotspotDistance, yRotation = 0) {
  const update2 = () => {
    const inHotspot = IsHotspot(npc.root.position, player.root.position, hotspotDistance);
    if (inHotspot) {
      npc.root.rotationQuaternion = null;
      npc.root.rotation.x = 0;
      const targetDir = player.root.position.subtract(npc.root.position).normalize();
      const npcRotation = BABYLON$1.Quaternion.FromLookDirectionLH(npc.root.forward, new BABYLON$1.Vector3(0, 1, 0));
      const targetRotation = BABYLON$1.Quaternion.Identity();
      BABYLON$1.Quaternion.FromLookDirectionLHToRef(targetDir, new BABYLON$1.Vector3(0, 1, 0), targetRotation);
      const npcRotationQuat = new BABYLON$1.Quaternion();
      BABYLON$1.Quaternion.SmoothToRef(npcRotation, targetRotation, 0.05, 1.5, npcRotationQuat);
      const tempAngle = new BABYLON$1.Vector3();
      npcRotationQuat.toEulerAnglesToRef(tempAngle);
      npc.root.rotation.y = tempAngle.y + Math.PI;
    } else if (Math.abs(npc.root.rotation.y - yRotation) > 0.01) {
      npc.root.rotationQuaternion = null;
      npc.root.rotation.x = 0;
      const npcRotation = BABYLON$1.Quaternion.RotationAxis(new BABYLON$1.Vector3(0, 1, 0), npc.root.rotation.y);
      const targetAngle = BABYLON$1.Quaternion.FromEulerAngles(0, yRotation, 0);
      const npcRotationQuat = BABYLON$1.Quaternion.Identity();
      BABYLON$1.Quaternion.SmoothToRef(npcRotation, targetAngle, 0.05, 1.5, npcRotationQuat);
      const tempAngle = new BABYLON$1.Vector3();
      npcRotationQuat.toEulerAnglesToRef(tempAngle);
      npc.root.rotation.y = tempAngle.y;
    }
    if (npc.titleView) {
      const isActive = npc.titleView.children[0].isVisible;
      if (inHotspot && !isActive) {
        changeNpcAnimation(AVATAR_ANIMATION_ENUM.WAVE, npc);
        npc.titleView.children[0].isVisible = true;
        npc.titleView.children[1].isVisible = false;
        npc.billboard && NpcTitleViewBigAnimation(npc.billboard.mesh);
      } else if (!inHotspot && isActive) {
        npc.titleView.children[0].isVisible = false;
        npc.titleView.children[1].isVisible = true;
        npc.billboard && NpcTitleViewSmallAnimation(npc.billboard.mesh);
      }
    }
  };
  scene.registerAfterRender(update2);
}
function changeNpcAnimation(aniName, npc) {
  var _a2, _b2, _c2, _d;
  const currentAni = npc.asset.animationGroups.filter((ani) => ani.isPlaying);
  const nextAni = npc.asset.animationGroups.find((ani) => ani.name === aniName);
  const animationMap = /* @__PURE__ */ new Map();
  npc.asset.animationGroups.forEach((ani) => {
    animationMap.set(ani.name, {
      name: ani.name,
      animation: ani,
      weight: 0
    });
  });
  const waveAni = (_a2 = animationMap.get(AVATAR_ANIMATION_ENUM.WAVE)) == null ? void 0 : _a2.animation;
  const idleAni = (_b2 = animationMap.get(AVATAR_ANIMATION_ENUM.IDLE)) == null ? void 0 : _b2.animation;
  const walkAni = (_c2 = animationMap.get(AVATAR_ANIMATION_ENUM.WALK)) == null ? void 0 : _c2.animation;
  const runAni = (_d = animationMap.get(AVATAR_ANIMATION_ENUM.RUN)) == null ? void 0 : _d.animation;
  if (!waveAni || !idleAni || !walkAni || !runAni || !currentAni.length || !nextAni) {
    return;
  }
  const time0 = 1e3;
  const time1 = 1e3;
  if (!currentAni.find((ani) => ani.name === AVATAR_ANIMATION_ENUM.RUN)) {
    const obj = {
      weight: 0
    };
    const target2 = {
      weight: 1
    };
    const target22 = {
      weight: 0
    };
    const tweenAni = new Tween(obj);
    const tweenAni2 = new Tween(obj);
    tweenAni.to(target2, time0);
    tweenAni2.to(target22, time1);
    tweenAni.easing(Easing.Linear.None);
    tweenAni2.easing(Easing.Linear.None);
    tweenAni.onStart(() => {
      nextAni.play(false);
    });
    tweenAni.onUpdate((object) => {
      nextAni.setWeightForAllAnimatables(object.weight);
    });
    tweenAni2.onUpdate((object) => {
      nextAni.setWeightForAllAnimatables(object.weight);
    });
    tweenAni.onComplete(() => {
      tweenAni2.start();
    });
    tweenAni2.onComplete(() => {
      waveAni.stop();
      runAni.stop();
      walkAni.stop();
    });
    tweenAni.start();
  } else {
    const obj = {
      weight: 0
    };
    const target2 = {
      weight: 1
    };
    const target22 = {
      weight: 0
    };
    const tweenAni = new Tween(obj);
    const tweenAni2 = new Tween(obj);
    tweenAni.to(target2, time0);
    tweenAni2.to(target22, time1);
    tweenAni.easing(Easing.Linear.None);
    tweenAni2.easing(Easing.Linear.None);
    tweenAni.onStart(() => {
      waveAni.play(false).setWeightForAllAnimatables(1);
      idleAni.stop().setWeightForAllAnimatables(0);
      runAni.stop().setWeightForAllAnimatables(0);
      walkAni.stop().setWeightForAllAnimatables(0);
    });
    tweenAni2.onUpdate((object) => {
      waveAni.setWeightForAllAnimatables(object.weight);
      idleAni.play(true).setWeightForAllAnimatables(1 - object.weight);
    });
    tweenAni.onComplete(() => {
      tweenAni2.start();
    });
    tweenAni2.onComplete(() => {
      waveAni.stop().setWeightForAllAnimatables(0);
      runAni.play(true).setWeightForAllAnimatables(0);
    });
    tweenAni.start();
  }
}
function IsHotspot(mesh1Postion, mesh2Postion, hotspotDistance = 3) {
  if (Math.abs(mesh1Postion.x - mesh2Postion.x) <= hotspotDistance && Math.abs(mesh1Postion.z - mesh2Postion.z) <= hotspotDistance) {
    return true;
  }
  return false;
}
const resourceMeshMap = {
  head1: "Basics_Hair_1",
  head2: "Basics_Hair_2",
  head3: "Basics_Hair_3",
  head4: "Basics_Hair_4",
  head5: "Basics_Hair_5",
  head6: "Basics_Hair_6",
  head7: "Basics_Hair_7",
  head8: "Basics_Hair_8",
  clothes1: "Basics_Shirt_1",
  clothes2: "Basics_Shirt_2",
  clothes3: "Basics_Shirt_3",
  clothes4: "Basics_Shirt_4",
  clothes5: "Basics_Shirt_5",
  clothes6: "Basics_Shirt_6",
  clothes7: "Basics_Shirt_7",
  clothes8: "Basics_Shirt_8",
  trousers1: "Basics_Pants_1",
  trousers2: "Basics_Pants_2",
  trousers3: "Basics_Pants_3",
  trousers4: "Basics_Pants_4",
  trousers5: "Basics_Pants_5",
  trousers6: "Basics_Pants_6",
  trousers7: "Basics_Pants_7",
  trousers8: "Basics_Pants_8"
};
function GetResourceNameFromConfig(config, avatarConfigId) {
  const avatarConfig = config.avatar;
  let ret = void 0;
  avatarConfig.forEach((element) => {
    if (element.id === avatarConfigId) {
      const row = element;
      ret = row.resourceName;
    }
  });
  return ret;
}
function BuildAvatarAssetOption(config, choiceArray) {
  const result = {
    staticMeshes: ["Basics_Head"],
    dynamicMeshes: []
  };
  choiceArray.forEach((element) => {
    const resourceName = GetResourceNameFromConfig({ avatar: config }, element.id);
    if (resourceName) {
      const meshId = resourceMeshMap[resourceName];
      if (meshId) {
        result.dynamicMeshes.push(meshId);
      }
    }
  });
  return result;
}
function ConvertEventIntoAvatarAsset(config, event) {
  let ret = void 0;
  if (config) {
    if (event instanceof Array) {
      const input = [];
      event.forEach((element) => {
        let aType = -1;
        let aId = -1;
        if (element.type && typeof element.type === "number") {
          aType = element.type;
        }
        if (element.id && typeof element.id === "number") {
          aId = element.id;
        }
        input.push({ type: aType, id: aId });
        ret = BuildAvatarAssetOption(config, input);
      });
    } else {
      console.error("ConvertEventIntoAvatarAsset, But event is wrong");
    }
  } else {
    console.error("ConvertEventIntoAvatarAsset, But config is wrong");
  }
  return ret;
}
function CreateNpc(scene, interactGroundAsset, player, avatar, rowArray, modelArray, avatarConfig) {
  const npcRecord = {};
  const interactAsset = interactGroundAsset == null ? void 0 : interactGroundAsset.asset;
  if (interactAsset) {
    const nodes = interactAsset.getNodes();
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].name.length === 5 && nodes[i].name[4] !== "G") {
        if (nodes[i].name[2] === "A") {
          const mesh = nodes[i];
          if (mesh instanceof BABYLON$1.AbstractMesh) {
            let material = mesh.material;
            if (material) {
              material = material;
              material.transparencyMode = 2;
              material.alpha = 0;
            }
            mesh.name = nodes[i].name[2] + nodes[i].name[4];
            scene.addMesh(mesh);
            mesh.isPickable = true;
            mesh.checkCollisions = false;
          }
        }
      }
    }
  }
  for (let i = 0; i < ConfigNpc.length; i++) {
    const npcConfig = ConfigNpc[i];
    const type = npcConfig.name[0];
    const remoteConfig = FindRowById(npcConfig.tableId, rowArray);
    const remoteModelId = (remoteConfig == null ? void 0 : remoteConfig.model) ? parseInt(remoteConfig.model) : -1;
    const npcNameText = (remoteConfig == null ? void 0 : remoteConfig.npcName) ? remoteConfig == null ? void 0 : remoteConfig.npcName : "";
    const hotpotDistance = (remoteConfig == null ? void 0 : remoteConfig.rangeHot) ? remoteConfig == null ? void 0 : remoteConfig.rangeHot : 5;
    const npcModel = FindModelRowById(remoteModelId, modelArray);
    const titleView = BuildNpcTitleView(remoteConfig);
    switch (type) {
      case "P":
      case "N":
        {
          const npc = avatar.CreateAvatar(npcConfig.name, npcNameText, titleView, BuildNpcAsset(npcModel, avatarConfig));
          npc.root.position.set(npcConfig.position.x, 1.3, npcConfig.position.z);
          npc.root.rotation.y = npcConfig.yRotation;
          npc.root.isPickable = true;
          npc.root.checkCollisions = true;
          NpcLookAtPlayer(scene, npc, player, hotpotDistance, npcConfig.yRotation);
          npcRecord[npcConfig.name] = NewAvatarNpc(npcConfig.name, npc, remoteConfig);
        }
        break;
      case "A":
        {
          npcRecord[npcConfig.name] = NewAvatarNpc(npcConfig.name, void 0, remoteConfig);
        }
        break;
    }
  }
  return npcRecord;
}
function BuildNpcTitleView(config) {
  const ret = {
    activeImageUrl: "",
    defaultImageUrl: ""
  };
  if (config == null ? void 0 : config.npcBubble1) {
    ret.defaultImageUrl = config.bubble + config.npcBubble1;
  }
  if (config == null ? void 0 : config.npcBubble2) {
    ret.activeImageUrl = config.bubble + config.npcBubble2;
  }
  return ret;
}
function NewAvatarNpc(name2, npc, row) {
  return {
    name: name2,
    avatar: npc,
    npcConfig: row
  };
}
function FindRowById(id, npcConfigArray) {
  return npcConfigArray.find((item) => {
    return item.id === id;
  });
}
function FindModelRowById(modelId, array) {
  return array.find((item) => {
    return item.id === modelId;
  });
}
function BuildNpcAsset(row, avatarConfig) {
  if (row === void 0) {
    return void 0;
  }
  const choiceArray = [
    {
      type: 1,
      id: row.head
    },
    {
      type: 2,
      id: row.upperBody
    },
    {
      type: 3,
      id: row.lowerBody
    }
  ];
  const result = BuildAvatarAssetOption(avatarConfig, choiceArray);
  return result;
}
const minimapAsset = {
  minimapView: "./game_njcb/map/little_map.png",
  playerLabel: "./game_njcb/map/pointer.svg",
  background: "./game_njcb/map/down_background.png"
};
class Minimap {
  constructor(scene, ui, player) {
    this._isShow = false;
    this._minimapViewTop = 0;
    this._playerLabelHeightHalf = 0;
    this._updateHandler = () => {
      const dpr = window.devicePixelRatio;
      const playerZ = (37 + this._player.root.position.z) / 91 * 200;
      const playerX = -this._player.root.position.x;
      this._playerLabel.top = this._minimapViewTop - this._playerLabelHeightHalf + playerZ + "px";
      this._playerLabel.left = playerX * dpr * 1.6 + "px";
    };
    this._resizeHandler = () => {
      const dpr = window.devicePixelRatio;
      const uiScreenSize = this._ui.getSize();
      if (this._background.isLoaded) {
        this._background.width = this._background.imageWidth * dpr + "px";
        this._background.height = this._background.imageHeight * dpr + "px";
        this._background.top = uiScreenSize.height * 0.5 - this._background.imageHeight * dpr * 0.5 + "px";
      }
      if (this._minimapView.isLoaded) {
        this._minimapView.width = this._minimapView.imageWidth / 4 * dpr + "px";
        this._minimapView.height = this._minimapView.imageHeight / 4 * dpr + "px";
        this._minimapViewTop = uiScreenSize.height * 0.5 - this._minimapView.imageHeight / 4 * dpr * 0.5;
        this._minimapView.top = this._minimapViewTop + "px";
      }
      if (this._playerLabel.isLoaded) {
        this._playerLabel.width = this._playerLabel.imageWidth * dpr + "px";
        this._playerLabel.height = this._playerLabel.imageHeight * dpr + "px";
        this._playerLabelHeightHalf = this._playerLabel.imageHeight * dpr * 0.5;
        this._playerLabel.top = this._minimapViewTop - this._playerLabelHeightHalf + "px";
      }
    };
    this._scene = scene;
    this._player = player;
    this._ui = ui;
    this._contentView = new BABYLONGUI.Rectangle();
    this._contentView.verticalAlignment = BABYLONGUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
    this._contentView.thickness = 0;
    this._contentView.top = 500;
    this._background = this._createBackground(minimapAsset.background);
    this._minimapView = this._createMinimapView(minimapAsset.minimapView);
    this._playerLabel = this._creatPlayerLabel(minimapAsset.playerLabel);
    window.addEventListener("resize", this._resizeHandler);
    this.show();
  }
  dispose() {
    this.hide();
    window.removeEventListener("resize", this._resizeHandler);
  }
  show() {
    if (this._isShow) {
      return;
    }
    this._ui.addControl(this._contentView);
    this._contentView.addControl(this._background);
    this._contentView.addControl(this._minimapView);
    this._contentView.addControl(this._playerLabel);
    this._scene.registerAfterRender(this._updateHandler);
  }
  animalShow() {
    const origin2 = {
      contentViewTop: 500
    };
    const target2 = {
      contentViewTop: 0
    };
    const animalShow = new Tween(origin2);
    animalShow.to(target2, 1e3);
    animalShow.easing(Easing.Quadratic.InOut);
    animalShow.onUpdate((object) => {
      this._contentView.top = object.contentViewTop;
    });
    animalShow.start();
  }
  hide() {
    if (!this._isShow) {
      return;
    }
    this._ui.removeControl(this._contentView);
    this._scene.unregisterAfterRender(this._updateHandler);
    this._isShow = false;
  }
  _createMinimapView(minimapViewUrl) {
    const image = new BABYLONGUI.Image("minimap", minimapViewUrl);
    image.onImageLoadedObservable.add(() => {
      image.color = "transparent";
      this._resizeHandler();
    });
    return image;
  }
  _creatPlayerLabel(playerLabelUrl) {
    const image = new BABYLONGUI.Image("minimap", playerLabelUrl);
    image.onImageLoadedObservable.add(() => {
      image.color = "transparent";
      this._resizeHandler();
    });
    return image;
  }
  _createBackground(backgroundUrl) {
    const image = new BABYLONGUI.Image("minimap", backgroundUrl);
    image.onImageLoadedObservable.add(() => {
      image.color = "transparent";
      this._resizeHandler();
    });
    return image;
  }
}
function LookatNpcAnimation(npc, player, camera, lookSpeed = 1, onStart, onComplete, onUpdate) {
  const direction = player.root.position.clone().subtract(npc.root.position).normalize();
  const dot = Math.acos(BABYLON$1.Vector3.Dot(new BABYLON$1.Vector3(1, 0, 0), direction));
  const cross = BABYLON$1.Vector3.Cross(new BABYLON$1.Vector3(1, 0, 0), direction);
  const cameraAlpha = cross.y > 0 ? -dot : dot;
  let cameraAlphaDiff = cameraAlpha - camera.alpha;
  cameraAlphaDiff = Math.round(cameraAlphaDiff * 100) % (314 * 2) / 100;
  cameraAlphaDiff = cameraAlphaDiff > 3.14 ? cameraAlphaDiff - 3.14 * 2 : cameraAlphaDiff;
  cameraAlphaDiff = cameraAlphaDiff < -3.14 ? cameraAlphaDiff + 3.14 * 2 : cameraAlphaDiff;
  const origin2 = {
    cameraAlpha: camera.alpha,
    cameraRadius: camera.radius
  };
  const target2 = {
    cameraAlpha: camera.alpha + cameraAlphaDiff,
    cameraRadius: camera.radius * 0.5 > 15 ? camera.radius * 0.5 : 15
  };
  onStart && onStart();
  player.root.lookAt(npc.root.position);
  const tween = new Tween(origin2);
  tween.to(target2, 1500 / lookSpeed);
  tween.easing(Easing.Quadratic.InOut);
  tween.onUpdate((object) => {
    camera.alpha = object.cameraAlpha;
    camera.radius = object.cameraRadius;
    onUpdate && onUpdate();
  });
  onComplete && tween.onComplete(onComplete);
  tween.start();
}
function cameraAwayFromNpc(camera, controller, callBack) {
  if (controller) {
    const origin2 = {
      cameraAlpha: camera.alpha,
      cameraRadius: camera.radius
    };
    const defaultDis = controller._controlAttribute.cameraDistDefault || 30;
    const target2 = {
      cameraAlpha: camera.alpha,
      cameraRadius: defaultDis
    };
    const tweenOut = new Tween(origin2);
    tweenOut.to(target2, 1500);
    tweenOut.easing(Easing.Quadratic.InOut);
    tweenOut.onUpdate((object) => {
      camera.alpha = object.cameraAlpha;
      camera.radius = object.cameraRadius || 0;
    });
    tweenOut.start();
    tweenOut.onComplete(() => {
      controller.attachControl({ camera: controller.getCameraState() });
      callBack && callBack();
    });
  }
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$c = Object.prototype;
var hasOwnProperty$9 = objectProto$c.hasOwnProperty;
var nativeObjectToString$1 = objectProto$c.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$9.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$b = Object.prototype;
var nativeObjectToString = objectProto$b.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isArray = Array.isArray;
var isArray$1 = isArray;
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$2 = "[object Function]", genTag$1 = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$1(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$a = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap = getNative(root$1, "WeakMap");
var WeakMap$1 = WeakMap;
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$1 = defineProperty;
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$7.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction$1(value);
}
var objectProto$8 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$8;
  return value === proto;
}
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$2 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$2 ? Buffer$2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$2 = "[object Boolean]", dateTag$2 = "[object Date]", errorTag$1 = "[object Error]", funcTag$1 = "[object Function]", mapTag$4 = "[object Map]", numberTag$2 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$2 = "[object RegExp]", setTag$4 = "[object Set]", stringTag$2 = "[object String]", weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$2 = "[object ArrayBuffer]", dataViewTag$3 = "[object DataView]", float32Tag$2 = "[object Float32Array]", float64Tag$2 = "[object Float64Array]", int8Tag$2 = "[object Int8Array]", int16Tag$2 = "[object Int16Array]", int32Tag$2 = "[object Int32Array]", uint8Tag$2 = "[object Uint8Array]", uint8ClampedTag$2 = "[object Uint8ClampedArray]", uint16Tag$2 = "[object Uint16Array]", uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform2) {
  return function(arg) {
    return func(transform2(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$4.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$3.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$2.call(data, key) ? data[key] : void 0;
}
var objectProto$2 = Object.prototype;
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$1.call(data, key);
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer$1 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$1 = Object.prototype;
var propertyIsEnumerable = objectProto$1.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols$1(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function copySymbols(source, object) {
  return copyObject(source, getSymbols$1(source), object);
}
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols$1(object));
    object = getPrototype$1(object);
  }
  return result;
};
var getSymbolsIn$1 = getSymbolsIn;
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn$1(source), object);
}
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn$1);
}
var DataView$1 = getNative(root$1, "DataView");
var DataView$2 = DataView$1;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set = getNative(root$1, "Set");
var Set$1 = Set;
var mapTag$3 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$3 = "[object Set]", weakMapTag$1 = "[object WeakMap]";
var dataViewTag$2 = "[object DataView]";
var dataViewCtorString = toSource(DataView$2), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$2 && getTag(new DataView$2(new ArrayBuffer(1))) != dataViewTag$2 || Map$2 && getTag(new Map$2()) != mapTag$3 || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag$1) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$2;
        case mapCtorString:
          return mapTag$3;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$3;
        case weakMapCtorString:
          return weakMapTag$1;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var Uint8Array$1 = root$1.Uint8Array;
var Uint8Array$2 = Uint8Array$1;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$2(result).set(new Uint8Array$2(arrayBuffer));
  return result;
}
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag$1 = "[object Float32Array]", float64Tag$1 = "[object Float64Array]", int8Tag$1 = "[object Int8Array]", int16Tag$1 = "[object Int16Array]", int32Tag$1 = "[object Int32Array]", uint8Tag$1 = "[object Uint8Array]", uint8ClampedTag$1 = "[object Uint8ClampedArray]", uint16Tag$1 = "[object Uint16Array]", uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag$1:
      return cloneArrayBuffer(object);
    case boolTag$1:
    case dateTag$1:
      return new Ctor(+object);
    case dataViewTag$1:
      return cloneDataView(object, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return cloneTypedArray(object, isDeep);
    case mapTag$2:
      return new Ctor();
    case numberTag$1:
    case stringTag$1:
      return new Ctor(object);
    case regexpTag$1:
      return cloneRegExp(object);
    case setTag$2:
      return new Ctor();
    case symbolTag$1:
      return cloneSymbol(object);
  }
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
var mapTag$1 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike(value) && getTag$1(value) == mapTag$1;
}
var nodeIsMap = nodeUtil$1 && nodeUtil$1.isMap;
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
var isMap$1 = isMap;
var setTag$1 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike(value) && getTag$1(value) == setTag$1;
}
var nodeIsSet = nodeUtil$1 && nodeUtil$1.isSet;
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
var isSet$1 = isSet;
var CLONE_DEEP_FLAG$1 = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG$1 = 4;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$1, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG$1;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray$1(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag$1(value), isFunc = tag == funcTag || tag == genTag;
    if (isBuffer$1(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet$1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap$1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}
function isFunction(val) {
  return typeof val === "function";
}
class WAxios {
  constructor(options) {
    this.options = options;
    this.axiosInstance = axios.create(options);
  }
  setHeader(headers) {
    if (!this.axiosInstance) {
      return;
    }
    Object.assign(this.axiosInstance.defaults.headers, headers);
  }
  getTransform() {
    const { transform: transform2 } = this.options;
    return transform2;
  }
  get(config, options) {
    return this.request(__spreadProps(__spreadValues({}, config), { method: "GET" }), options);
  }
  post(config, options) {
    return this.request(__spreadProps(__spreadValues({}, config), { method: "POST" }), options);
  }
  put(config, options) {
    return this.request(__spreadProps(__spreadValues({}, config), { method: "PUT" }), options);
  }
  delete(config, options) {
    return this.request(__spreadProps(__spreadValues({}, config), { method: "DELETE" }), options);
  }
  request(config, options) {
    let conf = cloneDeep(config);
    const transform2 = this.getTransform();
    const { requestOptions } = this.options;
    const opt = Object.assign({}, requestOptions, options);
    const { beforeRequestHook, requestCatchHook, transformResponseHook } = transform2 || {};
    if (beforeRequestHook && isFunction(beforeRequestHook)) {
      conf = beforeRequestHook(conf, opt);
    }
    conf.requestOptions = opt;
    return new Promise((resolve, reject) => {
      this.axiosInstance.request(conf).then((res) => {
        if (transformResponseHook && isFunction(transformResponseHook)) {
          try {
            const ret = transformResponseHook(res, opt);
            resolve(ret);
          } catch (err) {
            reject(err || new Error("request error!"));
          }
          return;
        }
        resolve(res);
      }).catch((e) => {
        if (requestCatchHook && isFunction(requestCatchHook)) {
          reject(requestCatchHook(e, opt));
          return;
        }
        if (axios.isAxiosError(e))
          ;
        reject(e);
      });
    });
  }
}
var WrongNetwork = /* @__PURE__ */ ((WrongNetwork2) => {
  WrongNetwork2[WrongNetwork2["week"] = -1] = "week";
  WrongNetwork2[WrongNetwork2["recovery"] = 0] = "recovery";
  WrongNetwork2[WrongNetwork2["disconnection"] = 20015] = "disconnection";
  WrongNetwork2[WrongNetwork2["loadfailed"] = 20043] = "loadfailed";
  WrongNetwork2[WrongNetwork2["serverError"] = 20027] = "serverError";
  return WrongNetwork2;
})(WrongNetwork || {});
let _emitter$2;
function ConfigHttpEmitter(emit) {
  _emitter$2 = emit;
}
const urlPort = { url: "", port: 0 };
const transform = {
  transformResponseHook: (res, options) => {
    const { isTransformResponse, isReturnNativeResponse } = options;
    if (isReturnNativeResponse) {
      return res;
    }
    if (!isTransformResponse) {
      return res.data;
    }
    const { data } = res;
    if (!data) {
      throw new Error("sys.api.apiRequestFailed");
    }
    const { code, message } = data;
    const hasSuccess = data && Reflect.has(data, "code") && code === 0;
    if (hasSuccess) {
      return data.data;
    }
    if (code === 10) {
      _emitter$2.emit(NjcbEventEnum.WRONG_NET_WORK, { id: WrongNetwork.serverError });
      console.warn("\u{1F680} ~ file: index.ts ~ line 82 ~ _emitter", _emitter$2);
    }
  },
  beforeRequestHook: (config, options) => {
    const { apiUrl, joinPrefix, joinParamsToUrl, formatDate, joinTime = true, urlPrefix } = options;
    if (joinPrefix) {
      config.url = `${urlPrefix}${config.url}`;
    }
    if (apiUrl) {
      config.url = `https://${urlPort.url}:${urlPort.port}${config.url}`;
    }
    const token = localStorage.getItem("token");
    config.headers = { Authorization: token };
    return config;
  },
  requestInterceptors: (config, options) => {
    return config;
  },
  responseInterceptors: (res) => {
    return res;
  }
};
function createAxios(opt) {
  return new WAxios({
    authenticationScheme: "",
    timeout: 10 * 1e3,
    headers: { "Content-Type": "application/json;charset=UTF-8" },
    transform,
    requestOptions: {
      joinPrefix: true,
      isReturnNativeResponse: false,
      isTransformResponse: true,
      joinParamsToUrl: false,
      formatDate: true,
      errorMessageMode: "message",
      apiUrl: "https://gs-core.test.gotin.top:11200",
      urlPrefix: "/nj",
      joinTime: true,
      ignoreCancelToken: true,
      withToken: true,
      retryRequest: {
        isOpenRetry: true,
        count: 5,
        waitTime: 100
      }
    }
  });
}
const defHttp = createAxios();
const setUrlAndPort = (url, port) => {
  urlPort.url = url;
  urlPort.port = port;
};
function checkDuckState() {
  return defHttp.get({
    url: "/checkDuckState"
  });
}
function eggDuckUpdate(data) {
  return defHttp.post({
    data,
    url: "/updateDuckPoints"
  });
}
function getDuckNpcDialog() {
  return defHttp.get({
    url: "/getDuckNpcDialog"
  });
}
function getDuckReward(duckId) {
  return defHttp.post({
    data: {
      duckId
    },
    url: "/getDuckReward"
  });
}
class Raycast {
  constructor(emitter, scene, camera, player, playerController, npcRecord, lookSpeed = 1) {
    this._lookSpeed = 1;
    this._pickHandler = (pointerInfo) => {
      if (pointerInfo.type !== BABYLON$1.PointerEventTypes.POINTERUP) {
        return;
      }
      const pickResult = this._scene.pick(this._scene.pointerX, this._scene.pointerY, void 0);
      if (pickResult && pickResult.pickedMesh && pickResult.pickedPoint) {
        let pickedMeshName = pickResult.pickedMesh.name;
        pickedMeshName = pickedMeshName.replace("_title_view", "");
        const info = this._npcRecord[pickedMeshName];
        if (!info) {
          return;
        }
        const npcAvatar = info.avatar;
        const config = info.npcConfig;
        const hotspotDistance = (config == null ? void 0 : config.rangeHot) ? config.rangeHot : 5;
        if (npcAvatar) {
          const isHot = IsHotspot(this._player.root.absolutePosition, pickResult.pickedMesh.absolutePosition, hotspotDistance);
          if (!isHot) {
            return;
          }
          const emitData = this._convertEmitterInfo(config);
          LookatNpcAnimation(npcAvatar, this._player, this._camera, this._lookSpeed, () => {
            this._playerController.detachControl();
            this.detachControl();
            this._emitter.emit(NjcbEventEnum.CAMERA_START, null);
          }, () => {
            this._emitter.emit(NjcbEventEnum.CAMERA_END, null);
            if (npcAvatar.name === "P1") {
              checkDuckState().then((data) => {
                const { talkId } = data;
                emitData.id = talkId;
                this._emitter.emit(NjcbEventEnum.NPC_START, emitData);
              });
            } else if (npcAvatar.name === "N7") {
              getDuckNpcDialog().then((data) => {
                const { dialogId } = data;
                emitData.id = dialogId;
                this._emitter.emit(NjcbEventEnum.NPC_START, emitData);
              });
            } else {
              this._emitter.emit(NjcbEventEnum.NPC_START, emitData);
            }
          }, () => {
            this._playerController.checkObstacleAndProcess();
          });
        } else if (config) {
          this._playerController.stopPlayer();
          const emitData = this._convertEmitterInfo(config);
          this._emitter.emit(NjcbEventEnum.NPC_START, emitData);
        } else if (pointerInfo.event.ctrlKey) {
          cameraAwayFromNpc(this._camera, this._playerController, this.attachControl.bind(this));
        }
      }
    };
    this._emitter = emitter;
    this._scene = scene;
    this._camera = camera;
    this._player = player;
    this._playerController = playerController;
    this._npcRecord = npcRecord;
    lookSpeed && (this._lookSpeed = lookSpeed);
    this._emitter.on(NjcbEventEnum.NPC_END, () => {
      player.root.setEnabled(true);
      this._emitter.emit(NjcbEventEnum.CAMERA_START, null);
      cameraAwayFromNpc(this._camera, this._playerController, this.attachControl.bind(this));
    });
  }
  attachControl() {
    if (!this._pointerObservable) {
      const observable = this._scene.onPointerObservable.add(this._pickHandler);
      if (observable) {
        this._pointerObservable = observable;
      }
    }
    this._emitter.emit(NjcbEventEnum.CAMERA_END, null);
  }
  detachControl() {
    if (this._pointerObservable) {
      this._scene.onPointerObservable.remove(this._pointerObservable);
      this._pointerObservable = void 0;
    }
  }
  _convertEmitterInfo(config) {
    const aType = config ? config.skipType : -1;
    let aId = parseInt((config == null ? void 0 : config.dialogueId1) ? config.dialogueId1 : "-1");
    if (isNaN(aId)) {
      aId = -1;
    }
    const aNpcId = config ? config.id : -1;
    return { type: aType, id: aId, npcId: aNpcId };
  }
}
class DuckPond {
  constructor(scene, duckModel, duckList = []) {
    this._indexArr = [];
    this._ducks = [];
    this._duckList = [];
    this._pointArr = [];
    this._numberOfCoordinates = 500;
    this.updateHandler = () => {
      this._ducks.forEach((duck, index) => {
        if (duck.rootNodes[0].parent instanceof BABYLON$1.Mesh) {
          duck.rootNodes[0].parent.position.x = this._pointArr[index][this._indexArr[index]].x;
          duck.rootNodes[0].parent.position.z = this._pointArr[index][this._indexArr[index]].z;
          duck.rootNodes[0].parent.lookAt(this._pointArr[index][this._indexArr[index] + 1].add(new BABYLON$1.Vector3(0, -0.33, 0)));
          this._indexArr[index] = (this._indexArr[index] + 1) % (this._numberOfCoordinates - 1);
        }
      });
    };
    this._duckList = duckList;
    this._duckModel = duckModel;
    this._lDuckMaterial = new BABYLON$1.StandardMaterial("l_duck", scene);
    this._mDuckMaterial = new BABYLON$1.StandardMaterial("m_duck", scene);
    this._sDuckMaterial = new BABYLON$1.StandardMaterial("s_duck", scene);
    this._texture0 = new BABYLON$1.Texture(ConfigAsset.duck.texture, scene);
    this._texture1 = new BABYLON$1.Texture(ConfigAsset.duck.texture, scene);
    this._texture2 = new BABYLON$1.Texture(ConfigAsset.duck.texture, scene);
    this._texture0.vScale = -1;
    this._texture1.vScale = -1;
    this._texture2.vScale = -1;
    this._lDuckMaterial.diffuseTexture = this._texture0;
    this._mDuckMaterial.diffuseTexture = this._texture1;
    this._sDuckMaterial.diffuseTexture = this._texture2;
    this._lDuckMaterial.specularColor = new BABYLON$1.Color3(0, 0, 0);
    this._mDuckMaterial.specularColor = new BABYLON$1.Color3(0, 0, 0);
    this._sDuckMaterial.specularColor = new BABYLON$1.Color3(0, 0, 0);
    this._lDuckMaterial.diffuseTexture.uOffset = 0;
    this._lDuckMaterial.diffuseTexture.vOffset = 0;
    this._mDuckMaterial.diffuseTexture.uOffset = 0.5;
    this._mDuckMaterial.diffuseTexture.vOffset = 0;
    this._sDuckMaterial.diffuseTexture.uOffset = 0;
    this._sDuckMaterial.diffuseTexture.vOffset = 0.5;
    this.DuckPond(scene, duckList);
  }
  DuckPond(scene, duckList) {
    var _a2, _b2, _c2;
    const duck = {
      l: 3,
      m: 3,
      s: 4
    };
    let duckCount = 0;
    for (let i = 0; i < duck.l; i++) {
      if (duckCount >= 10) {
        break;
      }
      const duck2 = this._duckModel.instantiateModelsToScene();
      (_a2 = duck2.animationGroups.find((ani) => ani.name === "Clone of Duck_swimming")) == null ? void 0 : _a2.play(true);
      duck2.rootNodes[0].scaling.set(0.4, 0.4, -0.4);
      duck2.rootNodes[0].getChildMeshes().forEach((mesh) => {
        mesh instanceof BABYLON$1.Mesh && (mesh.material = this._lDuckMaterial);
      });
      this._ducks.push(duck2);
      duckCount++;
    }
    for (let i = 0; i < duck.m; i++) {
      if (duckCount >= 10) {
        break;
      }
      const duck2 = this._duckModel.instantiateModelsToScene();
      (_b2 = duck2.animationGroups.find((ani) => ani.name === "Clone of Duck_swimming")) == null ? void 0 : _b2.play(true);
      duck2.rootNodes[0].scaling.set(0.3, 0.3, -0.3);
      duck2.rootNodes[0].getChildMeshes().forEach((mesh) => {
        mesh instanceof BABYLON$1.Mesh && (mesh.material = this._mDuckMaterial);
      });
      this._ducks.push(duck2);
      duckCount++;
    }
    for (let i = 0; i < duck.s; i++) {
      if (duckCount >= 10) {
        break;
      }
      const duck2 = this._duckModel.instantiateModelsToScene();
      (_c2 = duck2.animationGroups.find((ani) => ani.name === "Clone of Duck_swimming")) == null ? void 0 : _c2.play(true);
      duck2.rootNodes[0].scaling.set(0.2, 0.2, -0.2);
      duck2.rootNodes[0].getChildMeshes().forEach((mesh) => {
        mesh instanceof BABYLON$1.Mesh && (mesh.material = this._sDuckMaterial);
      });
      this._ducks.push(duck2);
      duckCount++;
    }
    for (let i = 0; i < duckCount; i++) {
      this._indexArr.push(Math.floor(this._numberOfCoordinates * Math.random()));
    }
    this._ducks.forEach((duck2, index) => {
      this.initDuck(duck2, 1, new BABYLON$1.Vector3(randomPosition[index][0], randomPosition[index][1], randomPosition[index][2]), scene);
    });
    this.updateDucksInPond(duckList);
    scene.registerAfterRender(this.updateHandler);
  }
  updateDucksInPond(list = []) {
    const duckList = list.slice(0, 10);
    duckList.forEach((info, index) => {
      if (info.age < 50) {
        this._ducks[index].rootNodes[0].scaling.set(0.2, 0.2, -0.2);
        this._ducks[index].rootNodes[0].getChildMeshes().forEach((mesh) => {
          mesh instanceof BABYLON$1.Mesh && (mesh.material = this._sDuckMaterial);
        });
      } else if (info.age >= 100) {
        this._ducks[index].rootNodes[0].scaling.set(0.4, 0.4, -0.4);
        this._ducks[index].rootNodes[0].getChildMeshes().forEach((mesh) => {
          mesh instanceof BABYLON$1.Mesh && (mesh.material = this._lDuckMaterial);
        });
      } else {
        this._ducks[index].rootNodes[0].scaling.set(0.3, 0.3, -0.3);
        this._ducks[index].rootNodes[0].getChildMeshes().forEach((mesh) => {
          mesh instanceof BABYLON$1.Mesh && (mesh.material = this._mDuckMaterial);
        });
      }
    });
    for (let i = duckList.length; i < 10; i++) {
      this._ducks[i].rootNodes[0].setEnabled(false);
    }
    for (let i = 0; i < duckList.length; i++) {
      this._ducks[i].rootNodes[0].setEnabled(true);
    }
  }
  initDuck(duck, velocity = 1, center = new BABYLON$1.Vector3(), scene) {
    const r = 1 * Math.abs(duck.rootNodes[0].scaling.x);
    const points = [];
    this._numberOfCoordinates = Math.floor(1e3 * velocity);
    const randomIndex = Math.random() > 0.5 ? 1 : -1;
    for (let i = 0; i < this._numberOfCoordinates + 1; i++) {
      points.push(new BABYLON$1.Vector3((r + r / 10 * Math.sin(8 * i * Math.PI / this._numberOfCoordinates)) * Math.cos(randomIndex * 2 * i * Math.PI / this._numberOfCoordinates), 0, (r + r / 10 * Math.sin(4 * i * Math.PI / this._numberOfCoordinates)) * Math.sin(randomIndex * 2 * i * Math.PI / this._numberOfCoordinates)).add(center));
    }
    this._pointArr.push(points);
    const root2 = BABYLON$1.CreateBox(duck.rootNodes[0].name + "_box", {
      size: 1,
      width: 0.5,
      height: 2,
      depth: 0.5
    }, scene);
    duck.rootNodes[0].parent = root2;
    const path3d = new BABYLON$1.Path3D(points);
    const normals = path3d.getNormals();
    const theta = Math.acos(BABYLON$1.Vector3.Dot(BABYLON$1.Axis.Z, normals[0]));
    root2.checkCollisions = false;
    root2.rotate(BABYLON$1.Axis.Y, theta - Math.PI / 2, BABYLON$1.Space.WORLD);
    root2.up.copyFrom(new BABYLON$1.Vector3(0, 1, 0));
    root2.position.y = -0.33;
    root2.visibility = 0;
  }
}
const randomPosition = [
  [-21.86, 0, 19.58],
  [-16.49, 0, 30],
  [-6.87, 0, 44.88],
  [-17.64, 0, 45.84],
  [-28.64, 0, 35.13],
  [-16.6, 0, 18.6],
  [-16.83, 0, 27.45],
  [-8.95, 0, 40.99],
  [-15.88, 0, 42.65],
  [-25.02, 0, 34.82]
];
var cryptoJs = { exports: {} };
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core = { exports: {} };
var __viteBrowserExternal = new Proxy({}, {
  get() {
    throw new Error('Module "" has been externalized for browser compatibility and cannot be accessed in client code.');
  }
});
var __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
var require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore)
    return core.exports;
  hasRequiredCore = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined$1) {
        var crypto;
        if (typeof window !== "undefined" && window.crypto) {
          crypto = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto = globalThis.crypto;
        }
        if (!crypto && typeof window !== "undefined" && window.msCrypto) {
          crypto = window.msCrypto;
        }
        if (!crypto && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto = commonjsGlobal.crypto;
        }
        if (!crypto && typeof commonjsRequire === "function") {
          try {
            crypto = require$$0;
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto) {
            if (typeof crypto.getRandomValues === "function") {
              try {
                return crypto.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto.randomBytes === "function") {
              try {
                return crypto.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function() {
            },
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  })(core);
  return core.exports;
}
var x64Core = { exports: {} };
var hasRequiredX64Core;
function requireX64Core() {
  if (hasRequiredX64Core)
    return x64Core.exports;
  hasRequiredX64Core = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        C_x64.Word = Base.extend({
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
        });
        C_x64.WordArray = Base.extend({
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
  })(x64Core);
  return x64Core.exports;
}
var libTypedarrays = { exports: {} };
var hasRequiredLibTypedarrays;
function requireLibTypedarrays() {
  if (hasRequiredLibTypedarrays)
    return libTypedarrays.exports;
  hasRequiredLibTypedarrays = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
  })(libTypedarrays);
  return libTypedarrays.exports;
}
var encUtf16 = { exports: {} };
var hasRequiredEncUtf16;
function requireEncUtf16() {
  if (hasRequiredEncUtf16)
    return encUtf16.exports;
  hasRequiredEncUtf16 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
  })(encUtf16);
  return encUtf16.exports;
}
var encBase64 = { exports: {} };
var hasRequiredEncBase64;
function requireEncBase64() {
  if (hasRequiredEncBase64)
    return encBase64.exports;
  hasRequiredEncBase64 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64 = {
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
  })(encBase64);
  return encBase64.exports;
}
var encBase64url = { exports: {} };
var hasRequiredEncBase64url;
function requireEncBase64url() {
  if (hasRequiredEncBase64url)
    return encBase64url.exports;
  hasRequiredEncBase64url = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64url = {
          stringify: function(wordArray, urlSafe = true) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          parse: function(base64Str, urlSafe = true) {
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64url;
    });
  })(encBase64url);
  return encBase64url.exports;
}
var md5 = { exports: {} };
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5)
    return md5.exports;
  hasRequiredMd5 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
  })(md5);
  return md5.exports;
}
var sha1 = { exports: {} };
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1)
    return sha1.exports;
  hasRequiredSha1 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
  })(sha1);
  return sha1.exports;
}
var sha256 = { exports: {} };
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256)
    return sha256.exports;
  hasRequiredSha256 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  })(sha256);
  return sha256.exports;
}
var sha224 = { exports: {} };
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224)
    return sha224.exports;
  hasRequiredSha224 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireSha256());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
  })(sha224);
  return sha224.exports;
}
var sha512 = { exports: {} };
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512)
    return sha512.exports;
  hasRequiredSha512 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wil;
              var Wih;
              var Wi = W[i];
              if (i < 16) {
                Wih = Wi.high = M[offset + i * 2] | 0;
                Wil = Wi.low = M[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
  })(sha512);
  return sha512.exports;
}
var sha384 = { exports: {} };
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384)
    return sha384.exports;
  hasRequiredSha384 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireX64Core(), requireSha512());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
  })(sha384);
  return sha384.exports;
}
var sha3 = { exports: {} };
var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3)
    return sha3.exports;
  hasRequiredSha3 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
  })(sha3);
  return sha3.exports;
}
var ripemd160 = { exports: {} };
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160)
    return ripemd160.exports;
  hasRequiredRipemd160 = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
      			(c) 2012 by Cdric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })();
      return CryptoJS.RIPEMD160;
    });
  })(ripemd160);
  return ripemd160.exports;
}
var hmac = { exports: {} };
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac)
    return hmac.exports;
  hasRequiredHmac = 1;
  (function(module2, exports2) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        C_algo.HMAC = Base.extend({
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  })(hmac);
  return hmac.exports;
}
var pbkdf2 = { exports: {} };
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2)
    return pbkdf2.exports;
  hasRequiredPbkdf2 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA1,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac2 = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac2.update(salt).finalize(blockIndex);
              hmac2.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac2.finalize(intermediate);
                hmac2.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
  })(pbkdf2);
  return pbkdf2.exports;
}
var evpkdf = { exports: {} };
var hasRequiredEvpkdf;
function requireEvpkdf() {
  if (hasRequiredEvpkdf)
    return evpkdf.exports;
  hasRequiredEvpkdf = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
  })(evpkdf);
  return evpkdf.exports;
}
var cipherCore = { exports: {} };
var hasRequiredCipherCore;
function requireCipherCore() {
  if (hasRequiredCipherCore)
    return cipherCore.exports;
  hasRequiredCipherCore = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEvpkdf());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined$1) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined$1;
            } else {
              block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function(password, keySize, ivSize, salt) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  })(cipherCore);
  return cipherCore.exports;
}
var modeCfb = { exports: {} };
var hasRequiredModeCfb;
function requireModeCfb() {
  if (hasRequiredModeCfb)
    return modeCfb.exports;
  hasRequiredModeCfb = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
  })(modeCfb);
  return modeCfb.exports;
}
var modeCtr = { exports: {} };
var hasRequiredModeCtr;
function requireModeCtr() {
  if (hasRequiredModeCtr)
    return modeCtr.exports;
  hasRequiredModeCtr = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
  })(modeCtr);
  return modeCtr.exports;
}
var modeCtrGladman = { exports: {} };
var hasRequiredModeCtrGladman;
function requireModeCtrGladman() {
  if (hasRequiredModeCtrGladman)
    return modeCtrGladman.exports;
  hasRequiredModeCtrGladman = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
  })(modeCtrGladman);
  return modeCtrGladman.exports;
}
var modeOfb = { exports: {} };
var hasRequiredModeOfb;
function requireModeOfb() {
  if (hasRequiredModeOfb)
    return modeOfb.exports;
  hasRequiredModeOfb = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
  })(modeOfb);
  return modeOfb.exports;
}
var modeEcb = { exports: {} };
var hasRequiredModeEcb;
function requireModeEcb() {
  if (hasRequiredModeEcb)
    return modeEcb.exports;
  hasRequiredModeEcb = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
  })(modeEcb);
  return modeEcb.exports;
}
var padAnsix923 = { exports: {} };
var hasRequiredPadAnsix923;
function requirePadAnsix923() {
  if (hasRequiredPadAnsix923)
    return padAnsix923.exports;
  hasRequiredPadAnsix923 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
  })(padAnsix923);
  return padAnsix923.exports;
}
var padIso10126 = { exports: {} };
var hasRequiredPadIso10126;
function requirePadIso10126() {
  if (hasRequiredPadIso10126)
    return padIso10126.exports;
  hasRequiredPadIso10126 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
  })(padIso10126);
  return padIso10126.exports;
}
var padIso97971 = { exports: {} };
var hasRequiredPadIso97971;
function requirePadIso97971() {
  if (hasRequiredPadIso97971)
    return padIso97971.exports;
  hasRequiredPadIso97971 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([2147483648], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
  })(padIso97971);
  return padIso97971.exports;
}
var padZeropadding = { exports: {} };
var hasRequiredPadZeropadding;
function requirePadZeropadding() {
  if (hasRequiredPadZeropadding)
    return padZeropadding.exports;
  hasRequiredPadZeropadding = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          for (var i = data.sigBytes - 1; i >= 0; i--) {
            if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
              data.sigBytes = i + 1;
              break;
            }
          }
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
  })(padZeropadding);
  return padZeropadding.exports;
}
var padNopadding = { exports: {} };
var hasRequiredPadNopadding;
function requirePadNopadding() {
  if (hasRequiredPadNopadding)
    return padNopadding.exports;
  hasRequiredPadNopadding = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS.pad.NoPadding;
    });
  })(padNopadding);
  return padNopadding.exports;
}
var formatHex = { exports: {} };
var hasRequiredFormatHex;
function requireFormatHex() {
  if (hasRequiredFormatHex)
    return formatHex.exports;
  hasRequiredFormatHex = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function(undefined$1) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        C_format.Hex = {
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
  })(formatHex);
  return formatHex.exports;
}
var aes = { exports: {} };
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes)
    return aes.exports;
  hasRequiredAes = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
  })(aes);
  return aes.exports;
}
var tripledes = { exports: {} };
var hasRequiredTripledes;
function requireTripledes() {
  if (hasRequiredTripledes)
    return tripledes.exports;
  hasRequiredTripledes = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i = 0; i < 8; i++) {
                f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
  })(tripledes);
  return tripledes.exports;
}
var rc4 = { exports: {} };
var hasRequiredRc4;
function requireRc4() {
  if (hasRequiredRc4)
    return rc4.exports;
  hasRequiredRc4 = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) {
              S[i] = i;
            }
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
  })(rc4);
  return rc4.exports;
}
var rabbit = { exports: {} };
var hasRequiredRabbit;
function requireRabbit() {
  if (hasRequiredRabbit)
    return rabbit.exports;
  hasRequiredRabbit = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
  })(rabbit);
  return rabbit.exports;
}
var rabbitLegacy = { exports: {} };
var hasRequiredRabbitLegacy;
function requireRabbitLegacy() {
  if (hasRequiredRabbitLegacy)
    return rabbitLegacy.exports;
  hasRequiredRabbitLegacy = 1;
  (function(module2, exports2) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
  })(rabbitLegacy);
  return rabbitLegacy.exports;
}
(function(module2, exports2) {
  (function(root2, factory, undef) {
    {
      module2.exports = factory(requireCore(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy());
    }
  })(commonjsGlobal, function(CryptoJS) {
    return CryptoJS;
  });
})(cryptoJs);
const GLTF_AES_KEY = "1656918242000001";
const GLTF_AES_IV = "1001656918242001";
function UnpackBinaryV2Async(dataReader, length) {
  const ChunkFormat = {
    JSON: 1313821514,
    BIN: 5130562
  };
  const chunkLength = dataReader.readUint32();
  const chunkFormat = dataReader.readUint32();
  if (chunkFormat !== ChunkFormat.JSON) {
    throw new Error("First chunk format is not JSON");
  }
  if (dataReader.byteOffset + chunkLength === length) {
    const binObj = void 0;
    return dataReader.loadAsync(chunkLength).then(function() {
      const glbObj = { json: DecodeAndParseJson(dataReader.readString(chunkLength)), bin: binObj };
      return glbObj;
    });
  }
  return dataReader.loadAsync(chunkLength + 8).then(function() {
    const data = { json: DecodeAndParseJson(dataReader.readString(chunkLength)), bin: void 0 };
    const readAsync = function() {
      const chunkLength2 = dataReader.readUint32();
      const chunkFormat2 = dataReader.readUint32();
      switch (chunkFormat2) {
        case ChunkFormat.JSON: {
          throw new Error("Unexpected JSON chunk");
        }
        case ChunkFormat.BIN: {
          const startByteOffset_2 = dataReader.byteOffset;
          data.bin = {
            readAsync: function(byteOffset, byteLength) {
              return dataReader.buffer.readAsync(startByteOffset_2 + byteOffset, byteLength);
            },
            byteLength: chunkLength2
          };
          dataReader.skipBytes(chunkLength2);
          break;
        }
        default: {
          dataReader.skipBytes(chunkLength2);
          break;
        }
      }
      if (dataReader.byteOffset !== length) {
        return dataReader.loadAsync(8).then(readAsync);
      }
      return Promise.resolve(data);
    };
    return readAsync();
  });
}
function UnpackBinaryAsync(dataReader) {
  return dataReader.loadAsync(20).then(function() {
    const Binary = {
      Magic: 1179937895
    };
    const magic = dataReader.readUint32();
    if (magic !== Binary.Magic) {
      throw new RuntimeError$1("GLTFFileLoaderExt Unexpected magic: " + magic, ErrorCodes$1.GLTFLoaderUnexpectedMagicError);
    }
    const version = dataReader.readUint32();
    const length = dataReader.readUint32();
    if (dataReader.buffer.byteLength !== 0 && length !== dataReader.buffer.byteLength) {
      throw new Error("GLTFFileLoaderExt: Length in header does not match actual data length");
    }
    let unpacked;
    switch (version) {
      case 1: {
        throw new Error("Unexpected GLTF Version 1");
      }
      case 2: {
        unpacked = UnpackBinaryV2Async(dataReader, length);
        break;
      }
      default: {
        throw new Error("Unsupported version: " + version);
      }
    }
    return unpacked;
  });
}
function DecodeAndParseJson(encryptedJson) {
  const parsed = JSON.parse(DecryptByAES(encryptedJson, GLTF_AES_KEY, GLTF_AES_IV));
  return parsed;
}
function ReadAsync(arrayBuffer, byteOffset, byteLength) {
  try {
    return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));
  } catch (e) {
    return Promise.reject(e);
  }
}
class GLTFFileLoaderExt extends GLTFFileLoader {
  constructor() {
    super(...arguments);
    this.name = "gotin-loader";
    this.extensions = {
      ".ext1": { isBinary: false },
      ".ext2": { isBinary: true }
    };
  }
  loadFile(scene, fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError) {
    let outputUrl = void 0;
    if (typeof fileOrUrl === "string") {
      outputUrl = fileOrUrl;
    }
    if (useArrayBuffer) {
      return super._loadFile(scene, fileOrUrl, function(data) {
        if (typeof data === "string") {
          return new Error("GLTFFileLoaderExt, GLB file need ArrayBuffer");
        }
        UnpackBinaryAsync(new DataReader({
          readAsync: function(byteOffset, byteLength) {
            return ReadAsync(data, byteOffset, byteLength);
          },
          byteLength: data.byteLength
        })).then(function(loaderData) {
          onSuccess(loaderData);
        }, onError ? function(error) {
          return onError(void 0, error);
        } : void 0);
      }, true, onError);
    }
    return super._loadFile(scene, fileOrUrl, (data) => {
      if (typeof data === "string") {
        const gltf = DecryptByAES(data, GLTF_AES_KEY, GLTF_AES_IV);
        onSuccess({ json: JSON.parse(gltf) }, outputUrl);
      }
    }, false, onError);
  }
  createPlugin() {
    return new GLTFFileLoaderExt();
  }
}
function DecryptByAES(input, key, iv) {
  const keyArray = cryptoJs.exports.enc.Utf8.parse(key);
  const ivArray = cryptoJs.exports.enc.Utf8.parse(iv);
  return cryptoJs.exports.AES.decrypt(input, keyArray, {
    keySize: 128 / 8,
    iv: ivArray,
    mode: cryptoJs.exports.mode.CBC,
    padding: cryptoJs.exports.pad.Pkcs7
  }).toString(cryptoJs.exports.enc.Utf8);
}
function CameraAnimationFromPointToPoint(camera, start, end, onComplete, timeNumber = 2500) {
  const tween = new Tween(start);
  tween.to(end, timeNumber);
  tween.easing(Easing.Quadratic.InOut);
  tween.onUpdate((object) => {
    camera.radius = object.radius;
    camera.alpha = object.alpha;
    camera.beta = object.beta;
    camera.target.copyFrom(object.target);
  });
  onComplete && tween.onComplete(onComplete);
  tween.start();
}
function CameraAnimationFlyToTarget(camera, start, end, onComplete) {
  const direction = end.target.subtract(camera.position).multiplyByFloats(0.6, 0.8, 0.6);
  start.fov = 1.2;
  const midPoint = {
    alpha: start.alpha,
    beta: start.beta,
    radius: start.radius,
    target: start.target.clone().add(direction),
    fov: 0.8
  };
  const tween1 = new Tween(start);
  tween1.to(midPoint, 2e3);
  tween1.easing(Easing.Quadratic.InOut);
  tween1.onUpdate((object) => {
    camera.radius = object.radius;
    camera.alpha = object.alpha;
    camera.beta = object.beta;
    camera.target.copyFrom(object.target);
    object.fov && (camera.fov = object.fov);
  });
  const tween2 = new Tween(midPoint);
  tween2.to(end, 1500);
  tween2.easing(Easing.Quadratic.InOut);
  tween2.onUpdate((object) => {
    camera.radius = object.radius;
    camera.alpha = object.alpha;
    camera.beta = object.beta;
    camera.target.copyFrom(object.target);
  });
  onComplete && tween2.onComplete(onComplete);
  tween1.chain(tween2);
  tween1.start();
}
class AiNpcMove {
  constructor(scene, camera, npc, pathData, velocityScale = 1, player, hotPotDistance = 5) {
    var _a2;
    this._isDebug = false;
    this._isStop = false;
    this._lastStopTime = 0;
    this._hotPotDistance = 5;
    this.updateHandler = () => {
      let isHot = false;
      if (this._player) {
        isHot = IsHotspot(this._npc.position, this._player.root.position, this._hotPotDistance);
      }
      if (isHot) {
        this._lastStopTime = Date.now();
        this._isStop = true;
      } else {
        const time = Date.now();
        if (time - this._lastStopTime > 2e3) {
          this._isStop = false;
        }
      }
      const idleAni = this._npcAsset.asset.animationGroups.find((ani) => ani.name === AVATAR_ANIMATION_ENUM.IDLE);
      const runAni = this._npcAsset.asset.animationGroups.find((ani) => ani.name === AVATAR_ANIMATION_ENUM.RUN);
      if (!idleAni || !runAni) {
        return;
      }
      if (this._isStop) {
        if (runAni.isPlaying && runAni.animatables[0].weight) {
          idleAni.play(true).setWeightForAllAnimatables(1);
          runAni.setWeightForAllAnimatables(0);
        }
        return;
      } else {
        if (!runAni.isPlaying || !runAni.animatables[0].weight) {
          idleAni.stop().setWeightForAllAnimatables(0);
          runAni.play(true).setWeightForAllAnimatables(1);
        }
        this._npc.position.x = this._points[this._i].x;
        this._npc.position.z = this._points[this._i].z;
        this._npc.lookAt(this._points[this._i + 1].add(new BABYLON$1.Vector3(0, 1.3, 0)));
        this._i = (this._i + 1) % (this._numberOfCoordinates - 1);
      }
    };
    this._scene = scene;
    this._camera = camera;
    this._i = 0;
    this._hotPotDistance = hotPotDistance;
    if (player) {
      this._player = player;
    }
    this._npcAsset = npc;
    this._points = [];
    this._numberOfCoordinates = Math.floor(1e3 * velocityScale);
    let numberScale = 1;
    const r = 10;
    if (pathData) {
      const tempPoints3 = [];
      for (let i = 0; i < pathData.length; i++) {
        tempPoints3.push(new BABYLON$1.Vector3(-pathData[i][0] / 100, 0, pathData[i][2] / 100));
      }
      const curve3d = BABYLON$1.Curve3.CreateCatmullRomSpline(tempPoints3, 60, true);
      const tempPoints = curve3d.getPoints();
      const path = new BABYLON$1.Path3D(tempPoints);
      const pathLength = path.length();
      numberScale = Math.floor(pathLength / 50);
      this._numberOfCoordinates = this._numberOfCoordinates * numberScale;
      for (let i = 0; i < this._numberOfCoordinates + 1; i++) {
        this._points.push(path.getPointAt(i / this._numberOfCoordinates));
      }
    } else {
      for (let i = 0; i < this._numberOfCoordinates + 1; i++) {
        this._points.push(new BABYLON$1.Vector3((r + r / 5 * Math.sin(8 * i * Math.PI / this._numberOfCoordinates)) * Math.cos(2 * i * Math.PI / this._numberOfCoordinates), 0, (r + r / 10 * Math.sin(6 * i * Math.PI / this._numberOfCoordinates)) * Math.sin(2 * i * Math.PI / this._numberOfCoordinates)));
      }
    }
    if (this._isDebug) {
      const track = BABYLON$1.MeshBuilder.CreateLines("ai_track", { points: this._points }, this._scene);
      track.color = new BABYLON$1.Color3(0, 0, 0);
      track.position.y = 0.5;
    }
    const path3d = new BABYLON$1.Path3D(this._points);
    this._normals = path3d.getNormals();
    this._theta = Math.acos(BABYLON$1.Vector3.Dot(BABYLON$1.Axis.Z, this._normals[0]));
    (_a2 = npc.asset.animationGroups.find((ani) => ani.name === AVATAR_ANIMATION_ENUM.RUN)) == null ? void 0 : _a2.start(true, 1);
    this._npc = npc.root;
    this._npc.checkCollisions = false;
    this._npc.rotate(BABYLON$1.Axis.Y, this._theta - Math.PI / 2, BABYLON$1.Space.WORLD);
    this._npc.up.copyFrom(new BABYLON$1.Vector3(0, 1, 0));
    this._npc.position.y = 1.3;
    this._scene.registerAfterRender(this.updateHandler);
  }
}
function serialize$1(dv, type, value, offset, littleEndian = true) {
  let nextOffset = offset;
  switch (type) {
    case "i":
      dv.setInt32(offset, value, littleEndian);
      nextOffset += 4;
      break;
    case "I":
      dv.setUint32(offset, value, littleEndian);
      nextOffset += 4;
      break;
    case "h":
      dv.setInt16(offset, value, littleEndian);
      nextOffset += 2;
      break;
    case "H":
      dv.setUint16(offset, value, littleEndian);
      nextOffset += 2;
      break;
    case "c":
      dv.setInt8(offset, value);
      nextOffset += 1;
      break;
    case "C":
      dv.setUint8(offset, value);
      nextOffset += 1;
      break;
    case "f":
      dv.setFloat32(offset, value, littleEndian);
      nextOffset += 4;
      break;
    case "d":
      dv.setFloat64(offset, value, littleEndian);
      nextOffset += 8;
      break;
  }
  return nextOffset;
}
function serializeString(dv, buffer, arr, type, offset) {
  let nextOffset = offset;
  if (type === "s") {
    dv.setUint8(offset, arr.byteLength);
    nextOffset += 1;
  } else {
    dv.setUint16(offset, arr.byteLength, true);
    nextOffset += 2;
  }
  const temp = new Uint8Array(buffer, nextOffset, arr.byteLength);
  temp.set(arr);
  nextOffset += arr.byteLength;
  return nextOffset;
}
function deserialize(dv, type, offset, littleEndian = true) {
  switch (type) {
    case "i":
      return [dv.getInt32(offset, littleEndian), offset + 4];
    case "I":
      return [dv.getUint32(offset, littleEndian), offset + 4];
    case "h":
      return [dv.getInt16(offset, littleEndian), offset + 2];
    case "H":
      return [dv.getUint16(offset, littleEndian), offset + 2];
    case "c":
      return [dv.getInt8(offset), offset + 1];
    case "C":
      return [dv.getUint8(offset), offset + 1];
    case "f":
      return [dv.getFloat32(offset, littleEndian), offset + 4];
    case "d":
      return [dv.getFloat64(offset, littleEndian), offset + 8];
  }
  throw new Error("cant resolve type");
}
function deserializeString(dv, buffer, type, offset) {
  let nextOffset = offset;
  let strLength = 0;
  if (type === "s") {
    strLength = dv.getUint8(offset);
    nextOffset += 1;
  } else {
    strLength = dv.getUint16(offset, true);
    nextOffset += 2;
  }
  const decoder = new TextDecoder();
  const arr = new Uint8Array(buffer, nextOffset, strLength);
  const str = decoder.decode(arr);
  nextOffset += strLength;
  return [str, nextOffset];
}
function getNumberByteLength(type) {
  switch (type) {
    case "i":
      return 4;
    case "I":
      return 4;
    case "h":
      return 2;
    case "H":
      return 2;
    case "c":
      return 1;
    case "C":
      return 1;
    case "f":
      return 4;
    case "d":
      return 8;
    default:
      throw new Error(`type description error, please check type ${type}, it should be one of i, I, h, H, c, C, f, d, s, S`);
  }
}
function getStringByteLength(str) {
  const encoder = new TextEncoder();
  const message = encoder.encode(str);
  return message.length;
}
function getStringByte(str) {
  const encoder = new TextEncoder();
  const message = encoder.encode(str);
  return message;
}
function sendBufferLength(typeDes, fields, content) {
  let length = 0;
  typeDes.split("").forEach((type, index) => {
    switch (type) {
      case "s": {
        const str = content[fields[index]];
        length += getStringByteLength(str) + 1;
        break;
      }
      case "S": {
        const str = content[fields[index]];
        length += getStringByteLength(str) + 2;
        break;
      }
      default: {
        length += getNumberByteLength(type);
      }
    }
  });
  return length;
}
class RpcMessage {
  constructor(cmdid, typeDescription, fileds, defaultObj) {
    this.cmdid = cmdid;
    this.typeDescription = typeDescription;
    this.typeDescriptionArray = typeDescription.split("");
    this.fileds = fileds;
    this.defaultObj = defaultObj;
  }
  encode(obj) {
    const sendObj = __spreadValues(__spreadValues({}, cloneDeep(this.defaultObj)), obj);
    const buffer = new ArrayBuffer(sendBufferLength(this.typeDescription, this.fileds, sendObj) + 2);
    const dv = new DataView(buffer);
    const offset = serialize$1(dv, "h", this.cmdid, 0);
    this.typeDescriptionArray.reduce(({ dv: dv2, offset: offset2 }, type, index) => {
      switch (type) {
        case "s": {
          const str = sendObj[this.fileds[index]];
          return { dv: dv2, offset: serializeString(dv2, buffer, getStringByte(str), type, offset2) };
        }
        case "S": {
          const str = sendObj[this.fileds[index]];
          return { dv: dv2, offset: serializeString(dv2, buffer, getStringByte(str), type, offset2) };
        }
        default: {
          let value;
          if (type === "c") {
            const temp = sendObj[this.fileds[index]];
            value = temp.charCodeAt(0);
          } else {
            value = sendObj[this.fileds[index]];
          }
          return { dv: dv2, offset: serialize$1(dv2, type, value, offset2) };
        }
      }
    }, { dv, offset });
    return buffer;
  }
  decode(buffer) {
    const dv = new DataView(buffer);
    const newObj = cloneDeep(this.defaultObj);
    this.typeDescriptionArray.reduce(({ dv: dv2, dvOffset }, type, index) => {
      const field = this.fileds[index];
      switch (type) {
        case "s": {
          const [value, offset] = deserializeString(dv2, buffer, type, dvOffset);
          newObj[field] = value;
          return { dv: dv2, dvOffset: offset };
        }
        case "S": {
          const [value, offset] = deserializeString(dv2, buffer, type, dvOffset);
          newObj[field] = value;
          return { dv: dv2, dvOffset: offset };
        }
        default: {
          const [value, offset] = deserialize(dv2, type, dvOffset);
          if (type === "c") {
            newObj[field] = String.fromCharCode(value);
          } else {
            newObj[field] = value;
          }
          return { dv: dv2, dvOffset: offset };
        }
      }
    }, { dv, dvOffset: 2 });
    return newObj;
  }
}
var SocketLoginRequestEvents = /* @__PURE__ */ ((SocketLoginRequestEvents2) => {
  SocketLoginRequestEvents2[SocketLoginRequestEvents2["RequestAuthorize"] = 101] = "RequestAuthorize";
  return SocketLoginRequestEvents2;
})(SocketLoginRequestEvents || {});
var SocketLoginResponseEvents = /* @__PURE__ */ ((SocketLoginResponseEvents2) => {
  SocketLoginResponseEvents2[SocketLoginResponseEvents2["SendErrorMessage"] = 101] = "SendErrorMessage";
  SocketLoginResponseEvents2[SocketLoginResponseEvents2["EnterGameSuccess"] = 102] = "EnterGameSuccess";
  return SocketLoginResponseEvents2;
})(SocketLoginResponseEvents || {});
const RequestAuthorize = {
  sessionId: ""
};
const requestAuthorize = new RpcMessage(SocketLoginRequestEvents.RequestAuthorize, "S", ["sessionId"], RequestAuthorize);
const defaultRequestEnterGameSuccess = {
  accountName: "",
  ticket: "",
  gatewayAddr: "",
  gatewayPort: 0,
  gatewaySslPort: 0
};
const enterGameSuccess = new RpcMessage(SocketLoginResponseEvents.SendErrorMessage, "sssII", ["accountName", "ticket", "gatewayAddr", "gatewayPort", "gatewaySslPort"], defaultRequestEnterGameSuccess);
const defaultSendErrorMessage = {
  id: 0
};
const sendErrorMessage = new RpcMessage(SocketLoginResponseEvents.SendErrorMessage, "I", ["id"], defaultSendErrorMessage);
const getTime = () => {
  const date = new Date();
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();
  const hour = date.getHours();
  const minute = date.getMinutes();
  const second = date.getSeconds();
  return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
};
class GameSocket {
  constructor(url, engine, emmit, options) {
    this.eventList = /* @__PURE__ */ new Map();
    this.rpcResponeList = /* @__PURE__ */ new Map();
    this.rpcRequestList = /* @__PURE__ */ new Map();
    this.rpcRequestQueue = new Array();
    this.onCloseCallBack = () => {
    };
    (function() {
      File.prototype.arrayBuffer = File.prototype.arrayBuffer || myArrayBuffer;
      Blob.prototype.arrayBuffer = Blob.prototype.arrayBuffer || myArrayBuffer;
      function myArrayBuffer() {
        return new Promise((resolve) => {
          const fr = new FileReader();
          fr.onload = () => {
            resolve(fr.result);
          };
          fr.readAsArrayBuffer(this);
        });
      }
    })();
    this.websocket = new WebSocket(url);
    this.websocket.onopen = (event) => {
      console.warn("time:", getTime(), "[CLIENT] connection open.");
      this.rpcRequestQueue.forEach((data) => {
        this.websocket.send(data);
      });
    };
    this.websocket.onmessage = (event) => {
      event.data.arrayBuffer().then((buffer) => {
        const dv = new DataView(buffer);
        const cmdid = deserialize(dv, "h", 0)[0];
        if (cmdid !== 104) {
          console.warn("time:", getTime(), "[CLIENT] receive message:", event.data);
          console.warn("time:", getTime(), "[CLIENT] response===cmdid", cmdid);
        }
        const rpc = this.rpcResponeList.get(cmdid);
        if (rpc) {
          const data = rpc.decode(buffer);
          if (cmdid !== 104) {
            console.warn("time:", getTime(), "[CLIENT] response===data", data);
          }
          const eventList = this.eventList.get(cmdid);
          if (eventList) {
            eventList.forEach((callback) => {
              callback(data);
            });
          }
        }
      });
    };
    this.websocket.onclose = (event) => {
      console.warn("time:", getTime(), "[CLIENT] connection closed.");
      this.onCloseCallBack();
    };
    this.websocket.onerror = (event) => {
      console.error("time:", getTime(), "[CLIENT] connection error.", event);
      this.onCloseCallBack();
    };
  }
  onClose(callback) {
    this.onCloseCallBack = callback;
  }
  getSocketState() {
    return this.websocket.readyState;
  }
  on(event, callback) {
    const eventList = this.eventList.get(event);
    if (eventList) {
      eventList.push(callback);
    } else {
      this.eventList.set(event, [callback]);
    }
  }
  off(event, callback) {
    console.warn("off", event, callback);
    const eventList = this.eventList.get(event);
    if (eventList && eventList.includes(callback)) {
      this.eventList.set(event, eventList.filter((i) => i !== callback));
    } else {
      console.warn(`no have this event:${event}`);
    }
  }
  close() {
    this.websocket.close();
  }
  send(event, data) {
    if (event !== 103) {
      console.warn("time:", getTime(), " send", "cmdid:", event, "data:", data);
    }
    const rpc = this.rpcRequestList.get(event);
    if (rpc) {
      const encodeData = rpc.encode(data);
      if (this.websocket.readyState === WebSocket.OPEN) {
        this.websocket.send(encodeData);
      } else {
        console.warn("[CLIENT] websocket is not open.");
        this.rpcRequestQueue.push(encodeData);
      }
    } else {
      console.warn(`no have this event:${String(event)}`);
    }
  }
  registerRequestRpc(event, rpc) {
    console.warn("rpc", event, rpc);
    this.rpcRequestList.set(event, rpc);
  }
  registerResponeRpc(event, rpc) {
    console.warn("rpc", event, rpc);
    this.rpcResponeList.set(event, rpc);
  }
}
let _emitter$1;
const loginGame = (url, token, emitter) => {
  _emitter$1 = emitter;
  return new Promise((resolve, reject) => {
    const socket2 = new GameSocket(url);
    socket2.registerRequestRpc(SocketLoginRequestEvents.RequestAuthorize, requestAuthorize);
    socket2.registerResponeRpc(SocketLoginResponseEvents.EnterGameSuccess, enterGameSuccess);
    socket2.registerResponeRpc(SocketLoginResponseEvents.SendErrorMessage, sendErrorMessage);
    socket2.on(SocketLoginResponseEvents.EnterGameSuccess, (data) => {
      resolve(data);
    });
    socket2.on(SocketLoginResponseEvents.SendErrorMessage, (data) => {
      const { id } = data;
      _emitter$1.emit(NjcbEventEnum.WRONG_NET_WORK, { id });
    });
    socket2.send(SocketLoginRequestEvents.RequestAuthorize, { sessionId: token });
  });
};
var SocketGatewayRequestEvents = /* @__PURE__ */ ((SocketGatewayRequestEvents2) => {
  SocketGatewayRequestEvents2[SocketGatewayRequestEvents2["ConnectToLobby"] = 101] = "ConnectToLobby";
  SocketGatewayRequestEvents2[SocketGatewayRequestEvents2["AddSetpNum"] = 104] = "AddSetpNum";
  SocketGatewayRequestEvents2[SocketGatewayRequestEvents2["HeartBeat"] = 103] = "HeartBeat";
  SocketGatewayRequestEvents2[SocketGatewayRequestEvents2["InitiativeQuite"] = 102] = "InitiativeQuite";
  return SocketGatewayRequestEvents2;
})(SocketGatewayRequestEvents || {});
var SocketGatewayResponseEvents = /* @__PURE__ */ ((SocketGatewayResponseEvents2) => {
  SocketGatewayResponseEvents2[SocketGatewayResponseEvents2["InitPlayer"] = 101] = "InitPlayer";
  SocketGatewayResponseEvents2[SocketGatewayResponseEvents2["KickOffMessage"] = 102] = "KickOffMessage";
  SocketGatewayResponseEvents2[SocketGatewayResponseEvents2["NotifyClientRefreshDuck"] = 105] = "NotifyClientRefreshDuck";
  SocketGatewayResponseEvents2[SocketGatewayResponseEvents2["NotifyRefreshDucks"] = 106] = "NotifyRefreshDucks";
  SocketGatewayResponseEvents2[SocketGatewayResponseEvents2["HeartBeatResponse"] = 104] = "HeartBeatResponse";
  SocketGatewayResponseEvents2[SocketGatewayResponseEvents2["NotifyGoldLimit"] = 107] = "NotifyGoldLimit";
  SocketGatewayResponseEvents2[SocketGatewayResponseEvents2["NotifyGoldMaxLimit"] = 108] = "NotifyGoldMaxLimit";
  SocketGatewayResponseEvents2[SocketGatewayResponseEvents2["NotifyRedPoint"] = 109] = "NotifyRedPoint";
  return SocketGatewayResponseEvents2;
})(SocketGatewayResponseEvents || {});
const defaultRequestConnectToLobby = {
  accountName: "",
  ticket: "",
  sessionId: ""
};
const connectToLobby = new RpcMessage(SocketGatewayRequestEvents.ConnectToLobby, "ssS", ["accountName", "ticket", "sessionId"], defaultRequestConnectToLobby);
const defaultRequestAddSetpNum = {
  state: 0
};
const addSetpNum = new RpcMessage(SocketGatewayRequestEvents.AddSetpNum, "I", ["state"], defaultRequestAddSetpNum);
const defaultRequestNotifyClientRefreshDuck = {
  duckid: "",
  dialogId: 0
};
const notifyClientRefreshDuck = new RpcMessage(SocketGatewayResponseEvents.NotifyClientRefreshDuck, "sI", ["duckid", "dialogId"], defaultRequestNotifyClientRefreshDuck);
const defaultRequestNotifyRefreshDucks = {
  duckStr: ""
};
const notifyRefreshDucks = new RpcMessage(SocketGatewayResponseEvents.NotifyRefreshDucks, "S", ["duckStr"], defaultRequestNotifyRefreshDucks);
const defaultResponseNotifyGoldLimit = {
  id: 0
};
const notifyGoldLimit = new RpcMessage(SocketGatewayResponseEvents.NotifyGoldLimit, "I", ["id"], defaultResponseNotifyGoldLimit);
const defaultResponseNotifyGoldMaxLimit = {
  id: 0
};
const notifyGoldMaxLimit = new RpcMessage(SocketGatewayResponseEvents.NotifyGoldMaxLimit, "I", ["id"], defaultResponseNotifyGoldMaxLimit);
const defaultInitPlayer = {
  basic_str: "",
  item_str: "",
  play_str: ""
};
const initPlayer = new RpcMessage(SocketGatewayResponseEvents.InitPlayer, "SSS", ["basic_str", "item_str", "play_str"], defaultInitPlayer);
const defaultRequestHeartBeat = {};
const heartBeat = new RpcMessage(SocketGatewayRequestEvents.HeartBeat, "", [], defaultRequestHeartBeat);
const heartBeatResponse = new RpcMessage(SocketGatewayResponseEvents.HeartBeatResponse, "", [], defaultRequestHeartBeat);
const defaultRequestInitiativeQuite = {};
const initiativeQuite = new RpcMessage(SocketGatewayRequestEvents.InitiativeQuite, "", [], defaultRequestInitiativeQuite);
const defaultKickOffMessage = {
  id: 0
};
const kickOffMessage = new RpcMessage(SocketGatewayResponseEvents.KickOffMessage, "I", ["id"], defaultKickOffMessage);
const defaultResponseNotifyRedPoint = {
  id: 0
};
const notifyRedPoint = new RpcMessage(SocketGatewayResponseEvents.NotifyRedPoint, "I", ["id"], defaultResponseNotifyRedPoint);
let socket;
const heart = { count: 0, isWeek: false };
let _emitter;
let _isReceiveError = false;
const gateWay = (account, ticket, gatewayAddr, gatewayPort, token, emitter) => {
  _emitter = emitter;
  return new Promise((resolve, reject) => {
    socket = new GameSocket(`wss://${gatewayAddr}:${gatewayPort}`);
    socket.registerResponeRpc(SocketGatewayResponseEvents.InitPlayer, initPlayer);
    socket.registerRequestRpc(SocketGatewayRequestEvents.ConnectToLobby, connectToLobby);
    socket.registerRequestRpc(SocketGatewayRequestEvents.AddSetpNum, addSetpNum);
    socket.registerRequestRpc(SocketGatewayRequestEvents.HeartBeat, heartBeat);
    socket.registerRequestRpc(SocketGatewayRequestEvents.InitiativeQuite, initiativeQuite);
    socket.registerResponeRpc(SocketGatewayResponseEvents.NotifyClientRefreshDuck, notifyClientRefreshDuck);
    socket.registerResponeRpc(SocketGatewayResponseEvents.NotifyRefreshDucks, notifyRefreshDucks);
    socket.registerResponeRpc(SocketGatewayResponseEvents.HeartBeatResponse, heartBeatResponse);
    socket.registerResponeRpc(SocketGatewayResponseEvents.KickOffMessage, kickOffMessage);
    socket.registerResponeRpc(SocketGatewayResponseEvents.NotifyGoldLimit, notifyGoldLimit);
    socket.registerResponeRpc(SocketGatewayResponseEvents.NotifyGoldMaxLimit, notifyGoldMaxLimit);
    socket.registerResponeRpc(SocketGatewayResponseEvents.NotifyRedPoint, notifyRedPoint);
    socket.onClose(() => {
      if (!_isReceiveError) {
        _emitter.emit(NjcbEventEnum.WRONG_NET_WORK, { id: WrongNetwork.disconnection });
      }
    });
    socket.on(SocketGatewayResponseEvents.HeartBeatResponse, () => {
      if (socket.getSocketState() === WebSocket.OPEN) {
        if (heart.isWeek) {
          heart.isWeek = false;
          _emitter.emit(NjcbEventEnum.WRONG_NET_WORK, { id: WrongNetwork.recovery });
        }
        heart.count = 0;
      }
    });
    socket.on(SocketGatewayResponseEvents.NotifyGoldLimit, (data) => {
      const { id } = data;
      _emitter.emit(NjcbEventEnum.Open_Account, { id });
    });
    socket.on(SocketGatewayResponseEvents.NotifyGoldMaxLimit, (data) => {
      const { id } = data;
      _emitter.emit(NjcbEventEnum.Wrong_Account, { id });
    });
    socket.on(SocketGatewayResponseEvents.NotifyRedPoint, (data) => {
      const { id } = data;
      _emitter.emit(NjcbEventEnum.UPDATE_HOME, { id });
    });
    socket.on(SocketGatewayResponseEvents.InitPlayer, (data) => {
      const { basic_str, item_str, play_str } = data;
      const basic = JSON.parse(basic_str);
      resolve({ socket, player: { basic, item: item_str, play: play_str } });
    });
    socket.on(SocketGatewayResponseEvents.KickOffMessage, (data) => {
      console.warn("server error");
      _isReceiveError = true;
      const { id } = data;
      _emitter.emit(NjcbEventEnum.WRONG_NET_WORK, { id });
    });
    socket.send(SocketGatewayRequestEvents.ConnectToLobby, { accountName: account, ticket, sessionId: token });
  });
};
const addSetpNumSocket = (state) => {
  if (socket && socket.getSocketState() === WebSocket.OPEN) {
    socket.send(SocketGatewayRequestEvents.AddSetpNum, { state });
  }
};
const sendHeartBeat = () => {
  if (socket && _emitter && socket.getSocketState() === WebSocket.OPEN) {
    if (heart.count > 4 && !heart.isWeek) {
      heart.isWeek = true;
      _emitter.emit(NjcbEventEnum.WRONG_NET_WORK, { id: WrongNetwork.week });
    }
    socket.send(SocketGatewayRequestEvents.HeartBeat, null);
    heart.count++;
  }
};
const notifyClientRefreshDuckSocket = (callback) => {
  if (socket) {
    socket.on(SocketGatewayResponseEvents.NotifyClientRefreshDuck, callback);
  }
};
const notifyRefreshDuckSocket = (callback) => {
  if (socket) {
    socket.on(SocketGatewayResponseEvents.NotifyRefreshDucks, callback);
  }
};
function createCaiDanYa(scene) {
  const M_FX_CaiDanYa = new NodeMaterial("M_FX_CaiDanYa", scene, {
    emitComments: true
  });
  M_FX_CaiDanYa.loadAsync("/game_njcb/scene/material/caiDanYa.json").then(() => {
    M_FX_CaiDanYa.build(false);
    M_FX_CaiDanYa.stencil.enabled = true;
    M_FX_CaiDanYa.stencil.funcRef = 1;
  });
  return M_FX_CaiDanYa;
}
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __decorate(decorators, target2, key, desc) {
  var c = arguments.length, r = c < 3 ? target2 : desc === null ? desc = Object.getOwnPropertyDescriptor(target2, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target2, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target2, key, r) : d(target2, key)) || r;
  return c > 3 && r && Object.defineProperty(target2, key, r), r;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var EventState = function() {
  function EventState2(mask, skipNextObservers, target2, currentTarget) {
    if (skipNextObservers === void 0) {
      skipNextObservers = false;
    }
    this.initialize(mask, skipNextObservers, target2, currentTarget);
  }
  EventState2.prototype.initialize = function(mask, skipNextObservers, target2, currentTarget) {
    if (skipNextObservers === void 0) {
      skipNextObservers = false;
    }
    this.mask = mask;
    this.skipNextObservers = skipNextObservers;
    this.target = target2;
    this.currentTarget = currentTarget;
    return this;
  };
  return EventState2;
}();
var Observer = function() {
  function Observer2(callback, mask, scope) {
    if (scope === void 0) {
      scope = null;
    }
    this.callback = callback;
    this.mask = mask;
    this.scope = scope;
    this._willBeUnregistered = false;
    this.unregisterOnNextCall = false;
  }
  return Observer2;
}();
var Observable = function() {
  function Observable2(onObserverAdded) {
    this._observers = new Array();
    this._eventState = new EventState(0);
    if (onObserverAdded) {
      this._onObserverAdded = onObserverAdded;
    }
  }
  Observable2.FromPromise = function(promise, onErrorObservable) {
    var observable = new Observable2();
    promise.then(function(ret) {
      observable.notifyObservers(ret);
    }).catch(function(err) {
      if (onErrorObservable) {
        onErrorObservable.notifyObservers(err);
      } else {
        throw err;
      }
    });
    return observable;
  };
  Object.defineProperty(Observable2.prototype, "observers", {
    get: function() {
      return this._observers;
    },
    enumerable: false,
    configurable: true
  });
  Observable2.prototype.add = function(callback, mask, insertFirst, scope, unregisterOnFirstCall) {
    if (mask === void 0) {
      mask = -1;
    }
    if (insertFirst === void 0) {
      insertFirst = false;
    }
    if (scope === void 0) {
      scope = null;
    }
    if (unregisterOnFirstCall === void 0) {
      unregisterOnFirstCall = false;
    }
    if (!callback) {
      return null;
    }
    var observer = new Observer(callback, mask, scope);
    observer.unregisterOnNextCall = unregisterOnFirstCall;
    if (insertFirst) {
      this._observers.unshift(observer);
    } else {
      this._observers.push(observer);
    }
    if (this._onObserverAdded) {
      this._onObserverAdded(observer);
    }
    return observer;
  };
  Observable2.prototype.addOnce = function(callback) {
    return this.add(callback, void 0, void 0, void 0, true);
  };
  Observable2.prototype.remove = function(observer) {
    if (!observer) {
      return false;
    }
    var index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._deferUnregister(observer);
      return true;
    }
    return false;
  };
  Observable2.prototype.removeCallback = function(callback, scope) {
    for (var index = 0; index < this._observers.length; index++) {
      var observer = this._observers[index];
      if (observer._willBeUnregistered) {
        continue;
      }
      if (observer.callback === callback && (!scope || scope === observer.scope)) {
        this._deferUnregister(observer);
        return true;
      }
    }
    return false;
  };
  Observable2.prototype._deferUnregister = function(observer) {
    var _this = this;
    observer.unregisterOnNextCall = false;
    observer._willBeUnregistered = true;
    setTimeout(function() {
      _this._remove(observer);
    }, 0);
  };
  Observable2.prototype._remove = function(observer) {
    if (!observer) {
      return false;
    }
    var index = this._observers.indexOf(observer);
    if (index !== -1) {
      this._observers.splice(index, 1);
      return true;
    }
    return false;
  };
  Observable2.prototype.makeObserverTopPriority = function(observer) {
    this._remove(observer);
    this._observers.unshift(observer);
  };
  Observable2.prototype.makeObserverBottomPriority = function(observer) {
    this._remove(observer);
    this._observers.push(observer);
  };
  Observable2.prototype.notifyObservers = function(eventData, mask, target2, currentTarget, userInfo) {
    if (mask === void 0) {
      mask = -1;
    }
    if (!this._observers.length) {
      return true;
    }
    var state = this._eventState;
    state.mask = mask;
    state.target = target2;
    state.currentTarget = currentTarget;
    state.skipNextObservers = false;
    state.lastReturnValue = eventData;
    state.userInfo = userInfo;
    for (var _i = 0, _a2 = this._observers; _i < _a2.length; _i++) {
      var obs = _a2[_i];
      if (obs._willBeUnregistered) {
        continue;
      }
      if (obs.mask & mask) {
        if (obs.scope) {
          state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);
        } else {
          state.lastReturnValue = obs.callback(eventData, state);
        }
        if (obs.unregisterOnNextCall) {
          this._deferUnregister(obs);
        }
      }
      if (state.skipNextObservers) {
        return false;
      }
    }
    return true;
  };
  Observable2.prototype.notifyObserversWithPromise = function(eventData, mask, target2, currentTarget, userInfo) {
    var _this = this;
    if (mask === void 0) {
      mask = -1;
    }
    var p = Promise.resolve(eventData);
    if (!this._observers.length) {
      return p;
    }
    var state = this._eventState;
    state.mask = mask;
    state.target = target2;
    state.currentTarget = currentTarget;
    state.skipNextObservers = false;
    state.userInfo = userInfo;
    this._observers.forEach(function(obs) {
      if (state.skipNextObservers) {
        return;
      }
      if (obs._willBeUnregistered) {
        return;
      }
      if (obs.mask & mask) {
        if (obs.scope) {
          p = p.then(function(lastReturnedValue) {
            state.lastReturnValue = lastReturnedValue;
            return obs.callback.apply(obs.scope, [eventData, state]);
          });
        } else {
          p = p.then(function(lastReturnedValue) {
            state.lastReturnValue = lastReturnedValue;
            return obs.callback(eventData, state);
          });
        }
        if (obs.unregisterOnNextCall) {
          _this._deferUnregister(obs);
        }
      }
    });
    return p.then(function() {
      return eventData;
    });
  };
  Observable2.prototype.notifyObserver = function(observer, eventData, mask) {
    if (mask === void 0) {
      mask = -1;
    }
    if (observer._willBeUnregistered) {
      return;
    }
    var state = this._eventState;
    state.mask = mask;
    state.skipNextObservers = false;
    observer.callback(eventData, state);
    if (observer.unregisterOnNextCall) {
      this._deferUnregister(observer);
    }
  };
  Observable2.prototype.hasObservers = function() {
    return this._observers.length > 0;
  };
  Observable2.prototype.clear = function() {
    this._observers = new Array();
    this._onObserverAdded = null;
  };
  Observable2.prototype.clone = function() {
    var result = new Observable2();
    result._observers = this._observers.slice(0);
    return result;
  };
  Observable2.prototype.hasSpecificMask = function(mask) {
    if (mask === void 0) {
      mask = -1;
    }
    for (var _i = 0, _a2 = this._observers; _i < _a2.length; _i++) {
      var obs = _a2[_i];
      if (obs.mask & mask || obs.mask === mask) {
        return true;
      }
    }
    return false;
  };
  return Observable2;
}();
function IsWindowObjectExist() {
  return typeof window !== "undefined";
}
function IsNavigatorAvailable() {
  return typeof navigator !== "undefined";
}
function IsDocumentAvailable() {
  return typeof document !== "undefined";
}
function GetDOMTextContent(element) {
  var result = "";
  var child = element.firstChild;
  while (child) {
    if (child.nodeType === 3) {
      result += child.textContent;
    }
    child = child.nextSibling;
  }
  return result;
}
var DomManagement = {
  IsWindowObjectExist,
  IsNavigatorAvailable,
  IsDocumentAvailable,
  GetDOMTextContent
};
var Logger = function() {
  function Logger2() {
  }
  Logger2._CheckLimit = function(message, limit) {
    var entry = Logger2._LogLimitOutputs[message];
    if (!entry) {
      entry = { limit, current: 1 };
      Logger2._LogLimitOutputs[message] = entry;
    } else {
      entry.current++;
    }
    return entry.current <= entry.limit;
  };
  Logger2._GenerateLimitMessage = function(message, messageType) {
    var entry = Logger2._LogLimitOutputs[message];
    if (!entry || !Logger2.MessageLimitReached) {
      return;
    }
    if (entry.current === entry.limit) {
      switch (messageType) {
        case 0:
          Logger2.Log(Logger2.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, "log"));
          break;
        case 1:
          Logger2.Warn(Logger2.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, "warning"));
          break;
        case 2:
          Logger2.Error(Logger2.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, "error"));
          break;
      }
    }
  };
  Logger2._AddLogEntry = function(entry) {
    Logger2._LogCache = entry + Logger2._LogCache;
    if (Logger2.OnNewCacheEntry) {
      Logger2.OnNewCacheEntry(entry);
    }
  };
  Logger2._FormatMessage = function(message) {
    var padStr = function(i) {
      return i < 10 ? "0" + i : "" + i;
    };
    var date = new Date();
    return "[" + padStr(date.getHours()) + ":" + padStr(date.getMinutes()) + ":" + padStr(date.getSeconds()) + "]: " + message;
  };
  Logger2._LogDisabled = function(message, limit) {
  };
  Logger2._LogEnabled = function(message, limit) {
    if (limit !== void 0 && !Logger2._CheckLimit(message, limit)) {
      return;
    }
    var formattedMessage = Logger2._FormatMessage(message);
    console.log("BJS - " + formattedMessage);
    var entry = "<div style='color:white'>" + formattedMessage + "</div><br>";
    Logger2._AddLogEntry(entry);
    Logger2._GenerateLimitMessage(message, 0);
  };
  Logger2._WarnDisabled = function(message, limit) {
  };
  Logger2._WarnEnabled = function(message, limit) {
    if (limit !== void 0 && !Logger2._CheckLimit(message, limit)) {
      return;
    }
    var formattedMessage = Logger2._FormatMessage(message);
    console.warn("BJS - " + formattedMessage);
    var entry = "<div style='color:orange'>" + message + "</div><br>";
    Logger2._AddLogEntry(entry);
    Logger2._GenerateLimitMessage(message, 1);
  };
  Logger2._ErrorDisabled = function(message, limit) {
  };
  Logger2._ErrorEnabled = function(message, limit) {
    if (limit !== void 0 && !Logger2._CheckLimit(message, limit)) {
      return;
    }
    var formattedMessage = Logger2._FormatMessage(message);
    Logger2.errorsCount++;
    console.error("BJS - " + formattedMessage);
    var entry = "<div style='color:red'>" + formattedMessage + "</div><br>";
    Logger2._AddLogEntry(entry);
    Logger2._GenerateLimitMessage(message, 2);
  };
  Object.defineProperty(Logger2, "LogCache", {
    get: function() {
      return Logger2._LogCache;
    },
    enumerable: false,
    configurable: true
  });
  Logger2.ClearLogCache = function() {
    Logger2._LogCache = "";
    Logger2._LogLimitOutputs = {};
    Logger2.errorsCount = 0;
  };
  Object.defineProperty(Logger2, "LogLevels", {
    set: function(level) {
      if ((level & Logger2.MessageLogLevel) === Logger2.MessageLogLevel) {
        Logger2.Log = Logger2._LogEnabled;
      } else {
        Logger2.Log = Logger2._LogDisabled;
      }
      if ((level & Logger2.WarningLogLevel) === Logger2.WarningLogLevel) {
        Logger2.Warn = Logger2._WarnEnabled;
      } else {
        Logger2.Warn = Logger2._WarnDisabled;
      }
      if ((level & Logger2.ErrorLogLevel) === Logger2.ErrorLogLevel) {
        Logger2.Error = Logger2._ErrorEnabled;
      } else {
        Logger2.Error = Logger2._ErrorDisabled;
      }
    },
    enumerable: false,
    configurable: true
  });
  Logger2.NoneLogLevel = 0;
  Logger2.MessageLogLevel = 1;
  Logger2.WarningLogLevel = 2;
  Logger2.ErrorLogLevel = 4;
  Logger2.AllLogLevel = 7;
  Logger2.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
  Logger2._LogCache = "";
  Logger2._LogLimitOutputs = {};
  Logger2.errorsCount = 0;
  Logger2.Log = Logger2._LogEnabled;
  Logger2.Warn = Logger2._WarnEnabled;
  Logger2.Error = Logger2._ErrorEnabled;
  return Logger2;
}();
var CloneValue = function(source, destinationObject) {
  if (!source) {
    return null;
  }
  if (source.getClassName && source.getClassName() === "Mesh") {
    return null;
  }
  if (source.getClassName && source.getClassName() === "SubMesh") {
    return source.clone(destinationObject);
  } else if (source.clone) {
    return source.clone();
  }
  return null;
};
function GetAllPropertyNames(obj) {
  var props = [];
  do {
    Object.getOwnPropertyNames(obj).forEach(function(prop) {
      if (props.indexOf(prop) === -1) {
        props.push(prop);
      }
    });
  } while (obj = Object.getPrototypeOf(obj));
  return props;
}
var DeepCopier = function() {
  function DeepCopier2() {
  }
  DeepCopier2.DeepCopy = function(source, destination, doNotCopyList, mustCopyList) {
    var properties = GetAllPropertyNames(source);
    for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
      var prop = properties_1[_i];
      if (prop[0] === "_" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {
        continue;
      }
      if (prop.endsWith("Observable")) {
        continue;
      }
      if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {
        continue;
      }
      var sourceValue = source[prop];
      var typeOfSourceValue = typeof sourceValue;
      if (typeOfSourceValue === "function") {
        continue;
      }
      try {
        if (typeOfSourceValue === "object") {
          if (sourceValue instanceof Array) {
            destination[prop] = [];
            if (sourceValue.length > 0) {
              if (typeof sourceValue[0] == "object") {
                for (var index = 0; index < sourceValue.length; index++) {
                  var clonedValue = CloneValue(sourceValue[index], destination);
                  if (destination[prop].indexOf(clonedValue) === -1) {
                    destination[prop].push(clonedValue);
                  }
                }
              } else {
                destination[prop] = sourceValue.slice(0);
              }
            }
          } else {
            destination[prop] = CloneValue(sourceValue, destination);
          }
        } else {
          destination[prop] = sourceValue;
        }
      } catch (e) {
        Logger.Warn(e.message);
      }
    }
  };
  return DeepCopier2;
}();
var PrecisionDate = function() {
  function PrecisionDate2() {
  }
  Object.defineProperty(PrecisionDate2, "Now", {
    get: function() {
      if (DomManagement.IsWindowObjectExist() && window.performance && window.performance.now) {
        return window.performance.now();
      }
      return Date.now();
    },
    enumerable: false,
    configurable: true
  });
  return PrecisionDate2;
}();
function _WarnImport(name2) {
  return "".concat(name2, " needs to be imported before as it contains a side-effect required by your code.");
}
function createXMLHttpRequest() {
  if (typeof _native !== "undefined" && _native.XMLHttpRequest) {
    return new _native.XMLHttpRequest();
  } else {
    return new XMLHttpRequest();
  }
}
var WebRequest = function() {
  function WebRequest2() {
    this._xhr = createXMLHttpRequest();
    this._requestURL = "";
  }
  WebRequest2.prototype._injectCustomRequestHeaders = function() {
    if (this._shouldSkipRequestModifications(this._requestURL)) {
      return;
    }
    for (var key in WebRequest2.CustomRequestHeaders) {
      var val = WebRequest2.CustomRequestHeaders[key];
      if (val) {
        this._xhr.setRequestHeader(key, val);
      }
    }
  };
  WebRequest2.prototype._shouldSkipRequestModifications = function(url) {
    return WebRequest2.SkipRequestModificationForBabylonCDN && (url.includes("preview.babylonjs.com") || url.includes("cdn.babylonjs.com"));
  };
  Object.defineProperty(WebRequest2.prototype, "onprogress", {
    get: function() {
      return this._xhr.onprogress;
    },
    set: function(value) {
      this._xhr.onprogress = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "readyState", {
    get: function() {
      return this._xhr.readyState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "status", {
    get: function() {
      return this._xhr.status;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "statusText", {
    get: function() {
      return this._xhr.statusText;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "response", {
    get: function() {
      return this._xhr.response;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "responseURL", {
    get: function() {
      return this._xhr.responseURL;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "responseText", {
    get: function() {
      return this._xhr.responseText;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "responseType", {
    get: function() {
      return this._xhr.responseType;
    },
    set: function(value) {
      this._xhr.responseType = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebRequest2.prototype, "timeout", {
    get: function() {
      return this._xhr.timeout;
    },
    set: function(value) {
      this._xhr.timeout = value;
    },
    enumerable: false,
    configurable: true
  });
  WebRequest2.prototype.addEventListener = function(type, listener, options) {
    this._xhr.addEventListener(type, listener, options);
  };
  WebRequest2.prototype.removeEventListener = function(type, listener, options) {
    this._xhr.removeEventListener(type, listener, options);
  };
  WebRequest2.prototype.abort = function() {
    this._xhr.abort();
  };
  WebRequest2.prototype.send = function(body) {
    if (WebRequest2.CustomRequestHeaders) {
      this._injectCustomRequestHeaders();
    }
    this._xhr.send(body);
  };
  WebRequest2.prototype.open = function(method, url) {
    for (var _i = 0, _a2 = WebRequest2.CustomRequestModifiers; _i < _a2.length; _i++) {
      var update2 = _a2[_i];
      if (this._shouldSkipRequestModifications(url)) {
        return;
      }
      update2(this._xhr, url);
    }
    url = url.replace("file:http:", "http:");
    url = url.replace("file:https:", "https:");
    this._requestURL = url;
    return this._xhr.open(method, url, true);
  };
  WebRequest2.prototype.setRequestHeader = function(name2, value) {
    this._xhr.setRequestHeader(name2, value);
  };
  WebRequest2.prototype.getResponseHeader = function(name2) {
    return this._xhr.getResponseHeader(name2);
  };
  WebRequest2.CustomRequestHeaders = {};
  WebRequest2.CustomRequestModifiers = new Array();
  WebRequest2.SkipRequestModificationForBabylonCDN = true;
  return WebRequest2;
}();
var EngineStore = function() {
  function EngineStore2() {
  }
  Object.defineProperty(EngineStore2, "LastCreatedEngine", {
    get: function() {
      if (this.Instances.length === 0) {
        return null;
      }
      return this.Instances[this.Instances.length - 1];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(EngineStore2, "LastCreatedScene", {
    get: function() {
      return this._LastCreatedScene;
    },
    enumerable: false,
    configurable: true
  });
  EngineStore2.Instances = new Array();
  EngineStore2._LastCreatedScene = null;
  EngineStore2.UseFallbackTexture = true;
  EngineStore2.FallbackTexture = "";
  return EngineStore2;
}();
var FilesInputStore = function() {
  function FilesInputStore2() {
  }
  FilesInputStore2.FilesToLoad = {};
  return FilesInputStore2;
}();
var RetryStrategy = function() {
  function RetryStrategy2() {
  }
  RetryStrategy2.ExponentialBackoff = function(maxRetries, baseInterval) {
    if (maxRetries === void 0) {
      maxRetries = 3;
    }
    if (baseInterval === void 0) {
      baseInterval = 500;
    }
    return function(url, request, retryIndex) {
      if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf("file:") !== -1) {
        return -1;
      }
      return Math.pow(2, retryIndex) * baseInterval;
    };
  };
  return RetryStrategy2;
}();
var BaseError = function(_super) {
  __extends(BaseError2, _super);
  function BaseError2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  BaseError2._setPrototypeOf = Object.setPrototypeOf || function(o, proto) {
    o.__proto__ = proto;
    return o;
  };
  return BaseError2;
}(Error);
var ErrorCodes = {
  MeshInvalidPositionsError: 0,
  UnsupportedTextureError: 1e3,
  GLTFLoaderUnexpectedMagicError: 2e3,
  SceneLoaderError: 3e3,
  LoadFileError: 4e3,
  RequestFileError: 4001,
  ReadFileError: 4002
};
var RuntimeError = function(_super) {
  __extends(RuntimeError2, _super);
  function RuntimeError2(message, errorCode, innerError) {
    var _this = _super.call(this, message) || this;
    _this.errorCode = errorCode;
    _this.innerError = innerError;
    _this.name = "RuntimeError";
    BaseError._setPrototypeOf(_this, RuntimeError2.prototype);
    return _this;
  }
  return RuntimeError2;
}(BaseError);
var EncodeArrayBufferToBase64 = function(buffer) {
  var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var output = "";
  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  var i = 0;
  var bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
  while (i < bytes.length) {
    chr1 = bytes[i++];
    chr2 = i < bytes.length ? bytes[i++] : Number.NaN;
    chr3 = i < bytes.length ? bytes[i++] : Number.NaN;
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
  }
  return output;
};
var DecodeBase64ToString = function(base64Data) {
  return atob(base64Data);
};
var DecodeBase64ToBinary = function(base64Data) {
  var decodedString = DecodeBase64ToString(base64Data);
  var bufferLength = decodedString.length;
  var bufferView = new Uint8Array(new ArrayBuffer(bufferLength));
  for (var i = 0; i < bufferLength; i++) {
    bufferView[i] = decodedString.charCodeAt(i);
  }
  return bufferView.buffer;
};
var ShaderCodeNode = function() {
  function ShaderCodeNode2() {
    this.children = [];
  }
  ShaderCodeNode2.prototype.isValid = function(preprocessors) {
    return true;
  };
  ShaderCodeNode2.prototype.process = function(preprocessors, options) {
    var result = "";
    if (this.line) {
      var value = this.line;
      var processor = options.processor;
      if (processor) {
        if (processor.lineProcessor) {
          value = processor.lineProcessor(value, options.isFragment, options.processingContext);
        }
        if (processor.attributeProcessor && this.line.startsWith("attribute")) {
          value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);
        } else if (processor.varyingProcessor && this.line.startsWith("varying")) {
          value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
        } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {
          if (!options.lookForClosingBracketForUniformBuffer) {
            value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
          }
        } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {
          if (!options.lookForClosingBracketForUniformBuffer) {
            value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
            options.lookForClosingBracketForUniformBuffer = true;
          }
        } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {
          value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
        } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith("uniform") && !options.lookForClosingBracketForUniformBuffer) {
          var regex = /uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/;
          if (regex.test(this.line)) {
            if (processor.uniformProcessor) {
              value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
            }
          } else {
            if (processor.uniformBufferProcessor) {
              value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
              options.lookForClosingBracketForUniformBuffer = true;
            }
          }
        }
        if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1) {
          options.lookForClosingBracketForUniformBuffer = false;
          if (processor.endOfUniformBufferProcessor) {
            value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);
          }
        }
      }
      result += value + "\r\n";
    }
    this.children.forEach(function(child) {
      result += child.process(preprocessors, options);
    });
    if (this.additionalDefineKey) {
      preprocessors[this.additionalDefineKey] = this.additionalDefineValue || "true";
    }
    return result;
  };
  return ShaderCodeNode2;
}();
var ShaderCodeCursor = function() {
  function ShaderCodeCursor2() {
  }
  Object.defineProperty(ShaderCodeCursor2.prototype, "currentLine", {
    get: function() {
      return this._lines[this.lineIndex];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShaderCodeCursor2.prototype, "canRead", {
    get: function() {
      return this.lineIndex < this._lines.length - 1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ShaderCodeCursor2.prototype, "lines", {
    set: function(value) {
      this._lines = [];
      for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
        var line = value_1[_i];
        if (line[0] === "#") {
          this._lines.push(line);
          continue;
        }
        if (line.trim().startsWith("//")) {
          this._lines.push(line);
          continue;
        }
        var split = line.split(";");
        for (var index = 0; index < split.length; index++) {
          var subLine = split[index];
          subLine = subLine.trim();
          if (!subLine) {
            continue;
          }
          this._lines.push(subLine + (index !== split.length - 1 ? ";" : ""));
        }
      }
    },
    enumerable: false,
    configurable: true
  });
  return ShaderCodeCursor2;
}();
var ShaderCodeConditionNode = function(_super) {
  __extends(ShaderCodeConditionNode2, _super);
  function ShaderCodeConditionNode2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderCodeConditionNode2.prototype.process = function(preprocessors, options) {
    for (var index = 0; index < this.children.length; index++) {
      var node = this.children[index];
      if (node.isValid(preprocessors)) {
        return node.process(preprocessors, options);
      }
    }
    return "";
  };
  return ShaderCodeConditionNode2;
}(ShaderCodeNode);
var ShaderCodeTestNode = function(_super) {
  __extends(ShaderCodeTestNode2, _super);
  function ShaderCodeTestNode2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderCodeTestNode2.prototype.isValid = function(preprocessors) {
    return this.testExpression.isTrue(preprocessors);
  };
  return ShaderCodeTestNode2;
}(ShaderCodeNode);
var ShaderDefineExpression = function() {
  function ShaderDefineExpression2() {
  }
  ShaderDefineExpression2.prototype.isTrue = function(preprocessors) {
    return true;
  };
  ShaderDefineExpression2.postfixToInfix = function(postfix) {
    var stack = [];
    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {
      var c = postfix_1[_i];
      if (ShaderDefineExpression2._OperatorPriority[c] === void 0) {
        stack.push(c);
      } else {
        var v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        stack.push("(".concat(v2).concat(c).concat(v1, ")"));
      }
    }
    return stack[stack.length - 1];
  };
  ShaderDefineExpression2.infixToPostfix = function(infix) {
    var result = [];
    var stackIdx = -1;
    var pushOperand = function() {
      operand = operand.trim();
      if (operand !== "") {
        result.push(operand);
        operand = "";
      }
    };
    var push = function(s) {
      if (stackIdx < ShaderDefineExpression2._Stack.length - 1) {
        ShaderDefineExpression2._Stack[++stackIdx] = s;
      }
    };
    var peek = function() {
      return ShaderDefineExpression2._Stack[stackIdx];
    };
    var pop = function() {
      return stackIdx === -1 ? "!!INVALID EXPRESSION!!" : ShaderDefineExpression2._Stack[stackIdx--];
    };
    var idx = 0, operand = "";
    while (idx < infix.length) {
      var c = infix.charAt(idx), token = idx < infix.length - 1 ? infix.substr(idx, 2) : "";
      if (c === "(") {
        operand = "";
        push(c);
      } else if (c === ")") {
        pushOperand();
        while (stackIdx !== -1 && peek() !== "(") {
          result.push(pop());
        }
        pop();
      } else if (ShaderDefineExpression2._OperatorPriority[token] > 1) {
        pushOperand();
        while (stackIdx !== -1 && ShaderDefineExpression2._OperatorPriority[peek()] >= ShaderDefineExpression2._OperatorPriority[token]) {
          result.push(pop());
        }
        push(token);
        idx++;
      } else {
        operand += c;
      }
      idx++;
    }
    pushOperand();
    while (stackIdx !== -1) {
      if (peek() === "(") {
        pop();
      } else {
        result.push(pop());
      }
    }
    return result;
  };
  ShaderDefineExpression2._OperatorPriority = {
    ")": 0,
    "(": 1,
    "||": 2,
    "&&": 3
  };
  ShaderDefineExpression2._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  return ShaderDefineExpression2;
}();
var ShaderDefineIsDefinedOperator = function(_super) {
  __extends(ShaderDefineIsDefinedOperator2, _super);
  function ShaderDefineIsDefinedOperator2(define, not) {
    if (not === void 0) {
      not = false;
    }
    var _this = _super.call(this) || this;
    _this.define = define;
    _this.not = not;
    return _this;
  }
  ShaderDefineIsDefinedOperator2.prototype.isTrue = function(preprocessors) {
    var condition = preprocessors[this.define] !== void 0;
    if (this.not) {
      condition = !condition;
    }
    return condition;
  };
  return ShaderDefineIsDefinedOperator2;
}(ShaderDefineExpression);
var ShaderDefineOrOperator = function(_super) {
  __extends(ShaderDefineOrOperator2, _super);
  function ShaderDefineOrOperator2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderDefineOrOperator2.prototype.isTrue = function(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);
  };
  return ShaderDefineOrOperator2;
}(ShaderDefineExpression);
var ShaderDefineAndOperator = function(_super) {
  __extends(ShaderDefineAndOperator2, _super);
  function ShaderDefineAndOperator2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ShaderDefineAndOperator2.prototype.isTrue = function(preprocessors) {
    return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);
  };
  return ShaderDefineAndOperator2;
}(ShaderDefineExpression);
var ShaderDefineArithmeticOperator = function(_super) {
  __extends(ShaderDefineArithmeticOperator2, _super);
  function ShaderDefineArithmeticOperator2(define, operand, testValue) {
    var _this = _super.call(this) || this;
    _this.define = define;
    _this.operand = operand;
    _this.testValue = testValue;
    return _this;
  }
  ShaderDefineArithmeticOperator2.prototype.isTrue = function(preprocessors) {
    var value = preprocessors[this.define];
    if (value === void 0) {
      value = this.define;
    }
    var condition = false;
    var left = parseInt(value);
    var right = parseInt(this.testValue);
    switch (this.operand) {
      case ">":
        condition = left > right;
        break;
      case "<":
        condition = left < right;
        break;
      case "<=":
        condition = left <= right;
        break;
      case ">=":
        condition = left >= right;
        break;
      case "==":
        condition = left === right;
        break;
    }
    return condition;
  };
  return ShaderDefineArithmeticOperator2;
}(ShaderDefineExpression);
var ShaderLanguage;
(function(ShaderLanguage2) {
  ShaderLanguage2[ShaderLanguage2["GLSL"] = 0] = "GLSL";
  ShaderLanguage2[ShaderLanguage2["WGSL"] = 1] = "WGSL";
})(ShaderLanguage || (ShaderLanguage = {}));
var regexSE = /defined\s*?\((.+?)\)/g;
var regexSERevert = /defined\s*?\[(.+?)\]/g;
var regexShaderInclude = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g;
var ShaderProcessor = function() {
  function ShaderProcessor2() {
  }
  ShaderProcessor2.Initialize = function(options) {
    if (options.processor && options.processor.initializeShaders) {
      options.processor.initializeShaders(options.processingContext);
    }
  };
  ShaderProcessor2.Process = function(sourceCode, options, callback, engine) {
    var _this = this;
    var _a2;
    if ((_a2 = options.processor) === null || _a2 === void 0 ? void 0 : _a2.preProcessShaderCode) {
      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
    }
    this._ProcessIncludes(sourceCode, options, function(codeWithIncludes) {
      if (options.processCodeAfterIncludes) {
        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
      }
      var migratedCode = _this._ProcessShaderConversion(codeWithIncludes, options, engine);
      callback(migratedCode);
    });
  };
  ShaderProcessor2.PreProcess = function(sourceCode, options, callback, engine) {
    var _this = this;
    var _a2;
    if ((_a2 = options.processor) === null || _a2 === void 0 ? void 0 : _a2.preProcessShaderCode) {
      sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
    }
    this._ProcessIncludes(sourceCode, options, function(codeWithIncludes) {
      if (options.processCodeAfterIncludes) {
        codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
      }
      var migratedCode = _this._ApplyPreProcessing(codeWithIncludes, options, engine);
      callback(migratedCode);
    });
  };
  ShaderProcessor2.Finalize = function(vertexCode, fragmentCode, options) {
    if (!options.processor || !options.processor.finalizeShaders) {
      return { vertexCode, fragmentCode };
    }
    return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);
  };
  ShaderProcessor2._ProcessPrecision = function(source, options) {
    var _a2;
    if ((_a2 = options.processor) === null || _a2 === void 0 ? void 0 : _a2.noPrecision) {
      return source;
    }
    var shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;
    if (source.indexOf("precision highp float") === -1) {
      if (!shouldUseHighPrecisionShader) {
        source = "precision mediump float;\n" + source;
      } else {
        source = "precision highp float;\n" + source;
      }
    } else {
      if (!shouldUseHighPrecisionShader) {
        source = source.replace("precision highp float", "precision mediump float");
      }
    }
    return source;
  };
  ShaderProcessor2._ExtractOperation = function(expression) {
    var regex = /defined\((.+)\)/;
    var match = regex.exec(expression);
    if (match && match.length) {
      return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === "!");
    }
    var operators = ["==", ">=", "<=", "<", ">"];
    var operator = "";
    var indexOperator = 0;
    for (var _i = 0, operators_1 = operators; _i < operators_1.length; _i++) {
      operator = operators_1[_i];
      indexOperator = expression.indexOf(operator);
      if (indexOperator > -1) {
        break;
      }
    }
    if (indexOperator === -1) {
      return new ShaderDefineIsDefinedOperator(expression);
    }
    var define = expression.substring(0, indexOperator).trim();
    var value = expression.substring(indexOperator + operator.length).trim();
    return new ShaderDefineArithmeticOperator(define, operator, value);
  };
  ShaderProcessor2._BuildSubExpression = function(expression) {
    expression = expression.replace(regexSE, "defined[$1]");
    var postfix = ShaderDefineExpression.infixToPostfix(expression);
    var stack = [];
    for (var _i = 0, postfix_1 = postfix; _i < postfix_1.length; _i++) {
      var c = postfix_1[_i];
      if (c !== "||" && c !== "&&") {
        stack.push(c);
      } else if (stack.length >= 2) {
        var v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
        stack.length -= 2;
        var operator = c == "&&" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();
        if (typeof v1 === "string") {
          v1 = v1.replace(regexSERevert, "defined($1)");
        }
        if (typeof v2 === "string") {
          v2 = v2.replace(regexSERevert, "defined($1)");
        }
        operator.leftOperand = typeof v2 === "string" ? this._ExtractOperation(v2) : v2;
        operator.rightOperand = typeof v1 === "string" ? this._ExtractOperation(v1) : v1;
        stack.push(operator);
      }
    }
    var result = stack[stack.length - 1];
    if (typeof result === "string") {
      result = result.replace(regexSERevert, "defined($1)");
    }
    return typeof result === "string" ? this._ExtractOperation(result) : result;
  };
  ShaderProcessor2._BuildExpression = function(line, start) {
    var node = new ShaderCodeTestNode();
    var command = line.substring(0, start);
    var expression = line.substring(start);
    expression = expression.substring(0, (expression.indexOf("//") + 1 || expression.length + 1) - 1).trim();
    if (command === "#ifdef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression);
    } else if (command === "#ifndef") {
      node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);
    } else {
      node.testExpression = this._BuildSubExpression(expression);
    }
    return node;
  };
  ShaderProcessor2._MoveCursorWithinIf = function(cursor, rootNode, ifNode) {
    var line = cursor.currentLine;
    while (this._MoveCursor(cursor, ifNode)) {
      line = cursor.currentLine;
      var first5 = line.substring(0, 5).toLowerCase();
      if (first5 === "#else") {
        var elseNode = new ShaderCodeNode();
        rootNode.children.push(elseNode);
        this._MoveCursor(cursor, elseNode);
        return;
      } else if (first5 === "#elif") {
        var elifNode = this._BuildExpression(line, 5);
        rootNode.children.push(elifNode);
        ifNode = elifNode;
      }
    }
  };
  ShaderProcessor2._MoveCursor = function(cursor, rootNode) {
    while (cursor.canRead) {
      cursor.lineIndex++;
      var line = cursor.currentLine;
      var keywords = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;
      var matches = keywords.exec(line);
      if (matches && matches.length) {
        var keyword = matches[0];
        switch (keyword) {
          case "#ifdef": {
            var newRootNode = new ShaderCodeConditionNode();
            rootNode.children.push(newRootNode);
            var ifNode = this._BuildExpression(line, 6);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
          case "#else":
          case "#elif":
            return true;
          case "#endif":
            return false;
          case "#ifndef": {
            var newRootNode = new ShaderCodeConditionNode();
            rootNode.children.push(newRootNode);
            var ifNode = this._BuildExpression(line, 7);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
          case "#if": {
            var newRootNode = new ShaderCodeConditionNode();
            var ifNode = this._BuildExpression(line, 3);
            rootNode.children.push(newRootNode);
            newRootNode.children.push(ifNode);
            this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
            break;
          }
        }
      } else {
        var newNode = new ShaderCodeNode();
        newNode.line = line;
        rootNode.children.push(newNode);
        if (line[0] === "#" && line[1] === "d") {
          var split = line.replace(";", "").split(" ");
          newNode.additionalDefineKey = split[1];
          if (split.length === 3) {
            newNode.additionalDefineValue = split[2];
          }
        }
      }
    }
    return false;
  };
  ShaderProcessor2._EvaluatePreProcessors = function(sourceCode, preprocessors, options) {
    var rootNode = new ShaderCodeNode();
    var cursor = new ShaderCodeCursor();
    cursor.lineIndex = -1;
    cursor.lines = sourceCode.split("\n");
    this._MoveCursor(cursor, rootNode);
    return rootNode.process(preprocessors, options);
  };
  ShaderProcessor2._PreparePreProcessors = function(options, engine) {
    var _a2;
    var defines = options.defines;
    var preprocessors = {};
    for (var _i = 0, defines_1 = defines; _i < defines_1.length; _i++) {
      var define = defines_1[_i];
      var keyValue = define.replace("#define", "").replace(";", "").trim();
      var split = keyValue.split(" ");
      preprocessors[split[0]] = split.length > 1 ? split[1] : "";
    }
    if (((_a2 = options.processor) === null || _a2 === void 0 ? void 0 : _a2.shaderLanguage) === ShaderLanguage.GLSL) {
      preprocessors["GL_ES"] = "true";
    }
    preprocessors["__VERSION__"] = options.version;
    preprocessors[options.platformName] = "true";
    engine._getGlobalDefines(preprocessors);
    return preprocessors;
  };
  ShaderProcessor2._ProcessShaderConversion = function(sourceCode, options, engine) {
    var preparedSourceCode = this._ProcessPrecision(sourceCode, options);
    if (!options.processor) {
      return preparedSourceCode;
    }
    if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf("#version 3") !== -1) {
      return preparedSourceCode.replace("#version 300 es", "");
    }
    var defines = options.defines;
    var preprocessors = this._PreparePreProcessors(options, engine);
    if (options.processor.preProcessor) {
      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
    }
    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
    if (options.processor.postProcessor) {
      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
    }
    if (engine._features.needShaderCodeInlining) {
      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
    }
    return preparedSourceCode;
  };
  ShaderProcessor2._ApplyPreProcessing = function(sourceCode, options, engine) {
    var _a2, _b2;
    var preparedSourceCode = sourceCode;
    var defines = options.defines;
    var preprocessors = this._PreparePreProcessors(options, engine);
    if ((_a2 = options.processor) === null || _a2 === void 0 ? void 0 : _a2.preProcessor) {
      preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
    }
    preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
    if ((_b2 = options.processor) === null || _b2 === void 0 ? void 0 : _b2.postProcessor) {
      preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
    }
    if (engine._features.needShaderCodeInlining) {
      preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
    }
    return preparedSourceCode;
  };
  ShaderProcessor2._ProcessIncludes = function(sourceCode, options, callback) {
    var _this = this;
    var match = regexShaderInclude.exec(sourceCode);
    var returnValue = new String(sourceCode);
    var keepProcessing = false;
    var _loop_1 = function() {
      var includeFile = match[1];
      if (includeFile.indexOf("__decl__") !== -1) {
        includeFile = includeFile.replace(/__decl__/, "");
        if (options.supportsUniformBuffers) {
          includeFile = includeFile.replace(/Vertex/, "Ubo");
          includeFile = includeFile.replace(/Fragment/, "Ubo");
        }
        includeFile = includeFile + "Declaration";
      }
      if (options.includesShadersStore[includeFile]) {
        var includeContent = options.includesShadersStore[includeFile];
        if (match[2]) {
          var splits = match[3].split(",");
          for (var index = 0; index < splits.length; index += 2) {
            var source = new RegExp(splits[index], "g");
            var dest = splits[index + 1];
            includeContent = includeContent.replace(source, dest);
          }
        }
        if (match[4]) {
          var indexString = match[5];
          if (indexString.indexOf("..") !== -1) {
            var indexSplits = indexString.split("..");
            var minIndex = parseInt(indexSplits[0]);
            var maxIndex = parseInt(indexSplits[1]);
            var sourceIncludeContent = includeContent.slice(0);
            includeContent = "";
            if (isNaN(maxIndex)) {
              maxIndex = options.indexParameters[indexSplits[1]];
            }
            for (var i = minIndex; i < maxIndex; i++) {
              if (!options.supportsUniformBuffers) {
                sourceIncludeContent = sourceIncludeContent.replace(/light\{X\}.(\w*)/g, function(str, p1) {
                  return p1 + "{X}";
                });
              }
              includeContent += sourceIncludeContent.replace(/\{X\}/g, i.toString()) + "\n";
            }
          } else {
            if (!options.supportsUniformBuffers) {
              includeContent = includeContent.replace(/light\{X\}.(\w*)/g, function(str, p1) {
                return p1 + "{X}";
              });
            }
            includeContent = includeContent.replace(/\{X\}/g, indexString);
          }
        }
        returnValue = returnValue.replace(match[0], includeContent);
        keepProcessing = keepProcessing || includeContent.indexOf("#include<") >= 0 || includeContent.indexOf("#include <") >= 0;
      } else {
        var includeShaderUrl = options.shadersRepository + "ShadersInclude/" + includeFile + ".fx";
        ShaderProcessor2._FileToolsLoadFile(includeShaderUrl, function(fileContent) {
          options.includesShadersStore[includeFile] = fileContent;
          _this._ProcessIncludes(returnValue, options, callback);
        });
        return { value: void 0 };
      }
      match = regexShaderInclude.exec(sourceCode);
    };
    while (match != null) {
      var state_1 = _loop_1();
      if (typeof state_1 === "object")
        return state_1.value;
    }
    if (keepProcessing) {
      this._ProcessIncludes(returnValue.toString(), options, callback);
    } else {
      callback(returnValue);
    }
  };
  ShaderProcessor2._FileToolsLoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _WarnImport("FileTools");
  };
  return ShaderProcessor2;
}();
var ShaderStore = function() {
  function ShaderStore2() {
  }
  ShaderStore2.GetShadersRepository = function(shaderLanguage) {
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore2.ShadersRepository : ShaderStore2.ShadersRepositoryWGSL;
  };
  ShaderStore2.GetShadersStore = function(shaderLanguage) {
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore2.ShadersStore : ShaderStore2.ShadersStoreWGSL;
  };
  ShaderStore2.GetIncludesShadersStore = function(shaderLanguage) {
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore2.IncludesShadersStore : ShaderStore2.IncludesShadersStoreWGSL;
  };
  ShaderStore2.ShadersRepository = "src/Shaders/";
  ShaderStore2.ShadersStore = {};
  ShaderStore2.IncludesShadersStore = {};
  ShaderStore2.ShadersRepositoryWGSL = "src/ShadersWGSL/";
  ShaderStore2.ShadersStoreWGSL = {};
  ShaderStore2.IncludesShadersStoreWGSL = {};
  return ShaderStore2;
}();
var Effect = function() {
  function Effect2(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, engine, defines, fallbacks, onCompiled, onError, indexParameters, key, shaderLanguage) {
    if (samplers === void 0) {
      samplers = null;
    }
    if (defines === void 0) {
      defines = null;
    }
    if (fallbacks === void 0) {
      fallbacks = null;
    }
    if (onCompiled === void 0) {
      onCompiled = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (key === void 0) {
      key = "";
    }
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    var _this = this;
    var _a2, _b2, _c2;
    this.name = null;
    this.defines = "";
    this.onCompiled = null;
    this.onError = null;
    this.onBind = null;
    this.uniqueId = 0;
    this.onCompileObservable = new Observable();
    this.onErrorObservable = new Observable();
    this._onBindObservable = null;
    this._wasPreviouslyReady = false;
    this._isDisposed = false;
    this._bonesComputationForcedToCPU = false;
    this._uniformBuffersNames = {};
    this._multiTarget = false;
    this._samplers = {};
    this._isReady = false;
    this._compilationError = "";
    this._allFallbacksProcessed = false;
    this._uniforms = {};
    this._key = "";
    this._fallbacks = null;
    this._vertexSourceCodeOverride = "";
    this._fragmentSourceCodeOverride = "";
    this._transformFeedbackVaryings = null;
    this._pipelineContext = null;
    this._vertexSourceCode = "";
    this._fragmentSourceCode = "";
    this._rawVertexSourceCode = "";
    this._rawFragmentSourceCode = "";
    this.name = baseName;
    this._key = key;
    var processCodeAfterIncludes = void 0;
    var processFinalCode = null;
    if (attributesNamesOrOptions.attributes) {
      var options = attributesNamesOrOptions;
      this._engine = uniformsNamesOrEngine;
      this._attributesNames = options.attributes;
      this._uniformsNames = options.uniformsNames.concat(options.samplers);
      this._samplerList = options.samplers.slice();
      this.defines = options.defines;
      this.onError = options.onError;
      this.onCompiled = options.onCompiled;
      this._fallbacks = options.fallbacks;
      this._indexParameters = options.indexParameters;
      this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;
      this._multiTarget = !!options.multiTarget;
      this._shaderLanguage = (_a2 = options.shaderLanguage) !== null && _a2 !== void 0 ? _a2 : ShaderLanguage.GLSL;
      if (options.uniformBuffersNames) {
        this._uniformBuffersNamesList = options.uniformBuffersNames.slice();
        for (var i = 0; i < options.uniformBuffersNames.length; i++) {
          this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;
        }
      }
      processFinalCode = (_b2 = options.processFinalCode) !== null && _b2 !== void 0 ? _b2 : null;
      processCodeAfterIncludes = (_c2 = options.processCodeAfterIncludes) !== null && _c2 !== void 0 ? _c2 : void 0;
    } else {
      this._engine = engine;
      this.defines = defines == null ? "" : defines;
      this._uniformsNames = uniformsNamesOrEngine.concat(samplers);
      this._samplerList = samplers ? samplers.slice() : [];
      this._attributesNames = attributesNamesOrOptions;
      this._uniformBuffersNamesList = [];
      this._shaderLanguage = shaderLanguage;
      this.onError = onError;
      this.onCompiled = onCompiled;
      this._indexParameters = indexParameters;
      this._fallbacks = fallbacks;
    }
    this._attributeLocationByName = {};
    this.uniqueId = Effect2._UniqueIdSeed++;
    var vertexSource;
    var fragmentSource;
    var hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;
    if (baseName.vertexSource) {
      vertexSource = "source:" + baseName.vertexSource;
    } else if (baseName.vertexElement) {
      vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;
      if (!vertexSource) {
        vertexSource = baseName.vertexElement;
      }
    } else {
      vertexSource = baseName.vertex || baseName;
    }
    if (baseName.fragmentSource) {
      fragmentSource = "source:" + baseName.fragmentSource;
    } else if (baseName.fragmentElement) {
      fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;
      if (!fragmentSource) {
        fragmentSource = baseName.fragmentElement;
      }
    } else {
      fragmentSource = baseName.fragment || baseName;
    }
    this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
    var processorOptions = {
      defines: this.defines.split("\n"),
      indexParameters: this._indexParameters,
      isFragment: false,
      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
      processor: this._engine._getShaderProcessor(this._shaderLanguage),
      supportsUniformBuffers: this._engine.supportsUniformBuffers,
      shadersRepository: ShaderStore.GetShadersRepository(this._shaderLanguage),
      includesShadersStore: ShaderStore.GetIncludesShadersStore(this._shaderLanguage),
      version: (this._engine.version * 100).toString(),
      platformName: this._engine.shaderPlatformName,
      processingContext: this._processingContext,
      isNDCHalfZRange: this._engine.isNDCHalfZRange,
      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
      processCodeAfterIncludes
    };
    var shaderCodes = [void 0, void 0];
    var shadersLoaded = function() {
      if (shaderCodes[0] && shaderCodes[1]) {
        processorOptions.isFragment = true;
        var migratedVertexCode_1 = shaderCodes[0], fragmentCode = shaderCodes[1];
        ShaderProcessor.Process(fragmentCode, processorOptions, function(migratedFragmentCode) {
          if (processFinalCode) {
            migratedFragmentCode = processFinalCode("fragment", migratedFragmentCode);
          }
          var finalShaders = ShaderProcessor.Finalize(migratedVertexCode_1, migratedFragmentCode, processorOptions);
          _this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName);
        }, _this._engine);
      }
    };
    this._loadShader(vertexSource, "Vertex", "", function(vertexCode) {
      ShaderProcessor.Initialize(processorOptions);
      ShaderProcessor.Process(vertexCode, processorOptions, function(migratedVertexCode) {
        _this._rawVertexSourceCode = vertexCode;
        if (processFinalCode) {
          migratedVertexCode = processFinalCode("vertex", migratedVertexCode);
        }
        shaderCodes[0] = migratedVertexCode;
        shadersLoaded();
      }, _this._engine);
    });
    this._loadShader(fragmentSource, "Fragment", "Pixel", function(fragmentCode) {
      _this._rawFragmentSourceCode = fragmentCode;
      shaderCodes[1] = fragmentCode;
      shadersLoaded();
    });
  }
  Object.defineProperty(Effect2, "ShadersRepository", {
    get: function() {
      return ShaderStore.ShadersRepository;
    },
    set: function(repo) {
      ShaderStore.ShadersRepository = repo;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "onBindObservable", {
    get: function() {
      if (!this._onBindObservable) {
        this._onBindObservable = new Observable();
      }
      return this._onBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype._useFinalCode = function(migratedVertexCode, migratedFragmentCode, baseName) {
    if (baseName) {
      var vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;
      var fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;
      this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + vertex + "\n" + migratedVertexCode;
      this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + fragment + "\n" + migratedFragmentCode;
    } else {
      this._vertexSourceCode = migratedVertexCode;
      this._fragmentSourceCode = migratedFragmentCode;
    }
    this._prepareEffect();
  };
  Object.defineProperty(Effect2.prototype, "key", {
    get: function() {
      return this._key;
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype.isReady = function() {
    try {
      return this._isReadyInternal();
    } catch (_a2) {
      return false;
    }
  };
  Effect2.prototype._isReadyInternal = function() {
    if (this._isReady) {
      return true;
    }
    if (this._pipelineContext) {
      return this._pipelineContext.isReady;
    }
    return false;
  };
  Effect2.prototype.getEngine = function() {
    return this._engine;
  };
  Effect2.prototype.getPipelineContext = function() {
    return this._pipelineContext;
  };
  Effect2.prototype.getAttributesNames = function() {
    return this._attributesNames;
  };
  Effect2.prototype.getAttributeLocation = function(index) {
    return this._attributes[index];
  };
  Effect2.prototype.getAttributeLocationByName = function(name2) {
    return this._attributeLocationByName[name2];
  };
  Effect2.prototype.getAttributesCount = function() {
    return this._attributes.length;
  };
  Effect2.prototype.getUniformIndex = function(uniformName) {
    return this._uniformsNames.indexOf(uniformName);
  };
  Effect2.prototype.getUniform = function(uniformName) {
    return this._uniforms[uniformName];
  };
  Effect2.prototype.getSamplers = function() {
    return this._samplerList;
  };
  Effect2.prototype.getUniformNames = function() {
    return this._uniformsNames;
  };
  Effect2.prototype.getUniformBuffersNames = function() {
    return this._uniformBuffersNamesList;
  };
  Effect2.prototype.getIndexParameters = function() {
    return this._indexParameters;
  };
  Effect2.prototype.getCompilationError = function() {
    return this._compilationError;
  };
  Effect2.prototype.allFallbacksProcessed = function() {
    return this._allFallbacksProcessed;
  };
  Effect2.prototype.executeWhenCompiled = function(func) {
    var _this = this;
    if (this.isReady()) {
      func(this);
      return;
    }
    this.onCompileObservable.add(function(effect) {
      func(effect);
    });
    if (!this._pipelineContext || this._pipelineContext.isAsync) {
      setTimeout(function() {
        _this._checkIsReady(null);
      }, 16);
    }
  };
  Effect2.prototype._checkIsReady = function(previousPipelineContext) {
    var _this = this;
    try {
      if (this._isReadyInternal()) {
        return;
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
      return;
    }
    if (this._isDisposed) {
      return;
    }
    setTimeout(function() {
      _this._checkIsReady(previousPipelineContext);
    }, 16);
  };
  Effect2.prototype._loadShader = function(shader2, key, optionalKey, callback) {
    if (typeof HTMLElement !== "undefined") {
      if (shader2 instanceof HTMLElement) {
        var shaderCode = GetDOMTextContent(shader2);
        callback(shaderCode);
        return;
      }
    }
    if (shader2.substr(0, 7) === "source:") {
      callback(shader2.substr(7));
      return;
    }
    if (shader2.substr(0, 7) === "base64:") {
      var shaderBinary = window.atob(shader2.substr(7));
      callback(shaderBinary);
      return;
    }
    var shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);
    if (shaderStore[shader2 + key + "Shader"]) {
      callback(shaderStore[shader2 + key + "Shader"]);
      return;
    }
    if (optionalKey && shaderStore[shader2 + optionalKey + "Shader"]) {
      callback(shaderStore[shader2 + optionalKey + "Shader"]);
      return;
    }
    var shaderUrl;
    if (shader2[0] === "." || shader2[0] === "/" || shader2.indexOf("http") > -1) {
      shaderUrl = shader2;
    } else {
      shaderUrl = ShaderStore.GetShadersRepository(this._shaderLanguage) + shader2;
    }
    this._engine._loadFile(shaderUrl + "." + key.toLowerCase() + ".fx", callback);
  };
  Object.defineProperty(Effect2.prototype, "vertexSourceCode", {
    get: function() {
      var _a2, _b2;
      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (_b2 = (_a2 = this._pipelineContext) === null || _a2 === void 0 ? void 0 : _a2._getVertexShaderCode()) !== null && _b2 !== void 0 ? _b2 : this._vertexSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "fragmentSourceCode", {
    get: function() {
      var _a2, _b2;
      return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (_b2 = (_a2 = this._pipelineContext) === null || _a2 === void 0 ? void 0 : _a2._getFragmentShaderCode()) !== null && _b2 !== void 0 ? _b2 : this._fragmentSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "rawVertexSourceCode", {
    get: function() {
      return this._rawVertexSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Effect2.prototype, "rawFragmentSourceCode", {
    get: function() {
      return this._rawFragmentSourceCode;
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype._rebuildProgram = function(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
    var _this = this;
    this._isReady = false;
    this._vertexSourceCodeOverride = vertexSourceCode;
    this._fragmentSourceCodeOverride = fragmentSourceCode;
    this.onError = function(effect, error) {
      if (onError) {
        onError(error);
      }
    };
    this.onCompiled = function() {
      var scenes = _this.getEngine().scenes;
      if (scenes) {
        for (var i = 0; i < scenes.length; i++) {
          scenes[i].markAllMaterialsAsDirty(63);
        }
      }
      _this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);
    };
    this._fallbacks = null;
    this._prepareEffect();
  };
  Effect2.prototype._prepareEffect = function() {
    var _this = this;
    var attributesNames = this._attributesNames;
    var defines = this.defines;
    var previousPipelineContext = this._pipelineContext;
    this._isReady = false;
    try {
      var engine_1 = this._engine;
      this._pipelineContext = engine_1.createPipelineContext(this._processingContext);
      this._pipelineContext._name = this._key;
      var rebuildRebind = this._rebuildProgram.bind(this);
      if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {
        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, null, this._transformFeedbackVaryings, this._key);
      } else {
        engine_1._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, defines, this._transformFeedbackVaryings, this._key);
      }
      engine_1._executeWhenRenderingStateIsCompiled(this._pipelineContext, function() {
        _this._attributes = [];
        _this._pipelineContext._fillEffectInformation(_this, _this._uniformBuffersNames, _this._uniformsNames, _this._uniforms, _this._samplerList, _this._samplers, attributesNames, _this._attributes);
        if (attributesNames) {
          for (var i = 0; i < attributesNames.length; i++) {
            var name_1 = attributesNames[i];
            _this._attributeLocationByName[name_1] = _this._attributes[i];
          }
        }
        engine_1.bindSamplers(_this);
        _this._compilationError = "";
        _this._isReady = true;
        if (_this.onCompiled) {
          _this.onCompiled(_this);
        }
        _this.onCompileObservable.notifyObservers(_this);
        _this.onCompileObservable.clear();
        if (_this._fallbacks) {
          _this._fallbacks.unBindMesh();
        }
        if (previousPipelineContext) {
          _this.getEngine()._deletePipelineContext(previousPipelineContext);
        }
      });
      if (this._pipelineContext.isAsync) {
        this._checkIsReady(previousPipelineContext);
      }
    } catch (e) {
      this._processCompilationErrors(e, previousPipelineContext);
    }
  };
  Effect2.prototype._getShaderCodeAndErrorLine = function(code, error, isFragment) {
    var regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
    var errorLine = null;
    if (error && code) {
      var res = error.match(regexp);
      if (res && res.length === 2) {
        var lineNumber = parseInt(res[1]);
        var lines = code.split("\n", -1);
        if (lines.length >= lineNumber) {
          errorLine = "Offending line [".concat(lineNumber, "] in ").concat(isFragment ? "fragment" : "vertex", " code: ").concat(lines[lineNumber - 1]);
        }
      }
    }
    return [code, errorLine];
  };
  Effect2.prototype._processCompilationErrors = function(e, previousPipelineContext) {
    var _a2, _b2;
    var _c2, _d, _e;
    if (previousPipelineContext === void 0) {
      previousPipelineContext = null;
    }
    this._compilationError = e.message;
    var attributesNames = this._attributesNames;
    var fallbacks = this._fallbacks;
    Logger.Error("Unable to compile effect:");
    Logger.Error("Uniforms: " + this._uniformsNames.map(function(uniform) {
      return " " + uniform;
    }));
    Logger.Error("Attributes: " + attributesNames.map(function(attribute) {
      return " " + attribute;
    }));
    Logger.Error("Defines:\r\n" + this.defines);
    if (Effect2.LogShaderCodeOnCompilationError) {
      var lineErrorVertex = null, lineErrorFragment = null, code = null;
      if ((_c2 = this._pipelineContext) === null || _c2 === void 0 ? void 0 : _c2._getVertexShaderCode()) {
        _a2 = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false), code = _a2[0], lineErrorVertex = _a2[1];
        if (code) {
          Logger.Error("Vertex code:");
          Logger.Error(code);
        }
      }
      if ((_d = this._pipelineContext) === null || _d === void 0 ? void 0 : _d._getFragmentShaderCode()) {
        _b2 = this._getShaderCodeAndErrorLine((_e = this._pipelineContext) === null || _e === void 0 ? void 0 : _e._getFragmentShaderCode(), this._compilationError, true), code = _b2[0], lineErrorFragment = _b2[1];
        if (code) {
          Logger.Error("Fragment code:");
          Logger.Error(code);
        }
      }
      if (lineErrorVertex) {
        Logger.Error(lineErrorVertex);
      }
      if (lineErrorFragment) {
        Logger.Error(lineErrorFragment);
      }
    }
    Logger.Error("Error: " + this._compilationError);
    if (previousPipelineContext) {
      this._pipelineContext = previousPipelineContext;
      this._isReady = true;
      if (this.onError) {
        this.onError(this, this._compilationError);
      }
      this.onErrorObservable.notifyObservers(this);
    }
    if (fallbacks) {
      this._pipelineContext = null;
      if (fallbacks.hasMoreFallbacks) {
        this._allFallbacksProcessed = false;
        Logger.Error("Trying next fallback.");
        this.defines = fallbacks.reduce(this.defines, this);
        this._prepareEffect();
      } else {
        this._allFallbacksProcessed = true;
        if (this.onError) {
          this.onError(this, this._compilationError);
        }
        this.onErrorObservable.notifyObservers(this);
        this.onErrorObservable.clear();
        if (this._fallbacks) {
          this._fallbacks.unBindMesh();
        }
      }
    } else {
      this._allFallbacksProcessed = true;
    }
  };
  Object.defineProperty(Effect2.prototype, "isSupported", {
    get: function() {
      return this._compilationError === "";
    },
    enumerable: false,
    configurable: true
  });
  Effect2.prototype._bindTexture = function(channel, texture) {
    this._engine._bindTexture(this._samplers[channel], texture, channel);
  };
  Effect2.prototype.setTexture = function(channel, texture) {
    this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
  };
  Effect2.prototype.setDepthStencilTexture = function(channel, texture) {
    this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
  };
  Effect2.prototype.setTextureArray = function(channel, textures) {
    var exName = channel + "Ex";
    if (this._samplerList.indexOf(exName + "0") === -1) {
      var initialPos = this._samplerList.indexOf(channel);
      for (var index = 1; index < textures.length; index++) {
        var currentExName = exName + (index - 1).toString();
        this._samplerList.splice(initialPos + index, 0, currentExName);
      }
      var channelIndex = 0;
      for (var _i = 0, _a2 = this._samplerList; _i < _a2.length; _i++) {
        var key = _a2[_i];
        this._samplers[key] = channelIndex;
        channelIndex += 1;
      }
    }
    this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);
  };
  Effect2.prototype.setTextureFromPostProcess = function(channel, postProcess) {
    this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);
  };
  Effect2.prototype.setTextureFromPostProcessOutput = function(channel, postProcess) {
    this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);
  };
  Effect2.prototype.bindUniformBuffer = function(buffer, name2) {
    var bufferName = this._uniformBuffersNames[name2];
    if (bufferName === void 0 || Effect2._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache) {
      return;
    }
    Effect2._BaseCache[bufferName] = buffer;
    this._engine.bindUniformBufferBase(buffer, bufferName, name2);
  };
  Effect2.prototype.bindUniformBlock = function(blockName, index) {
    this._engine.bindUniformBlock(this._pipelineContext, blockName, index);
  };
  Effect2.prototype.setInt = function(uniformName, value) {
    this._pipelineContext.setInt(uniformName, value);
    return this;
  };
  Effect2.prototype.setInt2 = function(uniformName, x, y) {
    this._pipelineContext.setInt2(uniformName, x, y);
    return this;
  };
  Effect2.prototype.setInt3 = function(uniformName, x, y, z) {
    this._pipelineContext.setInt3(uniformName, x, y, z);
    return this;
  };
  Effect2.prototype.setInt4 = function(uniformName, x, y, z, w) {
    this._pipelineContext.setInt4(uniformName, x, y, z, w);
    return this;
  };
  Effect2.prototype.setIntArray = function(uniformName, array) {
    this._pipelineContext.setIntArray(uniformName, array);
    return this;
  };
  Effect2.prototype.setIntArray2 = function(uniformName, array) {
    this._pipelineContext.setIntArray2(uniformName, array);
    return this;
  };
  Effect2.prototype.setIntArray3 = function(uniformName, array) {
    this._pipelineContext.setIntArray3(uniformName, array);
    return this;
  };
  Effect2.prototype.setIntArray4 = function(uniformName, array) {
    this._pipelineContext.setIntArray4(uniformName, array);
    return this;
  };
  Effect2.prototype.setFloatArray = function(uniformName, array) {
    this._pipelineContext.setArray(uniformName, array);
    return this;
  };
  Effect2.prototype.setFloatArray2 = function(uniformName, array) {
    this._pipelineContext.setArray2(uniformName, array);
    return this;
  };
  Effect2.prototype.setFloatArray3 = function(uniformName, array) {
    this._pipelineContext.setArray3(uniformName, array);
    return this;
  };
  Effect2.prototype.setFloatArray4 = function(uniformName, array) {
    this._pipelineContext.setArray4(uniformName, array);
    return this;
  };
  Effect2.prototype.setArray = function(uniformName, array) {
    this._pipelineContext.setArray(uniformName, array);
    return this;
  };
  Effect2.prototype.setArray2 = function(uniformName, array) {
    this._pipelineContext.setArray2(uniformName, array);
    return this;
  };
  Effect2.prototype.setArray3 = function(uniformName, array) {
    this._pipelineContext.setArray3(uniformName, array);
    return this;
  };
  Effect2.prototype.setArray4 = function(uniformName, array) {
    this._pipelineContext.setArray4(uniformName, array);
    return this;
  };
  Effect2.prototype.setMatrices = function(uniformName, matrices) {
    this._pipelineContext.setMatrices(uniformName, matrices);
    return this;
  };
  Effect2.prototype.setMatrix = function(uniformName, matrix) {
    this._pipelineContext.setMatrix(uniformName, matrix);
    return this;
  };
  Effect2.prototype.setMatrix3x3 = function(uniformName, matrix) {
    this._pipelineContext.setMatrix3x3(uniformName, matrix);
    return this;
  };
  Effect2.prototype.setMatrix2x2 = function(uniformName, matrix) {
    this._pipelineContext.setMatrix2x2(uniformName, matrix);
    return this;
  };
  Effect2.prototype.setFloat = function(uniformName, value) {
    this._pipelineContext.setFloat(uniformName, value);
    return this;
  };
  Effect2.prototype.setBool = function(uniformName, bool) {
    this._pipelineContext.setInt(uniformName, bool ? 1 : 0);
    return this;
  };
  Effect2.prototype.setVector2 = function(uniformName, vector2) {
    this._pipelineContext.setVector2(uniformName, vector2);
    return this;
  };
  Effect2.prototype.setFloat2 = function(uniformName, x, y) {
    this._pipelineContext.setFloat2(uniformName, x, y);
    return this;
  };
  Effect2.prototype.setVector3 = function(uniformName, vector3) {
    this._pipelineContext.setVector3(uniformName, vector3);
    return this;
  };
  Effect2.prototype.setFloat3 = function(uniformName, x, y, z) {
    this._pipelineContext.setFloat3(uniformName, x, y, z);
    return this;
  };
  Effect2.prototype.setVector4 = function(uniformName, vector4) {
    this._pipelineContext.setVector4(uniformName, vector4);
    return this;
  };
  Effect2.prototype.setQuaternion = function(uniformName, quaternion) {
    this._pipelineContext.setQuaternion(uniformName, quaternion);
    return this;
  };
  Effect2.prototype.setFloat4 = function(uniformName, x, y, z, w) {
    this._pipelineContext.setFloat4(uniformName, x, y, z, w);
    return this;
  };
  Effect2.prototype.setColor3 = function(uniformName, color3) {
    this._pipelineContext.setColor3(uniformName, color3);
    return this;
  };
  Effect2.prototype.setColor4 = function(uniformName, color3, alpha) {
    this._pipelineContext.setColor4(uniformName, color3, alpha);
    return this;
  };
  Effect2.prototype.setDirectColor4 = function(uniformName, color4) {
    this._pipelineContext.setDirectColor4(uniformName, color4);
    return this;
  };
  Effect2.prototype.dispose = function() {
    if (this._pipelineContext) {
      this._pipelineContext.dispose();
    }
    this._engine._releaseEffect(this);
    this._isDisposed = true;
  };
  Effect2.RegisterShader = function(name2, pixelShader, vertexShader, shaderLanguage) {
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    if (pixelShader) {
      ShaderStore.GetShadersStore(shaderLanguage)["".concat(name2, "PixelShader")] = pixelShader;
    }
    if (vertexShader) {
      ShaderStore.GetShadersStore(shaderLanguage)["".concat(name2, "VertexShader")] = vertexShader;
    }
  };
  Effect2.ResetCache = function() {
    Effect2._BaseCache = {};
  };
  Effect2.LogShaderCodeOnCompilationError = true;
  Effect2._UniqueIdSeed = 0;
  Effect2._BaseCache = {};
  Effect2.ShadersStore = ShaderStore.ShadersStore;
  Effect2.IncludesShadersStore = ShaderStore.IncludesShadersStore;
  return Effect2;
}();
var DepthCullingState = function() {
  function DepthCullingState2(reset) {
    if (reset === void 0) {
      reset = true;
    }
    this._isDepthTestDirty = false;
    this._isDepthMaskDirty = false;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = false;
    this._isFrontFaceDirty = false;
    if (reset) {
      this.reset();
    }
  }
  Object.defineProperty(DepthCullingState2.prototype, "isDirty", {
    get: function() {
      return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "zOffset", {
    get: function() {
      return this._zOffset;
    },
    set: function(value) {
      if (this._zOffset === value) {
        return;
      }
      this._zOffset = value;
      this._isZOffsetDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "zOffsetUnits", {
    get: function() {
      return this._zOffsetUnits;
    },
    set: function(value) {
      if (this._zOffsetUnits === value) {
        return;
      }
      this._zOffsetUnits = value;
      this._isZOffsetDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "cullFace", {
    get: function() {
      return this._cullFace;
    },
    set: function(value) {
      if (this._cullFace === value) {
        return;
      }
      this._cullFace = value;
      this._isCullFaceDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "cull", {
    get: function() {
      return this._cull;
    },
    set: function(value) {
      if (this._cull === value) {
        return;
      }
      this._cull = value;
      this._isCullDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "depthFunc", {
    get: function() {
      return this._depthFunc;
    },
    set: function(value) {
      if (this._depthFunc === value) {
        return;
      }
      this._depthFunc = value;
      this._isDepthFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "depthMask", {
    get: function() {
      return this._depthMask;
    },
    set: function(value) {
      if (this._depthMask === value) {
        return;
      }
      this._depthMask = value;
      this._isDepthMaskDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "depthTest", {
    get: function() {
      return this._depthTest;
    },
    set: function(value) {
      if (this._depthTest === value) {
        return;
      }
      this._depthTest = value;
      this._isDepthTestDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(DepthCullingState2.prototype, "frontFace", {
    get: function() {
      return this._frontFace;
    },
    set: function(value) {
      if (this._frontFace === value) {
        return;
      }
      this._frontFace = value;
      this._isFrontFaceDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  DepthCullingState2.prototype.reset = function() {
    this._depthMask = true;
    this._depthTest = true;
    this._depthFunc = null;
    this._cullFace = null;
    this._cull = null;
    this._zOffset = 0;
    this._zOffsetUnits = 0;
    this._frontFace = null;
    this._isDepthTestDirty = true;
    this._isDepthMaskDirty = true;
    this._isDepthFuncDirty = false;
    this._isCullFaceDirty = false;
    this._isCullDirty = false;
    this._isZOffsetDirty = true;
    this._isFrontFaceDirty = false;
  };
  DepthCullingState2.prototype.apply = function(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isCullDirty) {
      if (this.cull) {
        gl.enable(gl.CULL_FACE);
      } else {
        gl.disable(gl.CULL_FACE);
      }
      this._isCullDirty = false;
    }
    if (this._isCullFaceDirty) {
      gl.cullFace(this.cullFace);
      this._isCullFaceDirty = false;
    }
    if (this._isDepthMaskDirty) {
      gl.depthMask(this.depthMask);
      this._isDepthMaskDirty = false;
    }
    if (this._isDepthTestDirty) {
      if (this.depthTest) {
        gl.enable(gl.DEPTH_TEST);
      } else {
        gl.disable(gl.DEPTH_TEST);
      }
      this._isDepthTestDirty = false;
    }
    if (this._isDepthFuncDirty) {
      gl.depthFunc(this.depthFunc);
      this._isDepthFuncDirty = false;
    }
    if (this._isZOffsetDirty) {
      if (this.zOffset || this.zOffsetUnits) {
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.polygonOffset(this.zOffset, this.zOffsetUnits);
      } else {
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
      this._isZOffsetDirty = false;
    }
    if (this._isFrontFaceDirty) {
      gl.frontFace(this.frontFace);
      this._isFrontFaceDirty = false;
    }
  };
  return DepthCullingState2;
}();
var StencilState = function() {
  function StencilState2() {
    this.reset();
  }
  StencilState2.prototype.reset = function() {
    this.enabled = false;
    this.mask = 255;
    this.func = StencilState2.ALWAYS;
    this.funcRef = 1;
    this.funcMask = 255;
    this.opStencilFail = StencilState2.KEEP;
    this.opDepthFail = StencilState2.KEEP;
    this.opStencilDepthPass = StencilState2.REPLACE;
  };
  Object.defineProperty(StencilState2.prototype, "stencilFunc", {
    get: function() {
      return this.func;
    },
    set: function(value) {
      this.func = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilFuncRef", {
    get: function() {
      return this.funcRef;
    },
    set: function(value) {
      this.funcRef = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilFuncMask", {
    get: function() {
      return this.funcMask;
    },
    set: function(value) {
      this.funcMask = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilOpStencilFail", {
    get: function() {
      return this.opStencilFail;
    },
    set: function(value) {
      this.opStencilFail = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilOpDepthFail", {
    get: function() {
      return this.opDepthFail;
    },
    set: function(value) {
      this.opDepthFail = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilOpStencilDepthPass", {
    get: function() {
      return this.opStencilDepthPass;
    },
    set: function(value) {
      this.opStencilDepthPass = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilMask", {
    get: function() {
      return this.mask;
    },
    set: function(value) {
      this.mask = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilState2.prototype, "stencilTest", {
    get: function() {
      return this.enabled;
    },
    set: function(value) {
      this.enabled = value;
    },
    enumerable: false,
    configurable: true
  });
  StencilState2.ALWAYS = 519;
  StencilState2.KEEP = 7680;
  StencilState2.REPLACE = 7681;
  return StencilState2;
}();
var AlphaState = function() {
  function AlphaState2() {
    this._blendFunctionParameters = new Array(4);
    this._blendEquationParameters = new Array(2);
    this._blendConstants = new Array(4);
    this._isBlendConstantsDirty = false;
    this._alphaBlend = false;
    this._isAlphaBlendDirty = false;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this.reset();
  }
  Object.defineProperty(AlphaState2.prototype, "isDirty", {
    get: function() {
      return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AlphaState2.prototype, "alphaBlend", {
    get: function() {
      return this._alphaBlend;
    },
    set: function(value) {
      if (this._alphaBlend === value) {
        return;
      }
      this._alphaBlend = value;
      this._isAlphaBlendDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  AlphaState2.prototype.setAlphaBlendConstants = function(r, g, b, a) {
    if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {
      return;
    }
    this._blendConstants[0] = r;
    this._blendConstants[1] = g;
    this._blendConstants[2] = b;
    this._blendConstants[3] = a;
    this._isBlendConstantsDirty = true;
  };
  AlphaState2.prototype.setAlphaBlendFunctionParameters = function(value0, value1, value2, value3) {
    if (this._blendFunctionParameters[0] === value0 && this._blendFunctionParameters[1] === value1 && this._blendFunctionParameters[2] === value2 && this._blendFunctionParameters[3] === value3) {
      return;
    }
    this._blendFunctionParameters[0] = value0;
    this._blendFunctionParameters[1] = value1;
    this._blendFunctionParameters[2] = value2;
    this._blendFunctionParameters[3] = value3;
    this._isBlendFunctionParametersDirty = true;
  };
  AlphaState2.prototype.setAlphaEquationParameters = function(rgb, alpha) {
    if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {
      return;
    }
    this._blendEquationParameters[0] = rgb;
    this._blendEquationParameters[1] = alpha;
    this._isBlendEquationParametersDirty = true;
  };
  AlphaState2.prototype.reset = function() {
    this._alphaBlend = false;
    this._blendFunctionParameters[0] = null;
    this._blendFunctionParameters[1] = null;
    this._blendFunctionParameters[2] = null;
    this._blendFunctionParameters[3] = null;
    this._blendEquationParameters[0] = null;
    this._blendEquationParameters[1] = null;
    this._blendConstants[0] = null;
    this._blendConstants[1] = null;
    this._blendConstants[2] = null;
    this._blendConstants[3] = null;
    this._isAlphaBlendDirty = true;
    this._isBlendFunctionParametersDirty = false;
    this._isBlendEquationParametersDirty = false;
    this._isBlendConstantsDirty = false;
  };
  AlphaState2.prototype.apply = function(gl) {
    if (!this.isDirty) {
      return;
    }
    if (this._isAlphaBlendDirty) {
      if (this._alphaBlend) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      this._isAlphaBlendDirty = false;
    }
    if (this._isBlendFunctionParametersDirty) {
      gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);
      this._isBlendFunctionParametersDirty = false;
    }
    if (this._isBlendEquationParametersDirty) {
      gl.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]);
      this._isBlendEquationParametersDirty = false;
    }
    if (this._isBlendConstantsDirty) {
      gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);
      this._isBlendConstantsDirty = false;
    }
  };
  return AlphaState2;
}();
var TextureSampler = function() {
  function TextureSampler2() {
    this.samplingMode = -1;
    this._useMipMaps = true;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedWrapR = null;
    this._cachedAnisotropicFilteringLevel = null;
    this._comparisonFunction = 0;
  }
  Object.defineProperty(TextureSampler2.prototype, "wrapU", {
    get: function() {
      return this._cachedWrapU;
    },
    set: function(value) {
      this._cachedWrapU = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "wrapV", {
    get: function() {
      return this._cachedWrapV;
    },
    set: function(value) {
      this._cachedWrapV = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "wrapR", {
    get: function() {
      return this._cachedWrapR;
    },
    set: function(value) {
      this._cachedWrapR = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "anisotropicFilteringLevel", {
    get: function() {
      return this._cachedAnisotropicFilteringLevel;
    },
    set: function(value) {
      this._cachedAnisotropicFilteringLevel = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "comparisonFunction", {
    get: function() {
      return this._comparisonFunction;
    },
    set: function(value) {
      this._comparisonFunction = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TextureSampler2.prototype, "useMipMaps", {
    get: function() {
      return this._useMipMaps;
    },
    set: function(value) {
      this._useMipMaps = value;
    },
    enumerable: false,
    configurable: true
  });
  TextureSampler2.prototype.setParameters = function(wrapU, wrapV, wrapR, anisotropicFilteringLevel, samplingMode, comparisonFunction) {
    if (wrapU === void 0) {
      wrapU = 1;
    }
    if (wrapV === void 0) {
      wrapV = 1;
    }
    if (wrapR === void 0) {
      wrapR = 1;
    }
    if (anisotropicFilteringLevel === void 0) {
      anisotropicFilteringLevel = 1;
    }
    if (samplingMode === void 0) {
      samplingMode = 2;
    }
    if (comparisonFunction === void 0) {
      comparisonFunction = 0;
    }
    this._cachedWrapU = wrapU;
    this._cachedWrapV = wrapV;
    this._cachedWrapR = wrapR;
    this._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
    this.samplingMode = samplingMode;
    this._comparisonFunction = comparisonFunction;
    return this;
  };
  TextureSampler2.prototype.compareSampler = function(other) {
    return this._cachedWrapU === other._cachedWrapU && this._cachedWrapV === other._cachedWrapV && this._cachedWrapR === other._cachedWrapR && this._cachedAnisotropicFilteringLevel === other._cachedAnisotropicFilteringLevel && this.samplingMode === other.samplingMode && this._comparisonFunction === other._comparisonFunction && this._useMipMaps === other._useMipMaps;
  };
  return TextureSampler2;
}();
var InternalTextureSource;
(function(InternalTextureSource2) {
  InternalTextureSource2[InternalTextureSource2["Unknown"] = 0] = "Unknown";
  InternalTextureSource2[InternalTextureSource2["Url"] = 1] = "Url";
  InternalTextureSource2[InternalTextureSource2["Temp"] = 2] = "Temp";
  InternalTextureSource2[InternalTextureSource2["Raw"] = 3] = "Raw";
  InternalTextureSource2[InternalTextureSource2["Dynamic"] = 4] = "Dynamic";
  InternalTextureSource2[InternalTextureSource2["RenderTarget"] = 5] = "RenderTarget";
  InternalTextureSource2[InternalTextureSource2["MultiRenderTarget"] = 6] = "MultiRenderTarget";
  InternalTextureSource2[InternalTextureSource2["Cube"] = 7] = "Cube";
  InternalTextureSource2[InternalTextureSource2["CubeRaw"] = 8] = "CubeRaw";
  InternalTextureSource2[InternalTextureSource2["CubePrefiltered"] = 9] = "CubePrefiltered";
  InternalTextureSource2[InternalTextureSource2["Raw3D"] = 10] = "Raw3D";
  InternalTextureSource2[InternalTextureSource2["Raw2DArray"] = 11] = "Raw2DArray";
  InternalTextureSource2[InternalTextureSource2["DepthStencil"] = 12] = "DepthStencil";
  InternalTextureSource2[InternalTextureSource2["CubeRawRGBD"] = 13] = "CubeRawRGBD";
  InternalTextureSource2[InternalTextureSource2["Depth"] = 14] = "Depth";
})(InternalTextureSource || (InternalTextureSource = {}));
var InternalTexture = function(_super) {
  __extends(InternalTexture2, _super);
  function InternalTexture2(engine, source, delayAllocation) {
    if (delayAllocation === void 0) {
      delayAllocation = false;
    }
    var _this = _super.call(this) || this;
    _this.isReady = false;
    _this.isCube = false;
    _this.is3D = false;
    _this.is2DArray = false;
    _this.isMultiview = false;
    _this.url = "";
    _this.generateMipMaps = false;
    _this.samples = 0;
    _this.type = -1;
    _this.format = -1;
    _this.onLoadedObservable = new Observable();
    _this.onErrorObservable = new Observable();
    _this.onRebuildCallback = null;
    _this.width = 0;
    _this.height = 0;
    _this.depth = 0;
    _this.baseWidth = 0;
    _this.baseHeight = 0;
    _this.baseDepth = 0;
    _this.invertY = false;
    _this._invertVScale = false;
    _this._associatedChannel = -1;
    _this._source = InternalTextureSource.Unknown;
    _this._buffer = null;
    _this._bufferView = null;
    _this._bufferViewArray = null;
    _this._bufferViewArrayArray = null;
    _this._size = 0;
    _this._extension = "";
    _this._files = null;
    _this._workingCanvas = null;
    _this._workingContext = null;
    _this._cachedCoordinatesMode = null;
    _this._isDisabled = false;
    _this._compression = null;
    _this._sphericalPolynomial = null;
    _this._sphericalPolynomialPromise = null;
    _this._sphericalPolynomialComputed = false;
    _this._lodGenerationScale = 0;
    _this._lodGenerationOffset = 0;
    _this._useSRGBBuffer = false;
    _this._lodTextureHigh = null;
    _this._lodTextureMid = null;
    _this._lodTextureLow = null;
    _this._isRGBD = false;
    _this._linearSpecularLOD = false;
    _this._irradianceTexture = null;
    _this._hardwareTexture = null;
    _this._maxLodLevel = null;
    _this._references = 1;
    _this._gammaSpace = null;
    _this._engine = engine;
    _this._source = source;
    _this._uniqueId = InternalTexture2._Counter++;
    if (!delayAllocation) {
      _this._hardwareTexture = engine._createHardwareTexture();
    }
    return _this;
  }
  Object.defineProperty(InternalTexture2.prototype, "useMipMaps", {
    get: function() {
      return this.generateMipMaps;
    },
    set: function(value) {
      this.generateMipMaps = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InternalTexture2.prototype, "uniqueId", {
    get: function() {
      return this._uniqueId;
    },
    enumerable: false,
    configurable: true
  });
  InternalTexture2.prototype.getEngine = function() {
    return this._engine;
  };
  Object.defineProperty(InternalTexture2.prototype, "source", {
    get: function() {
      return this._source;
    },
    enumerable: false,
    configurable: true
  });
  InternalTexture2.prototype.incrementReferences = function() {
    this._references++;
  };
  InternalTexture2.prototype.updateSize = function(width, height, depth) {
    if (depth === void 0) {
      depth = 1;
    }
    this._engine.updateTextureDimensions(this, width, height, depth);
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.baseWidth = width;
    this.baseHeight = height;
    this.baseDepth = depth;
    this._size = width * height * depth;
  };
  InternalTexture2.prototype._rebuild = function() {
    var _this = this;
    var _a2;
    this.isReady = false;
    this._cachedCoordinatesMode = null;
    this._cachedWrapU = null;
    this._cachedWrapV = null;
    this._cachedWrapR = null;
    this._cachedAnisotropicFilteringLevel = null;
    if (this.onRebuildCallback) {
      var data_1 = this.onRebuildCallback(this);
      var swapAndSetIsReady = function(proxyInternalTexture) {
        proxyInternalTexture._swapAndDie(_this, false);
        _this.isReady = data_1.isReady;
      };
      if (data_1.isAsync) {
        data_1.proxy.then(swapAndSetIsReady);
      } else {
        swapAndSetIsReady(data_1.proxy);
      }
      return;
    }
    var proxy;
    switch (this.source) {
      case InternalTextureSource.Temp:
        break;
      case InternalTextureSource.Url:
        proxy = this._engine.createTexture((_a2 = this._originalUrl) !== null && _a2 !== void 0 ? _a2 : this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, function() {
          proxy._swapAndDie(_this, false);
          _this.isReady = true;
        }, null, this._buffer, void 0, this.format, this._extension, void 0, void 0, void 0, this._useSRGBBuffer);
        return;
      case InternalTextureSource.Raw:
        proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, void 0, this._useSRGBBuffer);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Raw3D:
        proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Raw2DArray:
        proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.Dynamic:
        proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);
        proxy._swapAndDie(this, false);
        this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, void 0, void 0, true);
        break;
      case InternalTextureSource.Cube:
        proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, function() {
          proxy._swapAndDie(_this, false);
          _this.isReady = true;
        }, null, this.format, this._extension, false, 0, 0, null, void 0, this._useSRGBBuffer);
        return;
      case InternalTextureSource.CubeRaw:
        proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
        proxy._swapAndDie(this, false);
        this.isReady = true;
        break;
      case InternalTextureSource.CubeRawRGBD:
        return;
      case InternalTextureSource.CubePrefiltered:
        proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, function(proxy2) {
          if (proxy2) {
            proxy2._swapAndDie(_this, false);
          }
          _this.isReady = true;
        }, null, this.format, this._extension);
        proxy._sphericalPolynomial = this._sphericalPolynomial;
        return;
    }
  };
  InternalTexture2.prototype._swapAndDie = function(target2, swapAll) {
    var _a2;
    if (swapAll === void 0) {
      swapAll = true;
    }
    (_a2 = this._hardwareTexture) === null || _a2 === void 0 ? void 0 : _a2.setUsage(target2._source, this.generateMipMaps, this.isCube, this.width, this.height);
    target2._hardwareTexture = this._hardwareTexture;
    if (swapAll) {
      target2._isRGBD = this._isRGBD;
    }
    if (this._lodTextureHigh) {
      if (target2._lodTextureHigh) {
        target2._lodTextureHigh.dispose();
      }
      target2._lodTextureHigh = this._lodTextureHigh;
    }
    if (this._lodTextureMid) {
      if (target2._lodTextureMid) {
        target2._lodTextureMid.dispose();
      }
      target2._lodTextureMid = this._lodTextureMid;
    }
    if (this._lodTextureLow) {
      if (target2._lodTextureLow) {
        target2._lodTextureLow.dispose();
      }
      target2._lodTextureLow = this._lodTextureLow;
    }
    if (this._irradianceTexture) {
      if (target2._irradianceTexture) {
        target2._irradianceTexture.dispose();
      }
      target2._irradianceTexture = this._irradianceTexture;
    }
    var cache = this._engine.getLoadedTexturesCache();
    var index = cache.indexOf(this);
    if (index !== -1) {
      cache.splice(index, 1);
    }
    index = cache.indexOf(target2);
    if (index === -1) {
      cache.push(target2);
    }
  };
  InternalTexture2.prototype.dispose = function() {
    this._references--;
    this.onLoadedObservable.clear();
    this.onErrorObservable.clear();
    if (this._references === 0) {
      this._engine._releaseTexture(this);
      this._hardwareTexture = null;
    }
  };
  InternalTexture2._Counter = 0;
  return InternalTexture2;
}(TextureSampler);
var WebGLShaderProcessor = function() {
  function WebGLShaderProcessor2() {
    this.shaderLanguage = ShaderLanguage.GLSL;
  }
  WebGLShaderProcessor2.prototype.postProcessor = function(code, defines, isFragment, processingContext, engine) {
    if (!engine.getCaps().drawBuffersExtension) {
      var regex = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
      code = code.replace(regex, "");
    }
    return code;
  };
  return WebGLShaderProcessor2;
}();
var WebGL2ShaderProcessor = function() {
  function WebGL2ShaderProcessor2() {
    this.shaderLanguage = ShaderLanguage.GLSL;
  }
  WebGL2ShaderProcessor2.prototype.attributeProcessor = function(attribute) {
    return attribute.replace("attribute", "in");
  };
  WebGL2ShaderProcessor2.prototype.varyingProcessor = function(varying, isFragment) {
    return varying.replace("varying", isFragment ? "in" : "out");
  };
  WebGL2ShaderProcessor2.prototype.postProcessor = function(code, defines, isFragment) {
    var hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
    var regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    code = code.replace(regex, "");
    code = code.replace(/texture2D\s*\(/g, "texture(");
    if (isFragment) {
      code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
      code = code.replace(/textureCube\s*\(/g, "texture(");
      code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
      code = code.replace(/gl_FragColor/g, "glFragColor");
      code = code.replace(/gl_FragData/g, "glFragData");
      code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension ? "" : "out vec4 glFragColor;\n") + "void main(");
    } else {
      var hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
      if (hasMultiviewExtension) {
        return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
      }
    }
    return code;
  };
  return WebGL2ShaderProcessor2;
}();
var DataBuffer = function() {
  function DataBuffer2() {
    this.references = 0;
    this.capacity = 0;
    this.is32Bits = false;
    this.uniqueId = DataBuffer2._Counter++;
  }
  Object.defineProperty(DataBuffer2.prototype, "underlyingResource", {
    get: function() {
      return null;
    },
    enumerable: false,
    configurable: true
  });
  DataBuffer2._Counter = 0;
  return DataBuffer2;
}();
var WebGLDataBuffer = function(_super) {
  __extends(WebGLDataBuffer2, _super);
  function WebGLDataBuffer2(resource) {
    var _this = _super.call(this) || this;
    _this._buffer = resource;
    return _this;
  }
  Object.defineProperty(WebGLDataBuffer2.prototype, "underlyingResource", {
    get: function() {
      return this._buffer;
    },
    enumerable: false,
    configurable: true
  });
  return WebGLDataBuffer2;
}(DataBuffer);
var WebGLPipelineContext = function() {
  function WebGLPipelineContext2() {
    this._valueCache = {};
    this.vertexCompilationError = null;
    this.fragmentCompilationError = null;
    this.programLinkError = null;
    this.programValidationError = null;
  }
  Object.defineProperty(WebGLPipelineContext2.prototype, "isAsync", {
    get: function() {
      return this.isParallelCompiled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(WebGLPipelineContext2.prototype, "isReady", {
    get: function() {
      if (this.program) {
        if (this.isParallelCompiled) {
          return this.engine._isRenderingStateCompiled(this);
        }
        return true;
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  WebGLPipelineContext2.prototype._handlesSpectorRebuildCallback = function(onCompiled) {
    if (onCompiled && this.program) {
      onCompiled(this.program);
    }
  };
  WebGLPipelineContext2.prototype._fillEffectInformation = function(effect, uniformBuffersNames, uniformsNames, uniforms, samplerList, samplers, attributesNames, attributes) {
    var engine = this.engine;
    if (engine.supportsUniformBuffers) {
      for (var name_1 in uniformBuffersNames) {
        effect.bindUniformBlock(name_1, uniformBuffersNames[name_1]);
      }
    }
    var effectAvailableUniforms = this.engine.getUniforms(this, uniformsNames);
    effectAvailableUniforms.forEach(function(uniform, index2) {
      uniforms[uniformsNames[index2]] = uniform;
    });
    this._uniforms = uniforms;
    var index;
    for (index = 0; index < samplerList.length; index++) {
      var sampler = effect.getUniform(samplerList[index]);
      if (sampler == null) {
        samplerList.splice(index, 1);
        index--;
      }
    }
    samplerList.forEach(function(name2, index2) {
      samplers[name2] = index2;
    });
    for (var _i = 0, _a2 = engine.getAttributes(this, attributesNames); _i < _a2.length; _i++) {
      var attr = _a2[_i];
      attributes.push(attr);
    }
  };
  WebGLPipelineContext2.prototype.dispose = function() {
    this._uniforms = {};
  };
  WebGLPipelineContext2.prototype._cacheMatrix = function(uniformName, matrix) {
    var cache = this._valueCache[uniformName];
    var flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[uniformName] = flag;
    return true;
  };
  WebGLPipelineContext2.prototype._cacheFloat2 = function(uniformName, x, y) {
    var cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 2) {
      cache = [x, y];
      this._valueCache[uniformName] = cache;
      return true;
    }
    var changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    return changed;
  };
  WebGLPipelineContext2.prototype._cacheFloat3 = function(uniformName, x, y, z) {
    var cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 3) {
      cache = [x, y, z];
      this._valueCache[uniformName] = cache;
      return true;
    }
    var changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    return changed;
  };
  WebGLPipelineContext2.prototype._cacheFloat4 = function(uniformName, x, y, z, w) {
    var cache = this._valueCache[uniformName];
    if (!cache || cache.length !== 4) {
      cache = [x, y, z, w];
      this._valueCache[uniformName] = cache;
      return true;
    }
    var changed = false;
    if (cache[0] !== x) {
      cache[0] = x;
      changed = true;
    }
    if (cache[1] !== y) {
      cache[1] = y;
      changed = true;
    }
    if (cache[2] !== z) {
      cache[2] = z;
      changed = true;
    }
    if (cache[3] !== w) {
      cache[3] = w;
      changed = true;
    }
    return changed;
  };
  WebGLPipelineContext2.prototype.setInt = function(uniformName, value) {
    var cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return;
    }
    if (this.engine.setInt(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
  };
  WebGLPipelineContext2.prototype.setInt2 = function(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this.engine.setInt2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setInt3 = function(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this.engine.setInt3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setInt4 = function(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this.engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setIntArray = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setIntArray2 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray2(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setIntArray3 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray3(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setIntArray4 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setIntArray4(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setArray = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setArray2 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray2(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setArray3 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray3(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setArray4 = function(uniformName, array) {
    this._valueCache[uniformName] = null;
    this.engine.setArray4(this._uniforms[uniformName], array);
  };
  WebGLPipelineContext2.prototype.setMatrices = function(uniformName, matrices) {
    if (!matrices) {
      return;
    }
    this._valueCache[uniformName] = null;
    this.engine.setMatrices(this._uniforms[uniformName], matrices);
  };
  WebGLPipelineContext2.prototype.setMatrix = function(uniformName, matrix) {
    if (this._cacheMatrix(uniformName, matrix)) {
      if (!this.engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setMatrix3x3 = function(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this.engine.setMatrix3x3(this._uniforms[uniformName], matrix);
  };
  WebGLPipelineContext2.prototype.setMatrix2x2 = function(uniformName, matrix) {
    this._valueCache[uniformName] = null;
    this.engine.setMatrix2x2(this._uniforms[uniformName], matrix);
  };
  WebGLPipelineContext2.prototype.setFloat = function(uniformName, value) {
    var cache = this._valueCache[uniformName];
    if (cache !== void 0 && cache === value) {
      return;
    }
    if (this.engine.setFloat(this._uniforms[uniformName], value)) {
      this._valueCache[uniformName] = value;
    }
  };
  WebGLPipelineContext2.prototype.setVector2 = function(uniformName, vector2) {
    if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {
      if (!this.engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setFloat2 = function(uniformName, x, y) {
    if (this._cacheFloat2(uniformName, x, y)) {
      if (!this.engine.setFloat2(this._uniforms[uniformName], x, y)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setVector3 = function(uniformName, vector3) {
    if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {
      if (!this.engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setFloat3 = function(uniformName, x, y, z) {
    if (this._cacheFloat3(uniformName, x, y, z)) {
      if (!this.engine.setFloat3(this._uniforms[uniformName], x, y, z)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setVector4 = function(uniformName, vector4) {
    if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setQuaternion = function(uniformName, quaternion) {
    if (this._cacheFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setFloat4 = function(uniformName, x, y, z, w) {
    if (this._cacheFloat4(uniformName, x, y, z, w)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setColor3 = function(uniformName, color3) {
    if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {
      if (!this.engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setColor4 = function(uniformName, color3, alpha) {
    if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype.setDirectColor4 = function(uniformName, color4) {
    if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {
      if (!this.engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {
        this._valueCache[uniformName] = null;
      }
    }
  };
  WebGLPipelineContext2.prototype._getVertexShaderCode = function() {
    return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
  };
  WebGLPipelineContext2.prototype._getFragmentShaderCode = function() {
    return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
  };
  return WebGLPipelineContext2;
}();
var PerformanceConfigurator = function() {
  function PerformanceConfigurator2() {
  }
  PerformanceConfigurator2.SetMatrixPrecision = function(use64bits) {
    PerformanceConfigurator2.MatrixTrackPrecisionChange = false;
    if (use64bits && !PerformanceConfigurator2.MatrixUse64Bits) {
      if (PerformanceConfigurator2.MatrixTrackedMatrices) {
        for (var m = 0; m < PerformanceConfigurator2.MatrixTrackedMatrices.length; ++m) {
          var matrix = PerformanceConfigurator2.MatrixTrackedMatrices[m];
          var values = matrix._m;
          matrix._m = new Array(16);
          for (var i = 0; i < 16; ++i) {
            matrix._m[i] = values[i];
          }
        }
      }
    }
    PerformanceConfigurator2.MatrixUse64Bits = use64bits;
    PerformanceConfigurator2.MatrixCurrentType = PerformanceConfigurator2.MatrixUse64Bits ? Array : Float32Array;
    PerformanceConfigurator2.MatrixTrackedMatrices = null;
  };
  PerformanceConfigurator2.MatrixUse64Bits = false;
  PerformanceConfigurator2.MatrixTrackPrecisionChange = true;
  PerformanceConfigurator2.MatrixCurrentType = Float32Array;
  PerformanceConfigurator2.MatrixTrackedMatrices = [];
  return PerformanceConfigurator2;
}();
var WebGLHardwareTexture = function() {
  function WebGLHardwareTexture2(existingTexture, context) {
    if (existingTexture === void 0) {
      existingTexture = null;
    }
    this._MSAARenderBuffer = null;
    this._context = context;
    if (!existingTexture) {
      existingTexture = context.createTexture();
      if (!existingTexture) {
        throw new Error("Unable to create webGL texture");
      }
    }
    this.set(existingTexture);
  }
  Object.defineProperty(WebGLHardwareTexture2.prototype, "underlyingResource", {
    get: function() {
      return this._webGLTexture;
    },
    enumerable: false,
    configurable: true
  });
  WebGLHardwareTexture2.prototype.setUsage = function() {
  };
  WebGLHardwareTexture2.prototype.set = function(hardwareTexture) {
    this._webGLTexture = hardwareTexture;
  };
  WebGLHardwareTexture2.prototype.reset = function() {
    this._webGLTexture = null;
    this._MSAARenderBuffer = null;
  };
  WebGLHardwareTexture2.prototype.release = function() {
    if (this._MSAARenderBuffer) {
      this._context.deleteRenderbuffer(this._MSAARenderBuffer);
      this._MSAARenderBuffer = null;
    }
    if (this._webGLTexture) {
      this._context.deleteTexture(this._webGLTexture);
    }
    this.reset();
  };
  return WebGLHardwareTexture2;
}();
var DrawWrapper = function() {
  function DrawWrapper2(engine, createMaterialContext) {
    if (createMaterialContext === void 0) {
      createMaterialContext = true;
    }
    this.effect = null;
    this.defines = null;
    this.drawContext = engine.createDrawContext();
    if (createMaterialContext) {
      this.materialContext = engine.createMaterialContext();
    }
  }
  DrawWrapper2.IsWrapper = function(effect) {
    return effect.getPipelineContext === void 0;
  };
  DrawWrapper2.GetEffect = function(effect) {
    return effect.getPipelineContext === void 0 ? effect.effect : effect;
  };
  DrawWrapper2.prototype.setEffect = function(effect, defines, resetContext) {
    var _a2;
    if (resetContext === void 0) {
      resetContext = true;
    }
    this.effect = effect;
    if (defines !== void 0) {
      this.defines = defines;
    }
    if (resetContext) {
      (_a2 = this.drawContext) === null || _a2 === void 0 ? void 0 : _a2.reset();
    }
  };
  DrawWrapper2.prototype.dispose = function() {
    var _a2;
    (_a2 = this.drawContext) === null || _a2 === void 0 ? void 0 : _a2.dispose();
  };
  return DrawWrapper2;
}();
var StencilStateComposer = function() {
  function StencilStateComposer2(reset) {
    if (reset === void 0) {
      reset = true;
    }
    this._isStencilTestDirty = false;
    this._isStencilMaskDirty = false;
    this._isStencilFuncDirty = false;
    this._isStencilOpDirty = false;
    this.useStencilGlobalOnly = false;
    if (reset) {
      this.reset();
    }
  }
  Object.defineProperty(StencilStateComposer2.prototype, "isDirty", {
    get: function() {
      return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "func", {
    get: function() {
      return this._func;
    },
    set: function(value) {
      if (this._func === value) {
        return;
      }
      this._func = value;
      this._isStencilFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "funcRef", {
    get: function() {
      return this._funcRef;
    },
    set: function(value) {
      if (this._funcRef === value) {
        return;
      }
      this._funcRef = value;
      this._isStencilFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "funcMask", {
    get: function() {
      return this._funcMask;
    },
    set: function(value) {
      if (this._funcMask === value) {
        return;
      }
      this._funcMask = value;
      this._isStencilFuncDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "opStencilFail", {
    get: function() {
      return this._opStencilFail;
    },
    set: function(value) {
      if (this._opStencilFail === value) {
        return;
      }
      this._opStencilFail = value;
      this._isStencilOpDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "opDepthFail", {
    get: function() {
      return this._opDepthFail;
    },
    set: function(value) {
      if (this._opDepthFail === value) {
        return;
      }
      this._opDepthFail = value;
      this._isStencilOpDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "opStencilDepthPass", {
    get: function() {
      return this._opStencilDepthPass;
    },
    set: function(value) {
      if (this._opStencilDepthPass === value) {
        return;
      }
      this._opStencilDepthPass = value;
      this._isStencilOpDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(value) {
      if (this._mask === value) {
        return;
      }
      this._mask = value;
      this._isStencilMaskDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(StencilStateComposer2.prototype, "enabled", {
    get: function() {
      return this._enabled;
    },
    set: function(value) {
      if (this._enabled === value) {
        return;
      }
      this._enabled = value;
      this._isStencilTestDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  StencilStateComposer2.prototype.reset = function() {
    var _a2;
    this.stencilMaterial = void 0;
    (_a2 = this.stencilGlobal) === null || _a2 === void 0 ? void 0 : _a2.reset();
    this._isStencilTestDirty = true;
    this._isStencilMaskDirty = true;
    this._isStencilFuncDirty = true;
    this._isStencilOpDirty = true;
  };
  StencilStateComposer2.prototype.apply = function(gl) {
    var _a2;
    if (!gl) {
      return;
    }
    var stencilMaterialEnabled = !this.useStencilGlobalOnly && !!((_a2 = this.stencilMaterial) === null || _a2 === void 0 ? void 0 : _a2.enabled);
    this.enabled = stencilMaterialEnabled ? this.stencilMaterial.enabled : this.stencilGlobal.enabled;
    this.func = stencilMaterialEnabled ? this.stencilMaterial.func : this.stencilGlobal.func;
    this.funcRef = stencilMaterialEnabled ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef;
    this.funcMask = stencilMaterialEnabled ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask;
    this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail;
    this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail;
    this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;
    this.mask = stencilMaterialEnabled ? this.stencilMaterial.mask : this.stencilGlobal.mask;
    if (!this.isDirty) {
      return;
    }
    if (this._isStencilTestDirty) {
      if (this.enabled) {
        gl.enable(gl.STENCIL_TEST);
      } else {
        gl.disable(gl.STENCIL_TEST);
      }
      this._isStencilTestDirty = false;
    }
    if (this._isStencilMaskDirty) {
      gl.stencilMask(this.mask);
      this._isStencilMaskDirty = false;
    }
    if (this._isStencilFuncDirty) {
      gl.stencilFunc(this.func, this.funcRef, this.funcMask);
      this._isStencilFuncDirty = false;
    }
    if (this._isStencilOpDirty) {
      gl.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass);
      this._isStencilOpDirty = false;
    }
  };
  return StencilStateComposer2;
}();
var BufferPointer = function() {
  function BufferPointer2() {
  }
  return BufferPointer2;
}();
var ThinEngine = function() {
  function ThinEngine2(canvasOrContext, antialias, options, adaptToDeviceRatio) {
    var _this = this;
    this._name = "WebGL";
    this.forcePOTTextures = false;
    this.isFullscreen = false;
    this.cullBackFaces = null;
    this.renderEvenInBackground = true;
    this.preventCacheWipeBetweenFrames = false;
    this.validateShaderPrograms = false;
    this._useReverseDepthBuffer = false;
    this.isNDCHalfZRange = false;
    this.hasOriginBottomLeft = true;
    this.disableUniformBuffers = false;
    this.onDisposeObservable = new Observable();
    this._frameId = 0;
    this._uniformBuffers = new Array();
    this._storageBuffers = new Array();
    this._webGLVersion = 1;
    this._windowIsBackground = false;
    this._highPrecisionShadersAllowed = true;
    this._badOS = false;
    this._badDesktopOS = false;
    this._renderingQueueLaunched = false;
    this._activeRenderLoops = new Array();
    this.onContextLostObservable = new Observable();
    this.onContextRestoredObservable = new Observable();
    this._contextWasLost = false;
    this._doNotHandleContextLost = false;
    this.disableVertexArrayObjects = false;
    this._colorWrite = true;
    this._colorWriteChanged = true;
    this._depthCullingState = new DepthCullingState();
    this._stencilStateComposer = new StencilStateComposer();
    this._stencilState = new StencilState();
    this._alphaState = new AlphaState();
    this._alphaMode = 1;
    this._alphaEquation = 0;
    this._internalTexturesCache = new Array();
    this._renderTargetWrapperCache = new Array();
    this._activeChannel = 0;
    this._currentTextureChannel = -1;
    this._boundTexturesCache = {};
    this._compiledEffects = {};
    this._vertexAttribArraysEnabled = [];
    this._uintIndicesCurrentlySet = false;
    this._currentBoundBuffer = new Array();
    this._currentFramebuffer = null;
    this._dummyFramebuffer = null;
    this._currentBufferPointers = new Array();
    this._currentInstanceLocations = new Array();
    this._currentInstanceBuffers = new Array();
    this._vaoRecordInProgress = false;
    this._mustWipeVertexAttributes = false;
    this._nextFreeTextureSlots = new Array();
    this._maxSimultaneousTextures = 0;
    this._maxMSAASamplesOverride = null;
    this._activeRequests = new Array();
    this._adaptToDeviceRatio = false;
    this._transformTextureUrl = null;
    this.hostInformation = {
      isMobile: false
    };
    this.premultipliedAlpha = true;
    this.onBeforeTextureInitObservable = new Observable();
    this._isWebGPU = false;
    this._snapshotRenderingMode = 0;
    this._viewportCached = { x: 0, y: 0, z: 0, w: 0 };
    this._unpackFlipYCached = null;
    this.enableUnpackFlipYCached = true;
    this._boundUniforms = {};
    var canvas = null;
    options = options || {};
    this._creationOptions = options;
    this._adaptToDeviceRatio = adaptToDeviceRatio !== null && adaptToDeviceRatio !== void 0 ? adaptToDeviceRatio : false;
    this._stencilStateComposer.stencilGlobal = this._stencilState;
    PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
    if (!canvasOrContext) {
      return;
    }
    adaptToDeviceRatio = adaptToDeviceRatio || options.adaptToDeviceRatio || false;
    if (canvasOrContext.getContext) {
      canvas = canvasOrContext;
      this._renderingCanvas = canvas;
      if (antialias !== void 0) {
        options.antialias = antialias;
      }
      if (options.deterministicLockstep === void 0) {
        options.deterministicLockstep = false;
      }
      if (options.lockstepMaxSteps === void 0) {
        options.lockstepMaxSteps = 4;
      }
      if (options.timeStep === void 0) {
        options.timeStep = 1 / 60;
      }
      if (options.preserveDrawingBuffer === void 0) {
        options.preserveDrawingBuffer = false;
      }
      if (options.audioEngine === void 0) {
        options.audioEngine = true;
      }
      if (options.audioEngineOptions !== void 0 && options.audioEngineOptions.audioContext !== void 0) {
        this._audioContext = options.audioEngineOptions.audioContext;
      }
      if (options.audioEngineOptions !== void 0 && options.audioEngineOptions.audioDestination !== void 0) {
        this._audioDestination = options.audioEngineOptions.audioDestination;
      }
      if (options.stencil === void 0) {
        options.stencil = true;
      }
      if (options.premultipliedAlpha === false) {
        this.premultipliedAlpha = false;
      }
      if (options.xrCompatible === void 0) {
        options.xrCompatible = true;
      }
      this._doNotHandleContextLost = options.doNotHandleContextLost ? true : false;
      if (navigator && navigator.userAgent) {
        this._checkForMobile = function() {
          var currentUA = navigator.userAgent;
          _this.hostInformation.isMobile = currentUA.indexOf("Mobile") !== -1 || currentUA.indexOf("Mac") !== -1 && IsDocumentAvailable() && "ontouchend" in document;
        };
        this._checkForMobile();
        if (IsWindowObjectExist()) {
          window.addEventListener("resize", this._checkForMobile);
        }
        var ua = navigator.userAgent;
        for (var _i = 0, _a2 = ThinEngine2.ExceptionList; _i < _a2.length; _i++) {
          var exception = _a2[_i];
          var key = exception.key;
          var targets = exception.targets;
          var check = new RegExp(key);
          if (check.test(ua)) {
            if (exception.capture && exception.captureConstraint) {
              var capture = exception.capture;
              var constraint = exception.captureConstraint;
              var regex = new RegExp(capture);
              var matches = regex.exec(ua);
              if (matches && matches.length > 0) {
                var capturedValue = parseInt(matches[matches.length - 1]);
                if (capturedValue >= constraint) {
                  continue;
                }
              }
            }
            for (var _b2 = 0, targets_1 = targets; _b2 < targets_1.length; _b2++) {
              var target2 = targets_1[_b2];
              switch (target2) {
                case "uniformBuffer":
                  this.disableUniformBuffers = true;
                  break;
                case "vao":
                  this.disableVertexArrayObjects = true;
                  break;
                case "antialias":
                  options.antialias = false;
                  break;
                case "maxMSAASamples":
                  this._maxMSAASamplesOverride = 1;
                  break;
              }
            }
          }
        }
      }
      if (!this._doNotHandleContextLost) {
        this._onContextLost = function(evt) {
          evt.preventDefault();
          _this._contextWasLost = true;
          Logger.Warn("WebGL context lost.");
          _this.onContextLostObservable.notifyObservers(_this);
        };
        this._onContextRestored = function() {
          _this._restoreEngineAfterContextLost(_this._initGLContext.bind(_this));
        };
        canvas.addEventListener("webglcontextlost", this._onContextLost, false);
        canvas.addEventListener("webglcontextrestored", this._onContextRestored, false);
        options.powerPreference = "high-performance";
      }
      this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (this._badDesktopOS) {
        options.xrCompatible = false;
      }
      if (!options.disableWebGL2Support) {
        try {
          this._gl = canvas.getContext("webgl2", options) || canvas.getContext("experimental-webgl2", options);
          if (this._gl) {
            this._webGLVersion = 2;
            this._shaderPlatformName = "WEBGL2";
            if (!this._gl.deleteQuery) {
              this._webGLVersion = 1;
              this._shaderPlatformName = "WEBGL1";
            }
          }
        } catch (e) {
        }
      }
      if (!this._gl) {
        if (!canvas) {
          throw new Error("The provided canvas is null or undefined.");
        }
        try {
          this._gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
        } catch (e) {
          throw new Error("WebGL not supported");
        }
      }
      if (!this._gl) {
        throw new Error("WebGL not supported");
      }
    } else {
      this._gl = canvasOrContext;
      this._renderingCanvas = this._gl.canvas;
      if (this._gl.renderbufferStorageMultisample) {
        this._webGLVersion = 2;
        this._shaderPlatformName = "WEBGL2";
      } else {
        this._shaderPlatformName = "WEBGL1";
      }
      var attributes = this._gl.getContextAttributes();
      if (attributes) {
        options.stencil = attributes.stencil;
      }
    }
    this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
    if (options.useHighPrecisionFloats !== void 0) {
      this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;
    }
    var devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
    var limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;
    this._hardwareScalingLevel = adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio) : 1;
    this.resize();
    this._isStencilEnable = options.stencil ? true : false;
    this._initGLContext();
    this._initFeatures();
    for (var i = 0; i < this._caps.maxVertexAttribs; i++) {
      this._currentBufferPointers[i] = new BufferPointer();
    }
    this._shaderProcessor = this.webGLVersion > 1 ? new WebGL2ShaderProcessor() : new WebGLShaderProcessor();
    this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
    var versionToLog = "Babylon.js v".concat(ThinEngine2.Version);
    console.log(versionToLog + " - ".concat(this.description));
    if (this._renderingCanvas && this._renderingCanvas.setAttribute) {
      this._renderingCanvas.setAttribute("data-engine", versionToLog);
    }
  }
  Object.defineProperty(ThinEngine2, "NpmPackage", {
    get: function() {
      return "babylonjs@5.10.0";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2, "Version", {
    get: function() {
      return "5.10.0";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "description", {
    get: function() {
      var description = this.name + this.webGLVersion;
      if (this._caps.parallelShaderCompile) {
        description += " - Parallel shader compilation";
      }
      return description;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "name", {
    get: function() {
      return this._name;
    },
    set: function(value) {
      this._name = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "version", {
    get: function() {
      return this._webGLVersion;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2, "ShadersRepository", {
    get: function() {
      return Effect.ShadersRepository;
    },
    set: function(value) {
      Effect.ShadersRepository = value;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype._getShaderProcessor = function(shaderLanguage) {
    return this._shaderProcessor;
  };
  Object.defineProperty(ThinEngine2.prototype, "useReverseDepthBuffer", {
    get: function() {
      return this._useReverseDepthBuffer;
    },
    set: function(useReverse) {
      if (useReverse === this._useReverseDepthBuffer) {
        return;
      }
      this._useReverseDepthBuffer = useReverse;
      if (useReverse) {
        this._depthCullingState.depthFunc = 518;
      } else {
        this._depthCullingState.depthFunc = 515;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "frameId", {
    get: function() {
      return this._frameId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "supportsUniformBuffers", {
    get: function() {
      return this.webGLVersion > 1 && !this.disableUniformBuffers;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.getCreationOptions = function() {
    return this._creationOptions;
  };
  Object.defineProperty(ThinEngine2.prototype, "_shouldUseHighPrecisionShader", {
    get: function() {
      return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "needPOTTextures", {
    get: function() {
      return this._webGLVersion < 2 || this.forcePOTTextures;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "activeRenderLoops", {
    get: function() {
      return this._activeRenderLoops;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "doNotHandleContextLost", {
    get: function() {
      return this._doNotHandleContextLost;
    },
    set: function(value) {
      this._doNotHandleContextLost = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "_supportsHardwareTextureRescaling", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "framebufferDimensionsObject", {
    set: function(dimensions) {
      this._framebufferDimensionsObject = dimensions;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "currentViewport", {
    get: function() {
      return this._cachedViewport;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyTexture", {
    get: function() {
      if (!this._emptyTexture) {
        this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, false, false, 1);
      }
      return this._emptyTexture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyTexture3D", {
    get: function() {
      if (!this._emptyTexture3D) {
        this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
      }
      return this._emptyTexture3D;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyTexture2DArray", {
    get: function() {
      if (!this._emptyTexture2DArray) {
        this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
      }
      return this._emptyTexture2DArray;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "emptyCubeTexture", {
    get: function() {
      if (!this._emptyCubeTexture) {
        var faceData = new Uint8Array(4);
        var cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];
        this._emptyCubeTexture = this.createRawCubeTexture(cubeData, 1, 5, 0, false, false, 1);
      }
      return this._emptyCubeTexture;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "isWebGPU", {
    get: function() {
      return this._isWebGPU;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "shaderPlatformName", {
    get: function() {
      return this._shaderPlatformName;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "snapshotRendering", {
    get: function() {
      return false;
    },
    set: function(activate) {
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "snapshotRenderingMode", {
    get: function() {
      return this._snapshotRenderingMode;
    },
    set: function(mode) {
      this._snapshotRenderingMode = mode;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.snapshotRenderingReset = function() {
    this.snapshotRendering = false;
  };
  ThinEngine2._CreateCanvas = function(width, height) {
    if (typeof document === "undefined") {
      return new OffscreenCanvas(width, height);
    }
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  };
  ThinEngine2.prototype.createCanvas = function(width, height) {
    return ThinEngine2._CreateCanvas(width, height);
  };
  ThinEngine2.prototype.createCanvasImage = function() {
    return document.createElement("img");
  };
  ThinEngine2.prototype._restoreEngineAfterContextLost = function(initEngine) {
    var _this = this;
    setTimeout(function() {
      return __awaiter(_this, void 0, void 0, function() {
        var depthTest, depthFunc, depthMask, stencilTest;
        var _a2;
        return __generator(this, function(_b2) {
          switch (_b2.label) {
            case 0:
              this._dummyFramebuffer = null;
              depthTest = this._depthCullingState.depthTest;
              depthFunc = this._depthCullingState.depthFunc;
              depthMask = this._depthCullingState.depthMask;
              stencilTest = this._stencilState.stencilTest;
              return [4, initEngine()];
            case 1:
              _b2.sent();
              this._rebuildEffects();
              (_a2 = this._rebuildComputeEffects) === null || _a2 === void 0 ? void 0 : _a2.call(this);
              this._rebuildInternalTextures();
              this._rebuildRenderTargetWrappers();
              this._rebuildBuffers();
              this.wipeCaches(true);
              this._depthCullingState.depthTest = depthTest;
              this._depthCullingState.depthFunc = depthFunc;
              this._depthCullingState.depthMask = depthMask;
              this._stencilState.stencilTest = stencilTest;
              Logger.Warn(this.name + " context successfully restored.");
              this.onContextRestoredObservable.notifyObservers(this);
              this._contextWasLost = false;
              return [2];
          }
        });
      });
    }, 0);
  };
  ThinEngine2.prototype._sharedInit = function(canvas, doNotHandleTouchAction, audioEngine) {
    this._renderingCanvas = canvas;
  };
  ThinEngine2.prototype._getShaderProcessingContext = function(shaderLanguage) {
    return null;
  };
  ThinEngine2.prototype._rebuildInternalTextures = function() {
    var currentState = this._internalTexturesCache.slice();
    for (var _i = 0, currentState_1 = currentState; _i < currentState_1.length; _i++) {
      var internalTexture = currentState_1[_i];
      internalTexture._rebuild();
    }
  };
  ThinEngine2.prototype._rebuildRenderTargetWrappers = function() {
    var currentState = this._renderTargetWrapperCache.slice();
    for (var _i = 0, currentState_2 = currentState; _i < currentState_2.length; _i++) {
      var renderTargetWrapper = currentState_2[_i];
      renderTargetWrapper._rebuild();
    }
  };
  ThinEngine2.prototype._rebuildEffects = function() {
    for (var key in this._compiledEffects) {
      var effect = this._compiledEffects[key];
      effect._pipelineContext = null;
      effect._wasPreviouslyReady = false;
      effect._prepareEffect();
    }
    Effect.ResetCache();
  };
  ThinEngine2.prototype.areAllEffectsReady = function() {
    for (var key in this._compiledEffects) {
      var effect = this._compiledEffects[key];
      if (!effect.isReady()) {
        return false;
      }
    }
    return true;
  };
  ThinEngine2.prototype._rebuildBuffers = function() {
    for (var _i = 0, _a2 = this._uniformBuffers; _i < _a2.length; _i++) {
      var uniformBuffer = _a2[_i];
      uniformBuffer._rebuild();
    }
    for (var _b2 = 0, _c2 = this._storageBuffers; _b2 < _c2.length; _b2++) {
      var storageBuffer = _c2[_b2];
      storageBuffer._rebuild();
    }
  };
  ThinEngine2.prototype._initGLContext = function() {
    this._caps = {
      maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
      maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
      maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
      maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
      maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
      maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
      maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
      maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
      parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
      standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
      maxAnisotropy: 1,
      astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
      bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
      s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
      s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
      pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
      etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
      textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
      uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
      fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
      highPrecisionShaderSupported: false,
      timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
      supportOcclusionQuery: this._webGLVersion > 1,
      canUseTimestampForTimerQuery: false,
      drawBuffersExtension: false,
      maxMSAASamples: 1,
      colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
      textureFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float") ? true : false,
      textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float") ? true : false,
      textureHalfFloatRender: false,
      textureFloatLinearFiltering: false,
      textureFloatRender: false,
      textureHalfFloatLinearFiltering: false,
      vertexArrayObject: false,
      instancedArrays: false,
      textureLOD: this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod") ? true : false,
      blendMinMax: false,
      multiview: this._gl.getExtension("OVR_multiview2"),
      oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
      depthTextureExtension: false,
      canUseGLInstanceID: this._webGLVersion > 1,
      canUseGLVertexID: this._webGLVersion > 1,
      supportComputeShaders: false,
      supportSRGBBuffers: false,
      supportTransformFeedbacks: this._webGLVersion > 1,
      textureMaxLevel: this._webGLVersion > 1,
      texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? 256 : 128
    };
    this._glVersion = this._gl.getParameter(this._gl.VERSION);
    var rendererInfo = this._gl.getExtension("WEBGL_debug_renderer_info");
    if (rendererInfo != null) {
      this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
      this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
    }
    if (!this._glVendor) {
      this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor";
    }
    if (!this._glRenderer) {
      this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer";
    }
    if (this._gl.HALF_FLOAT_OES !== 36193) {
      this._gl.HALF_FLOAT_OES = 36193;
    }
    if (this._gl.RGBA16F !== 34842) {
      this._gl.RGBA16F = 34842;
    }
    if (this._gl.RGBA32F !== 34836) {
      this._gl.RGBA32F = 34836;
    }
    if (this._gl.DEPTH24_STENCIL8 !== 35056) {
      this._gl.DEPTH24_STENCIL8 = 35056;
    }
    if (this._caps.timerQuery) {
      if (this._webGLVersion === 1) {
        this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery);
      }
      this._caps.canUseTimestampForTimerQuery = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) > 0;
    }
    this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
    this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear") ? true : false;
    this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;
    this._caps.textureHalfFloatLinearFiltering = this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear") ? true : false;
    if (this._caps.astc) {
      this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
    }
    if (this._caps.bptc) {
      this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
    }
    if (this._caps.s3tc_srgb) {
      this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT;
      this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
      this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
    }
    if (this._caps.etc2) {
      this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2;
      this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
    }
    if (this._webGLVersion > 1) {
      if (this._gl.HALF_FLOAT_OES !== 5131) {
        this._gl.HALF_FLOAT_OES = 5131;
      }
    }
    this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();
    if (this._webGLVersion > 1) {
      this._caps.drawBuffersExtension = true;
      this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
    } else {
      var drawBuffersExtension = this._gl.getExtension("WEBGL_draw_buffers");
      if (drawBuffersExtension !== null) {
        this._caps.drawBuffersExtension = true;
        this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);
        this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
        for (var i = 0; i < 16; i++) {
          this._gl["COLOR_ATTACHMENT" + i + "_WEBGL"] = drawBuffersExtension["COLOR_ATTACHMENT" + i + "_WEBGL"];
        }
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.depthTextureExtension = true;
    } else {
      var depthTextureExtension = this._gl.getExtension("WEBGL_depth_texture");
      if (depthTextureExtension != null) {
        this._caps.depthTextureExtension = true;
        this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
      }
    }
    if (this.disableVertexArrayObjects) {
      this._caps.vertexArrayObject = false;
    } else if (this._webGLVersion > 1) {
      this._caps.vertexArrayObject = true;
    } else {
      var vertexArrayObjectExtension = this._gl.getExtension("OES_vertex_array_object");
      if (vertexArrayObjectExtension != null) {
        this._caps.vertexArrayObject = true;
        this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);
        this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.instancedArrays = true;
    } else {
      var instanceExtension = this._gl.getExtension("ANGLE_instanced_arrays");
      if (instanceExtension != null) {
        this._caps.instancedArrays = true;
        this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);
        this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);
        this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);
      } else {
        this._caps.instancedArrays = false;
      }
    }
    if (this._gl.getShaderPrecisionFormat) {
      var vertexhighp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);
      var fragmenthighp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
      if (vertexhighp && fragmenthighp) {
        this._caps.highPrecisionShaderSupported = vertexhighp.precision !== 0 && fragmenthighp.precision !== 0;
      }
    }
    if (this._webGLVersion > 1) {
      this._caps.blendMinMax = true;
    } else {
      var blendMinMaxExtension = this._gl.getExtension("EXT_blend_minmax");
      if (blendMinMaxExtension != null) {
        this._caps.blendMinMax = true;
        this._gl.MAX = blendMinMaxExtension.MAX_EXT;
        this._gl.MIN = blendMinMaxExtension.MIN_EXT;
      }
    }
    if (!this._caps.supportSRGBBuffers) {
      if (this._webGLVersion > 1) {
        this._caps.supportSRGBBuffers = true;
      } else {
        var sRGBExtension = this._gl.getExtension("EXT_sRGB");
        if (sRGBExtension != null) {
          this._caps.supportSRGBBuffers = true;
          this._gl.SRGB = sRGBExtension.SRGB_EXT;
          this._gl.SRGB8 = sRGBExtension.SRGB_ALPHA_EXT;
          this._gl.SRGB8_ALPHA8 = sRGBExtension.SRGB_ALPHA_EXT;
        }
      }
      this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState);
    }
    this._depthCullingState.depthTest = true;
    this._depthCullingState.depthFunc = this._gl.LEQUAL;
    this._depthCullingState.depthMask = true;
    this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
    for (var slot = 0; slot < this._maxSimultaneousTextures; slot++) {
      this._nextFreeTextureSlots.push(slot);
    }
  };
  ThinEngine2.prototype._initFeatures = function() {
    this._features = {
      forceBitmapOverHTMLImageElement: false,
      supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
      supportDepthStencilTexture: this._webGLVersion !== 1,
      supportShadowSamplers: this._webGLVersion !== 1,
      uniformBufferHardCheckMatrix: false,
      allowTexturePrefiltering: this._webGLVersion !== 1,
      trackUbosInFrame: false,
      checkUbosContentBeforeUpload: false,
      supportCSM: this._webGLVersion !== 1,
      basisNeedsPOT: this._webGLVersion === 1,
      support3DTextures: this._webGLVersion !== 1,
      needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
      supportMSAA: this._webGLVersion !== 1,
      supportSSAO2: this._webGLVersion !== 1,
      supportExtendedTextureFormats: this._webGLVersion !== 1,
      supportSwitchCaseInShader: this._webGLVersion !== 1,
      supportSyncTextureRead: true,
      needsInvertingBitmap: true,
      useUBOBindingCache: true,
      needShaderCodeInlining: false,
      needToAlwaysBindUniformBuffers: false,
      supportRenderPasses: false,
      _collectUbosUpdatedInFrame: false
    };
  };
  Object.defineProperty(ThinEngine2.prototype, "webGLVersion", {
    get: function() {
      return this._webGLVersion;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.getClassName = function() {
    return "ThinEngine";
  };
  Object.defineProperty(ThinEngine2.prototype, "isStencilEnable", {
    get: function() {
      return this._isStencilEnable;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype._prepareWorkingCanvas = function() {
    if (this._workingCanvas) {
      return;
    }
    this._workingCanvas = this.createCanvas(1, 1);
    var context = this._workingCanvas.getContext("2d");
    if (context) {
      this._workingContext = context;
    }
  };
  ThinEngine2.prototype.resetTextureCache = function() {
    for (var key in this._boundTexturesCache) {
      if (!Object.prototype.hasOwnProperty.call(this._boundTexturesCache, key)) {
        continue;
      }
      this._boundTexturesCache[key] = null;
    }
    this._currentTextureChannel = -1;
  };
  ThinEngine2.prototype.getInfo = function() {
    return this.getGlInfo();
  };
  ThinEngine2.prototype.getGlInfo = function() {
    return {
      vendor: this._glVendor,
      renderer: this._glRenderer,
      version: this._glVersion
    };
  };
  ThinEngine2.prototype.setHardwareScalingLevel = function(level) {
    this._hardwareScalingLevel = level;
    this.resize();
  };
  ThinEngine2.prototype.getHardwareScalingLevel = function() {
    return this._hardwareScalingLevel;
  };
  ThinEngine2.prototype.getLoadedTexturesCache = function() {
    return this._internalTexturesCache;
  };
  ThinEngine2.prototype.getCaps = function() {
    return this._caps;
  };
  ThinEngine2.prototype.stopRenderLoop = function(renderFunction) {
    if (!renderFunction) {
      this._activeRenderLoops = [];
      return;
    }
    var index = this._activeRenderLoops.indexOf(renderFunction);
    if (index >= 0) {
      this._activeRenderLoops.splice(index, 1);
    }
  };
  ThinEngine2.prototype._renderLoop = function() {
    if (!this._contextWasLost) {
      var shouldRender = true;
      if (!this.renderEvenInBackground && this._windowIsBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        for (var index = 0; index < this._activeRenderLoops.length; index++) {
          var renderFunction = this._activeRenderLoops[index];
          renderFunction();
        }
        this.endFrame();
      }
    }
    if (this._activeRenderLoops.length > 0) {
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    } else {
      this._renderingQueueLaunched = false;
    }
  };
  ThinEngine2.prototype.getRenderingCanvas = function() {
    return this._renderingCanvas;
  };
  ThinEngine2.prototype.getAudioContext = function() {
    return this._audioContext;
  };
  ThinEngine2.prototype.getAudioDestination = function() {
    return this._audioDestination;
  };
  ThinEngine2.prototype.getHostWindow = function() {
    if (!IsWindowObjectExist()) {
      return null;
    }
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {
      return this._renderingCanvas.ownerDocument.defaultView;
    }
    return window;
  };
  ThinEngine2.prototype.getRenderWidth = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.width;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
  };
  ThinEngine2.prototype.getRenderHeight = function(useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    if (!useScreen && this._currentRenderTarget) {
      return this._currentRenderTarget.height;
    }
    return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
  };
  ThinEngine2.prototype._queueNewFrame = function(bindedRenderFunction, requester) {
    return ThinEngine2.QueueNewFrame(bindedRenderFunction, requester);
  };
  ThinEngine2.prototype.runRenderLoop = function(renderFunction) {
    if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {
      return;
    }
    this._activeRenderLoops.push(renderFunction);
    if (!this._renderingQueueLaunched) {
      this._renderingQueueLaunched = true;
      this._boundRenderFunction = this._renderLoop.bind(this);
      this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
    }
  };
  ThinEngine2.prototype.clear = function(color, backBuffer, depth, stencil) {
    if (stencil === void 0) {
      stencil = false;
    }
    var useStencilGlobalOnly = this.stencilStateComposer.useStencilGlobalOnly;
    this.stencilStateComposer.useStencilGlobalOnly = true;
    this.applyStates();
    this.stencilStateComposer.useStencilGlobalOnly = useStencilGlobalOnly;
    var mode = 0;
    if (backBuffer && color) {
      this._gl.clearColor(color.r, color.g, color.b, color.a !== void 0 ? color.a : 1);
      mode |= this._gl.COLOR_BUFFER_BIT;
    }
    if (depth) {
      if (this.useReverseDepthBuffer) {
        this._depthCullingState.depthFunc = this._gl.GEQUAL;
        this._gl.clearDepth(0);
      } else {
        this._gl.clearDepth(1);
      }
      mode |= this._gl.DEPTH_BUFFER_BIT;
    }
    if (stencil) {
      this._gl.clearStencil(0);
      mode |= this._gl.STENCIL_BUFFER_BIT;
    }
    this._gl.clear(mode);
  };
  ThinEngine2.prototype._viewport = function(x, y, width, height) {
    if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {
      this._viewportCached.x = x;
      this._viewportCached.y = y;
      this._viewportCached.z = width;
      this._viewportCached.w = height;
      this._gl.viewport(x, y, width, height);
    }
  };
  ThinEngine2.prototype.setViewport = function(viewport, requiredWidth, requiredHeight) {
    var width = requiredWidth || this.getRenderWidth();
    var height = requiredHeight || this.getRenderHeight();
    var x = viewport.x || 0;
    var y = viewport.y || 0;
    this._cachedViewport = viewport;
    this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);
  };
  ThinEngine2.prototype.beginFrame = function() {
  };
  ThinEngine2.prototype.endFrame = function() {
    if (this._badOS) {
      this.flushFramebuffer();
    }
    this._frameId++;
  };
  ThinEngine2.prototype.resize = function(forceSetSize) {
    if (forceSetSize === void 0) {
      forceSetSize = false;
    }
    var width;
    var height;
    if (this._adaptToDeviceRatio) {
      var devicePixelRatio_1 = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
      var limitDeviceRatio = this._creationOptions.limitDeviceRatio || devicePixelRatio_1;
      this._hardwareScalingLevel = this._adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio_1) : 1;
    }
    if (IsWindowObjectExist()) {
      width = this._renderingCanvas ? this._renderingCanvas.clientWidth || this._renderingCanvas.width : window.innerWidth;
      height = this._renderingCanvas ? this._renderingCanvas.clientHeight || this._renderingCanvas.height : window.innerHeight;
    } else {
      width = this._renderingCanvas ? this._renderingCanvas.width : 100;
      height = this._renderingCanvas ? this._renderingCanvas.height : 100;
    }
    this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel, forceSetSize);
  };
  ThinEngine2.prototype.setSize = function(width, height, forceSetSize) {
    if (forceSetSize === void 0) {
      forceSetSize = false;
    }
    if (!this._renderingCanvas) {
      return false;
    }
    width = width | 0;
    height = height | 0;
    if (!forceSetSize && this._renderingCanvas.width === width && this._renderingCanvas.height === height) {
      return false;
    }
    this._renderingCanvas.width = width;
    this._renderingCanvas.height = height;
    return true;
  };
  ThinEngine2.prototype.bindFramebuffer = function(texture, faceIndex, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel, layer) {
    var _a2, _b2, _c2, _d, _e;
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lodLevel === void 0) {
      lodLevel = 0;
    }
    if (layer === void 0) {
      layer = 0;
    }
    var webglRTWrapper = texture;
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    }
    this._currentRenderTarget = texture;
    this._bindUnboundFramebuffer(webglRTWrapper._MSAAFramebuffer ? webglRTWrapper._MSAAFramebuffer : webglRTWrapper._framebuffer);
    var gl = this._gl;
    if (texture.is2DArray) {
      gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, (_a2 = texture.texture._hardwareTexture) === null || _a2 === void 0 ? void 0 : _a2.underlyingResource, lodLevel, layer);
    } else if (texture.isCube) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_b2 = texture.texture._hardwareTexture) === null || _b2 === void 0 ? void 0 : _b2.underlyingResource, lodLevel);
    }
    var depthStencilTexture = texture._depthStencilTexture;
    if (depthStencilTexture) {
      var attachment = texture._depthStencilTextureWithStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
      if (texture.is2DArray) {
        gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, (_c2 = depthStencilTexture._hardwareTexture) === null || _c2 === void 0 ? void 0 : _c2.underlyingResource, lodLevel, layer);
      } else if (texture.isCube) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_d = depthStencilTexture._hardwareTexture) === null || _d === void 0 ? void 0 : _d.underlyingResource, lodLevel);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, (_e = depthStencilTexture._hardwareTexture) === null || _e === void 0 ? void 0 : _e.underlyingResource, lodLevel);
      }
    }
    if (this._cachedViewport && !forceFullscreenViewport) {
      this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
    } else {
      if (!requiredWidth) {
        requiredWidth = texture.width;
        if (lodLevel) {
          requiredWidth = requiredWidth / Math.pow(2, lodLevel);
        }
      }
      if (!requiredHeight) {
        requiredHeight = texture.height;
        if (lodLevel) {
          requiredHeight = requiredHeight / Math.pow(2, lodLevel);
        }
      }
      this._viewport(0, 0, requiredWidth, requiredHeight);
    }
    this.wipeCaches();
  };
  ThinEngine2.prototype.setState = function(culling, zOffset, force, reverseSide, cullBackFaces, stencil, zOffsetUnits) {
    var _a2, _b2;
    if (zOffset === void 0) {
      zOffset = 0;
    }
    if (reverseSide === void 0) {
      reverseSide = false;
    }
    if (zOffsetUnits === void 0) {
      zOffsetUnits = 0;
    }
    if (this._depthCullingState.cull !== culling || force) {
      this._depthCullingState.cull = culling;
    }
    var cullFace = ((_b2 = (_a2 = this.cullBackFaces) !== null && _a2 !== void 0 ? _a2 : cullBackFaces) !== null && _b2 !== void 0 ? _b2 : true) ? this._gl.BACK : this._gl.FRONT;
    if (this._depthCullingState.cullFace !== cullFace || force) {
      this._depthCullingState.cullFace = cullFace;
    }
    this.setZOffset(zOffset);
    this.setZOffsetUnits(zOffsetUnits);
    var frontFace = reverseSide ? this._gl.CW : this._gl.CCW;
    if (this._depthCullingState.frontFace !== frontFace || force) {
      this._depthCullingState.frontFace = frontFace;
    }
    this._stencilStateComposer.stencilMaterial = stencil;
  };
  ThinEngine2.prototype.setZOffset = function(value) {
    this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -value : value;
  };
  ThinEngine2.prototype.getZOffset = function() {
    var zOffset = this._depthCullingState.zOffset;
    return this.useReverseDepthBuffer ? -zOffset : zOffset;
  };
  ThinEngine2.prototype.setZOffsetUnits = function(value) {
    this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -value : value;
  };
  ThinEngine2.prototype.getZOffsetUnits = function() {
    var zOffsetUnits = this._depthCullingState.zOffsetUnits;
    return this.useReverseDepthBuffer ? -zOffsetUnits : zOffsetUnits;
  };
  ThinEngine2.prototype._bindUnboundFramebuffer = function(framebuffer) {
    if (this._currentFramebuffer !== framebuffer) {
      this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
      this._currentFramebuffer = framebuffer;
    }
  };
  ThinEngine2.prototype._currentFrameBufferIsDefaultFrameBuffer = function() {
    return this._currentFramebuffer === null;
  };
  ThinEngine2.prototype.generateMipmaps = function(texture) {
    this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
    this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  };
  ThinEngine2.prototype.unBindFramebuffer = function(texture, disableGenerateMipMaps, onBeforeUnbind) {
    var _a2;
    if (disableGenerateMipMaps === void 0) {
      disableGenerateMipMaps = false;
    }
    var webglRTWrapper = texture;
    this._currentRenderTarget = null;
    var gl = this._gl;
    if (webglRTWrapper._MSAAFramebuffer) {
      if (texture.isMulti) {
        this.unBindMultiColorAttachmentFramebuffer(texture, disableGenerateMipMaps, onBeforeUnbind);
        return;
      }
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webglRTWrapper._MSAAFramebuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, webglRTWrapper._framebuffer);
      gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
    }
    if (((_a2 = texture.texture) === null || _a2 === void 0 ? void 0 : _a2.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {
      this.generateMipmaps(texture.texture);
    }
    if (onBeforeUnbind) {
      if (webglRTWrapper._MSAAFramebuffer) {
        this._bindUnboundFramebuffer(webglRTWrapper._framebuffer);
      }
      onBeforeUnbind();
    }
    this._bindUnboundFramebuffer(null);
  };
  ThinEngine2.prototype.flushFramebuffer = function() {
    this._gl.flush();
  };
  ThinEngine2.prototype.restoreDefaultFramebuffer = function() {
    if (this._currentRenderTarget) {
      this.unBindFramebuffer(this._currentRenderTarget);
    } else {
      this._bindUnboundFramebuffer(null);
    }
    if (this._cachedViewport) {
      this.setViewport(this._cachedViewport);
    }
    this.wipeCaches();
  };
  ThinEngine2.prototype._resetVertexBufferBinding = function() {
    this.bindArrayBuffer(null);
    this._cachedVertexBuffers = null;
  };
  ThinEngine2.prototype.createVertexBuffer = function(data) {
    return this._createVertexBuffer(data, this._gl.STATIC_DRAW);
  };
  ThinEngine2.prototype._createVertexBuffer = function(data, usage) {
    var vbo = this._gl.createBuffer();
    if (!vbo) {
      throw new Error("Unable to create vertex buffer");
    }
    var dataBuffer = new WebGLDataBuffer(vbo);
    this.bindArrayBuffer(dataBuffer);
    if (data instanceof Array) {
      this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), usage);
    } else {
      this._gl.bufferData(this._gl.ARRAY_BUFFER, data, usage);
    }
    this._resetVertexBufferBinding();
    dataBuffer.references = 1;
    return dataBuffer;
  };
  ThinEngine2.prototype.createDynamicVertexBuffer = function(data) {
    return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);
  };
  ThinEngine2.prototype._resetIndexBufferBinding = function() {
    this.bindIndexBuffer(null);
    this._cachedIndexBuffer = null;
  };
  ThinEngine2.prototype.createIndexBuffer = function(indices, updatable) {
    var vbo = this._gl.createBuffer();
    var dataBuffer = new WebGLDataBuffer(vbo);
    if (!vbo) {
      throw new Error("Unable to create index buffer");
    }
    this.bindIndexBuffer(dataBuffer);
    var data = this._normalizeIndexData(indices);
    this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);
    this._resetIndexBufferBinding();
    dataBuffer.references = 1;
    dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
    return dataBuffer;
  };
  ThinEngine2.prototype._normalizeIndexData = function(indices) {
    var bytesPerElement = indices.BYTES_PER_ELEMENT;
    if (bytesPerElement === 2) {
      return indices;
    }
    if (this._caps.uintIndices) {
      if (indices instanceof Uint32Array) {
        return indices;
      } else {
        for (var index = 0; index < indices.length; index++) {
          if (indices[index] >= 65535) {
            return new Uint32Array(indices);
          }
        }
        return new Uint16Array(indices);
      }
    }
    return new Uint16Array(indices);
  };
  ThinEngine2.prototype.bindArrayBuffer = function(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this._bindBuffer(buffer, this._gl.ARRAY_BUFFER);
  };
  ThinEngine2.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
    var program = pipelineContext.program;
    var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
    this._gl.uniformBlockBinding(program, uniformLocation, index);
  };
  ThinEngine2.prototype.bindIndexBuffer = function(buffer) {
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this._bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);
  };
  ThinEngine2.prototype._bindBuffer = function(buffer, target2) {
    if (this._vaoRecordInProgress || this._currentBoundBuffer[target2] !== buffer) {
      this._gl.bindBuffer(target2, buffer ? buffer.underlyingResource : null);
      this._currentBoundBuffer[target2] = buffer;
    }
  };
  ThinEngine2.prototype.updateArrayBuffer = function(data) {
    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
  };
  ThinEngine2.prototype._vertexAttribPointer = function(buffer, indx, size, type, normalized, stride, offset) {
    var pointer = this._currentBufferPointers[indx];
    if (!pointer) {
      return;
    }
    var changed = false;
    if (!pointer.active) {
      changed = true;
      pointer.active = true;
      pointer.index = indx;
      pointer.size = size;
      pointer.type = type;
      pointer.normalized = normalized;
      pointer.stride = stride;
      pointer.offset = offset;
      pointer.buffer = buffer;
    } else {
      if (pointer.buffer !== buffer) {
        pointer.buffer = buffer;
        changed = true;
      }
      if (pointer.size !== size) {
        pointer.size = size;
        changed = true;
      }
      if (pointer.type !== type) {
        pointer.type = type;
        changed = true;
      }
      if (pointer.normalized !== normalized) {
        pointer.normalized = normalized;
        changed = true;
      }
      if (pointer.stride !== stride) {
        pointer.stride = stride;
        changed = true;
      }
      if (pointer.offset !== offset) {
        pointer.offset = offset;
        changed = true;
      }
    }
    if (changed || this._vaoRecordInProgress) {
      this.bindArrayBuffer(buffer);
      this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);
    }
  };
  ThinEngine2.prototype._bindIndexBufferWithCache = function(indexBuffer) {
    if (indexBuffer == null) {
      return;
    }
    if (this._cachedIndexBuffer !== indexBuffer) {
      this._cachedIndexBuffer = indexBuffer;
      this.bindIndexBuffer(indexBuffer);
      this._uintIndicesCurrentlySet = indexBuffer.is32Bits;
    }
  };
  ThinEngine2.prototype._bindVertexBuffersAttributes = function(vertexBuffers, effect, overrideVertexBuffers) {
    var attributes = effect.getAttributesNames();
    if (!this._vaoRecordInProgress) {
      this._unbindVertexArrayObject();
    }
    this.unbindAllAttributes();
    for (var index = 0; index < attributes.length; index++) {
      var order = effect.getAttributeLocation(index);
      if (order >= 0) {
        var ai = attributes[index];
        var vertexBuffer = null;
        if (overrideVertexBuffers) {
          vertexBuffer = overrideVertexBuffers[ai];
        }
        if (!vertexBuffer) {
          vertexBuffer = vertexBuffers[ai];
        }
        if (!vertexBuffer) {
          continue;
        }
        this._gl.enableVertexAttribArray(order);
        if (!this._vaoRecordInProgress) {
          this._vertexAttribArraysEnabled[order] = true;
        }
        var buffer = vertexBuffer.getBuffer();
        if (buffer) {
          this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);
          if (vertexBuffer.getIsInstanced()) {
            this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());
            if (!this._vaoRecordInProgress) {
              this._currentInstanceLocations.push(order);
              this._currentInstanceBuffers.push(buffer);
            }
          }
        }
      }
    }
  };
  ThinEngine2.prototype.recordVertexArrayObject = function(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    var vao = this._gl.createVertexArray();
    this._vaoRecordInProgress = true;
    this._gl.bindVertexArray(vao);
    this._mustWipeVertexAttributes = true;
    this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
    this.bindIndexBuffer(indexBuffer);
    this._vaoRecordInProgress = false;
    this._gl.bindVertexArray(null);
    return vao;
  };
  ThinEngine2.prototype.bindVertexArrayObject = function(vertexArrayObject, indexBuffer) {
    if (this._cachedVertexArrayObject !== vertexArrayObject) {
      this._cachedVertexArrayObject = vertexArrayObject;
      this._gl.bindVertexArray(vertexArrayObject);
      this._cachedVertexBuffers = null;
      this._cachedIndexBuffer = null;
      this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;
      this._mustWipeVertexAttributes = true;
    }
  };
  ThinEngine2.prototype.bindBuffersDirectly = function(vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {
    if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffer;
      this._cachedEffectForVertexBuffers = effect;
      var attributesCount = effect.getAttributesCount();
      this._unbindVertexArrayObject();
      this.unbindAllAttributes();
      var offset = 0;
      for (var index = 0; index < attributesCount; index++) {
        if (index < vertexDeclaration.length) {
          var order = effect.getAttributeLocation(index);
          if (order >= 0) {
            this._gl.enableVertexAttribArray(order);
            this._vertexAttribArraysEnabled[order] = true;
            this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);
          }
          offset += vertexDeclaration[index] * 4;
        }
      }
    }
    this._bindIndexBufferWithCache(indexBuffer);
  };
  ThinEngine2.prototype._unbindVertexArrayObject = function() {
    if (!this._cachedVertexArrayObject) {
      return;
    }
    this._cachedVertexArrayObject = null;
    this._gl.bindVertexArray(null);
  };
  ThinEngine2.prototype.bindBuffers = function(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
    if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {
      this._cachedVertexBuffers = vertexBuffers;
      this._cachedEffectForVertexBuffers = effect;
      this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
    }
    this._bindIndexBufferWithCache(indexBuffer);
  };
  ThinEngine2.prototype.unbindInstanceAttributes = function() {
    var boundBuffer;
    for (var i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {
      var instancesBuffer = this._currentInstanceBuffers[i];
      if (boundBuffer != instancesBuffer && instancesBuffer.references) {
        boundBuffer = instancesBuffer;
        this.bindArrayBuffer(instancesBuffer);
      }
      var offsetLocation = this._currentInstanceLocations[i];
      this._gl.vertexAttribDivisor(offsetLocation, 0);
    }
    this._currentInstanceBuffers.length = 0;
    this._currentInstanceLocations.length = 0;
  };
  ThinEngine2.prototype.releaseVertexArrayObject = function(vao) {
    this._gl.deleteVertexArray(vao);
  };
  ThinEngine2.prototype._releaseBuffer = function(buffer) {
    buffer.references--;
    if (buffer.references === 0) {
      this._deleteBuffer(buffer);
      return true;
    }
    return false;
  };
  ThinEngine2.prototype._deleteBuffer = function(buffer) {
    this._gl.deleteBuffer(buffer.underlyingResource);
  };
  ThinEngine2.prototype.updateAndBindInstancesBuffer = function(instancesBuffer, data, offsetLocations) {
    this.bindArrayBuffer(instancesBuffer);
    if (data) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
    if (offsetLocations[0].index !== void 0) {
      this.bindInstancesBuffer(instancesBuffer, offsetLocations, true);
    } else {
      for (var index = 0; index < 4; index++) {
        var offsetLocation = offsetLocations[index];
        if (!this._vertexAttribArraysEnabled[offsetLocation]) {
          this._gl.enableVertexAttribArray(offsetLocation);
          this._vertexAttribArraysEnabled[offsetLocation] = true;
        }
        this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);
        this._gl.vertexAttribDivisor(offsetLocation, 1);
        this._currentInstanceLocations.push(offsetLocation);
        this._currentInstanceBuffers.push(instancesBuffer);
      }
    }
  };
  ThinEngine2.prototype.bindInstancesBuffer = function(instancesBuffer, attributesInfo, computeStride) {
    if (computeStride === void 0) {
      computeStride = true;
    }
    this.bindArrayBuffer(instancesBuffer);
    var stride = 0;
    if (computeStride) {
      for (var i = 0; i < attributesInfo.length; i++) {
        var ai = attributesInfo[i];
        stride += ai.attributeSize * 4;
      }
    }
    for (var i = 0; i < attributesInfo.length; i++) {
      var ai = attributesInfo[i];
      if (ai.index === void 0) {
        ai.index = this._currentEffect.getAttributeLocationByName(ai.attributeName);
      }
      if (ai.index < 0) {
        continue;
      }
      if (!this._vertexAttribArraysEnabled[ai.index]) {
        this._gl.enableVertexAttribArray(ai.index);
        this._vertexAttribArraysEnabled[ai.index] = true;
      }
      this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);
      this._gl.vertexAttribDivisor(ai.index, ai.divisor === void 0 ? 1 : ai.divisor);
      this._currentInstanceLocations.push(ai.index);
      this._currentInstanceBuffers.push(instancesBuffer);
    }
  };
  ThinEngine2.prototype.disableInstanceAttributeByName = function(name2) {
    if (!this._currentEffect) {
      return;
    }
    var attributeLocation = this._currentEffect.getAttributeLocationByName(name2);
    this.disableInstanceAttribute(attributeLocation);
  };
  ThinEngine2.prototype.disableInstanceAttribute = function(attributeLocation) {
    var shouldClean = false;
    var index;
    while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {
      this._currentInstanceLocations.splice(index, 1);
      this._currentInstanceBuffers.splice(index, 1);
      shouldClean = true;
      index = this._currentInstanceLocations.indexOf(attributeLocation);
    }
    if (shouldClean) {
      this._gl.vertexAttribDivisor(attributeLocation, 0);
      this.disableAttributeByIndex(attributeLocation);
    }
  };
  ThinEngine2.prototype.disableAttributeByIndex = function(attributeLocation) {
    this._gl.disableVertexAttribArray(attributeLocation);
    this._vertexAttribArraysEnabled[attributeLocation] = false;
    this._currentBufferPointers[attributeLocation].active = false;
  };
  ThinEngine2.prototype.draw = function(useTriangles, indexStart, indexCount, instancesCount) {
    this.drawElementsType(useTriangles ? 0 : 1, indexStart, indexCount, instancesCount);
  };
  ThinEngine2.prototype.drawPointClouds = function(verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(2, verticesStart, verticesCount, instancesCount);
  };
  ThinEngine2.prototype.drawUnIndexed = function(useTriangles, verticesStart, verticesCount, instancesCount) {
    this.drawArraysType(useTriangles ? 0 : 1, verticesStart, verticesCount, instancesCount);
  };
  ThinEngine2.prototype.drawElementsType = function(fillMode, indexStart, indexCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    var drawMode = this._drawMode(fillMode);
    var indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;
    var mult = this._uintIndicesCurrentlySet ? 4 : 2;
    if (instancesCount) {
      this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);
    } else {
      this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);
    }
  };
  ThinEngine2.prototype.drawArraysType = function(fillMode, verticesStart, verticesCount, instancesCount) {
    this.applyStates();
    this._reportDrawCall();
    var drawMode = this._drawMode(fillMode);
    if (instancesCount) {
      this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);
    } else {
      this._gl.drawArrays(drawMode, verticesStart, verticesCount);
    }
  };
  ThinEngine2.prototype._drawMode = function(fillMode) {
    switch (fillMode) {
      case 0:
        return this._gl.TRIANGLES;
      case 2:
        return this._gl.POINTS;
      case 1:
        return this._gl.LINES;
      case 3:
        return this._gl.POINTS;
      case 4:
        return this._gl.LINES;
      case 5:
        return this._gl.LINE_LOOP;
      case 6:
        return this._gl.LINE_STRIP;
      case 7:
        return this._gl.TRIANGLE_STRIP;
      case 8:
        return this._gl.TRIANGLE_FAN;
      default:
        return this._gl.TRIANGLES;
    }
  };
  ThinEngine2.prototype._reportDrawCall = function() {
  };
  ThinEngine2.prototype._releaseEffect = function(effect) {
    if (this._compiledEffects[effect._key]) {
      delete this._compiledEffects[effect._key];
      var pipelineContext = effect.getPipelineContext();
      if (pipelineContext) {
        this._deletePipelineContext(pipelineContext);
      }
    }
  };
  ThinEngine2.prototype._deletePipelineContext = function(pipelineContext) {
    var webGLPipelineContext = pipelineContext;
    if (webGLPipelineContext && webGLPipelineContext.program) {
      webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;
      this._gl.deleteProgram(webGLPipelineContext.program);
    }
  };
  ThinEngine2.prototype._getGlobalDefines = function(defines) {
    if (defines) {
      if (this.isNDCHalfZRange) {
        defines["IS_NDC_HALF_ZRANGE"] = "";
      } else {
        delete defines["IS_NDC_HALF_ZRANGE"];
      }
      if (this.useReverseDepthBuffer) {
        defines["USE_REVERSE_DEPTHBUFFER"] = "";
      } else {
        delete defines["USE_REVERSE_DEPTHBUFFER"];
      }
      return;
    } else {
      var s = "";
      if (this.isNDCHalfZRange) {
        s += "#define IS_NDC_HALF_ZRANGE";
      }
      if (this.useReverseDepthBuffer) {
        if (s) {
          s += "\n";
        }
        s += "#define USE_REVERSE_DEPTHBUFFER";
      }
      return s;
    }
  };
  ThinEngine2.prototype.createEffect = function(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage) {
    var _a2;
    if (shaderLanguage === void 0) {
      shaderLanguage = ShaderLanguage.GLSL;
    }
    var vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;
    var fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;
    var globalDefines = this._getGlobalDefines();
    var fullDefines = (_a2 = defines !== null && defines !== void 0 ? defines : attributesNamesOrOptions.defines) !== null && _a2 !== void 0 ? _a2 : "";
    if (globalDefines) {
      fullDefines += globalDefines;
    }
    var name2 = vertex + "+" + fragment + "@" + fullDefines;
    if (this._compiledEffects[name2]) {
      var compiledEffect = this._compiledEffects[name2];
      if (onCompiled && compiledEffect.isReady()) {
        onCompiled(compiledEffect);
      }
      return compiledEffect;
    }
    var effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name2, shaderLanguage);
    this._compiledEffects[name2] = effect;
    return effect;
  };
  ThinEngine2._ConcatenateShader = function(source, defines, shaderVersion) {
    if (shaderVersion === void 0) {
      shaderVersion = "";
    }
    return shaderVersion + (defines ? defines + "\n" : "") + source;
  };
  ThinEngine2.prototype._compileShader = function(source, type, defines, shaderVersion) {
    return this._compileRawShader(ThinEngine2._ConcatenateShader(source, defines, shaderVersion), type);
  };
  ThinEngine2.prototype._compileRawShader = function(source, type) {
    var gl = this._gl;
    var shader2 = gl.createShader(type === "vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
    if (!shader2) {
      var error = gl.NO_ERROR;
      var tempError = gl.NO_ERROR;
      while ((tempError = gl.getError()) !== gl.NO_ERROR) {
        error = tempError;
      }
      throw new Error("Something went wrong while creating a gl ".concat(type, " shader object. gl error=").concat(error, ", gl isContextLost=").concat(gl.isContextLost(), ", _contextWasLost=").concat(this._contextWasLost));
    }
    gl.shaderSource(shader2, source);
    gl.compileShader(shader2);
    return shader2;
  };
  ThinEngine2.prototype._getShaderSource = function(shader2) {
    return this._gl.getShaderSource(shader2);
  };
  ThinEngine2.prototype.createRawShaderProgram = function(pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    context = context || this._gl;
    var vertexShader = this._compileRawShader(vertexCode, "vertex");
    var fragmentShader = this._compileRawShader(fragmentCode, "fragment");
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  };
  ThinEngine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    context = context || this._gl;
    var shaderVersion = this._webGLVersion > 1 ? "#version 300 es\n#define WEBGL2 \n" : "";
    var vertexShader = this._compileShader(vertexCode, "vertex", defines, shaderVersion);
    var fragmentShader = this._compileShader(fragmentCode, "fragment", defines, shaderVersion);
    return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
  };
  ThinEngine2.prototype.inlineShaderCode = function(code) {
    return code;
  };
  ThinEngine2.prototype.createPipelineContext = function(shaderProcessingContext) {
    var pipelineContext = new WebGLPipelineContext();
    pipelineContext.engine = this;
    if (this._caps.parallelShaderCompile) {
      pipelineContext.isParallelCompiled = true;
    }
    return pipelineContext;
  };
  ThinEngine2.prototype.createMaterialContext = function() {
    return void 0;
  };
  ThinEngine2.prototype.createDrawContext = function() {
    return void 0;
  };
  ThinEngine2.prototype._createShaderProgram = function(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {
    var shaderProgram = context.createProgram();
    pipelineContext.program = shaderProgram;
    if (!shaderProgram) {
      throw new Error("Unable to create program");
    }
    context.attachShader(shaderProgram, vertexShader);
    context.attachShader(shaderProgram, fragmentShader);
    context.linkProgram(shaderProgram);
    pipelineContext.context = context;
    pipelineContext.vertexShader = vertexShader;
    pipelineContext.fragmentShader = fragmentShader;
    if (!pipelineContext.isParallelCompiled) {
      this._finalizePipelineContext(pipelineContext);
    }
    return shaderProgram;
  };
  ThinEngine2.prototype._finalizePipelineContext = function(pipelineContext) {
    var context = pipelineContext.context;
    var vertexShader = pipelineContext.vertexShader;
    var fragmentShader = pipelineContext.fragmentShader;
    var program = pipelineContext.program;
    var linked = context.getProgramParameter(program, context.LINK_STATUS);
    if (!linked) {
      if (!this._gl.getShaderParameter(vertexShader, this._gl.COMPILE_STATUS)) {
        var log = this._gl.getShaderInfoLog(vertexShader);
        if (log) {
          pipelineContext.vertexCompilationError = log;
          throw new Error("VERTEX SHADER " + log);
        }
      }
      if (!this._gl.getShaderParameter(fragmentShader, this._gl.COMPILE_STATUS)) {
        var log = this._gl.getShaderInfoLog(fragmentShader);
        if (log) {
          pipelineContext.fragmentCompilationError = log;
          throw new Error("FRAGMENT SHADER " + log);
        }
      }
      var error = context.getProgramInfoLog(program);
      if (error) {
        pipelineContext.programLinkError = error;
        throw new Error(error);
      }
    }
    if (this.validateShaderPrograms) {
      context.validateProgram(program);
      var validated = context.getProgramParameter(program, context.VALIDATE_STATUS);
      if (!validated) {
        var error = context.getProgramInfoLog(program);
        if (error) {
          pipelineContext.programValidationError = error;
          throw new Error(error);
        }
      }
    }
    context.deleteShader(vertexShader);
    context.deleteShader(fragmentShader);
    pipelineContext.vertexShader = void 0;
    pipelineContext.fragmentShader = void 0;
    if (pipelineContext.onCompiled) {
      pipelineContext.onCompiled();
      pipelineContext.onCompiled = void 0;
    }
  };
  ThinEngine2.prototype._preparePipelineContext = function(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines, transformFeedbackVaryings, key) {
    var webGLRenderingState = pipelineContext;
    if (createAsRaw) {
      webGLRenderingState.program = this.createRawShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, void 0, transformFeedbackVaryings);
    } else {
      webGLRenderingState.program = this.createShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, defines, void 0, transformFeedbackVaryings);
    }
    webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;
  };
  ThinEngine2.prototype._isRenderingStateCompiled = function(pipelineContext) {
    var webGLPipelineContext = pipelineContext;
    if (this._gl.getProgramParameter(webGLPipelineContext.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)) {
      this._finalizePipelineContext(webGLPipelineContext);
      return true;
    }
    return false;
  };
  ThinEngine2.prototype._executeWhenRenderingStateIsCompiled = function(pipelineContext, action) {
    var webGLPipelineContext = pipelineContext;
    if (!webGLPipelineContext.isParallelCompiled) {
      action();
      return;
    }
    var oldHandler = webGLPipelineContext.onCompiled;
    if (oldHandler) {
      webGLPipelineContext.onCompiled = function() {
        oldHandler();
        action();
      };
    } else {
      webGLPipelineContext.onCompiled = action;
    }
  };
  ThinEngine2.prototype.getUniforms = function(pipelineContext, uniformsNames) {
    var results = new Array();
    var webGLPipelineContext = pipelineContext;
    for (var index = 0; index < uniformsNames.length; index++) {
      results.push(this._gl.getUniformLocation(webGLPipelineContext.program, uniformsNames[index]));
    }
    return results;
  };
  ThinEngine2.prototype.getAttributes = function(pipelineContext, attributesNames) {
    var results = [];
    var webGLPipelineContext = pipelineContext;
    for (var index = 0; index < attributesNames.length; index++) {
      try {
        results.push(this._gl.getAttribLocation(webGLPipelineContext.program, attributesNames[index]));
      } catch (e) {
        results.push(-1);
      }
    }
    return results;
  };
  ThinEngine2.prototype.enableEffect = function(effect) {
    effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect;
    if (!effect || effect === this._currentEffect) {
      return;
    }
    this._stencilStateComposer.stencilMaterial = void 0;
    effect = effect;
    this.bindSamplers(effect);
    this._currentEffect = effect;
    if (effect.onBind) {
      effect.onBind(effect);
    }
    if (effect._onBindObservable) {
      effect._onBindObservable.notifyObservers(effect);
    }
  };
  ThinEngine2.prototype.setInt = function(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1i(uniform, value);
    return true;
  };
  ThinEngine2.prototype.setInt2 = function(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2i(uniform, x, y);
    return true;
  };
  ThinEngine2.prototype.setInt3 = function(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3i(uniform, x, y, z);
    return true;
  };
  ThinEngine2.prototype.setInt4 = function(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4i(uniform, x, y, z, w);
    return true;
  };
  ThinEngine2.prototype.setIntArray = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setIntArray2 = function(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setIntArray3 = function(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setIntArray4 = function(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4iv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray = function(uniform, array) {
    if (!uniform) {
      return false;
    }
    if (array.length < 1) {
      return false;
    }
    this._gl.uniform1fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray2 = function(uniform, array) {
    if (!uniform || array.length % 2 !== 0) {
      return false;
    }
    this._gl.uniform2fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray3 = function(uniform, array) {
    if (!uniform || array.length % 3 !== 0) {
      return false;
    }
    this._gl.uniform3fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setArray4 = function(uniform, array) {
    if (!uniform || array.length % 4 !== 0) {
      return false;
    }
    this._gl.uniform4fv(uniform, array);
    return true;
  };
  ThinEngine2.prototype.setMatrices = function(uniform, matrices) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix4fv(uniform, false, matrices);
    return true;
  };
  ThinEngine2.prototype.setMatrix3x3 = function(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix3fv(uniform, false, matrix);
    return true;
  };
  ThinEngine2.prototype.setMatrix2x2 = function(uniform, matrix) {
    if (!uniform) {
      return false;
    }
    this._gl.uniformMatrix2fv(uniform, false, matrix);
    return true;
  };
  ThinEngine2.prototype.setFloat = function(uniform, value) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform1f(uniform, value);
    return true;
  };
  ThinEngine2.prototype.setFloat2 = function(uniform, x, y) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform2f(uniform, x, y);
    return true;
  };
  ThinEngine2.prototype.setFloat3 = function(uniform, x, y, z) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform3f(uniform, x, y, z);
    return true;
  };
  ThinEngine2.prototype.setFloat4 = function(uniform, x, y, z, w) {
    if (!uniform) {
      return false;
    }
    this._gl.uniform4f(uniform, x, y, z, w);
    return true;
  };
  ThinEngine2.prototype.applyStates = function() {
    this._depthCullingState.apply(this._gl);
    this._stencilStateComposer.apply(this._gl);
    this._alphaState.apply(this._gl);
    if (this._colorWriteChanged) {
      this._colorWriteChanged = false;
      var enable = this._colorWrite;
      this._gl.colorMask(enable, enable, enable, enable);
    }
  };
  ThinEngine2.prototype.setColorWrite = function(enable) {
    if (enable !== this._colorWrite) {
      this._colorWriteChanged = true;
      this._colorWrite = enable;
    }
  };
  ThinEngine2.prototype.getColorWrite = function() {
    return this._colorWrite;
  };
  Object.defineProperty(ThinEngine2.prototype, "depthCullingState", {
    get: function() {
      return this._depthCullingState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "alphaState", {
    get: function() {
      return this._alphaState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "stencilState", {
    get: function() {
      return this._stencilState;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2.prototype, "stencilStateComposer", {
    get: function() {
      return this._stencilStateComposer;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.prototype.clearInternalTexturesCache = function() {
    this._internalTexturesCache = [];
  };
  ThinEngine2.prototype.wipeCaches = function(bruteForce) {
    if (this.preventCacheWipeBetweenFrames && !bruteForce) {
      return;
    }
    this._currentEffect = null;
    this._viewportCached.x = 0;
    this._viewportCached.y = 0;
    this._viewportCached.z = 0;
    this._viewportCached.w = 0;
    this._unbindVertexArrayObject();
    if (bruteForce) {
      this._currentProgram = null;
      this.resetTextureCache();
      this._stencilStateComposer.reset();
      this._depthCullingState.reset();
      this._depthCullingState.depthFunc = this._gl.LEQUAL;
      this._alphaState.reset();
      this._alphaMode = 1;
      this._alphaEquation = 0;
      this._colorWrite = true;
      this._colorWriteChanged = true;
      this._unpackFlipYCached = null;
      this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
      this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
      this._mustWipeVertexAttributes = true;
      this.unbindAllAttributes();
    }
    this._resetVertexBufferBinding();
    this._cachedIndexBuffer = null;
    this._cachedEffectForVertexBuffers = null;
    this.bindIndexBuffer(null);
  };
  ThinEngine2.prototype._getSamplingParameters = function(samplingMode, generateMipMaps) {
    var gl = this._gl;
    var magFilter = gl.NEAREST;
    var minFilter = gl.NEAREST;
    switch (samplingMode) {
      case 11:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 3:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 8:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 4:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 5:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_NEAREST;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 6:
        magFilter = gl.NEAREST;
        if (generateMipMaps) {
          minFilter = gl.LINEAR_MIPMAP_LINEAR;
        } else {
          minFilter = gl.LINEAR;
        }
        break;
      case 7:
        magFilter = gl.NEAREST;
        minFilter = gl.LINEAR;
        break;
      case 1:
        magFilter = gl.NEAREST;
        minFilter = gl.NEAREST;
        break;
      case 9:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_NEAREST;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 10:
        magFilter = gl.LINEAR;
        if (generateMipMaps) {
          minFilter = gl.NEAREST_MIPMAP_LINEAR;
        } else {
          minFilter = gl.NEAREST;
        }
        break;
      case 2:
        magFilter = gl.LINEAR;
        minFilter = gl.LINEAR;
        break;
      case 12:
        magFilter = gl.LINEAR;
        minFilter = gl.NEAREST;
        break;
    }
    return {
      min: minFilter,
      mag: magFilter
    };
  };
  ThinEngine2.prototype._createTexture = function() {
    var texture = this._gl.createTexture();
    if (!texture) {
      throw new Error("Unable to create texture");
    }
    return texture;
  };
  ThinEngine2.prototype._createHardwareTexture = function() {
    return new WebGLHardwareTexture(this._createTexture(), this._gl);
  };
  ThinEngine2.prototype._createInternalTexture = function(size, options, delayGPUTextureCreation, source) {
    if (source === void 0) {
      source = InternalTextureSource.Unknown;
    }
    var fullOptions = {};
    if (options !== void 0 && typeof options === "object") {
      fullOptions.generateMipMaps = options.generateMipMaps;
      fullOptions.type = options.type === void 0 ? 0 : options.type;
      fullOptions.samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
      fullOptions.format = options.format === void 0 ? 5 : options.format;
      fullOptions.useSRGBBuffer = options.useSRGBBuffer === void 0 ? false : options.useSRGBBuffer;
    } else {
      fullOptions.generateMipMaps = options;
      fullOptions.type = 0;
      fullOptions.samplingMode = 3;
      fullOptions.format = 5;
      fullOptions.useSRGBBuffer = false;
    }
    fullOptions.useSRGBBuffer = fullOptions.useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU);
    if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
      fullOptions.samplingMode = 1;
    }
    if (fullOptions.type === 1 && !this._caps.textureFloat) {
      fullOptions.type = 0;
      Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
    }
    var gl = this._gl;
    var texture = new InternalTexture(this, source);
    texture._useSRGBBuffer = !!fullOptions.useSRGBBuffer;
    var width = size.width || size;
    var height = size.height || size;
    var layers = size.layers || 0;
    var filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps ? true : false);
    var target2 = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
    var sizedFormat = this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format, fullOptions.useSRGBBuffer);
    var internalFormat = this._getInternalFormat(fullOptions.format);
    var type = this._getWebGLTextureType(fullOptions.type);
    this._bindTextureDirectly(target2, texture);
    if (layers !== 0) {
      texture.is2DArray = true;
      gl.texImage3D(target2, 0, sizedFormat, width, height, layers, 0, internalFormat, type, null);
    } else {
      gl.texImage2D(target2, 0, sizedFormat, width, height, 0, internalFormat, type, null);
    }
    gl.texParameteri(target2, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(target2, gl.TEXTURE_MIN_FILTER, filters.min);
    gl.texParameteri(target2, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target2, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (fullOptions.generateMipMaps) {
      this._gl.generateMipmap(target2);
    }
    this._bindTextureDirectly(target2, null);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.width = width;
    texture.height = height;
    texture.depth = layers;
    texture.isReady = true;
    texture.samples = 1;
    texture.generateMipMaps = fullOptions.generateMipMaps ? true : false;
    texture.samplingMode = fullOptions.samplingMode;
    texture.type = fullOptions.type;
    texture.format = fullOptions.format;
    this._internalTexturesCache.push(texture);
    return texture;
  };
  ThinEngine2.prototype._getUseSRGBBuffer = function(useSRGBBuffer, noMipmap) {
    return useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || noMipmap);
  };
  ThinEngine2.prototype._createTextureBase = function(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, prepareTexture, prepareTextureProcessFunction, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer) {
    var _this = this;
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (fallback === void 0) {
      fallback = null;
    }
    if (format === void 0) {
      format = null;
    }
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    url = url || "";
    var fromData = url.substr(0, 5) === "data:";
    var fromBlob = url.substr(0, 5) === "blob:";
    var isBase64 = fromData && url.indexOf(";base64,") !== -1;
    var texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
    var originalUrl = url;
    if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {
      url = this._transformTextureUrl(url);
    }
    if (originalUrl !== url) {
      texture._originalUrl = originalUrl;
    }
    var lastDot = url.lastIndexOf(".");
    var extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
    var loader = null;
    var queryStringIndex = extension.indexOf("?");
    if (queryStringIndex > -1) {
      extension = extension.split("?")[0];
    }
    for (var _i = 0, _a2 = ThinEngine2._TextureLoaders; _i < _a2.length; _i++) {
      var availableLoader = _a2[_i];
      if (availableLoader.canLoad(extension, mimeType)) {
        loader = availableLoader;
        break;
      }
    }
    if (scene) {
      scene._addPendingData(texture);
    }
    texture.url = url;
    texture.generateMipMaps = !noMipmap;
    texture.samplingMode = samplingMode;
    texture.invertY = invertY;
    texture._useSRGBBuffer = this._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
    if (!this._doNotHandleContextLost) {
      texture._buffer = buffer;
    }
    var onLoadObserver = null;
    if (onLoad && !fallback) {
      onLoadObserver = texture.onLoadedObservable.add(onLoad);
    }
    if (!fallback) {
      this._internalTexturesCache.push(texture);
    }
    var onInternalError = function(message, exception) {
      if (scene) {
        scene._removePendingData(texture);
      }
      if (url === originalUrl) {
        if (onLoadObserver) {
          texture.onLoadedObservable.remove(onLoadObserver);
        }
        if (EngineStore.UseFallbackTexture) {
          _this._createTextureBase(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture);
        }
        message = (message || "Unknown error") + (EngineStore.UseFallbackTexture ? " - Fallback texture was used" : "");
        texture.onErrorObservable.notifyObservers({ message, exception });
        if (onError) {
          onError(message, exception);
        }
      } else {
        Logger.Warn("Failed to load ".concat(url, ", falling back to ").concat(originalUrl));
        _this._createTextureBase(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
      }
    };
    if (loader) {
      var callback_1 = function(data) {
        loader.loadData(data, texture, function(width, height, loadMipmap, isCompressed, done, loadFailed) {
          if (loadFailed) {
            onInternalError("TextureLoader failed to load data");
          } else {
            prepareTexture(texture, extension, scene, { width, height }, texture.invertY, !loadMipmap, isCompressed, function() {
              done();
              return false;
            }, samplingMode);
          }
        }, loaderOptions);
      };
      if (!buffer) {
        this._loadFile(url, function(data) {
          return callback_1(new Uint8Array(data));
        }, void 0, scene ? scene.offlineProvider : void 0, true, function(request, exception) {
          onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
        });
      } else {
        if (buffer instanceof ArrayBuffer) {
          callback_1(new Uint8Array(buffer));
        } else if (ArrayBuffer.isView(buffer)) {
          callback_1(buffer);
        } else {
          if (onError) {
            onError("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null);
          }
        }
      }
    } else {
      var onload_1 = function(img) {
        if (fromBlob && !_this._doNotHandleContextLost) {
          texture._buffer = img;
        }
        prepareTexture(texture, extension, scene, img, texture.invertY, noMipmap, false, prepareTextureProcessFunction, samplingMode);
      };
      if (!fromData || isBase64) {
        if (buffer && (typeof buffer.decoding === "string" || buffer.close)) {
          onload_1(buffer);
        } else {
          ThinEngine2._FileToolsLoadImage(url, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
        }
      } else if (typeof buffer === "string" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {
        ThinEngine2._FileToolsLoadImage(buffer, onload_1, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
      } else if (buffer) {
        onload_1(buffer);
      }
    }
    return texture;
  };
  ThinEngine2.prototype.createTexture = function(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {
    var _this = this;
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (fallback === void 0) {
      fallback = null;
    }
    if (format === void 0) {
      format = null;
    }
    if (forcedExtension === void 0) {
      forcedExtension = null;
    }
    return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, this._prepareWebGLTexture.bind(this), function(potWidth, potHeight, img, extension, texture, continuationCallback) {
      var gl = _this._gl;
      var isPot = img.width === potWidth && img.height === potHeight;
      var internalFormat = format ? _this._getInternalFormat(format, texture._useSRGBBuffer) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : texture._useSRGBBuffer ? gl.SRGB8_ALPHA8 : gl.RGBA;
      var texelFormat = format ? _this._getInternalFormat(format) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : gl.RGBA;
      if (texture._useSRGBBuffer && _this.webGLVersion === 1) {
        texelFormat = internalFormat;
      }
      if (isPot) {
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
        return false;
      }
      var maxTextureSize = _this._caps.maxTextureSize;
      if (img.width > maxTextureSize || img.height > maxTextureSize || !_this._supportsHardwareTextureRescaling) {
        _this._prepareWorkingCanvas();
        if (!_this._workingCanvas || !_this._workingContext) {
          return false;
        }
        _this._workingCanvas.width = potWidth;
        _this._workingCanvas.height = potHeight;
        _this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, _this._workingCanvas);
        texture.width = potWidth;
        texture.height = potHeight;
        return false;
      } else {
        var source_1 = new InternalTexture(_this, InternalTextureSource.Temp);
        _this._bindTextureDirectly(gl.TEXTURE_2D, source_1, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
        _this._rescaleTexture(source_1, texture, scene, internalFormat, function() {
          _this._releaseTexture(source_1);
          _this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
          continuationCallback();
        });
      }
      return true;
    }, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
  };
  ThinEngine2._FileToolsLoadImage = function(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
    throw _WarnImport("FileTools");
  };
  ThinEngine2.prototype._rescaleTexture = function(source, destination, scene, internalFormat, onComplete) {
  };
  ThinEngine2.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type, creationFlags, useSRGBBuffer) {
    throw _WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {
    throw _WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype.createRawTexture3D = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
    throw _WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype.createRawTexture2DArray = function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
    throw _WarnImport("Engine.RawTexture");
  };
  ThinEngine2.prototype._unpackFlipY = function(value) {
    if (this._unpackFlipYCached !== value) {
      this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);
      if (this.enableUnpackFlipYCached) {
        this._unpackFlipYCached = value;
      }
    }
  };
  ThinEngine2.prototype._getUnpackAlignement = function() {
    return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
  };
  ThinEngine2.prototype._getTextureTarget = function(texture) {
    if (texture.isCube) {
      return this._gl.TEXTURE_CUBE_MAP;
    } else if (texture.is3D) {
      return this._gl.TEXTURE_3D;
    } else if (texture.is2DArray || texture.isMultiview) {
      return this._gl.TEXTURE_2D_ARRAY;
    }
    return this._gl.TEXTURE_2D;
  };
  ThinEngine2.prototype.updateTextureSamplingMode = function(samplingMode, texture, generateMipMaps) {
    if (generateMipMaps === void 0) {
      generateMipMaps = false;
    }
    var target2 = this._getTextureTarget(texture);
    var filters = this._getSamplingParameters(samplingMode, texture.generateMipMaps || generateMipMaps);
    this._setTextureParameterInteger(target2, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);
    this._setTextureParameterInteger(target2, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      texture.generateMipMaps = true;
      this._gl.generateMipmap(target2);
    }
    this._bindTextureDirectly(target2, null);
    texture.samplingMode = samplingMode;
  };
  ThinEngine2.prototype.updateTextureDimensions = function(texture, width, height, depth) {
  };
  ThinEngine2.prototype.updateTextureWrappingMode = function(texture, wrapU, wrapV, wrapR) {
    if (wrapV === void 0) {
      wrapV = null;
    }
    if (wrapR === void 0) {
      wrapR = null;
    }
    var target2 = this._getTextureTarget(texture);
    if (wrapU !== null) {
      this._setTextureParameterInteger(target2, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);
      texture._cachedWrapU = wrapU;
    }
    if (wrapV !== null) {
      this._setTextureParameterInteger(target2, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);
      texture._cachedWrapV = wrapV;
    }
    if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
      this._setTextureParameterInteger(target2, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);
      texture._cachedWrapR = wrapR;
    }
    this._bindTextureDirectly(target2, null);
  };
  ThinEngine2.prototype._setupDepthStencilTexture = function(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction, samples) {
    if (samples === void 0) {
      samples = 1;
    }
    var width = size.width || size;
    var height = size.height || size;
    var layers = size.layers || 0;
    internalTexture.baseWidth = width;
    internalTexture.baseHeight = height;
    internalTexture.width = width;
    internalTexture.height = height;
    internalTexture.is2DArray = layers > 0;
    internalTexture.depth = layers;
    internalTexture.isReady = true;
    internalTexture.samples = samples;
    internalTexture.generateMipMaps = false;
    internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
    internalTexture.type = 0;
    internalTexture._comparisonFunction = comparisonFunction;
    var gl = this._gl;
    var target2 = this._getTextureTarget(internalTexture);
    var samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);
    gl.texParameteri(target2, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);
    gl.texParameteri(target2, gl.TEXTURE_MIN_FILTER, samplingParameters.min);
    gl.texParameteri(target2, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(target2, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    if (comparisonFunction === 0) {
      gl.texParameteri(target2, gl.TEXTURE_COMPARE_FUNC, 515);
      gl.texParameteri(target2, gl.TEXTURE_COMPARE_MODE, gl.NONE);
    } else {
      gl.texParameteri(target2, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
      gl.texParameteri(target2, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
    }
  };
  ThinEngine2.prototype._uploadCompressedDataToTextureDirectly = function(texture, internalFormat, width, height, data, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var target2 = gl.TEXTURE_2D;
    if (texture.isCube) {
      target2 = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    if (texture._useSRGBBuffer) {
      switch (internalFormat) {
        case 37492:
        case 36196:
          if (this._caps.etc2) {
            internalFormat = gl.COMPRESSED_SRGB8_ETC2;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 37496:
          if (this._caps.etc2) {
            internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 36492:
          internalFormat = gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
          break;
        case 37808:
          internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          break;
        case 33776:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 33777:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        case 33779:
          if (this._caps.s3tc_srgb) {
            internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
          } else {
            texture._useSRGBBuffer = false;
          }
          break;
        default:
          texture._useSRGBBuffer = false;
          break;
      }
    }
    this._gl.compressedTexImage2D(target2, lod, internalFormat, width, height, 0, data);
  };
  ThinEngine2.prototype._uploadDataToTextureDirectly = function(texture, imageData, faceIndex, lod, babylonInternalFormat, useTextureWidthAndHeight) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    if (useTextureWidthAndHeight === void 0) {
      useTextureWidthAndHeight = false;
    }
    var gl = this._gl;
    var textureType = this._getWebGLTextureType(texture.type);
    var format = this._getInternalFormat(texture.format);
    var internalFormat = babylonInternalFormat === void 0 ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer) : this._getInternalFormat(babylonInternalFormat, texture._useSRGBBuffer);
    this._unpackFlipY(texture.invertY);
    var target2 = gl.TEXTURE_2D;
    if (texture.isCube) {
      target2 = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    var lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
    var lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
    var width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
    var height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
    gl.texImage2D(target2, lod, internalFormat, width, height, 0, format, textureType, imageData);
  };
  ThinEngine2.prototype.updateTextureData = function(texture, imageData, xOffset, yOffset, width, height, faceIndex, lod, generateMipMaps) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    if (generateMipMaps === void 0) {
      generateMipMaps = false;
    }
    var gl = this._gl;
    var textureType = this._getWebGLTextureType(texture.type);
    var format = this._getInternalFormat(texture.format);
    this._unpackFlipY(texture.invertY);
    var target2 = gl.TEXTURE_2D;
    if (texture.isCube) {
      target2 = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    this._bindTextureDirectly(target2, texture, true);
    gl.texSubImage2D(target2, lod, xOffset, yOffset, width, height, format, textureType, imageData);
    if (generateMipMaps) {
      this._gl.generateMipmap(target2);
    }
    this._bindTextureDirectly(target2, null);
  };
  ThinEngine2.prototype._uploadArrayBufferViewToTexture = function(texture, imageData, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._bindTextureDirectly(bindTarget, texture, true);
    this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
    this._bindTextureDirectly(bindTarget, null, true);
  };
  ThinEngine2.prototype._prepareWebGLTextureContinuation = function(texture, scene, noMipmap, isCompressed, samplingMode) {
    var gl = this._gl;
    if (!gl) {
      return;
    }
    var filters = this._getSamplingParameters(samplingMode, !noMipmap);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
    if (!noMipmap && !isCompressed) {
      gl.generateMipmap(gl.TEXTURE_2D);
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, null);
    if (scene) {
      scene._removePendingData(texture);
    }
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
  };
  ThinEngine2.prototype._prepareWebGLTexture = function(texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction, samplingMode) {
    var _this = this;
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    var maxTextureSize = this.getCaps().maxTextureSize;
    var potWidth = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine2.GetExponentOfTwo(img.width, maxTextureSize) : img.width);
    var potHeight = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine2.GetExponentOfTwo(img.height, maxTextureSize) : img.height);
    var gl = this._gl;
    if (!gl) {
      return;
    }
    if (!texture._hardwareTexture) {
      if (scene) {
        scene._removePendingData(texture);
      }
      return;
    }
    this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    texture.baseWidth = img.width;
    texture.baseHeight = img.height;
    texture.width = potWidth;
    texture.height = potHeight;
    texture.isReady = true;
    if (processFunction(potWidth, potHeight, img, extension, texture, function() {
      _this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
    })) {
      return;
    }
    this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
  };
  ThinEngine2.prototype._setupFramebufferDepthAttachments = function(generateStencilBuffer, generateDepthBuffer, width, height, samples) {
    if (samples === void 0) {
      samples = 1;
    }
    var gl = this._gl;
    if (generateStencilBuffer && generateDepthBuffer) {
      return this._createRenderBuffer(width, height, samples, gl.DEPTH_STENCIL, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);
    }
    if (generateDepthBuffer) {
      var depthFormat = gl.DEPTH_COMPONENT16;
      if (this._webGLVersion > 1) {
        depthFormat = gl.DEPTH_COMPONENT32F;
      }
      return this._createRenderBuffer(width, height, samples, depthFormat, depthFormat, gl.DEPTH_ATTACHMENT);
    }
    if (generateStencilBuffer) {
      return this._createRenderBuffer(width, height, samples, gl.STENCIL_INDEX8, gl.STENCIL_INDEX8, gl.STENCIL_ATTACHMENT);
    }
    return null;
  };
  ThinEngine2.prototype._createRenderBuffer = function(width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer) {
    if (unbindBuffer === void 0) {
      unbindBuffer = true;
    }
    var gl = this._gl;
    var renderBuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
    if (samples > 1 && gl.renderbufferStorageMultisample) {
      gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);
    } else {
      gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
    }
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer);
    if (unbindBuffer) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    }
    return renderBuffer;
  };
  ThinEngine2.prototype._releaseTexture = function(texture) {
    var _a2;
    this._deleteTexture((_a2 = texture._hardwareTexture) === null || _a2 === void 0 ? void 0 : _a2.underlyingResource);
    this.unbindAllTextures();
    var index = this._internalTexturesCache.indexOf(texture);
    if (index !== -1) {
      this._internalTexturesCache.splice(index, 1);
    }
    if (texture._lodTextureHigh) {
      texture._lodTextureHigh.dispose();
    }
    if (texture._lodTextureMid) {
      texture._lodTextureMid.dispose();
    }
    if (texture._lodTextureLow) {
      texture._lodTextureLow.dispose();
    }
    if (texture._irradianceTexture) {
      texture._irradianceTexture.dispose();
    }
  };
  ThinEngine2.prototype._releaseRenderTargetWrapper = function(rtWrapper) {
    var index = this._renderTargetWrapperCache.indexOf(rtWrapper);
    if (index !== -1) {
      this._renderTargetWrapperCache.splice(index, 1);
    }
  };
  ThinEngine2.prototype._deleteTexture = function(texture) {
    if (texture) {
      this._gl.deleteTexture(texture);
    }
  };
  ThinEngine2.prototype._setProgram = function(program) {
    if (this._currentProgram !== program) {
      this._gl.useProgram(program);
      this._currentProgram = program;
    }
  };
  ThinEngine2.prototype.bindSamplers = function(effect) {
    var webGLPipelineContext = effect.getPipelineContext();
    this._setProgram(webGLPipelineContext.program);
    var samplers = effect.getSamplers();
    for (var index = 0; index < samplers.length; index++) {
      var uniform = effect.getUniform(samplers[index]);
      if (uniform) {
        this._boundUniforms[index] = uniform;
      }
    }
    this._currentEffect = null;
  };
  ThinEngine2.prototype._activateCurrentTexture = function() {
    if (this._currentTextureChannel !== this._activeChannel) {
      this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);
      this._currentTextureChannel = this._activeChannel;
    }
  };
  ThinEngine2.prototype._bindTextureDirectly = function(target2, texture, forTextureDataUpdate, force) {
    var _a2, _b2;
    if (forTextureDataUpdate === void 0) {
      forTextureDataUpdate = false;
    }
    if (force === void 0) {
      force = false;
    }
    var wasPreviouslyBound = false;
    var isTextureForRendering = texture && texture._associatedChannel > -1;
    if (forTextureDataUpdate && isTextureForRendering) {
      this._activeChannel = texture._associatedChannel;
    }
    var currentTextureBound = this._boundTexturesCache[this._activeChannel];
    if (currentTextureBound !== texture || force) {
      this._activateCurrentTexture();
      if (texture && texture.isMultiview) {
        console.error(target2, texture);
        throw "_bindTextureDirectly called with a multiview texture!";
      } else {
        this._gl.bindTexture(target2, (_b2 = (_a2 = texture === null || texture === void 0 ? void 0 : texture._hardwareTexture) === null || _a2 === void 0 ? void 0 : _a2.underlyingResource) !== null && _b2 !== void 0 ? _b2 : null);
      }
      this._boundTexturesCache[this._activeChannel] = texture;
      if (texture) {
        texture._associatedChannel = this._activeChannel;
      }
    } else if (forTextureDataUpdate) {
      wasPreviouslyBound = true;
      this._activateCurrentTexture();
    }
    if (isTextureForRendering && !forTextureDataUpdate) {
      this._bindSamplerUniformToChannel(texture._associatedChannel, this._activeChannel);
    }
    return wasPreviouslyBound;
  };
  ThinEngine2.prototype._bindTexture = function(channel, texture, name2) {
    if (channel === void 0) {
      return;
    }
    if (texture) {
      texture._associatedChannel = channel;
    }
    this._activeChannel = channel;
    var target2 = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;
    this._bindTextureDirectly(target2, texture);
  };
  ThinEngine2.prototype.unbindAllTextures = function() {
    for (var channel = 0; channel < this._maxSimultaneousTextures; channel++) {
      this._activeChannel = channel;
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
      if (this.webGLVersion > 1) {
        this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
      }
    }
  };
  ThinEngine2.prototype.setTexture = function(channel, uniform, texture, name2) {
    if (channel === void 0) {
      return;
    }
    if (uniform) {
      this._boundUniforms[channel] = uniform;
    }
    this._setTexture(channel, texture);
  };
  ThinEngine2.prototype._bindSamplerUniformToChannel = function(sourceSlot, destination) {
    var uniform = this._boundUniforms[sourceSlot];
    if (!uniform || uniform._currentState === destination) {
      return;
    }
    this._gl.uniform1i(uniform, destination);
    uniform._currentState = destination;
  };
  ThinEngine2.prototype._getTextureWrapMode = function(mode) {
    switch (mode) {
      case 1:
        return this._gl.REPEAT;
      case 0:
        return this._gl.CLAMP_TO_EDGE;
      case 2:
        return this._gl.MIRRORED_REPEAT;
    }
    return this._gl.REPEAT;
  };
  ThinEngine2.prototype._setTexture = function(channel, texture, isPartOfTextureArray, depthStencilTexture, name2) {
    if (isPartOfTextureArray === void 0) {
      isPartOfTextureArray = false;
    }
    if (depthStencilTexture === void 0) {
      depthStencilTexture = false;
    }
    if (!texture) {
      if (this._boundTexturesCache[channel] != null) {
        this._activeChannel = channel;
        this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
        if (this.webGLVersion > 1) {
          this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
          this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
        }
      }
      return false;
    }
    if (texture.video) {
      this._activeChannel = channel;
      texture.update();
    } else if (texture.delayLoadState === 4) {
      texture.delayLoad();
      return false;
    }
    var internalTexture;
    if (depthStencilTexture) {
      internalTexture = texture.depthStencilTexture;
    } else if (texture.isReady()) {
      internalTexture = texture.getInternalTexture();
    } else if (texture.isCube) {
      internalTexture = this.emptyCubeTexture;
    } else if (texture.is3D) {
      internalTexture = this.emptyTexture3D;
    } else if (texture.is2DArray) {
      internalTexture = this.emptyTexture2DArray;
    } else {
      internalTexture = this.emptyTexture;
    }
    if (!isPartOfTextureArray && internalTexture) {
      internalTexture._associatedChannel = channel;
    }
    var needToBind = true;
    if (this._boundTexturesCache[channel] === internalTexture) {
      if (!isPartOfTextureArray) {
        this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);
      }
      needToBind = false;
    }
    this._activeChannel = channel;
    var target2 = this._getTextureTarget(internalTexture);
    if (needToBind) {
      this._bindTextureDirectly(target2, internalTexture, isPartOfTextureArray);
    }
    if (internalTexture && !internalTexture.isMultiview) {
      if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
        internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
        var textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;
        texture.wrapU = textureWrapMode;
        texture.wrapV = textureWrapMode;
      }
      if (internalTexture._cachedWrapU !== texture.wrapU) {
        internalTexture._cachedWrapU = texture.wrapU;
        this._setTextureParameterInteger(target2, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);
      }
      if (internalTexture._cachedWrapV !== texture.wrapV) {
        internalTexture._cachedWrapV = texture.wrapV;
        this._setTextureParameterInteger(target2, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);
      }
      if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {
        internalTexture._cachedWrapR = texture.wrapR;
        this._setTextureParameterInteger(target2, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);
      }
      this._setAnisotropicLevel(target2, internalTexture, texture.anisotropicFilteringLevel);
    }
    return true;
  };
  ThinEngine2.prototype.setTextureArray = function(channel, uniform, textures, name2) {
    if (channel === void 0 || !uniform) {
      return;
    }
    if (!this._textureUnits || this._textureUnits.length !== textures.length) {
      this._textureUnits = new Int32Array(textures.length);
    }
    for (var i = 0; i < textures.length; i++) {
      var texture = textures[i].getInternalTexture();
      if (texture) {
        this._textureUnits[i] = channel + i;
        texture._associatedChannel = channel + i;
      } else {
        this._textureUnits[i] = -1;
      }
    }
    this._gl.uniform1iv(uniform, this._textureUnits);
    for (var index = 0; index < textures.length; index++) {
      this._setTexture(this._textureUnits[index], textures[index], true);
    }
  };
  ThinEngine2.prototype._setAnisotropicLevel = function(target2, internalTexture, anisotropicFilteringLevel) {
    var anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;
    if (internalTexture.samplingMode !== 11 && internalTexture.samplingMode !== 3 && internalTexture.samplingMode !== 2) {
      anisotropicFilteringLevel = 1;
    }
    if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
      this._setTextureParameterFloat(target2, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy), internalTexture);
      internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
    }
  };
  ThinEngine2.prototype._setTextureParameterFloat = function(target2, parameter, value, texture) {
    this._bindTextureDirectly(target2, texture, true, true);
    this._gl.texParameterf(target2, parameter, value);
  };
  ThinEngine2.prototype._setTextureParameterInteger = function(target2, parameter, value, texture) {
    if (texture) {
      this._bindTextureDirectly(target2, texture, true, true);
    }
    this._gl.texParameteri(target2, parameter, value);
  };
  ThinEngine2.prototype.unbindAllAttributes = function() {
    if (this._mustWipeVertexAttributes) {
      this._mustWipeVertexAttributes = false;
      for (var i = 0; i < this._caps.maxVertexAttribs; i++) {
        this.disableAttributeByIndex(i);
      }
      return;
    }
    for (var i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {
      if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {
        continue;
      }
      this.disableAttributeByIndex(i);
    }
  };
  ThinEngine2.prototype.releaseEffects = function() {
    for (var name_1 in this._compiledEffects) {
      var webGLPipelineContext = this._compiledEffects[name_1].getPipelineContext();
      this._deletePipelineContext(webGLPipelineContext);
    }
    this._compiledEffects = {};
  };
  ThinEngine2.prototype.dispose = function() {
    var _a2;
    this.stopRenderLoop();
    if (this.onBeforeTextureInitObservable) {
      this.onBeforeTextureInitObservable.clear();
    }
    if (this._emptyTexture) {
      this._releaseTexture(this._emptyTexture);
      this._emptyTexture = null;
    }
    if (this._emptyCubeTexture) {
      this._releaseTexture(this._emptyCubeTexture);
      this._emptyCubeTexture = null;
    }
    if (this._dummyFramebuffer) {
      this._gl.deleteFramebuffer(this._dummyFramebuffer);
    }
    this.releaseEffects();
    (_a2 = this.releaseComputeEffects) === null || _a2 === void 0 ? void 0 : _a2.call(this);
    this.unbindAllAttributes();
    this._boundUniforms = [];
    if (IsWindowObjectExist()) {
      if (this._renderingCanvas) {
        if (!this._doNotHandleContextLost) {
          this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost);
          this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored);
        }
        window.removeEventListener("resize", this._checkForMobile);
      }
    }
    this._workingCanvas = null;
    this._workingContext = null;
    this._currentBufferPointers = [];
    this._renderingCanvas = null;
    this._currentProgram = null;
    this._boundRenderFunction = null;
    Effect.ResetCache();
    for (var _i = 0, _b2 = this._activeRequests; _i < _b2.length; _i++) {
      var request = _b2[_i];
      request.abort();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  };
  ThinEngine2.prototype.attachContextLostEvent = function(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextlost", callback, false);
    }
  };
  ThinEngine2.prototype.attachContextRestoredEvent = function(callback) {
    if (this._renderingCanvas) {
      this._renderingCanvas.addEventListener("webglcontextrestored", callback, false);
    }
  };
  ThinEngine2.prototype.getError = function() {
    return this._gl.getError();
  };
  ThinEngine2.prototype._canRenderToFloatFramebuffer = function() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(1);
  };
  ThinEngine2.prototype._canRenderToHalfFloatFramebuffer = function() {
    if (this._webGLVersion > 1) {
      return this._caps.colorBufferFloat;
    }
    return this._canRenderToFramebuffer(2);
  };
  ThinEngine2.prototype._canRenderToFramebuffer = function(type) {
    var gl = this._gl;
    while (gl.getError() !== gl.NO_ERROR) {
    }
    var successful = true;
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    var fb = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    successful = successful && status === gl.FRAMEBUFFER_COMPLETE;
    successful = successful && gl.getError() === gl.NO_ERROR;
    if (successful) {
      gl.clear(gl.COLOR_BUFFER_BIT);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    if (successful) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      var readFormat = gl.RGBA;
      var readType = gl.UNSIGNED_BYTE;
      var buffer = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);
      successful = successful && gl.getError() === gl.NO_ERROR;
    }
    gl.deleteTexture(texture);
    gl.deleteFramebuffer(fb);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    while (!successful && gl.getError() !== gl.NO_ERROR) {
    }
    return successful;
  };
  ThinEngine2.prototype._getWebGLTextureType = function(type) {
    if (this._webGLVersion === 1) {
      switch (type) {
        case 1:
          return this._gl.FLOAT;
        case 2:
          return this._gl.HALF_FLOAT_OES;
        case 0:
          return this._gl.UNSIGNED_BYTE;
        case 8:
          return this._gl.UNSIGNED_SHORT_4_4_4_4;
        case 9:
          return this._gl.UNSIGNED_SHORT_5_5_5_1;
        case 10:
          return this._gl.UNSIGNED_SHORT_5_6_5;
      }
      return this._gl.UNSIGNED_BYTE;
    }
    switch (type) {
      case 3:
        return this._gl.BYTE;
      case 0:
        return this._gl.UNSIGNED_BYTE;
      case 4:
        return this._gl.SHORT;
      case 5:
        return this._gl.UNSIGNED_SHORT;
      case 6:
        return this._gl.INT;
      case 7:
        return this._gl.UNSIGNED_INT;
      case 1:
        return this._gl.FLOAT;
      case 2:
        return this._gl.HALF_FLOAT;
      case 8:
        return this._gl.UNSIGNED_SHORT_4_4_4_4;
      case 9:
        return this._gl.UNSIGNED_SHORT_5_5_5_1;
      case 10:
        return this._gl.UNSIGNED_SHORT_5_6_5;
      case 11:
        return this._gl.UNSIGNED_INT_2_10_10_10_REV;
      case 12:
        return this._gl.UNSIGNED_INT_24_8;
      case 13:
        return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
      case 14:
        return this._gl.UNSIGNED_INT_5_9_9_9_REV;
      case 15:
        return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
    }
    return this._gl.UNSIGNED_BYTE;
  };
  ThinEngine2.prototype._getInternalFormat = function(format, useSRGBBuffer) {
    if (useSRGBBuffer === void 0) {
      useSRGBBuffer = false;
    }
    var internalFormat = useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
    switch (format) {
      case 0:
        internalFormat = this._gl.ALPHA;
        break;
      case 1:
        internalFormat = this._gl.LUMINANCE;
        break;
      case 2:
        internalFormat = this._gl.LUMINANCE_ALPHA;
        break;
      case 6:
        internalFormat = this._gl.RED;
        break;
      case 7:
        internalFormat = this._gl.RG;
        break;
      case 4:
        internalFormat = useSRGBBuffer ? this._gl.SRGB : this._gl.RGB;
        break;
      case 5:
        internalFormat = useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
        break;
    }
    if (this._webGLVersion > 1) {
      switch (format) {
        case 8:
          internalFormat = this._gl.RED_INTEGER;
          break;
        case 9:
          internalFormat = this._gl.RG_INTEGER;
          break;
        case 10:
          internalFormat = this._gl.RGB_INTEGER;
          break;
        case 11:
          internalFormat = this._gl.RGBA_INTEGER;
          break;
      }
    }
    return internalFormat;
  };
  ThinEngine2.prototype._getRGBABufferInternalSizedFormat = function(type, format, useSRGBBuffer) {
    if (useSRGBBuffer === void 0) {
      useSRGBBuffer = false;
    }
    if (this._webGLVersion === 1) {
      if (format !== void 0) {
        switch (format) {
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          case 4:
            return useSRGBBuffer ? this._gl.SRGB : this._gl.RGB;
        }
      }
      return this._gl.RGBA;
    }
    switch (type) {
      case 3:
        switch (format) {
          case 6:
            return this._gl.R8_SNORM;
          case 7:
            return this._gl.RG8_SNORM;
          case 4:
            return this._gl.RGB8_SNORM;
          case 8:
            return this._gl.R8I;
          case 9:
            return this._gl.RG8I;
          case 10:
            return this._gl.RGB8I;
          case 11:
            return this._gl.RGBA8I;
          default:
            return this._gl.RGBA8_SNORM;
        }
      case 0:
        switch (format) {
          case 6:
            return this._gl.R8;
          case 7:
            return this._gl.RG8;
          case 4:
            return useSRGBBuffer ? this._gl.SRGB8 : this._gl.RGB8;
          case 5:
            return useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
          case 8:
            return this._gl.R8UI;
          case 9:
            return this._gl.RG8UI;
          case 10:
            return this._gl.RGB8UI;
          case 11:
            return this._gl.RGBA8UI;
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          default:
            return this._gl.RGBA8;
        }
      case 4:
        switch (format) {
          case 8:
            return this._gl.R16I;
          case 9:
            return this._gl.RG16I;
          case 10:
            return this._gl.RGB16I;
          case 11:
            return this._gl.RGBA16I;
          default:
            return this._gl.RGBA16I;
        }
      case 5:
        switch (format) {
          case 8:
            return this._gl.R16UI;
          case 9:
            return this._gl.RG16UI;
          case 10:
            return this._gl.RGB16UI;
          case 11:
            return this._gl.RGBA16UI;
          default:
            return this._gl.RGBA16UI;
        }
      case 6:
        switch (format) {
          case 8:
            return this._gl.R32I;
          case 9:
            return this._gl.RG32I;
          case 10:
            return this._gl.RGB32I;
          case 11:
            return this._gl.RGBA32I;
          default:
            return this._gl.RGBA32I;
        }
      case 7:
        switch (format) {
          case 8:
            return this._gl.R32UI;
          case 9:
            return this._gl.RG32UI;
          case 10:
            return this._gl.RGB32UI;
          case 11:
            return this._gl.RGBA32UI;
          default:
            return this._gl.RGBA32UI;
        }
      case 1:
        switch (format) {
          case 6:
            return this._gl.R32F;
          case 7:
            return this._gl.RG32F;
          case 4:
            return this._gl.RGB32F;
          case 5:
            return this._gl.RGBA32F;
          default:
            return this._gl.RGBA32F;
        }
      case 2:
        switch (format) {
          case 6:
            return this._gl.R16F;
          case 7:
            return this._gl.RG16F;
          case 4:
            return this._gl.RGB16F;
          case 5:
            return this._gl.RGBA16F;
          default:
            return this._gl.RGBA16F;
        }
      case 10:
        return this._gl.RGB565;
      case 13:
        return this._gl.R11F_G11F_B10F;
      case 14:
        return this._gl.RGB9_E5;
      case 8:
        return this._gl.RGBA4;
      case 9:
        return this._gl.RGB5_A1;
      case 11:
        switch (format) {
          case 5:
            return this._gl.RGB10_A2;
          case 11:
            return this._gl.RGB10_A2UI;
          default:
            return this._gl.RGB10_A2;
        }
    }
    return useSRGBBuffer ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
  };
  ThinEngine2.prototype._getRGBAMultiSampleBufferFormat = function(type) {
    if (type === 1) {
      return this._gl.RGBA32F;
    } else if (type === 2) {
      return this._gl.RGBA16F;
    }
    return this._gl.RGBA8;
  };
  ThinEngine2.prototype._loadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    var _this = this;
    var request = ThinEngine2._FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  ThinEngine2._FileToolsLoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    throw _WarnImport("FileTools");
  };
  ThinEngine2.prototype.readPixels = function(x, y, width, height, hasAlpha, flushRenderer) {
    if (hasAlpha === void 0) {
      hasAlpha = true;
    }
    if (flushRenderer === void 0) {
      flushRenderer = true;
    }
    var numChannels = hasAlpha ? 4 : 3;
    var format = hasAlpha ? this._gl.RGBA : this._gl.RGB;
    var data = new Uint8Array(height * width * numChannels);
    if (flushRenderer) {
      this.flushFramebuffer();
    }
    this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);
    return Promise.resolve(data);
  };
  Object.defineProperty(ThinEngine2, "IsSupportedAsync", {
    get: function() {
      return Promise.resolve(this.isSupported());
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinEngine2, "IsSupported", {
    get: function() {
      return this.isSupported();
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.isSupported = function() {
    if (this._HasMajorPerformanceCaveat !== null) {
      return !this._HasMajorPerformanceCaveat;
    }
    if (this._IsSupported === null) {
      try {
        var tempcanvas = this._CreateCanvas(1, 1);
        var gl = tempcanvas.getContext("webgl") || tempcanvas.getContext("experimental-webgl");
        this._IsSupported = gl != null && !!window.WebGLRenderingContext;
      } catch (e) {
        this._IsSupported = false;
      }
    }
    return this._IsSupported;
  };
  Object.defineProperty(ThinEngine2, "HasMajorPerformanceCaveat", {
    get: function() {
      if (this._HasMajorPerformanceCaveat === null) {
        try {
          var tempcanvas = this._CreateCanvas(1, 1);
          var gl = tempcanvas.getContext("webgl", { failIfMajorPerformanceCaveat: true }) || tempcanvas.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: true });
          this._HasMajorPerformanceCaveat = !gl;
        } catch (e) {
          this._HasMajorPerformanceCaveat = false;
        }
      }
      return this._HasMajorPerformanceCaveat;
    },
    enumerable: false,
    configurable: true
  });
  ThinEngine2.CeilingPOT = function(x) {
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;
    return x;
  };
  ThinEngine2.FloorPOT = function(x) {
    x = x | x >> 1;
    x = x | x >> 2;
    x = x | x >> 4;
    x = x | x >> 8;
    x = x | x >> 16;
    return x - (x >> 1);
  };
  ThinEngine2.NearestPOT = function(x) {
    var c = ThinEngine2.CeilingPOT(x);
    var f = ThinEngine2.FloorPOT(x);
    return c - x > x - f ? f : c;
  };
  ThinEngine2.GetExponentOfTwo = function(value, max, mode) {
    if (mode === void 0) {
      mode = 2;
    }
    var pot;
    switch (mode) {
      case 1:
        pot = ThinEngine2.FloorPOT(value);
        break;
      case 2:
        pot = ThinEngine2.NearestPOT(value);
        break;
      case 3:
      default:
        pot = ThinEngine2.CeilingPOT(value);
        break;
    }
    return Math.min(pot, max);
  };
  ThinEngine2.QueueNewFrame = function(func, requester) {
    if (!IsWindowObjectExist()) {
      if (typeof requestAnimationFrame !== "undefined") {
        return requestAnimationFrame(func);
      }
      return setTimeout(func, 16);
    }
    if (!requester) {
      requester = window;
    }
    if (requester.requestPostAnimationFrame) {
      return requester.requestPostAnimationFrame(func);
    } else if (requester.requestAnimationFrame) {
      return requester.requestAnimationFrame(func);
    } else if (requester.msRequestAnimationFrame) {
      return requester.msRequestAnimationFrame(func);
    } else if (requester.webkitRequestAnimationFrame) {
      return requester.webkitRequestAnimationFrame(func);
    } else if (requester.mozRequestAnimationFrame) {
      return requester.mozRequestAnimationFrame(func);
    } else if (requester.oRequestAnimationFrame) {
      return requester.oRequestAnimationFrame(func);
    } else {
      return window.setTimeout(func, 16);
    }
  };
  ThinEngine2.prototype.getHostDocument = function() {
    if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {
      return this._renderingCanvas.ownerDocument;
    }
    return IsDocumentAvailable() ? document : null;
  };
  ThinEngine2.ExceptionList = [
    { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
    { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] },
    { key: "Mac OS.+Chrome", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
    { key: ".*AppleWebKit.*(15.4).*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] },
    { key: ".*(15.4).*AppleWebKit.*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] }
  ];
  ThinEngine2._TextureLoaders = [];
  ThinEngine2.CollisionsEpsilon = 1e-3;
  ThinEngine2._IsSupported = null;
  ThinEngine2._HasMajorPerformanceCaveat = null;
  return ThinEngine2;
}();
var TimingTools = function() {
  function TimingTools2() {
  }
  TimingTools2.SetImmediate = function(action) {
    if (IsWindowObjectExist() && window.setImmediate) {
      window.setImmediate(action);
    } else {
      setTimeout(action, 1);
    }
  };
  return TimingTools2;
}();
var Base64DataUrlRegEx = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
var LoadFileError = function(_super) {
  __extends(LoadFileError2, _super);
  function LoadFileError2(message, object) {
    var _this = _super.call(this, message, ErrorCodes.LoadFileError) || this;
    _this.name = "LoadFileError";
    BaseError._setPrototypeOf(_this, LoadFileError2.prototype);
    if (object instanceof WebRequest) {
      _this.request = object;
    } else {
      _this.file = object;
    }
    return _this;
  }
  return LoadFileError2;
}(RuntimeError);
var RequestFileError = function(_super) {
  __extends(RequestFileError2, _super);
  function RequestFileError2(message, request) {
    var _this = _super.call(this, message, ErrorCodes.RequestFileError) || this;
    _this.request = request;
    _this.name = "RequestFileError";
    BaseError._setPrototypeOf(_this, RequestFileError2.prototype);
    return _this;
  }
  return RequestFileError2;
}(RuntimeError);
var ReadFileError = function(_super) {
  __extends(ReadFileError2, _super);
  function ReadFileError2(message, file) {
    var _this = _super.call(this, message, ErrorCodes.ReadFileError) || this;
    _this.file = file;
    _this.name = "ReadFileError";
    BaseError._setPrototypeOf(_this, ReadFileError2.prototype);
    return _this;
  }
  return ReadFileError2;
}(RuntimeError);
var FileToolsOptions = {
  DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),
  BaseUrl: "",
  CorsBehavior: "anonymous",
  PreprocessUrl: function(url) {
    return url;
  }
};
var _CleanUrl = function(url) {
  url = url.replace(/#/gm, "%23");
  return url;
};
var SetCorsBehavior = function(url, element) {
  if (url && url.indexOf("data:") === 0) {
    return;
  }
  if (FileToolsOptions.CorsBehavior) {
    if (typeof FileToolsOptions.CorsBehavior === "string" || FileToolsOptions.CorsBehavior instanceof String) {
      element.crossOrigin = FileToolsOptions.CorsBehavior;
    } else {
      var result = FileToolsOptions.CorsBehavior(url);
      if (result) {
        element.crossOrigin = result;
      }
    }
  }
};
var LoadImage = function(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
  var _a2;
  if (mimeType === void 0) {
    mimeType = "";
  }
  var url;
  var usingObjectURL = false;
  if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
    if (typeof Blob !== "undefined") {
      url = URL.createObjectURL(new Blob([input], { type: mimeType }));
      usingObjectURL = true;
    } else {
      url = "data:".concat(mimeType, ";base64,") + EncodeArrayBufferToBase64(input);
    }
  } else if (input instanceof Blob) {
    url = URL.createObjectURL(input);
    usingObjectURL = true;
  } else {
    url = _CleanUrl(input);
    url = FileToolsOptions.PreprocessUrl(input);
  }
  var engine = EngineStore.LastCreatedEngine;
  var onErrorHandler = function(exception) {
    if (onError) {
      var inputText = url || input.toString();
      onError("Error while trying to load image: ".concat(inputText.indexOf("http") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + "..."), exception);
    }
  };
  if (typeof Image === "undefined" || ((_a2 = engine === null || engine === void 0 ? void 0 : engine._features.forceBitmapOverHTMLImageElement) !== null && _a2 !== void 0 ? _a2 : false)) {
    LoadFile(url, function(data) {
      engine.createImageBitmap(new Blob([data], { type: mimeType }), __assign({ premultiplyAlpha: "none" }, imageBitmapOptions)).then(function(imgBmp) {
        onLoad(imgBmp);
        if (usingObjectURL) {
          URL.revokeObjectURL(url);
        }
      }).catch(function(reason) {
        if (onError) {
          onError("Error while trying to load image: " + input, reason);
        }
      });
    }, void 0, offlineProvider || void 0, true, function(request, exception) {
      onErrorHandler(exception);
    });
    return null;
  }
  var img = new Image();
  SetCorsBehavior(url, img);
  var loadHandler = function() {
    img.removeEventListener("load", loadHandler);
    img.removeEventListener("error", errorHandler);
    onLoad(img);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  var errorHandler = function(err) {
    img.removeEventListener("load", loadHandler);
    img.removeEventListener("error", errorHandler);
    onErrorHandler(err);
    if (usingObjectURL && img.src) {
      URL.revokeObjectURL(img.src);
    }
  };
  img.addEventListener("load", loadHandler);
  img.addEventListener("error", errorHandler);
  var noOfflineSupport = function() {
    img.src = url;
  };
  var loadFromOfflineSupport = function() {
    if (offlineProvider) {
      offlineProvider.loadImage(url, img);
    }
  };
  if (url.substr(0, 5) !== "blob:" && url.substr(0, 5) !== "data:" && offlineProvider && offlineProvider.enableTexturesOffline) {
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
  } else {
    if (url.indexOf("file:") !== -1) {
      var textureName = decodeURIComponent(url.substring(5).toLowerCase());
      if (FilesInputStore.FilesToLoad[textureName]) {
        try {
          var blobURL = void 0;
          try {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          } catch (ex) {
            blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
          }
          img.src = blobURL;
          usingObjectURL = true;
        } catch (e) {
          img.src = "";
        }
        return img;
      }
    }
    noOfflineSupport();
  }
  return img;
};
var ReadFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
  var reader = new FileReader();
  var fileRequest = {
    onCompleteObservable: new Observable(),
    abort: function() {
      return reader.abort();
    }
  };
  reader.onloadend = function() {
    return fileRequest.onCompleteObservable.notifyObservers(fileRequest);
  };
  if (onError) {
    reader.onerror = function() {
      onError(new ReadFileError("Unable to read ".concat(file.name), file));
    };
  }
  reader.onload = function(e) {
    onSuccess(e.target["result"]);
  };
  if (onProgress) {
    reader.onprogress = onProgress;
  }
  if (!useArrayBuffer) {
    reader.readAsText(file);
  } else {
    reader.readAsArrayBuffer(file);
  }
  return fileRequest;
};
var LoadFile = function(fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {
  if (fileOrUrl.name) {
    return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? function(error) {
      onError(void 0, error);
    } : void 0);
  }
  var url = fileOrUrl;
  if (url.indexOf("file:") !== -1) {
    var fileName = decodeURIComponent(url.substring(5).toLowerCase());
    if (fileName.indexOf("./") === 0) {
      fileName = fileName.substring(2);
    }
    var file = FilesInputStore.FilesToLoad[fileName];
    if (file) {
      return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? function(error) {
        return onError(void 0, new LoadFileError(error.message, error.file));
      } : void 0);
    }
  }
  if (IsBase64DataUrl(url)) {
    var fileRequest_1 = {
      onCompleteObservable: new Observable(),
      abort: function() {
        return function() {
        };
      }
    };
    try {
      onSuccess(useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url));
    } catch (error) {
      if (onError) {
        onError(void 0, error);
      } else {
        Logger.Error(error.message || "Failed to parse the Data URL");
      }
    }
    TimingTools.SetImmediate(function() {
      fileRequest_1.onCompleteObservable.notifyObservers(fileRequest_1);
    });
    return fileRequest_1;
  }
  return RequestFile(url, function(data, request) {
    onSuccess(data, request ? request.responseURL : void 0);
  }, onProgress, offlineProvider, useArrayBuffer, onError ? function(error) {
    onError(error.request, new LoadFileError(error.message, error.request));
  } : void 0, onOpened);
};
var RequestFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) {
  url = _CleanUrl(url);
  url = FileToolsOptions.PreprocessUrl(url);
  var loadUrl = FileToolsOptions.BaseUrl + url;
  var aborted = false;
  var fileRequest = {
    onCompleteObservable: new Observable(),
    abort: function() {
      return aborted = true;
    }
  };
  var requestFile = function() {
    var request = new WebRequest();
    var retryHandle = null;
    var onReadyStateChange;
    var unbindEvents = function() {
      if (!request) {
        return;
      }
      if (onProgress) {
        request.removeEventListener("progress", onProgress);
      }
      if (onReadyStateChange) {
        request.removeEventListener("readystatechange", onReadyStateChange);
      }
      request.removeEventListener("loadend", onLoadEnd);
    };
    var onLoadEnd = function() {
      unbindEvents();
      fileRequest.onCompleteObservable.notifyObservers(fileRequest);
      fileRequest.onCompleteObservable.clear();
      onProgress = void 0;
      onReadyStateChange = null;
      onLoadEnd = null;
      onError = void 0;
      onOpened = void 0;
      onSuccess = void 0;
    };
    fileRequest.abort = function() {
      aborted = true;
      if (onLoadEnd) {
        onLoadEnd();
      }
      if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {
        request.abort();
      }
      if (retryHandle !== null) {
        clearTimeout(retryHandle);
        retryHandle = null;
      }
      request = null;
    };
    var handleError = function(error) {
      var message = error.message || "Unknown error";
      if (onError && request) {
        onError(new RequestFileError(message, request));
      } else {
        Logger.Error(message);
      }
    };
    var retryLoop = function(retryIndex) {
      if (!request) {
        return;
      }
      request.open("GET", loadUrl);
      if (onOpened) {
        try {
          onOpened(request);
        } catch (e) {
          handleError(e);
          return;
        }
      }
      if (useArrayBuffer) {
        request.responseType = "arraybuffer";
      }
      if (onProgress) {
        request.addEventListener("progress", onProgress);
      }
      if (onLoadEnd) {
        request.addEventListener("loadend", onLoadEnd);
      }
      onReadyStateChange = function() {
        if (aborted || !request) {
          return;
        }
        if (request.readyState === (XMLHttpRequest.DONE || 4)) {
          if (onReadyStateChange) {
            request.removeEventListener("readystatechange", onReadyStateChange);
          }
          if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {
            try {
              if (onSuccess) {
                onSuccess(useArrayBuffer ? request.response : request.responseText, request);
              }
            } catch (e) {
              handleError(e);
            }
            return;
          }
          var retryStrategy = FileToolsOptions.DefaultRetryStrategy;
          if (retryStrategy) {
            var waitTime = retryStrategy(loadUrl, request, retryIndex);
            if (waitTime !== -1) {
              unbindEvents();
              request = new WebRequest();
              retryHandle = setTimeout(function() {
                return retryLoop(retryIndex + 1);
              }, waitTime);
              return;
            }
          }
          var error = new RequestFileError("Error status: " + request.status + " " + request.statusText + " - Unable to load " + loadUrl, request);
          if (onError) {
            onError(error);
          }
        }
      };
      request.addEventListener("readystatechange", onReadyStateChange);
      request.send();
    };
    retryLoop(0);
  };
  if (offlineProvider && offlineProvider.enableSceneOffline) {
    var noOfflineSupport_1 = function(request) {
      if (request && request.status > 400) {
        if (onError) {
          onError(request);
        }
      } else {
        requestFile();
      }
    };
    var loadFromOfflineSupport = function() {
      if (offlineProvider) {
        offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, function(data) {
          if (!aborted && onSuccess) {
            onSuccess(data);
          }
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
        }, onProgress ? function(event) {
          if (!aborted && onProgress) {
            onProgress(event);
          }
        } : void 0, noOfflineSupport_1, useArrayBuffer);
      }
    };
    offlineProvider.open(loadFromOfflineSupport, noOfflineSupport_1);
  } else {
    requestFile();
  }
  return fileRequest;
};
var IsFileURL = function() {
  return typeof location !== "undefined" && location.protocol === "file:";
};
var IsBase64DataUrl = function(uri) {
  return Base64DataUrlRegEx.test(uri);
};
function DecodeBase64UrlToBinary(uri) {
  return DecodeBase64ToBinary(uri.split(",")[1]);
}
var DecodeBase64UrlToString = function(uri) {
  return DecodeBase64ToString(uri.split(",")[1]);
};
var initSideEffects = function() {
  ThinEngine._FileToolsLoadImage = LoadImage;
  ThinEngine._FileToolsLoadFile = LoadFile;
  ShaderProcessor._FileToolsLoadFile = LoadFile;
};
initSideEffects();
var FileTools;
var _injectLTSFileTools = function(DecodeBase64UrlToBinary2, DecodeBase64UrlToString2, FileToolsOptions2, IsBase64DataUrl2, IsFileURL2, LoadFile2, LoadImage2, ReadFile2, RequestFile2, SetCorsBehavior2) {
  FileTools = {
    DecodeBase64UrlToBinary: DecodeBase64UrlToBinary2,
    DecodeBase64UrlToString: DecodeBase64UrlToString2,
    DefaultRetryStrategy: FileToolsOptions2.DefaultRetryStrategy,
    BaseUrl: FileToolsOptions2.BaseUrl,
    CorsBehavior: FileToolsOptions2.CorsBehavior,
    PreprocessUrl: FileToolsOptions2.PreprocessUrl,
    IsBase64DataUrl: IsBase64DataUrl2,
    IsFileURL: IsFileURL2,
    LoadFile: LoadFile2,
    LoadImage: LoadImage2,
    ReadFile: ReadFile2,
    RequestFile: RequestFile2,
    SetCorsBehavior: SetCorsBehavior2
  };
  Object.defineProperty(FileTools, "DefaultRetryStrategy", {
    get: function() {
      return FileToolsOptions2.DefaultRetryStrategy;
    },
    set: function(value) {
      FileToolsOptions2.DefaultRetryStrategy = value;
    }
  });
  Object.defineProperty(FileTools, "BaseUrl", {
    get: function() {
      return FileToolsOptions2.BaseUrl;
    },
    set: function(value) {
      FileToolsOptions2.BaseUrl = value;
    }
  });
  Object.defineProperty(FileTools, "PreprocessUrl", {
    get: function() {
      return FileToolsOptions2.PreprocessUrl;
    },
    set: function(value) {
      FileToolsOptions2.PreprocessUrl = value;
    }
  });
  Object.defineProperty(FileTools, "CorsBehavior", {
    get: function() {
      return FileToolsOptions2.CorsBehavior;
    },
    set: function(value) {
      FileToolsOptions2.CorsBehavior = value;
    }
  });
};
_injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);
var _RegisteredTypes = {};
function RegisterClass(className, type) {
  _RegisteredTypes[className] = type;
}
function GetClass(fqdn) {
  return _RegisteredTypes[fqdn];
}
var InstantiationTools = function() {
  function InstantiationTools2() {
  }
  InstantiationTools2.Instantiate = function(className) {
    if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className]) {
      return this.RegisteredExternalClasses[className];
    }
    var internalClass = GetClass(className);
    if (internalClass) {
      return internalClass;
    }
    Logger.Warn(className + " not found, you may have missed an import.");
    var arr = className.split(".");
    var fn = window || this;
    for (var i = 0, len = arr.length; i < len; i++) {
      fn = fn[arr[i]];
    }
    if (typeof fn !== "function") {
      return null;
    }
    return fn;
  };
  InstantiationTools2.RegisteredExternalClasses = {};
  return InstantiationTools2;
}();
function RandomGUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var Tools = function() {
  function Tools2() {
  }
  Object.defineProperty(Tools2, "BaseUrl", {
    get: function() {
      return FileToolsOptions.BaseUrl;
    },
    set: function(value) {
      FileToolsOptions.BaseUrl = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "DefaultRetryStrategy", {
    get: function() {
      return FileToolsOptions.DefaultRetryStrategy;
    },
    set: function(strategy) {
      FileToolsOptions.DefaultRetryStrategy = strategy;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "CorsBehavior", {
    get: function() {
      return FileToolsOptions.CorsBehavior;
    },
    set: function(value) {
      FileToolsOptions.CorsBehavior = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "UseFallbackTexture", {
    get: function() {
      return EngineStore.UseFallbackTexture;
    },
    set: function(value) {
      EngineStore.UseFallbackTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "RegisteredExternalClasses", {
    get: function() {
      return InstantiationTools.RegisteredExternalClasses;
    },
    set: function(classes) {
      InstantiationTools.RegisteredExternalClasses = classes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "fallbackTexture", {
    get: function() {
      return EngineStore.FallbackTexture;
    },
    set: function(value) {
      EngineStore.FallbackTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.FetchToRef = function(u, v, width, height, pixels, color) {
    var wrappedU = Math.abs(u) * width % width | 0;
    var wrappedV = Math.abs(v) * height % height | 0;
    var position = (wrappedU + wrappedV * width) * 4;
    color.r = pixels[position] / 255;
    color.g = pixels[position + 1] / 255;
    color.b = pixels[position + 2] / 255;
    color.a = pixels[position + 3] / 255;
  };
  Tools2.Mix = function(a, b, alpha) {
    return a * (1 - alpha) + b * alpha;
  };
  Tools2.Instantiate = function(className) {
    return InstantiationTools.Instantiate(className);
  };
  Tools2.SetImmediate = function(action) {
    TimingTools.SetImmediate(action);
  };
  Tools2.IsExponentOfTwo = function(value) {
    var count = 1;
    do {
      count *= 2;
    } while (count < value);
    return count === value;
  };
  Tools2.FloatRound = function(value) {
    if (Math.fround) {
      return Math.fround(value);
    }
    return Tools2._TmpFloatArray[0] = value, Tools2._TmpFloatArray[0];
  };
  Tools2.GetFilename = function(path) {
    var index = path.lastIndexOf("/");
    if (index < 0) {
      return path;
    }
    return path.substring(index + 1);
  };
  Tools2.GetFolderPath = function(uri, returnUnchangedIfNoSlash) {
    if (returnUnchangedIfNoSlash === void 0) {
      returnUnchangedIfNoSlash = false;
    }
    var index = uri.lastIndexOf("/");
    if (index < 0) {
      if (returnUnchangedIfNoSlash) {
        return uri;
      }
      return "";
    }
    return uri.substring(0, index + 1);
  };
  Tools2.ToDegrees = function(angle) {
    return angle * 180 / Math.PI;
  };
  Tools2.ToRadians = function(angle) {
    return angle * Math.PI / 180;
  };
  Tools2.MakeArray = function(obj, allowsNullUndefined) {
    if (allowsNullUndefined !== true && (obj === void 0 || obj == null)) {
      return null;
    }
    return Array.isArray(obj) ? obj : [obj];
  };
  Tools2.GetPointerPrefix = function(engine) {
    var eventPrefix = "pointer";
    if (IsWindowObjectExist() && !window.PointerEvent) {
      eventPrefix = "mouse";
    }
    if (engine._badDesktopOS && !engine._badOS && !(document && "ontouchend" in document)) {
      eventPrefix = "mouse";
    }
    return eventPrefix;
  };
  Tools2.SetCorsBehavior = function(url, element) {
    SetCorsBehavior(url, element);
  };
  Tools2.CleanUrl = function(url) {
    url = url.replace(/#/gm, "%23");
    return url;
  };
  Object.defineProperty(Tools2, "PreprocessUrl", {
    get: function() {
      return FileToolsOptions.PreprocessUrl;
    },
    set: function(processor) {
      FileToolsOptions.PreprocessUrl = processor;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.LoadImage = function(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
    return LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);
  };
  Tools2.LoadFile = function(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
    return LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
  };
  Tools2.LoadFileAsync = function(url, useArrayBuffer) {
    if (useArrayBuffer === void 0) {
      useArrayBuffer = true;
    }
    return new Promise(function(resolve, reject) {
      LoadFile(url, function(data) {
        resolve(data);
      }, void 0, void 0, useArrayBuffer, function(request, exception) {
        reject(exception);
      });
    });
  };
  Tools2.LoadScript = function(scriptUrl, onSuccess, onError, scriptId) {
    if (!IsWindowObjectExist()) {
      return;
    }
    var head = document.getElementsByTagName("head")[0];
    var script = document.createElement("script");
    script.setAttribute("type", "text/javascript");
    script.setAttribute("src", scriptUrl);
    if (scriptId) {
      script.id = scriptId;
    }
    script.onload = function() {
      if (onSuccess) {
        onSuccess();
      }
    };
    script.onerror = function(e) {
      if (onError) {
        onError("Unable to load script '".concat(scriptUrl, "'"), e);
      }
    };
    head.appendChild(script);
  };
  Tools2.LoadScriptAsync = function(scriptUrl) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.LoadScript(scriptUrl, function() {
        resolve();
      }, function(message, exception) {
        reject(exception);
      });
    });
  };
  Tools2.ReadFileAsDataURL = function(fileToLoad, callback, progressCallback) {
    var reader = new FileReader();
    var request = {
      onCompleteObservable: new Observable(),
      abort: function() {
        return reader.abort();
      }
    };
    reader.onloadend = function() {
      request.onCompleteObservable.notifyObservers(request);
    };
    reader.onload = function(e) {
      callback(e.target["result"]);
    };
    reader.onprogress = progressCallback;
    reader.readAsDataURL(fileToLoad);
    return request;
  };
  Tools2.ReadFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
    return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
  };
  Tools2.FileAsURL = function(content) {
    var fileBlob = new Blob([content]);
    var url = window.URL || window.webkitURL;
    var link = url.createObjectURL(fileBlob);
    return link;
  };
  Tools2.Format = function(value, decimals) {
    if (decimals === void 0) {
      decimals = 2;
    }
    return value.toFixed(decimals);
  };
  Tools2.DeepCopy = function(source, destination, doNotCopyList, mustCopyList) {
    DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);
  };
  Tools2.IsEmpty = function(obj) {
    for (var i in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, i)) {
        return false;
      }
    }
    return true;
  };
  Tools2.RegisterTopRootEvents = function(windowElement, events) {
    for (var index = 0; index < events.length; index++) {
      var event_1 = events[index];
      windowElement.addEventListener(event_1.name, event_1.handler, false);
      try {
        if (window.parent) {
          window.parent.addEventListener(event_1.name, event_1.handler, false);
        }
      } catch (e) {
      }
    }
  };
  Tools2.UnregisterTopRootEvents = function(windowElement, events) {
    for (var index = 0; index < events.length; index++) {
      var event_2 = events[index];
      windowElement.removeEventListener(event_2.name, event_2.handler);
      try {
        if (windowElement.parent) {
          windowElement.parent.removeEventListener(event_2.name, event_2.handler);
        }
      } catch (e) {
      }
    }
  };
  Tools2.DumpFramebuffer = function(width, height, engine, successCallback, mimeType, fileName) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    return __awaiter(this, void 0, void 0, function() {
      var bufferView, data;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, engine.readPixels(0, 0, width, height)];
          case 1:
            bufferView = _a2.sent();
            data = new Uint8Array(bufferView.buffer);
            Tools2.DumpData(width, height, data, successCallback, mimeType, fileName, true);
            return [2];
        }
      });
    });
  };
  Tools2.DumpData = function(width, height, data, successCallback, mimeType, fileName, invertY, toArrayBuffer, quality) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (toArrayBuffer === void 0) {
      toArrayBuffer = false;
    }
    if (!Tools2._ScreenshotCanvas) {
      Tools2._ScreenshotCanvas = document.createElement("canvas");
    }
    Tools2._ScreenshotCanvas.width = width;
    Tools2._ScreenshotCanvas.height = height;
    var context = Tools2._ScreenshotCanvas.getContext("2d");
    if (context) {
      if (data instanceof Float32Array) {
        var data2 = new Uint8Array(data.length);
        var n = data.length;
        while (n--) {
          var v = data[n];
          data2[n] = v < 0 ? 0 : v > 1 ? 1 : Math.round(v * 255);
        }
        data = data2;
      }
      var imageData = context.createImageData(width, height);
      var castData = imageData.data;
      castData.set(data);
      context.putImageData(imageData, 0, 0);
      var canvas = Tools2._ScreenshotCanvas;
      if (invertY) {
        var canvas2 = document.createElement("canvas");
        canvas2.width = width;
        canvas2.height = height;
        var ctx2 = canvas2.getContext("2d");
        if (!ctx2) {
          return;
        }
        ctx2.translate(0, height);
        ctx2.scale(1, -1);
        ctx2.drawImage(Tools2._ScreenshotCanvas, 0, 0);
        canvas = canvas2;
      }
      if (toArrayBuffer) {
        Tools2.ToBlob(canvas, function(blob) {
          var fileReader = new FileReader();
          fileReader.onload = function(event) {
            var arrayBuffer = event.target.result;
            if (successCallback) {
              successCallback(arrayBuffer);
            }
          };
          fileReader.readAsArrayBuffer(blob);
        }, mimeType, quality);
      } else {
        Tools2.EncodeScreenshotCanvasData(successCallback, mimeType, fileName, canvas, quality);
      }
    }
  };
  Tools2.DumpDataAsync = function(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (toArrayBuffer === void 0) {
      toArrayBuffer = false;
    }
    return new Promise(function(resolve) {
      Tools2.DumpData(width, height, data, function(result) {
        return resolve(result);
      }, mimeType, fileName, invertY, toArrayBuffer, quality);
    });
  };
  Tools2.ToBlob = function(canvas, successCallback, mimeType, quality) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (!canvas.toBlob) {
      canvas.toBlob = function(callback, type, quality2) {
        var _this = this;
        setTimeout(function() {
          var binStr = atob(_this.toDataURL(type, quality2).split(",")[1]), len = binStr.length, arr = new Uint8Array(len);
          for (var i = 0; i < len; i++) {
            arr[i] = binStr.charCodeAt(i);
          }
          callback(new Blob([arr]));
        });
      };
    }
    canvas.toBlob(function(blob) {
      successCallback(blob);
    }, mimeType, quality);
  };
  Tools2.EncodeScreenshotCanvasData = function(successCallback, mimeType, fileName, canvas, quality) {
    if (mimeType === void 0) {
      mimeType = "image/png";
    }
    if (successCallback) {
      var base64Image = (canvas !== null && canvas !== void 0 ? canvas : Tools2._ScreenshotCanvas).toDataURL(mimeType, quality);
      successCallback(base64Image);
    } else {
      this.ToBlob(canvas !== null && canvas !== void 0 ? canvas : Tools2._ScreenshotCanvas, function(blob) {
        if ("download" in document.createElement("a")) {
          if (!fileName) {
            var date = new Date();
            var stringDate = (date.getFullYear() + "-" + (date.getMonth() + 1)).slice(2) + "-" + date.getDate() + "_" + date.getHours() + "-" + ("0" + date.getMinutes()).slice(-2);
            fileName = "screenshot_" + stringDate + ".png";
          }
          Tools2.Download(blob, fileName);
        } else {
          if (blob) {
            var url_1 = URL.createObjectURL(blob);
            var newWindow = window.open("");
            if (!newWindow) {
              return;
            }
            var img = newWindow.document.createElement("img");
            img.onload = function() {
              URL.revokeObjectURL(url_1);
            };
            img.src = url_1;
            newWindow.document.body.appendChild(img);
          }
        }
      }, mimeType, quality);
    }
  };
  Tools2.Download = function(blob, fileName) {
    if (navigator && navigator.msSaveBlob) {
      navigator.msSaveBlob(blob, fileName);
      return;
    }
    var url = window.URL.createObjectURL(blob);
    var a = document.createElement("a");
    document.body.appendChild(a);
    a.style.display = "none";
    a.href = url;
    a.download = fileName;
    a.addEventListener("click", function() {
      if (a.parentElement) {
        a.parentElement.removeChild(a);
      }
    });
    a.click();
    window.URL.revokeObjectURL(url);
  };
  Tools2.BackCompatCameraNoPreventDefault = function(args) {
    if (typeof args[0] === "boolean") {
      return args[0];
    } else if (typeof args[1] === "boolean") {
      return args[1];
    }
    return false;
  };
  Tools2.CreateScreenshot = function(engine, camera, size, successCallback, mimeType) {
    throw _WarnImport("ScreenshotTools");
  };
  Tools2.CreateScreenshotAsync = function(engine, camera, size, mimeType) {
    throw _WarnImport("ScreenshotTools");
  };
  Tools2.CreateScreenshotUsingRenderTarget = function(engine, camera, size, successCallback, mimeType, samples, antialiasing, fileName) {
    throw _WarnImport("ScreenshotTools");
  };
  Tools2.CreateScreenshotUsingRenderTargetAsync = function(engine, camera, size, mimeType, samples, antialiasing, fileName) {
    throw _WarnImport("ScreenshotTools");
  };
  Tools2.RandomId = function() {
    return RandomGUID();
  };
  Tools2.IsBase64 = function(uri) {
    return IsBase64DataUrl(uri);
  };
  Tools2.DecodeBase64 = function(uri) {
    return DecodeBase64UrlToBinary(uri);
  };
  Object.defineProperty(Tools2, "errorsCount", {
    get: function() {
      return Logger.errorsCount;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.Log = function(message) {
    Logger.Log(message);
  };
  Tools2.Warn = function(message) {
    Logger.Warn(message);
  };
  Tools2.Error = function(message) {
    Logger.Error(message);
  };
  Object.defineProperty(Tools2, "LogCache", {
    get: function() {
      return Logger.LogCache;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.ClearLogCache = function() {
    Logger.ClearLogCache();
  };
  Object.defineProperty(Tools2, "LogLevels", {
    set: function(level) {
      Logger.LogLevels = level;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Tools2, "PerformanceLogLevel", {
    set: function(level) {
      if ((level & Tools2.PerformanceUserMarkLogLevel) === Tools2.PerformanceUserMarkLogLevel) {
        Tools2.StartPerformanceCounter = Tools2._StartUserMark;
        Tools2.EndPerformanceCounter = Tools2._EndUserMark;
        return;
      }
      if ((level & Tools2.PerformanceConsoleLogLevel) === Tools2.PerformanceConsoleLogLevel) {
        Tools2.StartPerformanceCounter = Tools2._StartPerformanceConsole;
        Tools2.EndPerformanceCounter = Tools2._EndPerformanceConsole;
        return;
      }
      Tools2.StartPerformanceCounter = Tools2._StartPerformanceCounterDisabled;
      Tools2.EndPerformanceCounter = Tools2._EndPerformanceCounterDisabled;
    },
    enumerable: false,
    configurable: true
  });
  Tools2._StartPerformanceCounterDisabled = function(counterName, condition) {
  };
  Tools2._EndPerformanceCounterDisabled = function(counterName, condition) {
  };
  Tools2._StartUserMark = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!Tools2._Performance) {
      if (!IsWindowObjectExist()) {
        return;
      }
      Tools2._Performance = window.performance;
    }
    if (!condition || !Tools2._Performance.mark) {
      return;
    }
    Tools2._Performance.mark(counterName + "-Begin");
  };
  Tools2._EndUserMark = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!condition || !Tools2._Performance.mark) {
      return;
    }
    Tools2._Performance.mark(counterName + "-End");
    Tools2._Performance.measure(counterName, counterName + "-Begin", counterName + "-End");
  };
  Tools2._StartPerformanceConsole = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!condition) {
      return;
    }
    Tools2._StartUserMark(counterName, condition);
    if (console.time) {
      console.time(counterName);
    }
  };
  Tools2._EndPerformanceConsole = function(counterName, condition) {
    if (condition === void 0) {
      condition = true;
    }
    if (!condition) {
      return;
    }
    Tools2._EndUserMark(counterName, condition);
    console.timeEnd(counterName);
  };
  Object.defineProperty(Tools2, "Now", {
    get: function() {
      return PrecisionDate.Now;
    },
    enumerable: false,
    configurable: true
  });
  Tools2.GetClassName = function(object, isType) {
    if (isType === void 0) {
      isType = false;
    }
    var name2 = null;
    if (!isType && object.getClassName) {
      name2 = object.getClassName();
    } else {
      if (object instanceof Object) {
        var classObj = isType ? object : Object.getPrototypeOf(object);
        name2 = classObj.constructor["__bjsclassName__"];
      }
      if (!name2) {
        name2 = typeof object;
      }
    }
    return name2;
  };
  Tools2.First = function(array, predicate) {
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
      var el = array_1[_i];
      if (predicate(el)) {
        return el;
      }
    }
    return null;
  };
  Tools2.getFullClassName = function(object, isType) {
    if (isType === void 0) {
      isType = false;
    }
    var className = null;
    var moduleName = null;
    if (!isType && object.getClassName) {
      className = object.getClassName();
    } else {
      if (object instanceof Object) {
        var classObj = isType ? object : Object.getPrototypeOf(object);
        className = classObj.constructor["__bjsclassName__"];
        moduleName = classObj.constructor["__bjsmoduleName__"];
      }
      if (!className) {
        className = typeof object;
      }
    }
    if (!className) {
      return null;
    }
    return (moduleName != null ? moduleName + "." : "") + className;
  };
  Tools2.DelayAsync = function(delay) {
    return new Promise(function(resolve) {
      setTimeout(function() {
        resolve();
      }, delay);
    });
  };
  Tools2.IsSafari = function() {
    if (!IsNavigatorAvailable()) {
      return false;
    }
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  };
  Tools2.UseCustomRequestHeaders = false;
  Tools2.CustomRequestHeaders = WebRequest.CustomRequestHeaders;
  Tools2._TmpFloatArray = new Float32Array(1);
  Tools2.GetDOMTextContent = GetDOMTextContent;
  Tools2.GetAbsoluteUrl = typeof document === "object" ? function(url) {
    var a = document.createElement("a");
    a.href = url;
    return a.href;
  } : typeof URL === "function" && typeof location === "object" ? function(url) {
    return new URL(url, location.origin).href;
  } : function() {
    throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
  };
  Tools2.NoneLogLevel = Logger.NoneLogLevel;
  Tools2.MessageLogLevel = Logger.MessageLogLevel;
  Tools2.WarningLogLevel = Logger.WarningLogLevel;
  Tools2.ErrorLogLevel = Logger.ErrorLogLevel;
  Tools2.AllLogLevel = Logger.AllLogLevel;
  Tools2.IsWindowObjectExist = IsWindowObjectExist;
  Tools2.PerformanceNoneLogLevel = 0;
  Tools2.PerformanceUserMarkLogLevel = 1;
  Tools2.PerformanceConsoleLogLevel = 2;
  Tools2.StartPerformanceCounter = Tools2._StartPerformanceCounterDisabled;
  Tools2.EndPerformanceCounter = Tools2._EndPerformanceCounterDisabled;
  return Tools2;
}();
var AsyncLoop = function() {
  function AsyncLoop2(iterations, func, successCallback, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    this.iterations = iterations;
    this.index = offset - 1;
    this._done = false;
    this._fn = func;
    this._successCallback = successCallback;
  }
  AsyncLoop2.prototype.executeNext = function() {
    if (!this._done) {
      if (this.index + 1 < this.iterations) {
        ++this.index;
        this._fn(this);
      } else {
        this.breakLoop();
      }
    }
  };
  AsyncLoop2.prototype.breakLoop = function() {
    this._done = true;
    this._successCallback();
  };
  AsyncLoop2.Run = function(iterations, fn, successCallback, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var loop = new AsyncLoop2(iterations, fn, successCallback, offset);
    loop.executeNext();
    return loop;
  };
  AsyncLoop2.SyncAsyncForLoop = function(iterations, syncedIterations, fn, callback, breakFunction, timeout) {
    if (timeout === void 0) {
      timeout = 0;
    }
    return AsyncLoop2.Run(Math.ceil(iterations / syncedIterations), function(loop) {
      if (breakFunction && breakFunction()) {
        loop.breakLoop();
      } else {
        setTimeout(function() {
          for (var i = 0; i < syncedIterations; ++i) {
            var iteration = loop.index * syncedIterations + i;
            if (iteration >= iterations) {
              break;
            }
            fn(iteration);
            if (breakFunction && breakFunction()) {
              loop.breakLoop();
              break;
            }
          }
          loop.executeNext();
        }, timeout);
      }
    }, callback);
  };
  return AsyncLoop2;
}();
EngineStore.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
var AndOrNotEvaluator = function() {
  function AndOrNotEvaluator2() {
  }
  AndOrNotEvaluator2.Eval = function(query, evaluateCallback) {
    if (!query.match(/\([^()]*\)/g)) {
      query = AndOrNotEvaluator2._HandleParenthesisContent(query, evaluateCallback);
    } else {
      query = query.replace(/\([^()]*\)/g, function(r) {
        r = r.slice(1, r.length - 1);
        return AndOrNotEvaluator2._HandleParenthesisContent(r, evaluateCallback);
      });
    }
    if (query === "true") {
      return true;
    }
    if (query === "false") {
      return false;
    }
    return AndOrNotEvaluator2.Eval(query, evaluateCallback);
  };
  AndOrNotEvaluator2._HandleParenthesisContent = function(parenthesisContent, evaluateCallback) {
    evaluateCallback = evaluateCallback || function(r) {
      return r === "true" ? true : false;
    };
    var result;
    var or = parenthesisContent.split("||");
    for (var i in or) {
      if (Object.prototype.hasOwnProperty.call(or, i)) {
        var ori = AndOrNotEvaluator2._SimplifyNegation(or[i].trim());
        var and = ori.split("&&");
        if (and.length > 1) {
          for (var j = 0; j < and.length; ++j) {
            var andj = AndOrNotEvaluator2._SimplifyNegation(and[j].trim());
            if (andj !== "true" && andj !== "false") {
              if (andj[0] === "!") {
                result = !evaluateCallback(andj.substring(1));
              } else {
                result = evaluateCallback(andj);
              }
            } else {
              result = andj === "true" ? true : false;
            }
            if (!result) {
              ori = "false";
              break;
            }
          }
        }
        if (result || ori === "true") {
          result = true;
          break;
        }
        if (ori !== "true" && ori !== "false") {
          if (ori[0] === "!") {
            result = !evaluateCallback(ori.substring(1));
          } else {
            result = evaluateCallback(ori);
          }
        } else {
          result = ori === "true" ? true : false;
        }
      }
    }
    return result ? "true" : "false";
  };
  AndOrNotEvaluator2._SimplifyNegation = function(booleanString) {
    booleanString = booleanString.replace(/^[\s!]+/, function(r) {
      r = r.replace(/[\s]/g, function() {
        return "";
      });
      return r.length % 2 ? "!" : "";
    });
    booleanString = booleanString.trim();
    if (booleanString === "!true") {
      booleanString = "false";
    } else if (booleanString === "!false") {
      booleanString = "true";
    }
    return booleanString;
  };
  return AndOrNotEvaluator2;
}();
var Tags = function() {
  function Tags2() {
  }
  Tags2.EnableFor = function(obj) {
    obj._tags = obj._tags || {};
    obj.hasTags = function() {
      return Tags2.HasTags(obj);
    };
    obj.addTags = function(tagsString) {
      return Tags2.AddTagsTo(obj, tagsString);
    };
    obj.removeTags = function(tagsString) {
      return Tags2.RemoveTagsFrom(obj, tagsString);
    };
    obj.matchesTagsQuery = function(tagsQuery) {
      return Tags2.MatchesQuery(obj, tagsQuery);
    };
  };
  Tags2.DisableFor = function(obj) {
    delete obj._tags;
    delete obj.hasTags;
    delete obj.addTags;
    delete obj.removeTags;
    delete obj.matchesTagsQuery;
  };
  Tags2.HasTags = function(obj) {
    if (!obj._tags) {
      return false;
    }
    var tags = obj._tags;
    for (var i in tags) {
      if (Object.prototype.hasOwnProperty.call(tags, i)) {
        return true;
      }
    }
    return false;
  };
  Tags2.GetTags = function(obj, asString) {
    if (asString === void 0) {
      asString = true;
    }
    if (!obj._tags) {
      return null;
    }
    if (asString) {
      var tagsArray = [];
      for (var tag in obj._tags) {
        if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {
          tagsArray.push(tag);
        }
      }
      return tagsArray.join(" ");
    } else {
      return obj._tags;
    }
  };
  Tags2.AddTagsTo = function(obj, tagsString) {
    if (!tagsString) {
      return;
    }
    if (typeof tagsString !== "string") {
      return;
    }
    var tags = tagsString.split(" ");
    tags.forEach(function(tag) {
      Tags2._AddTagTo(obj, tag);
    });
  };
  Tags2._AddTagTo = function(obj, tag) {
    tag = tag.trim();
    if (tag === "" || tag === "true" || tag === "false") {
      return;
    }
    if (tag.match(/[\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {
      return;
    }
    Tags2.EnableFor(obj);
    obj._tags[tag] = true;
  };
  Tags2.RemoveTagsFrom = function(obj, tagsString) {
    if (!Tags2.HasTags(obj)) {
      return;
    }
    var tags = tagsString.split(" ");
    for (var t in tags) {
      Tags2._RemoveTagFrom(obj, tags[t]);
    }
  };
  Tags2._RemoveTagFrom = function(obj, tag) {
    delete obj._tags[tag];
  };
  Tags2.MatchesQuery = function(obj, tagsQuery) {
    if (tagsQuery === void 0) {
      return true;
    }
    if (tagsQuery === "") {
      return Tags2.HasTags(obj);
    }
    return AndOrNotEvaluator.Eval(tagsQuery, function(r) {
      return Tags2.HasTags(obj) && obj._tags[r];
    });
  };
  return Tags2;
}();
function inlineScheduler(coroutine, onStep, onError) {
  try {
    var step_1 = coroutine.next();
    if (step_1.done) {
      onStep(step_1);
    } else if (!step_1.value) {
      onStep(step_1);
    } else {
      step_1.value.then(function() {
        step_1.value = void 0;
        onStep(step_1);
      }, onError);
    }
  } catch (error) {
    onError(error);
  }
}
function createYieldingScheduler(yieldAfterMS) {
  if (yieldAfterMS === void 0) {
    yieldAfterMS = 25;
  }
  var startTime;
  return function(coroutine, onStep, onError) {
    var currentTime = performance.now();
    if (startTime === void 0 || currentTime - startTime > yieldAfterMS) {
      startTime = currentTime;
      setTimeout(function() {
        inlineScheduler(coroutine, onStep, onError);
      }, 0);
    } else {
      inlineScheduler(coroutine, onStep, onError);
    }
  };
}
function runCoroutine(coroutine, scheduler, onSuccess, onError, abortSignal) {
  var resume = function() {
    var reschedule;
    var onStep = function(stepResult) {
      if (stepResult.done) {
        onSuccess(stepResult.value);
      } else {
        if (reschedule === void 0) {
          reschedule = true;
        } else {
          resume();
        }
      }
    };
    do {
      reschedule = void 0;
      if (!abortSignal || !abortSignal.aborted) {
        scheduler(coroutine, onStep, onError);
      } else {
        onError(new Error("Aborted"));
      }
      if (reschedule === void 0) {
        reschedule = false;
      }
    } while (reschedule);
  };
  resume();
}
function runCoroutineSync(coroutine, abortSignal) {
  var result;
  runCoroutine(coroutine, inlineScheduler, function(r) {
    return result = r;
  }, function(e) {
    throw e;
  }, abortSignal);
  return result;
}
function runCoroutineAsync(coroutine, scheduler, abortSignal) {
  return new Promise(function(resolve, reject) {
    runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);
  });
}
function makeSyncFunction(coroutineFactory, abortSignal) {
  return function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    return runCoroutineSync(coroutineFactory.apply(void 0, params), abortSignal);
  };
}
var Scalar = function() {
  function Scalar2() {
  }
  Scalar2.WithinEpsilon = function(a, b, epsilon) {
    if (epsilon === void 0) {
      epsilon = 1401298e-51;
    }
    return Math.abs(a - b) <= epsilon;
  };
  Scalar2.ToHex = function(i) {
    var str = i.toString(16);
    if (i <= 15) {
      return ("0" + str).toUpperCase();
    }
    return str.toUpperCase();
  };
  Scalar2.Sign = function(value) {
    value = +value;
    if (value === 0 || isNaN(value)) {
      return value;
    }
    return value > 0 ? 1 : -1;
  };
  Scalar2.Clamp = function(value, min, max) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 1;
    }
    return Math.min(max, Math.max(min, value));
  };
  Scalar2.Log2 = function(value) {
    return Math.log(value) * Math.LOG2E;
  };
  Scalar2.ILog2 = function(value) {
    if (Math.log2) {
      return Math.floor(Math.log2(value));
    }
    if (value < 0) {
      return NaN;
    } else if (value === 0) {
      return -Infinity;
    }
    var n = 0;
    if (value < 1) {
      while (value < 1) {
        n++;
        value = value * 2;
      }
      n = -n;
    } else if (value > 1) {
      while (value > 1) {
        n++;
        value = Math.floor(value / 2);
      }
    }
    return n;
  };
  Scalar2.Repeat = function(value, length) {
    return value - Math.floor(value / length) * length;
  };
  Scalar2.Normalize = function(value, min, max) {
    return (value - min) / (max - min);
  };
  Scalar2.Denormalize = function(normalized, min, max) {
    return normalized * (max - min) + min;
  };
  Scalar2.DeltaAngle = function(current, target2) {
    var num = Scalar2.Repeat(target2 - current, 360);
    if (num > 180) {
      num -= 360;
    }
    return num;
  };
  Scalar2.PingPong = function(tx, length) {
    var t = Scalar2.Repeat(tx, length * 2);
    return length - Math.abs(t - length);
  };
  Scalar2.SmoothStep = function(from, to, tx) {
    var t = Scalar2.Clamp(tx);
    t = -2 * t * t * t + 3 * t * t;
    return to * t + from * (1 - t);
  };
  Scalar2.MoveTowards = function(current, target2, maxDelta) {
    var result = 0;
    if (Math.abs(target2 - current) <= maxDelta) {
      result = target2;
    } else {
      result = current + Scalar2.Sign(target2 - current) * maxDelta;
    }
    return result;
  };
  Scalar2.MoveTowardsAngle = function(current, target2, maxDelta) {
    var num = Scalar2.DeltaAngle(current, target2);
    var result = 0;
    if (-maxDelta < num && num < maxDelta) {
      result = target2;
    } else {
      target2 = current + num;
      result = Scalar2.MoveTowards(current, target2, maxDelta);
    }
    return result;
  };
  Scalar2.Lerp = function(start, end, amount) {
    return start + (end - start) * amount;
  };
  Scalar2.LerpAngle = function(start, end, amount) {
    var num = Scalar2.Repeat(end - start, 360);
    if (num > 180) {
      num -= 360;
    }
    return start + num * Scalar2.Clamp(amount);
  };
  Scalar2.InverseLerp = function(a, b, value) {
    var result = 0;
    if (a != b) {
      result = Scalar2.Clamp((value - a) / (b - a));
    } else {
      result = 0;
    }
    return result;
  };
  Scalar2.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;
  };
  Scalar2.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var t2 = time * time;
    return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;
  };
  Scalar2.RandomRange = function(min, max) {
    if (min === max) {
      return min;
    }
    return Math.random() * (max - min) + min;
  };
  Scalar2.RangeToPercent = function(number, min, max) {
    return (number - min) / (max - min);
  };
  Scalar2.PercentToRange = function(percent, min, max) {
    return (max - min) * percent + min;
  };
  Scalar2.NormalizeRadians = function(angle) {
    angle -= Scalar2.TwoPi * Math.floor((angle + Math.PI) / Scalar2.TwoPi);
    return angle;
  };
  Scalar2.HCF = function(a, b) {
    var r = a % b;
    if (r === 0) {
      return b;
    }
    return Scalar2.HCF(b, r);
  };
  Scalar2.TwoPi = Math.PI * 2;
  return Scalar2;
}();
var ToGammaSpace = 1 / 2.2;
var ToLinearSpace = 2.2;
var Epsilon = 1e-3;
var ArrayTools = function() {
  function ArrayTools2() {
  }
  ArrayTools2.BuildArray = function(size, itemBuilder) {
    var a = [];
    for (var i = 0; i < size; ++i) {
      a.push(itemBuilder());
    }
    return a;
  };
  ArrayTools2.BuildTuple = function(size, itemBuilder) {
    return ArrayTools2.BuildArray(size, itemBuilder);
  };
  return ArrayTools2;
}();
var _ExtractAsInt = function(value) {
  return parseInt(value.toString().replace(/\W/g, ""));
};
var Vector2 = function() {
  function Vector22(x, y) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    this.x = x;
    this.y = y;
  }
  Vector22.prototype.toString = function() {
    return "{X: ".concat(this.x, " Y: ").concat(this.y, "}");
  };
  Vector22.prototype.getClassName = function() {
    return "Vector2";
  };
  Vector22.prototype.getHashCode = function() {
    var x = _ExtractAsInt(this.x);
    var y = _ExtractAsInt(this.y);
    var hash = x;
    hash = hash * 397 ^ y;
    return hash;
  };
  Vector22.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.x;
    array[index + 1] = this.y;
    return this;
  };
  Vector22.prototype.fromArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    Vector22.FromArrayToRef(array, index, this);
    return this;
  };
  Vector22.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Vector22.prototype.copyFrom = function(source) {
    this.x = source.x;
    this.y = source.y;
    return this;
  };
  Vector22.prototype.copyFromFloats = function(x, y) {
    this.x = x;
    this.y = y;
    return this;
  };
  Vector22.prototype.set = function(x, y) {
    return this.copyFromFloats(x, y);
  };
  Vector22.prototype.add = function(otherVector) {
    return new Vector22(this.x + otherVector.x, this.y + otherVector.y);
  };
  Vector22.prototype.addToRef = function(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    return this;
  };
  Vector22.prototype.addInPlace = function(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    return this;
  };
  Vector22.prototype.addVector3 = function(otherVector) {
    return new Vector22(this.x + otherVector.x, this.y + otherVector.y);
  };
  Vector22.prototype.subtract = function(otherVector) {
    return new Vector22(this.x - otherVector.x, this.y - otherVector.y);
  };
  Vector22.prototype.subtractToRef = function(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    return this;
  };
  Vector22.prototype.subtractInPlace = function(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    return this;
  };
  Vector22.prototype.multiplyInPlace = function(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    return this;
  };
  Vector22.prototype.multiply = function(otherVector) {
    return new Vector22(this.x * otherVector.x, this.y * otherVector.y);
  };
  Vector22.prototype.multiplyToRef = function(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    return this;
  };
  Vector22.prototype.multiplyByFloats = function(x, y) {
    return new Vector22(this.x * x, this.y * y);
  };
  Vector22.prototype.divide = function(otherVector) {
    return new Vector22(this.x / otherVector.x, this.y / otherVector.y);
  };
  Vector22.prototype.divideToRef = function(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    return this;
  };
  Vector22.prototype.divideInPlace = function(otherVector) {
    return this.divideToRef(otherVector, this);
  };
  Vector22.prototype.negate = function() {
    return new Vector22(-this.x, -this.y);
  };
  Vector22.prototype.negateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    return this;
  };
  Vector22.prototype.negateToRef = function(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1);
  };
  Vector22.prototype.scaleInPlace = function(scale) {
    this.x *= scale;
    this.y *= scale;
    return this;
  };
  Vector22.prototype.scale = function(scale) {
    var result = new Vector22(0, 0);
    this.scaleToRef(scale, result);
    return result;
  };
  Vector22.prototype.scaleToRef = function(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    return this;
  };
  Vector22.prototype.scaleAndAddToRef = function(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    return this;
  };
  Vector22.prototype.equals = function(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y;
  };
  Vector22.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);
  };
  Vector22.prototype.floor = function() {
    return new Vector22(Math.floor(this.x), Math.floor(this.y));
  };
  Vector22.prototype.fract = function() {
    return new Vector22(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
  };
  Vector22.prototype.rotateToRef = function(angle, result) {
    var cos = Math.cos(angle);
    var sin = Math.sin(angle);
    result.x = cos * this.x - sin * this.y;
    result.y = sin * this.x + cos * this.y;
    return this;
  };
  Vector22.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  };
  Vector22.prototype.lengthSquared = function() {
    return this.x * this.x + this.y * this.y;
  };
  Vector22.prototype.normalize = function() {
    Vector22.NormalizeToRef(this, this);
    return this;
  };
  Vector22.prototype.clone = function() {
    return new Vector22(this.x, this.y);
  };
  Vector22.Zero = function() {
    return new Vector22(0, 0);
  };
  Vector22.One = function() {
    return new Vector22(1, 1);
  };
  Vector22.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Vector22(array[offset], array[offset + 1]);
  };
  Vector22.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
  };
  Vector22.CatmullRom = function(value1, value2, value3, value4, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var x = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
    var y = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
    return new Vector22(x, y);
  };
  Vector22.Clamp = function(value, min, max) {
    var x = value.x;
    x = x > max.x ? max.x : x;
    x = x < min.x ? min.x : x;
    var y = value.y;
    y = y > max.y ? max.y : y;
    y = y < min.y ? min.y : y;
    return new Vector22(x, y);
  };
  Vector22.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
    var y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
    return new Vector22(x, y);
  };
  Vector22.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = Vector22.Zero();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Vector22.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
  };
  Vector22.Lerp = function(start, end, amount) {
    var x = start.x + (end.x - start.x) * amount;
    var y = start.y + (end.y - start.y) * amount;
    return new Vector22(x, y);
  };
  Vector22.Dot = function(left, right) {
    return left.x * right.x + left.y * right.y;
  };
  Vector22.Normalize = function(vector) {
    var newVector = Vector22.Zero();
    this.NormalizeToRef(vector, newVector);
    return newVector;
  };
  Vector22.NormalizeToRef = function(vector, result) {
    var len = vector.length();
    if (len === 0) {
      return;
    }
    result.x = vector.x / len;
    result.y = vector.y / len;
  };
  Vector22.Minimize = function(left, right) {
    var x = left.x < right.x ? left.x : right.x;
    var y = left.y < right.y ? left.y : right.y;
    return new Vector22(x, y);
  };
  Vector22.Maximize = function(left, right) {
    var x = left.x > right.x ? left.x : right.x;
    var y = left.y > right.y ? left.y : right.y;
    return new Vector22(x, y);
  };
  Vector22.Transform = function(vector, transformation) {
    var r = Vector22.Zero();
    Vector22.TransformToRef(vector, transformation, r);
    return r;
  };
  Vector22.TransformToRef = function(vector, transformation, result) {
    var m = transformation.m;
    var x = vector.x * m[0] + vector.y * m[4] + m[12];
    var y = vector.x * m[1] + vector.y * m[5] + m[13];
    result.x = x;
    result.y = y;
  };
  Vector22.PointInTriangle = function(p, p0, p1, p2) {
    var a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
    var sign = a < 0 ? -1 : 1;
    var s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
    var t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;
    return s > 0 && t > 0 && s + t < 2 * a * sign;
  };
  Vector22.Distance = function(value1, value2) {
    return Math.sqrt(Vector22.DistanceSquared(value1, value2));
  };
  Vector22.DistanceSquared = function(value1, value2) {
    var x = value1.x - value2.x;
    var y = value1.y - value2.y;
    return x * x + y * y;
  };
  Vector22.Center = function(value1, value2) {
    return Vector22.CenterToRef(value1, value2, Vector22.Zero());
  };
  Vector22.CenterToRef = function(value1, value2, ref) {
    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);
  };
  Vector22.DistanceOfPointFromSegment = function(p, segA, segB) {
    var l2 = Vector22.DistanceSquared(segA, segB);
    if (l2 === 0) {
      return Vector22.Distance(p, segA);
    }
    var v = segB.subtract(segA);
    var t = Math.max(0, Math.min(1, Vector22.Dot(p.subtract(segA), v) / l2));
    var proj = segA.add(v.multiplyByFloats(t, t));
    return Vector22.Distance(p, proj);
  };
  return Vector22;
}();
var Vector3 = function() {
  function Vector32(x, y, z) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
  }
  Object.defineProperty(Vector32.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32.prototype, "z", {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.prototype.toString = function() {
    return "{X: ".concat(this._x, " Y: ").concat(this._y, " Z: ").concat(this._z, "}");
  };
  Vector32.prototype.getClassName = function() {
    return "Vector3";
  };
  Vector32.prototype.getHashCode = function() {
    var x = _ExtractAsInt(this._x);
    var y = _ExtractAsInt(this._y);
    var z = _ExtractAsInt(this._z);
    var hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    return hash;
  };
  Vector32.prototype.asArray = function() {
    var result = [];
    this.toArray(result, 0);
    return result;
  };
  Vector32.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this._x;
    array[index + 1] = this._y;
    array[index + 2] = this._z;
    return this;
  };
  Vector32.prototype.fromArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    Vector32.FromArrayToRef(array, index, this);
    return this;
  };
  Vector32.prototype.toQuaternion = function() {
    return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);
  };
  Vector32.prototype.addInPlace = function(otherVector) {
    return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);
  };
  Vector32.prototype.addInPlaceFromFloats = function(x, y, z) {
    this.x += x;
    this.y += y;
    this.z += z;
    return this;
  };
  Vector32.prototype.add = function(otherVector) {
    return new Vector32(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  };
  Vector32.prototype.addToRef = function(otherVector, result) {
    return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
  };
  Vector32.prototype.subtractInPlace = function(otherVector) {
    this.x -= otherVector._x;
    this.y -= otherVector._y;
    this.z -= otherVector._z;
    return this;
  };
  Vector32.prototype.subtract = function(otherVector) {
    return new Vector32(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);
  };
  Vector32.prototype.subtractToRef = function(otherVector, result) {
    return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);
  };
  Vector32.prototype.subtractFromFloats = function(x, y, z) {
    return new Vector32(this._x - x, this._y - y, this._z - z);
  };
  Vector32.prototype.subtractFromFloatsToRef = function(x, y, z, result) {
    return result.copyFromFloats(this._x - x, this._y - y, this._z - z);
  };
  Vector32.prototype.negate = function() {
    return new Vector32(-this._x, -this._y, -this._z);
  };
  Vector32.prototype.negateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  };
  Vector32.prototype.negateToRef = function(result) {
    return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
  };
  Vector32.prototype.scaleInPlace = function(scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    return this;
  };
  Vector32.prototype.scale = function(scale) {
    return new Vector32(this._x * scale, this._y * scale, this._z * scale);
  };
  Vector32.prototype.scaleToRef = function(scale, result) {
    return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);
  };
  Vector32.prototype.applyRotationQuaternionToRef = function(q, result) {
    var ix = q.w * this.x + q.y * this.z - q.z * this.y;
    var iy = q.w * this.y + q.z * this.x - q.x * this.z;
    var iz = q.w * this.z + q.x * this.y - q.y * this.x;
    var iw = -q.x * this.x - q.y * this.y - q.z * this.z;
    result.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;
    result.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;
    result.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;
    return result;
  };
  Vector32.prototype.applyRotationQuaternionInPlace = function(q) {
    return this.applyRotationQuaternionToRef(q, this);
  };
  Vector32.prototype.applyRotationQuaternion = function(q) {
    return this.applyRotationQuaternionToRef(q, Vector32.Zero());
  };
  Vector32.prototype.scaleAndAddToRef = function(scale, result) {
    return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);
  };
  Vector32.prototype.projectOnPlane = function(plane, origin2) {
    var result = Vector32.Zero();
    this.projectOnPlaneToRef(plane, origin2, result);
    return result;
  };
  Vector32.prototype.projectOnPlaneToRef = function(plane, origin2, result) {
    var n = plane.normal;
    var d = plane.d;
    var V = MathTmp.Vector3[0];
    this.subtractToRef(origin2, V);
    V.normalize();
    var denom = Vector32.Dot(V, n);
    var t = -(Vector32.Dot(origin2, n) + d) / denom;
    var scaledV = V.scaleInPlace(t);
    origin2.addToRef(scaledV, result);
  };
  Vector32.prototype.equals = function(otherVector) {
    return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;
  };
  Vector32.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);
  };
  Vector32.prototype.equalsToFloats = function(x, y, z) {
    return this._x === x && this._y === y && this._z === z;
  };
  Vector32.prototype.multiplyInPlace = function(otherVector) {
    this.x *= otherVector._x;
    this.y *= otherVector._y;
    this.z *= otherVector._z;
    return this;
  };
  Vector32.prototype.multiply = function(otherVector) {
    return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);
  };
  Vector32.prototype.multiplyToRef = function(otherVector, result) {
    return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);
  };
  Vector32.prototype.multiplyByFloats = function(x, y, z) {
    return new Vector32(this._x * x, this._y * y, this._z * z);
  };
  Vector32.prototype.divide = function(otherVector) {
    return new Vector32(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  };
  Vector32.prototype.divideToRef = function(otherVector, result) {
    return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
  };
  Vector32.prototype.divideInPlace = function(otherVector) {
    return this.divideToRef(otherVector, this);
  };
  Vector32.prototype.minimizeInPlace = function(other) {
    return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);
  };
  Vector32.prototype.maximizeInPlace = function(other) {
    return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);
  };
  Vector32.prototype.minimizeInPlaceFromFloats = function(x, y, z) {
    if (x < this._x) {
      this.x = x;
    }
    if (y < this._y) {
      this.y = y;
    }
    if (z < this._z) {
      this.z = z;
    }
    return this;
  };
  Vector32.prototype.maximizeInPlaceFromFloats = function(x, y, z) {
    if (x > this._x) {
      this.x = x;
    }
    if (y > this._y) {
      this.y = y;
    }
    if (z > this._z) {
      this.z = z;
    }
    return this;
  };
  Vector32.prototype.isNonUniformWithinEpsilon = function(epsilon) {
    var absX = Math.abs(this._x);
    var absY = Math.abs(this._y);
    if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {
      return true;
    }
    var absZ = Math.abs(this._z);
    if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {
      return true;
    }
    if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {
      return true;
    }
    return false;
  };
  Object.defineProperty(Vector32.prototype, "isNonUniform", {
    get: function() {
      var absX = Math.abs(this._x);
      var absY = Math.abs(this._y);
      if (absX !== absY) {
        return true;
      }
      var absZ = Math.abs(this._z);
      if (absX !== absZ) {
        return true;
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.prototype.floor = function() {
    return new Vector32(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
  };
  Vector32.prototype.fract = function() {
    return new Vector32(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
  };
  Vector32.prototype.length = function() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  };
  Vector32.prototype.lengthSquared = function() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  };
  Object.defineProperty(Vector32.prototype, "hasAZeroComponent", {
    get: function() {
      return this._x * this._y * this._z === 0;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.prototype.normalize = function() {
    return this.normalizeFromLength(this.length());
  };
  Vector32.prototype.reorderInPlace = function(order) {
    var _this = this;
    order = order.toLowerCase();
    if (order === "xyz") {
      return this;
    }
    MathTmp.Vector3[0].copyFrom(this);
    ["x", "y", "z"].forEach(function(val, i) {
      _this[val] = MathTmp.Vector3[0][order[i]];
    });
    return this;
  };
  Vector32.prototype.rotateByQuaternionToRef = function(quaternion, result) {
    quaternion.toRotationMatrix(MathTmp.Matrix[0]);
    Vector32.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);
    return result;
  };
  Vector32.prototype.rotateByQuaternionAroundPointToRef = function(quaternion, point, result) {
    this.subtractToRef(point, MathTmp.Vector3[0]);
    MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);
    point.addToRef(MathTmp.Vector3[0], result);
    return result;
  };
  Vector32.prototype.cross = function(other) {
    return Vector32.Cross(this, other);
  };
  Vector32.prototype.normalizeFromLength = function(len) {
    if (len === 0 || len === 1) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  };
  Vector32.prototype.normalizeToNew = function() {
    var normalized = new Vector32(0, 0, 0);
    this.normalizeToRef(normalized);
    return normalized;
  };
  Vector32.prototype.normalizeToRef = function(reference) {
    var len = this.length();
    if (len === 0 || len === 1) {
      return reference.copyFromFloats(this._x, this._y, this._z);
    }
    return this.scaleToRef(1 / len, reference);
  };
  Vector32.prototype.clone = function() {
    return new Vector32(this._x, this._y, this._z);
  };
  Vector32.prototype.copyFrom = function(source) {
    return this.copyFromFloats(source._x, source._y, source._z);
  };
  Vector32.prototype.copyFromFloats = function(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  };
  Vector32.prototype.set = function(x, y, z) {
    return this.copyFromFloats(x, y, z);
  };
  Vector32.prototype.setAll = function(v) {
    this.x = this.y = this.z = v;
    return this;
  };
  Vector32.GetClipFactor = function(vector0, vector1, axis, size) {
    var d0 = Vector32.Dot(vector0, axis) - size;
    var d1 = Vector32.Dot(vector1, axis) - size;
    var s = d0 / (d0 - d1);
    return s;
  };
  Vector32.GetAngleBetweenVectors = function(vector0, vector1, normal) {
    var v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);
    var v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);
    var dot = Vector32.Dot(v0, v1);
    dot = Scalar.Clamp(dot, -1, 1);
    var angle = Math.acos(dot);
    var n = MathTmp.Vector3[3];
    Vector32.CrossToRef(v0, v1, n);
    if (Vector32.Dot(n, normal) > 0) {
      return isNaN(angle) ? 0 : angle;
    }
    return isNaN(angle) ? -Math.PI : -Math.acos(dot);
  };
  Vector32.GetAngleBetweenVectorsOnPlane = function(vector0, vector1, normal) {
    MathTmp.Vector3[0].copyFrom(vector0);
    var v0 = MathTmp.Vector3[0];
    MathTmp.Vector3[1].copyFrom(vector1);
    var v1 = MathTmp.Vector3[1];
    MathTmp.Vector3[2].copyFrom(normal);
    var vNormal = MathTmp.Vector3[2];
    var right = MathTmp.Vector3[3];
    var forward = MathTmp.Vector3[4];
    v0.normalize();
    v1.normalize();
    vNormal.normalize();
    Vector32.CrossToRef(vNormal, v0, right);
    Vector32.CrossToRef(right, vNormal, forward);
    var angle = Math.atan2(Vector32.Dot(v1, right), Vector32.Dot(v1, forward));
    return Scalar.NormalizeRadians(angle);
  };
  Vector32.SlerpToRef = function(vector0, vector1, slerp, result) {
    slerp = Scalar.Clamp(slerp, 0, 1);
    var vector0Dir = MathTmp.Vector3[0];
    var vector1Dir = MathTmp.Vector3[1];
    vector0Dir.copyFrom(vector0);
    var vector0Length = vector0Dir.length();
    vector0Dir.normalizeFromLength(vector0Length);
    vector1Dir.copyFrom(vector1);
    var vector1Length = vector1Dir.length();
    vector1Dir.normalizeFromLength(vector1Length);
    var dot = Vector32.Dot(vector0Dir, vector1Dir);
    var scale0;
    var scale1;
    if (dot < 1 - Epsilon) {
      var omega = Math.acos(dot);
      var invSin = 1 / Math.sin(omega);
      scale0 = Math.sin((1 - slerp) * omega) * invSin;
      scale1 = Math.sin(slerp * omega) * invSin;
    } else {
      scale0 = 1 - slerp;
      scale1 = slerp;
    }
    vector0Dir.scaleInPlace(scale0);
    vector1Dir.scaleInPlace(scale1);
    result.copyFrom(vector0Dir).addInPlace(vector1Dir);
    result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));
  };
  Vector32.SmoothToRef = function(source, goal, deltaTime, lerpTime, result) {
    Vector32.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);
  };
  Vector32.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Vector32(array[offset], array[offset + 1], array[offset + 2]);
  };
  Vector32.FromFloatArray = function(array, offset) {
    return Vector32.FromArray(array, offset);
  };
  Vector32.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
  };
  Vector32.FromFloatArrayToRef = function(array, offset, result) {
    return Vector32.FromArrayToRef(array, offset, result);
  };
  Vector32.FromFloatsToRef = function(x, y, z, result) {
    result.copyFromFloats(x, y, z);
  };
  Vector32.Zero = function() {
    return new Vector32(0, 0, 0);
  };
  Vector32.One = function() {
    return new Vector32(1, 1, 1);
  };
  Vector32.Up = function() {
    return new Vector32(0, 1, 0);
  };
  Object.defineProperty(Vector32, "UpReadOnly", {
    get: function() {
      return Vector32._UpReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "RightReadOnly", {
    get: function() {
      return Vector32._RightReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "LeftReadOnly", {
    get: function() {
      return Vector32._LeftReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "LeftHandedForwardReadOnly", {
    get: function() {
      return Vector32._LeftHandedForwardReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "RightHandedForwardReadOnly", {
    get: function() {
      return Vector32._RightHandedForwardReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Vector32, "ZeroReadOnly", {
    get: function() {
      return Vector32._ZeroReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Vector32.Down = function() {
    return new Vector32(0, -1, 0);
  };
  Vector32.Forward = function(rightHandedSystem) {
    if (rightHandedSystem === void 0) {
      rightHandedSystem = false;
    }
    return new Vector32(0, 0, rightHandedSystem ? -1 : 1);
  };
  Vector32.Backward = function(rightHandedSystem) {
    if (rightHandedSystem === void 0) {
      rightHandedSystem = false;
    }
    return new Vector32(0, 0, rightHandedSystem ? 1 : -1);
  };
  Vector32.Right = function() {
    return new Vector32(1, 0, 0);
  };
  Vector32.Left = function() {
    return new Vector32(-1, 0, 0);
  };
  Vector32.TransformCoordinates = function(vector, transformation) {
    var result = Vector32.Zero();
    Vector32.TransformCoordinatesToRef(vector, transformation, result);
    return result;
  };
  Vector32.TransformCoordinatesToRef = function(vector, transformation, result) {
    Vector32.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
  };
  Vector32.TransformCoordinatesFromFloatsToRef = function(x, y, z, transformation, result) {
    var m = transformation.m;
    var rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    var ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    var rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    var rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);
    result.x = rx * rw;
    result.y = ry * rw;
    result.z = rz * rw;
  };
  Vector32.TransformNormal = function(vector, transformation) {
    var result = Vector32.Zero();
    Vector32.TransformNormalToRef(vector, transformation, result);
    return result;
  };
  Vector32.TransformNormalToRef = function(vector, transformation, result) {
    this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
  };
  Vector32.TransformNormalFromFloatsToRef = function(x, y, z, transformation, result) {
    var m = transformation.m;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
  };
  Vector32.CatmullRom = function(value1, value2, value3, value4, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var x = 0.5 * (2 * value2._x + (-value1._x + value3._x) * amount + (2 * value1._x - 5 * value2._x + 4 * value3._x - value4._x) * squared + (-value1._x + 3 * value2._x - 3 * value3._x + value4._x) * cubed);
    var y = 0.5 * (2 * value2._y + (-value1._y + value3._y) * amount + (2 * value1._y - 5 * value2._y + 4 * value3._y - value4._y) * squared + (-value1._y + 3 * value2._y - 3 * value3._y + value4._y) * cubed);
    var z = 0.5 * (2 * value2._z + (-value1._z + value3._z) * amount + (2 * value1._z - 5 * value2._z + 4 * value3._z - value4._z) * squared + (-value1._z + 3 * value2._z - 3 * value3._z + value4._z) * cubed);
    return new Vector32(x, y, z);
  };
  Vector32.Clamp = function(value, min, max) {
    var v = new Vector32();
    Vector32.ClampToRef(value, min, max, v);
    return v;
  };
  Vector32.ClampToRef = function(value, min, max, result) {
    var x = value._x;
    x = x > max._x ? max._x : x;
    x = x < min._x ? min._x : x;
    var y = value._y;
    y = y > max._y ? max._y : y;
    y = y < min._y ? min._y : y;
    var z = value._z;
    z = z > max._z ? max._z : z;
    z = z < min._z ? min._z : z;
    result.copyFromFloats(x, y, z);
  };
  Vector32.CheckExtends = function(v, min, max) {
    min.minimizeInPlace(v);
    max.maximizeInPlace(v);
  };
  Vector32.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    return new Vector32(x, y, z);
  };
  Vector32.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = Vector32.Zero();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Vector32.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
    result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;
  };
  Vector32.Lerp = function(start, end, amount) {
    var result = new Vector32(0, 0, 0);
    Vector32.LerpToRef(start, end, amount, result);
    return result;
  };
  Vector32.LerpToRef = function(start, end, amount, result) {
    result.x = start._x + (end._x - start._x) * amount;
    result.y = start._y + (end._y - start._y) * amount;
    result.z = start._z + (end._z - start._z) * amount;
  };
  Vector32.Dot = function(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z;
  };
  Vector32.Cross = function(left, right) {
    var result = Vector32.Zero();
    Vector32.CrossToRef(left, right, result);
    return result;
  };
  Vector32.CrossToRef = function(left, right, result) {
    var x = left._y * right._z - left._z * right._y;
    var y = left._z * right._x - left._x * right._z;
    var z = left._x * right._y - left._y * right._x;
    result.copyFromFloats(x, y, z);
  };
  Vector32.Normalize = function(vector) {
    var result = Vector32.Zero();
    Vector32.NormalizeToRef(vector, result);
    return result;
  };
  Vector32.NormalizeToRef = function(vector, result) {
    vector.normalizeToRef(result);
  };
  Vector32.Project = function(vector, world, transform2, viewport) {
    var result = new Vector32();
    Vector32.ProjectToRef(vector, world, transform2, viewport, result);
    return result;
  };
  Vector32.ProjectToRef = function(vector, world, transform2, viewport, result) {
    var cw = viewport.width;
    var ch = viewport.height;
    var cx = viewport.x;
    var cy = viewport.y;
    var viewportMatrix = MathTmp.Matrix[1];
    Matrix.FromValuesToRef(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, 0.5, 0, cx + cw / 2, ch / 2 + cy, 0.5, 1, viewportMatrix);
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(transform2, matrix);
    matrix.multiplyToRef(viewportMatrix, matrix);
    Vector32.TransformCoordinatesToRef(vector, matrix, result);
    return result;
  };
  Vector32._UnprojectFromInvertedMatrixToRef = function(source, matrix, result) {
    Vector32.TransformCoordinatesToRef(source, matrix, result);
    var m = matrix.m;
    var num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];
    if (Scalar.WithinEpsilon(num, 1)) {
      result.scaleInPlace(1 / num);
    }
  };
  Vector32.UnprojectFromTransform = function(source, viewportWidth, viewportHeight, world, transform2) {
    return this.Unproject(source, viewportWidth, viewportHeight, world, transform2, Matrix.IdentityReadOnly);
  };
  Vector32.Unproject = function(source, viewportWidth, viewportHeight, world, view, projection) {
    var result = Vector32.Zero();
    Vector32.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);
    return result;
  };
  Vector32.UnprojectToRef = function(source, viewportWidth, viewportHeight, world, view, projection, result) {
    Vector32.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);
  };
  Vector32.UnprojectFloatsToRef = function(sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {
    var _a2;
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    matrix.invert();
    var screenSource = MathTmp.Vector3[0];
    screenSource.x = sourceX / viewportWidth * 2 - 1;
    screenSource.y = -(sourceY / viewportHeight * 2 - 1);
    if ((_a2 = EngineStore.LastCreatedEngine) === null || _a2 === void 0 ? void 0 : _a2.isNDCHalfZRange) {
      screenSource.z = sourceZ;
    } else {
      screenSource.z = 2 * sourceZ - 1;
    }
    Vector32._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);
  };
  Vector32.Minimize = function(left, right) {
    var min = left.clone();
    min.minimizeInPlace(right);
    return min;
  };
  Vector32.Maximize = function(left, right) {
    var max = left.clone();
    max.maximizeInPlace(right);
    return max;
  };
  Vector32.Distance = function(value1, value2) {
    return Math.sqrt(Vector32.DistanceSquared(value1, value2));
  };
  Vector32.DistanceSquared = function(value1, value2) {
    var x = value1._x - value2._x;
    var y = value1._y - value2._y;
    var z = value1._z - value2._z;
    return x * x + y * y + z * z;
  };
  Vector32.ProjectOnTriangleToRef = function(vector, p0, p1, p2, ref) {
    var p1p0 = MathTmp.Vector3[0];
    var p2p0 = MathTmp.Vector3[1];
    var p2p1 = MathTmp.Vector3[2];
    var normal = MathTmp.Vector3[3];
    var vectorp0 = MathTmp.Vector3[4];
    p1.subtractToRef(p0, p1p0);
    p2.subtractToRef(p0, p2p0);
    p2.subtractToRef(p1, p2p1);
    var p1p0L = p1p0.length();
    var p2p0L = p2p0.length();
    var p2p1L = p2p1.length();
    if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {
      ref.copyFrom(p0);
      return Vector32.Distance(vector, p0);
    }
    vector.subtractToRef(p0, vectorp0);
    Vector32.CrossToRef(p1p0, p2p0, normal);
    var nl = normal.length();
    if (nl < Epsilon) {
      ref.copyFrom(p0);
      return Vector32.Distance(vector, p0);
    }
    normal.normalizeFromLength(nl);
    var l = vectorp0.length();
    if (l < Epsilon) {
      ref.copyFrom(p0);
      return 0;
    }
    vectorp0.normalizeFromLength(l);
    var cosA = Vector32.Dot(normal, vectorp0);
    var projVector = MathTmp.Vector3[5];
    var proj = MathTmp.Vector3[6];
    projVector.copyFrom(normal).scaleInPlace(-l * cosA);
    proj.copyFrom(vector).addInPlace(projVector);
    var v0 = MathTmp.Vector3[4];
    var v1 = MathTmp.Vector3[5];
    var v2 = MathTmp.Vector3[7];
    var tmp = MathTmp.Vector3[8];
    v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);
    tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);
    v0.addInPlace(tmp).scaleInPlace(-1);
    v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);
    tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);
    v1.addInPlace(tmp).scaleInPlace(-1);
    v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);
    tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);
    v2.addInPlace(tmp).scaleInPlace(-1);
    var projP = MathTmp.Vector3[9];
    var dot;
    projP.copyFrom(proj).subtractInPlace(p0);
    Vector32.CrossToRef(v0, projP, tmp);
    dot = Vector32.Dot(tmp, normal);
    var s0 = dot;
    projP.copyFrom(proj).subtractInPlace(p1);
    Vector32.CrossToRef(v1, projP, tmp);
    dot = Vector32.Dot(tmp, normal);
    var s1 = dot;
    projP.copyFrom(proj).subtractInPlace(p2);
    Vector32.CrossToRef(v2, projP, tmp);
    dot = Vector32.Dot(tmp, normal);
    var s2 = dot;
    var edge = MathTmp.Vector3[10];
    var e0, e1;
    if (s0 > 0 && s1 < 0) {
      edge.copyFrom(p1p0);
      e0 = p0;
      e1 = p1;
    } else if (s1 > 0 && s2 < 0) {
      edge.copyFrom(p2p1);
      e0 = p1;
      e1 = p2;
    } else {
      edge.copyFrom(p2p0).scaleInPlace(-1);
      e0 = p2;
      e1 = p0;
    }
    var tmp2 = MathTmp.Vector3[9];
    var tmp3 = MathTmp.Vector3[4];
    e0.subtractToRef(proj, tmp);
    e1.subtractToRef(proj, tmp2);
    Vector32.CrossToRef(tmp, tmp2, tmp3);
    var isOutside = Vector32.Dot(tmp3, normal) < 0;
    if (!isOutside) {
      ref.copyFrom(proj);
      return Math.abs(l * cosA);
    }
    var r = MathTmp.Vector3[5];
    Vector32.CrossToRef(edge, tmp3, r);
    r.normalize();
    var e0proj = MathTmp.Vector3[9];
    e0proj.copyFrom(e0).subtractInPlace(proj);
    var e0projL = e0proj.length();
    if (e0projL < Epsilon) {
      ref.copyFrom(e0);
      return Vector32.Distance(vector, e0);
    }
    e0proj.normalizeFromLength(e0projL);
    var cosG = Vector32.Dot(r, e0proj);
    var triProj = MathTmp.Vector3[7];
    triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG));
    tmp.copyFrom(triProj).subtractInPlace(e0);
    l = edge.length();
    edge.normalizeFromLength(l);
    var t = Vector32.Dot(tmp, edge) / Math.max(l, Epsilon);
    t = Scalar.Clamp(t, 0, 1);
    triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));
    ref.copyFrom(triProj);
    return Vector32.Distance(vector, triProj);
  };
  Vector32.Center = function(value1, value2) {
    return Vector32.CenterToRef(value1, value2, Vector32.Zero());
  };
  Vector32.CenterToRef = function(value1, value2, ref) {
    return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);
  };
  Vector32.RotationFromAxis = function(axis1, axis2, axis3) {
    var rotation = Vector32.Zero();
    Vector32.RotationFromAxisToRef(axis1, axis2, axis3, rotation);
    return rotation;
  };
  Vector32.RotationFromAxisToRef = function(axis1, axis2, axis3, ref) {
    var quat = MathTmp.Quaternion[0];
    Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    quat.toEulerAnglesToRef(ref);
  };
  Vector32._UpReadOnly = Vector32.Up();
  Vector32._LeftHandedForwardReadOnly = Vector32.Forward(false);
  Vector32._RightHandedForwardReadOnly = Vector32.Forward(true);
  Vector32._RightReadOnly = Vector32.Right();
  Vector32._LeftReadOnly = Vector32.Left();
  Vector32._ZeroReadOnly = Vector32.Zero();
  return Vector32;
}();
var Vector4 = function() {
  function Vector42(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  Vector42.prototype.toString = function() {
    return "{X: ".concat(this.x, " Y: ").concat(this.y, " Z: ").concat(this.z, " W: ").concat(this.w, "}");
  };
  Vector42.prototype.getClassName = function() {
    return "Vector4";
  };
  Vector42.prototype.getHashCode = function() {
    var x = _ExtractAsInt(this.x);
    var y = _ExtractAsInt(this.y);
    var z = _ExtractAsInt(this.z);
    var w = _ExtractAsInt(this.w);
    var hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    hash = hash * 397 ^ w;
    return hash;
  };
  Vector42.prototype.asArray = function() {
    var result = new Array();
    this.toArray(result, 0);
    return result;
  };
  Vector42.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.x;
    array[index + 1] = this.y;
    array[index + 2] = this.z;
    array[index + 3] = this.w;
    return this;
  };
  Vector42.prototype.fromArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    Vector42.FromArrayToRef(array, index, this);
    return this;
  };
  Vector42.prototype.addInPlace = function(otherVector) {
    this.x += otherVector.x;
    this.y += otherVector.y;
    this.z += otherVector.z;
    this.w += otherVector.w;
    return this;
  };
  Vector42.prototype.add = function(otherVector) {
    return new Vector42(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);
  };
  Vector42.prototype.addToRef = function(otherVector, result) {
    result.x = this.x + otherVector.x;
    result.y = this.y + otherVector.y;
    result.z = this.z + otherVector.z;
    result.w = this.w + otherVector.w;
    return this;
  };
  Vector42.prototype.subtractInPlace = function(otherVector) {
    this.x -= otherVector.x;
    this.y -= otherVector.y;
    this.z -= otherVector.z;
    this.w -= otherVector.w;
    return this;
  };
  Vector42.prototype.subtract = function(otherVector) {
    return new Vector42(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);
  };
  Vector42.prototype.subtractToRef = function(otherVector, result) {
    result.x = this.x - otherVector.x;
    result.y = this.y - otherVector.y;
    result.z = this.z - otherVector.z;
    result.w = this.w - otherVector.w;
    return this;
  };
  Vector42.prototype.subtractFromFloats = function(x, y, z, w) {
    return new Vector42(this.x - x, this.y - y, this.z - z, this.w - w);
  };
  Vector42.prototype.subtractFromFloatsToRef = function(x, y, z, w, result) {
    result.x = this.x - x;
    result.y = this.y - y;
    result.z = this.z - z;
    result.w = this.w - w;
    return this;
  };
  Vector42.prototype.negate = function() {
    return new Vector42(-this.x, -this.y, -this.z, -this.w);
  };
  Vector42.prototype.negateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    this.w *= -1;
    return this;
  };
  Vector42.prototype.negateToRef = function(result) {
    return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
  };
  Vector42.prototype.scaleInPlace = function(scale) {
    this.x *= scale;
    this.y *= scale;
    this.z *= scale;
    this.w *= scale;
    return this;
  };
  Vector42.prototype.scale = function(scale) {
    return new Vector42(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
  };
  Vector42.prototype.scaleToRef = function(scale, result) {
    result.x = this.x * scale;
    result.y = this.y * scale;
    result.z = this.z * scale;
    result.w = this.w * scale;
    return this;
  };
  Vector42.prototype.scaleAndAddToRef = function(scale, result) {
    result.x += this.x * scale;
    result.y += this.y * scale;
    result.z += this.z * scale;
    result.w += this.w * scale;
    return this;
  };
  Vector42.prototype.equals = function(otherVector) {
    return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;
  };
  Vector42.prototype.equalsWithEpsilon = function(otherVector, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);
  };
  Vector42.prototype.equalsToFloats = function(x, y, z, w) {
    return this.x === x && this.y === y && this.z === z && this.w === w;
  };
  Vector42.prototype.multiplyInPlace = function(otherVector) {
    this.x *= otherVector.x;
    this.y *= otherVector.y;
    this.z *= otherVector.z;
    this.w *= otherVector.w;
    return this;
  };
  Vector42.prototype.multiply = function(otherVector) {
    return new Vector42(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);
  };
  Vector42.prototype.multiplyToRef = function(otherVector, result) {
    result.x = this.x * otherVector.x;
    result.y = this.y * otherVector.y;
    result.z = this.z * otherVector.z;
    result.w = this.w * otherVector.w;
    return this;
  };
  Vector42.prototype.multiplyByFloats = function(x, y, z, w) {
    return new Vector42(this.x * x, this.y * y, this.z * z, this.w * w);
  };
  Vector42.prototype.divide = function(otherVector) {
    return new Vector42(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);
  };
  Vector42.prototype.divideToRef = function(otherVector, result) {
    result.x = this.x / otherVector.x;
    result.y = this.y / otherVector.y;
    result.z = this.z / otherVector.z;
    result.w = this.w / otherVector.w;
    return this;
  };
  Vector42.prototype.divideInPlace = function(otherVector) {
    return this.divideToRef(otherVector, this);
  };
  Vector42.prototype.minimizeInPlace = function(other) {
    if (other.x < this.x) {
      this.x = other.x;
    }
    if (other.y < this.y) {
      this.y = other.y;
    }
    if (other.z < this.z) {
      this.z = other.z;
    }
    if (other.w < this.w) {
      this.w = other.w;
    }
    return this;
  };
  Vector42.prototype.maximizeInPlace = function(other) {
    if (other.x > this.x) {
      this.x = other.x;
    }
    if (other.y > this.y) {
      this.y = other.y;
    }
    if (other.z > this.z) {
      this.z = other.z;
    }
    if (other.w > this.w) {
      this.w = other.w;
    }
    return this;
  };
  Vector42.prototype.floor = function() {
    return new Vector42(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
  };
  Vector42.prototype.fract = function() {
    return new Vector42(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
  };
  Vector42.prototype.length = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  };
  Vector42.prototype.lengthSquared = function() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  };
  Vector42.prototype.normalize = function() {
    var len = this.length();
    if (len === 0) {
      return this;
    }
    return this.scaleInPlace(1 / len);
  };
  Vector42.prototype.toVector3 = function() {
    return new Vector3(this.x, this.y, this.z);
  };
  Vector42.prototype.clone = function() {
    return new Vector42(this.x, this.y, this.z, this.w);
  };
  Vector42.prototype.copyFrom = function(source) {
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    this.w = source.w;
    return this;
  };
  Vector42.prototype.copyFromFloats = function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  Vector42.prototype.set = function(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  };
  Vector42.prototype.setAll = function(v) {
    this.x = this.y = this.z = this.w = v;
    return this;
  };
  Vector42.FromArray = function(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new Vector42(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  };
  Vector42.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    result.w = array[offset + 3];
  };
  Vector42.FromFloatArrayToRef = function(array, offset, result) {
    Vector42.FromArrayToRef(array, offset, result);
  };
  Vector42.FromFloatsToRef = function(x, y, z, w, result) {
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = w;
  };
  Vector42.Zero = function() {
    return new Vector42(0, 0, 0, 0);
  };
  Vector42.One = function() {
    return new Vector42(1, 1, 1, 1);
  };
  Vector42.Normalize = function(vector) {
    var result = Vector42.Zero();
    Vector42.NormalizeToRef(vector, result);
    return result;
  };
  Vector42.NormalizeToRef = function(vector, result) {
    result.copyFrom(vector);
    result.normalize();
  };
  Vector42.Minimize = function(left, right) {
    var min = left.clone();
    min.minimizeInPlace(right);
    return min;
  };
  Vector42.Maximize = function(left, right) {
    var max = left.clone();
    max.maximizeInPlace(right);
    return max;
  };
  Vector42.Distance = function(value1, value2) {
    return Math.sqrt(Vector42.DistanceSquared(value1, value2));
  };
  Vector42.DistanceSquared = function(value1, value2) {
    var x = value1.x - value2.x;
    var y = value1.y - value2.y;
    var z = value1.z - value2.z;
    var w = value1.w - value2.w;
    return x * x + y * y + z * z + w * w;
  };
  Vector42.Center = function(value1, value2) {
    return Vector42.CenterToRef(value1, value2, Vector42.Zero());
  };
  Vector42.CenterToRef = function(value1, value2, ref) {
    return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);
  };
  Vector42.TransformCoordinates = function(vector, transformation) {
    var result = Vector42.Zero();
    Vector42.TransformCoordinatesToRef(vector, transformation, result);
    return result;
  };
  Vector42.TransformCoordinatesToRef = function(vector, transformation, result) {
    Vector42.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
  };
  Vector42.TransformCoordinatesFromFloatsToRef = function(x, y, z, transformation, result) {
    var m = transformation.m;
    var rx = x * m[0] + y * m[4] + z * m[8] + m[12];
    var ry = x * m[1] + y * m[5] + z * m[9] + m[13];
    var rz = x * m[2] + y * m[6] + z * m[10] + m[14];
    var rw = x * m[3] + y * m[7] + z * m[11] + m[15];
    result.x = rx;
    result.y = ry;
    result.z = rz;
    result.w = rw;
  };
  Vector42.TransformNormal = function(vector, transformation) {
    var result = Vector42.Zero();
    Vector42.TransformNormalToRef(vector, transformation, result);
    return result;
  };
  Vector42.TransformNormalToRef = function(vector, transformation, result) {
    var m = transformation.m;
    var x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];
    var y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];
    var z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];
    result.x = x;
    result.y = y;
    result.z = z;
    result.w = vector.w;
  };
  Vector42.TransformNormalFromFloatsToRef = function(x, y, z, w, transformation, result) {
    var m = transformation.m;
    result.x = x * m[0] + y * m[4] + z * m[8];
    result.y = x * m[1] + y * m[5] + z * m[9];
    result.z = x * m[2] + y * m[6] + z * m[10];
    result.w = w;
  };
  Vector42.FromVector3 = function(source, w) {
    if (w === void 0) {
      w = 0;
    }
    return new Vector42(source._x, source._y, source._z, w);
  };
  return Vector42;
}();
var Quaternion = function() {
  function Quaternion2(x, y, z, w) {
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (w === void 0) {
      w = 1;
    }
    this._isDirty = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  Object.defineProperty(Quaternion2.prototype, "x", {
    get: function() {
      return this._x;
    },
    set: function(value) {
      this._x = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Quaternion2.prototype, "y", {
    get: function() {
      return this._y;
    },
    set: function(value) {
      this._y = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Quaternion2.prototype, "z", {
    get: function() {
      return this._z;
    },
    set: function(value) {
      this._z = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Quaternion2.prototype, "w", {
    get: function() {
      return this._w;
    },
    set: function(value) {
      this._w = value;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Quaternion2.prototype.toString = function() {
    return "{X: ".concat(this._x, " Y: ").concat(this._y, " Z: ").concat(this._z, " W: ").concat(this._w, "}");
  };
  Quaternion2.prototype.getClassName = function() {
    return "Quaternion";
  };
  Quaternion2.prototype.getHashCode = function() {
    var x = _ExtractAsInt(this._x);
    var y = _ExtractAsInt(this._y);
    var z = _ExtractAsInt(this._z);
    var w = _ExtractAsInt(this._w);
    var hash = x;
    hash = hash * 397 ^ y;
    hash = hash * 397 ^ z;
    hash = hash * 397 ^ w;
    return hash;
  };
  Quaternion2.prototype.asArray = function() {
    return [this._x, this._y, this._z, this._w];
  };
  Quaternion2.prototype.equals = function(otherQuaternion) {
    return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;
  };
  Quaternion2.prototype.equalsWithEpsilon = function(otherQuaternion, epsilon) {
    if (epsilon === void 0) {
      epsilon = Epsilon;
    }
    return otherQuaternion && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);
  };
  Quaternion2.prototype.clone = function() {
    return new Quaternion2(this._x, this._y, this._z, this._w);
  };
  Quaternion2.prototype.copyFrom = function(other) {
    this.x = other._x;
    this.y = other._y;
    this.z = other._z;
    this.w = other._w;
    return this;
  };
  Quaternion2.prototype.copyFromFloats = function(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  };
  Quaternion2.prototype.set = function(x, y, z, w) {
    return this.copyFromFloats(x, y, z, w);
  };
  Quaternion2.prototype.add = function(other) {
    return new Quaternion2(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);
  };
  Quaternion2.prototype.addInPlace = function(other) {
    this._x += other._x;
    this._y += other._y;
    this._z += other._z;
    this._w += other._w;
    return this;
  };
  Quaternion2.prototype.subtract = function(other) {
    return new Quaternion2(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);
  };
  Quaternion2.prototype.subtractInPlace = function(other) {
    this._x -= other._x;
    this._y -= other._y;
    this._z -= other._z;
    this._w -= other._w;
    return this;
  };
  Quaternion2.prototype.scale = function(value) {
    return new Quaternion2(this._x * value, this._y * value, this._z * value, this._w * value);
  };
  Quaternion2.prototype.scaleToRef = function(scale, result) {
    result.x = this._x * scale;
    result.y = this._y * scale;
    result.z = this._z * scale;
    result.w = this._w * scale;
    return this;
  };
  Quaternion2.prototype.scaleInPlace = function(value) {
    this.x *= value;
    this.y *= value;
    this.z *= value;
    this.w *= value;
    return this;
  };
  Quaternion2.prototype.scaleAndAddToRef = function(scale, result) {
    result.x += this._x * scale;
    result.y += this._y * scale;
    result.z += this._z * scale;
    result.w += this._w * scale;
    return this;
  };
  Quaternion2.prototype.multiply = function(q1) {
    var result = new Quaternion2(0, 0, 0, 1);
    this.multiplyToRef(q1, result);
    return result;
  };
  Quaternion2.prototype.multiplyToRef = function(q1, result) {
    var x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;
    var y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;
    var z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;
    var w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;
    result.copyFromFloats(x, y, z, w);
    return this;
  };
  Quaternion2.prototype.multiplyInPlace = function(q1) {
    this.multiplyToRef(q1, this);
    return this;
  };
  Quaternion2.prototype.conjugateToRef = function(ref) {
    ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);
    return this;
  };
  Quaternion2.prototype.conjugateInPlace = function() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    return this;
  };
  Quaternion2.prototype.conjugate = function() {
    return new Quaternion2(-this._x, -this._y, -this._z, this._w);
  };
  Quaternion2.prototype.invert = function() {
    var conjugate = this.conjugate();
    var lengthSquared = this.lengthSquared();
    if (lengthSquared == 0 || lengthSquared == 1) {
      return conjugate;
    }
    conjugate.scaleInPlace(1 / lengthSquared);
    return conjugate;
  };
  Quaternion2.prototype.invertInPlace = function() {
    this.conjugateInPlace();
    var lengthSquared = this.lengthSquared();
    if (lengthSquared == 0 || lengthSquared == 1) {
      return this;
    }
    this.scaleInPlace(1 / lengthSquared);
    return this;
  };
  Quaternion2.prototype.lengthSquared = function() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  };
  Quaternion2.prototype.length = function() {
    return Math.sqrt(this.lengthSquared());
  };
  Quaternion2.prototype.normalize = function() {
    var len = this.length();
    if (len === 0) {
      return this;
    }
    var inv = 1 / len;
    this.scaleInPlace(inv);
    return this;
  };
  Quaternion2.prototype.normalizeToNew = function() {
    var len = this.length();
    if (len === 0) {
      return this.clone();
    }
    var inv = 1 / len;
    return this.scale(inv);
  };
  Quaternion2.prototype.toEulerAngles = function() {
    var result = Vector3.Zero();
    this.toEulerAnglesToRef(result);
    return result;
  };
  Quaternion2.prototype.toEulerAnglesToRef = function(result) {
    var qz = this._z;
    var qx = this._x;
    var qy = this._y;
    var qw = this._w;
    var zAxisY = qy * qz - qx * qw;
    var limit = 0.4999999;
    if (zAxisY < -limit) {
      result.y = 2 * Math.atan2(qy, qw);
      result.x = Math.PI / 2;
      result.z = 0;
    } else if (zAxisY > limit) {
      result.y = 2 * Math.atan2(qy, qw);
      result.x = -Math.PI / 2;
      result.z = 0;
    } else {
      var sqw = qw * qw;
      var sqz = qz * qz;
      var sqx = qx * qx;
      var sqy = qy * qy;
      result.z = Math.atan2(2 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);
      result.x = Math.asin(-2 * zAxisY);
      result.y = Math.atan2(2 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);
    }
    return this;
  };
  Quaternion2.prototype.toRotationMatrix = function(result) {
    Matrix.FromQuaternionToRef(this, result);
    return this;
  };
  Quaternion2.prototype.fromRotationMatrix = function(matrix) {
    Quaternion2.FromRotationMatrixToRef(matrix, this);
    return this;
  };
  Quaternion2.FromRotationMatrix = function(matrix) {
    var result = new Quaternion2();
    Quaternion2.FromRotationMatrixToRef(matrix, result);
    return result;
  };
  Quaternion2.FromRotationMatrixToRef = function(matrix, result) {
    var data = matrix.m;
    var m11 = data[0], m12 = data[4], m13 = data[8];
    var m21 = data[1], m22 = data[5], m23 = data[9];
    var m31 = data[2], m32 = data[6], m33 = data[10];
    var trace = m11 + m22 + m33;
    var s;
    if (trace > 0) {
      s = 0.5 / Math.sqrt(trace + 1);
      result.w = 0.25 / s;
      result.x = (m32 - m23) * s;
      result.y = (m13 - m31) * s;
      result.z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      result.w = (m32 - m23) / s;
      result.x = 0.25 * s;
      result.y = (m12 + m21) / s;
      result.z = (m13 + m31) / s;
    } else if (m22 > m33) {
      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      result.w = (m13 - m31) / s;
      result.x = (m12 + m21) / s;
      result.y = 0.25 * s;
      result.z = (m23 + m32) / s;
    } else {
      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      result.w = (m21 - m12) / s;
      result.x = (m13 + m31) / s;
      result.y = (m23 + m32) / s;
      result.z = 0.25 * s;
    }
  };
  Quaternion2.Dot = function(left, right) {
    return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
  };
  Quaternion2.AreClose = function(quat0, quat1) {
    var dot = Quaternion2.Dot(quat0, quat1);
    return dot >= 0;
  };
  Quaternion2.SmoothToRef = function(source, goal, deltaTime, lerpTime, result) {
    var slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;
    slerp = Scalar.Clamp(slerp, 0, 1);
    Quaternion2.SlerpToRef(source, goal, slerp, result);
  };
  Quaternion2.Zero = function() {
    return new Quaternion2(0, 0, 0, 0);
  };
  Quaternion2.Inverse = function(q) {
    return new Quaternion2(-q._x, -q._y, -q._z, q._w);
  };
  Quaternion2.InverseToRef = function(q, result) {
    result.set(-q._x, -q._y, -q._z, q._w);
    return result;
  };
  Quaternion2.Identity = function() {
    return new Quaternion2(0, 0, 0, 1);
  };
  Quaternion2.IsIdentity = function(quaternion) {
    return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;
  };
  Quaternion2.RotationAxis = function(axis, angle) {
    return Quaternion2.RotationAxisToRef(axis, angle, new Quaternion2());
  };
  Quaternion2.RotationAxisToRef = function(axis, angle, result) {
    var sin = Math.sin(angle / 2);
    axis.normalize();
    result.w = Math.cos(angle / 2);
    result.x = axis._x * sin;
    result.y = axis._y * sin;
    result.z = axis._z * sin;
    return result;
  };
  Quaternion2.FromArray = function(array, offset) {
    if (!offset) {
      offset = 0;
    }
    return new Quaternion2(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  };
  Quaternion2.FromArrayToRef = function(array, offset, result) {
    result.x = array[offset];
    result.y = array[offset + 1];
    result.z = array[offset + 2];
    result.w = array[offset + 3];
  };
  Quaternion2.FromEulerAngles = function(x, y, z) {
    var q = new Quaternion2();
    Quaternion2.RotationYawPitchRollToRef(y, x, z, q);
    return q;
  };
  Quaternion2.FromEulerAnglesToRef = function(x, y, z, result) {
    Quaternion2.RotationYawPitchRollToRef(y, x, z, result);
    return result;
  };
  Quaternion2.FromEulerVector = function(vec) {
    var q = new Quaternion2();
    Quaternion2.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);
    return q;
  };
  Quaternion2.FromEulerVectorToRef = function(vec, result) {
    Quaternion2.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);
    return result;
  };
  Quaternion2.FromUnitVectorsToRef = function(vecFrom, vecTo, result) {
    var r = Vector3.Dot(vecFrom, vecTo) + 1;
    if (r < Epsilon) {
      if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {
        result.set(-vecFrom.y, vecFrom.x, 0, 0);
      } else {
        result.set(0, -vecFrom.z, vecFrom.y, 0);
      }
    } else {
      Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);
      result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);
    }
    return result.normalize();
  };
  Quaternion2.RotationYawPitchRoll = function(yaw, pitch, roll) {
    var q = new Quaternion2();
    Quaternion2.RotationYawPitchRollToRef(yaw, pitch, roll, q);
    return q;
  };
  Quaternion2.RotationYawPitchRollToRef = function(yaw, pitch, roll, result) {
    var halfRoll = roll * 0.5;
    var halfPitch = pitch * 0.5;
    var halfYaw = yaw * 0.5;
    var sinRoll = Math.sin(halfRoll);
    var cosRoll = Math.cos(halfRoll);
    var sinPitch = Math.sin(halfPitch);
    var cosPitch = Math.cos(halfPitch);
    var sinYaw = Math.sin(halfYaw);
    var cosYaw = Math.cos(halfYaw);
    result.x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
    result.y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
    result.z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
    result.w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
  };
  Quaternion2.RotationAlphaBetaGamma = function(alpha, beta, gamma) {
    var result = new Quaternion2();
    Quaternion2.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);
    return result;
  };
  Quaternion2.RotationAlphaBetaGammaToRef = function(alpha, beta, gamma, result) {
    var halfGammaPlusAlpha = (gamma + alpha) * 0.5;
    var halfGammaMinusAlpha = (gamma - alpha) * 0.5;
    var halfBeta = beta * 0.5;
    result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);
    result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);
    result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);
  };
  Quaternion2.RotationQuaternionFromAxis = function(axis1, axis2, axis3) {
    var quat = new Quaternion2(0, 0, 0, 0);
    Quaternion2.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
    return quat;
  };
  Quaternion2.RotationQuaternionFromAxisToRef = function(axis1, axis2, axis3, ref) {
    var rotMat = MathTmp.Matrix[0];
    Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);
    Quaternion2.FromRotationMatrixToRef(rotMat, ref);
  };
  Quaternion2.FromLookDirectionLH = function(forward, up) {
    var quat = new Quaternion2();
    Quaternion2.FromLookDirectionLHToRef(forward, up, quat);
    return quat;
  };
  Quaternion2.FromLookDirectionLHToRef = function(forward, up, ref) {
    var rotMat = MathTmp.Matrix[0];
    Matrix.LookDirectionLHToRef(forward, up, rotMat);
    Quaternion2.FromRotationMatrixToRef(rotMat, ref);
  };
  Quaternion2.FromLookDirectionRH = function(forward, up) {
    var quat = new Quaternion2();
    Quaternion2.FromLookDirectionRHToRef(forward, up, quat);
    return quat;
  };
  Quaternion2.FromLookDirectionRHToRef = function(forward, up, ref) {
    var rotMat = MathTmp.Matrix[0];
    Matrix.LookDirectionRHToRef(forward, up, rotMat);
    return Quaternion2.FromRotationMatrixToRef(rotMat, ref);
  };
  Quaternion2.Slerp = function(left, right, amount) {
    var result = Quaternion2.Identity();
    Quaternion2.SlerpToRef(left, right, amount, result);
    return result;
  };
  Quaternion2.SlerpToRef = function(left, right, amount, result) {
    var num2;
    var num3;
    var num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
    var flag = false;
    if (num4 < 0) {
      flag = true;
      num4 = -num4;
    }
    if (num4 > 0.999999) {
      num3 = 1 - amount;
      num2 = flag ? -amount : amount;
    } else {
      var num5 = Math.acos(num4);
      var num6 = 1 / Math.sin(num5);
      num3 = Math.sin((1 - amount) * num5) * num6;
      num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;
    }
    result.x = num3 * left._x + num2 * right._x;
    result.y = num3 * left._y + num2 * right._y;
    result.z = num3 * left._z + num2 * right._z;
    result.w = num3 * left._w + num2 * right._w;
  };
  Quaternion2.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
    var y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
    var z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
    var w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;
    return new Quaternion2(x, y, z, w);
  };
  Quaternion2.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = Quaternion2.Zero();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Quaternion2.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
    result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
    result.z = (t2 - time) * 6 * value1.z + (3 * t2 - 4 * time + 1) * tangent1.z + (-t2 + time) * 6 * value2.z + (3 * t2 - 2 * time) * tangent2.z;
    result.w = (t2 - time) * 6 * value1.w + (3 * t2 - 4 * time + 1) * tangent1.w + (-t2 + time) * 6 * value2.w + (3 * t2 - 2 * time) * tangent2.w;
  };
  return Quaternion2;
}();
var Matrix = function() {
  function Matrix2() {
    this._isIdentity = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2 = true;
    this._isIdentity3x2Dirty = true;
    this.updateFlag = -1;
    if (PerformanceConfigurator.MatrixTrackPrecisionChange) {
      PerformanceConfigurator.MatrixTrackedMatrices.push(this);
    }
    this._m = new PerformanceConfigurator.MatrixCurrentType(16);
    this.markAsUpdated();
  }
  Object.defineProperty(Matrix2, "Use64Bits", {
    get: function() {
      return PerformanceConfigurator.MatrixUse64Bits;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Matrix2.prototype, "m", {
    get: function() {
      return this._m;
    },
    enumerable: false,
    configurable: true
  });
  Matrix2.prototype.markAsUpdated = function() {
    this.updateFlag = Matrix2._UpdateFlagSeed++;
    this._isIdentity = false;
    this._isIdentity3x2 = false;
    this._isIdentityDirty = true;
    this._isIdentity3x2Dirty = true;
  };
  Matrix2.prototype._updateIdentityStatus = function(isIdentity, isIdentityDirty, isIdentity3x2, isIdentity3x2Dirty) {
    if (isIdentityDirty === void 0) {
      isIdentityDirty = false;
    }
    if (isIdentity3x2 === void 0) {
      isIdentity3x2 = false;
    }
    if (isIdentity3x2Dirty === void 0) {
      isIdentity3x2Dirty = true;
    }
    this._isIdentity = isIdentity;
    this._isIdentity3x2 = isIdentity || isIdentity3x2;
    this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;
    this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;
  };
  Matrix2.prototype.isIdentity = function() {
    if (this._isIdentityDirty) {
      this._isIdentityDirty = false;
      var m = this._m;
      this._isIdentity = m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
    }
    return this._isIdentity;
  };
  Matrix2.prototype.isIdentityAs3x2 = function() {
    if (this._isIdentity3x2Dirty) {
      this._isIdentity3x2Dirty = false;
      if (this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1) {
        this._isIdentity3x2 = false;
      } else if (this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0) {
        this._isIdentity3x2 = false;
      } else {
        this._isIdentity3x2 = true;
      }
    }
    return this._isIdentity3x2;
  };
  Matrix2.prototype.determinant = function() {
    if (this._isIdentity === true) {
      return 1;
    }
    var m = this._m;
    var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    var det_22_33 = m22 * m33 - m32 * m23;
    var det_21_33 = m21 * m33 - m31 * m23;
    var det_21_32 = m21 * m32 - m31 * m22;
    var det_20_33 = m20 * m33 - m30 * m23;
    var det_20_32 = m20 * m32 - m22 * m30;
    var det_20_31 = m20 * m31 - m30 * m21;
    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
  };
  Matrix2.prototype.toArray = function() {
    return this._m;
  };
  Matrix2.prototype.asArray = function() {
    return this._m;
  };
  Matrix2.prototype.invert = function() {
    this.invertToRef(this);
    return this;
  };
  Matrix2.prototype.reset = function() {
    Matrix2.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this);
    this._updateIdentityStatus(false);
    return this;
  };
  Matrix2.prototype.add = function(other) {
    var result = new Matrix2();
    this.addToRef(other, result);
    return result;
  };
  Matrix2.prototype.addToRef = function(other, result) {
    var m = this._m;
    var resultM = result._m;
    var otherM = other.m;
    for (var index = 0; index < 16; index++) {
      resultM[index] = m[index] + otherM[index];
    }
    result.markAsUpdated();
    return this;
  };
  Matrix2.prototype.addToSelf = function(other) {
    var m = this._m;
    var otherM = other.m;
    for (var index = 0; index < 16; index++) {
      m[index] += otherM[index];
    }
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.invertToRef = function(other) {
    if (this._isIdentity === true) {
      Matrix2.IdentityToRef(other);
      return this;
    }
    var m = this._m;
    var m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
    var m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
    var m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
    var m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
    var det_22_33 = m22 * m33 - m32 * m23;
    var det_21_33 = m21 * m33 - m31 * m23;
    var det_21_32 = m21 * m32 - m31 * m22;
    var det_20_33 = m20 * m33 - m30 * m23;
    var det_20_32 = m20 * m32 - m22 * m30;
    var det_20_31 = m20 * m31 - m30 * m21;
    var cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
    var cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
    var cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
    var cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
    var det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
    if (det === 0) {
      other.copyFrom(this);
      return this;
    }
    var detInv = 1 / det;
    var det_12_33 = m12 * m33 - m32 * m13;
    var det_11_33 = m11 * m33 - m31 * m13;
    var det_11_32 = m11 * m32 - m31 * m12;
    var det_10_33 = m10 * m33 - m30 * m13;
    var det_10_32 = m10 * m32 - m30 * m12;
    var det_10_31 = m10 * m31 - m30 * m11;
    var det_12_23 = m12 * m23 - m22 * m13;
    var det_11_23 = m11 * m23 - m21 * m13;
    var det_11_22 = m11 * m22 - m21 * m12;
    var det_10_23 = m10 * m23 - m20 * m13;
    var det_10_22 = m10 * m22 - m20 * m12;
    var det_10_21 = m10 * m21 - m20 * m11;
    var cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);
    var cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);
    var cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);
    var cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);
    var cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);
    var cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);
    var cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);
    var cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);
    var cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);
    var cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);
    var cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);
    var cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);
    Matrix2.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);
    return this;
  };
  Matrix2.prototype.addAtIndex = function(index, value) {
    this._m[index] += value;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.multiplyAtIndex = function(index, value) {
    this._m[index] *= value;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.setTranslationFromFloats = function(x, y, z) {
    this._m[12] = x;
    this._m[13] = y;
    this._m[14] = z;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.addTranslationFromFloats = function(x, y, z) {
    this._m[12] += x;
    this._m[13] += y;
    this._m[14] += z;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.setTranslation = function(vector3) {
    return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);
  };
  Matrix2.prototype.getTranslation = function() {
    return new Vector3(this._m[12], this._m[13], this._m[14]);
  };
  Matrix2.prototype.getTranslationToRef = function(result) {
    result.x = this._m[12];
    result.y = this._m[13];
    result.z = this._m[14];
    return this;
  };
  Matrix2.prototype.removeRotationAndScaling = function() {
    var m = this.m;
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, m[12], m[13], m[14], m[15], this);
    this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);
    return this;
  };
  Matrix2.prototype.multiply = function(other) {
    var result = new Matrix2();
    this.multiplyToRef(other, result);
    return result;
  };
  Matrix2.prototype.copyFrom = function(other) {
    other.copyToArray(this._m);
    var o = other;
    this.updateFlag = o.updateFlag;
    this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);
    return this;
  };
  Matrix2.prototype.copyToArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var source = this._m;
    array[offset] = source[0];
    array[offset + 1] = source[1];
    array[offset + 2] = source[2];
    array[offset + 3] = source[3];
    array[offset + 4] = source[4];
    array[offset + 5] = source[5];
    array[offset + 6] = source[6];
    array[offset + 7] = source[7];
    array[offset + 8] = source[8];
    array[offset + 9] = source[9];
    array[offset + 10] = source[10];
    array[offset + 11] = source[11];
    array[offset + 12] = source[12];
    array[offset + 13] = source[13];
    array[offset + 14] = source[14];
    array[offset + 15] = source[15];
    return this;
  };
  Matrix2.prototype.multiplyToRef = function(other, result) {
    if (this._isIdentity) {
      result.copyFrom(other);
      return this;
    }
    if (other._isIdentity) {
      result.copyFrom(this);
      return this;
    }
    this.multiplyToArray(other, result._m, 0);
    result.markAsUpdated();
    return this;
  };
  Matrix2.prototype.multiplyToArray = function(other, result, offset) {
    var m = this._m;
    var otherM = other.m;
    var tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];
    var tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];
    var tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];
    var tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];
    var om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];
    var om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];
    var om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];
    var om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];
    result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;
    result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;
    result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;
    result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;
    result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;
    result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;
    result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;
    result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;
    result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;
    result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;
    result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;
    result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;
    result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;
    result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;
    result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;
    result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;
    return this;
  };
  Matrix2.prototype.equals = function(value) {
    var other = value;
    if (!other) {
      return false;
    }
    if (this._isIdentity || other._isIdentity) {
      if (!this._isIdentityDirty && !other._isIdentityDirty) {
        return this._isIdentity && other._isIdentity;
      }
    }
    var m = this.m;
    var om = other.m;
    return m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] && m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] && m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] && m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15];
  };
  Matrix2.prototype.clone = function() {
    var matrix = new Matrix2();
    matrix.copyFrom(this);
    return matrix;
  };
  Matrix2.prototype.getClassName = function() {
    return "Matrix";
  };
  Matrix2.prototype.getHashCode = function() {
    var hash = _ExtractAsInt(this._m[0]);
    for (var i = 1; i < 16; i++) {
      hash = hash * 397 ^ _ExtractAsInt(this._m[i]);
    }
    return hash;
  };
  Matrix2.prototype.decomposeToTransformNode = function(node) {
    node.rotationQuaternion = node.rotationQuaternion || new Quaternion();
    return this.decompose(node.scaling, node.rotationQuaternion, node.position);
  };
  Matrix2.prototype.decompose = function(scale, rotation, translation, preserveScalingNode) {
    if (this._isIdentity) {
      if (translation) {
        translation.setAll(0);
      }
      if (scale) {
        scale.setAll(1);
      }
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return true;
    }
    var m = this._m;
    if (translation) {
      translation.copyFromFloats(m[12], m[13], m[14]);
    }
    scale = scale || MathTmp.Vector3[0];
    scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
    scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
    scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);
    if (preserveScalingNode) {
      var signX = preserveScalingNode.scaling.x < 0 ? -1 : 1;
      var signY = preserveScalingNode.scaling.y < 0 ? -1 : 1;
      var signZ = preserveScalingNode.scaling.z < 0 ? -1 : 1;
      scale.x *= signX;
      scale.y *= signY;
      scale.z *= signZ;
    } else {
      if (this.determinant() <= 0) {
        scale.y *= -1;
      }
    }
    if (scale._x === 0 || scale._y === 0 || scale._z === 0) {
      if (rotation) {
        rotation.copyFromFloats(0, 0, 0, 1);
      }
      return false;
    }
    if (rotation) {
      var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
      Matrix2.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);
      Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);
    }
    return true;
  };
  Matrix2.prototype.getRow = function(index) {
    if (index < 0 || index > 3) {
      return null;
    }
    var i = index * 4;
    return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);
  };
  Matrix2.prototype.setRow = function(index, row) {
    return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);
  };
  Matrix2.prototype.transpose = function() {
    return Matrix2.Transpose(this);
  };
  Matrix2.prototype.transposeToRef = function(result) {
    Matrix2.TransposeToRef(this, result);
    return this;
  };
  Matrix2.prototype.setRowFromFloats = function(index, x, y, z, w) {
    if (index < 0 || index > 3) {
      return this;
    }
    var i = index * 4;
    this._m[i + 0] = x;
    this._m[i + 1] = y;
    this._m[i + 2] = z;
    this._m[i + 3] = w;
    this.markAsUpdated();
    return this;
  };
  Matrix2.prototype.scale = function(scale) {
    var result = new Matrix2();
    this.scaleToRef(scale, result);
    return result;
  };
  Matrix2.prototype.scaleToRef = function(scale, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] = this._m[index] * scale;
    }
    result.markAsUpdated();
    return this;
  };
  Matrix2.prototype.scaleAndAddToRef = function(scale, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] += this._m[index] * scale;
    }
    result.markAsUpdated();
    return this;
  };
  Matrix2.prototype.toNormalMatrix = function(ref) {
    var tmp = MathTmp.Matrix[0];
    this.invertToRef(tmp);
    tmp.transposeToRef(ref);
    var m = ref._m;
    Matrix2.FromValuesToRef(m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, 0, 0, 0, 1, ref);
  };
  Matrix2.prototype.getRotationMatrix = function() {
    var result = new Matrix2();
    this.getRotationMatrixToRef(result);
    return result;
  };
  Matrix2.prototype.getRotationMatrixToRef = function(result) {
    var scale = MathTmp.Vector3[0];
    if (!this.decompose(scale)) {
      Matrix2.IdentityToRef(result);
      return this;
    }
    var m = this._m;
    var sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
    Matrix2.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, result);
    return this;
  };
  Matrix2.prototype.toggleModelMatrixHandInPlace = function() {
    var m = this._m;
    m[2] *= -1;
    m[6] *= -1;
    m[8] *= -1;
    m[9] *= -1;
    m[14] *= -1;
    this.markAsUpdated();
  };
  Matrix2.prototype.toggleProjectionMatrixHandInPlace = function() {
    var m = this._m;
    m[8] *= -1;
    m[9] *= -1;
    m[10] *= -1;
    m[11] *= -1;
    this.markAsUpdated();
  };
  Matrix2.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    var result = new Matrix2();
    Matrix2.FromArrayToRef(array, offset, result);
    return result;
  };
  Matrix2.FromArrayToRef = function(array, offset, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] = array[index + offset];
    }
    result.markAsUpdated();
  };
  Matrix2.FromFloat32ArrayToRefScaled = function(array, offset, scale, result) {
    for (var index = 0; index < 16; index++) {
      result._m[index] = array[index + offset] * scale;
    }
    result.markAsUpdated();
  };
  Object.defineProperty(Matrix2, "IdentityReadOnly", {
    get: function() {
      return Matrix2._IdentityReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Matrix2.FromValuesToRef = function(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {
    var m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result.markAsUpdated();
  };
  Matrix2.FromValues = function(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {
    var result = new Matrix2();
    var m = result._m;
    m[0] = initialM11;
    m[1] = initialM12;
    m[2] = initialM13;
    m[3] = initialM14;
    m[4] = initialM21;
    m[5] = initialM22;
    m[6] = initialM23;
    m[7] = initialM24;
    m[8] = initialM31;
    m[9] = initialM32;
    m[10] = initialM33;
    m[11] = initialM34;
    m[12] = initialM41;
    m[13] = initialM42;
    m[14] = initialM43;
    m[15] = initialM44;
    result.markAsUpdated();
    return result;
  };
  Matrix2.Compose = function(scale, rotation, translation) {
    var result = new Matrix2();
    Matrix2.ComposeToRef(scale, rotation, translation, result);
    return result;
  };
  Matrix2.ComposeToRef = function(scale, rotation, translation, result) {
    var m = result._m;
    var x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
    var x2 = x + x, y2 = y + y, z2 = z + z;
    var xx = x * x2, xy = x * y2, xz = x * z2;
    var yy = y * y2, yz = y * z2, zz = z * z2;
    var wx = w * x2, wy = w * y2, wz = w * z2;
    var sx = scale._x, sy = scale._y, sz = scale._z;
    m[0] = (1 - (yy + zz)) * sx;
    m[1] = (xy + wz) * sx;
    m[2] = (xz - wy) * sx;
    m[3] = 0;
    m[4] = (xy - wz) * sy;
    m[5] = (1 - (xx + zz)) * sy;
    m[6] = (yz + wx) * sy;
    m[7] = 0;
    m[8] = (xz + wy) * sz;
    m[9] = (yz - wx) * sz;
    m[10] = (1 - (xx + yy)) * sz;
    m[11] = 0;
    m[12] = translation._x;
    m[13] = translation._y;
    m[14] = translation._z;
    m[15] = 1;
    result.markAsUpdated();
  };
  Matrix2.Identity = function() {
    var identity = Matrix2.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    identity._updateIdentityStatus(true);
    return identity;
  };
  Matrix2.IdentityToRef = function(result) {
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(true);
  };
  Matrix2.Zero = function() {
    var zero = Matrix2.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    zero._updateIdentityStatus(false);
    return zero;
  };
  Matrix2.RotationX = function(angle) {
    var result = new Matrix2();
    Matrix2.RotationXToRef(angle, result);
    return result;
  };
  Matrix2.Invert = function(source) {
    var result = new Matrix2();
    source.invertToRef(result);
    return result;
  };
  Matrix2.RotationXToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
  };
  Matrix2.RotationY = function(angle) {
    var result = new Matrix2();
    Matrix2.RotationYToRef(angle, result);
    return result;
  };
  Matrix2.RotationYToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    Matrix2.FromValuesToRef(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
  };
  Matrix2.RotationZ = function(angle) {
    var result = new Matrix2();
    Matrix2.RotationZToRef(angle, result);
    return result;
  };
  Matrix2.RotationZToRef = function(angle, result) {
    var s = Math.sin(angle);
    var c = Math.cos(angle);
    Matrix2.FromValuesToRef(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(c === 1 && s === 0);
  };
  Matrix2.RotationAxis = function(axis, angle) {
    var result = new Matrix2();
    Matrix2.RotationAxisToRef(axis, angle, result);
    return result;
  };
  Matrix2.RotationAxisToRef = function(axis, angle, result) {
    var s = Math.sin(-angle);
    var c = Math.cos(-angle);
    var c1 = 1 - c;
    axis.normalize();
    var m = result._m;
    m[0] = axis._x * axis._x * c1 + c;
    m[1] = axis._x * axis._y * c1 - axis._z * s;
    m[2] = axis._x * axis._z * c1 + axis._y * s;
    m[3] = 0;
    m[4] = axis._y * axis._x * c1 + axis._z * s;
    m[5] = axis._y * axis._y * c1 + c;
    m[6] = axis._y * axis._z * c1 - axis._x * s;
    m[7] = 0;
    m[8] = axis._z * axis._x * c1 - axis._y * s;
    m[9] = axis._z * axis._y * c1 + axis._x * s;
    m[10] = axis._z * axis._z * c1 + c;
    m[11] = 0;
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result.markAsUpdated();
  };
  Matrix2.RotationAlignToRef = function(from, to, result) {
    var c = Vector3.Dot(to, from);
    var m = result._m;
    if (c < -1 + Epsilon) {
      m[0] = -1;
      m[1] = 0;
      m[2] = 0;
      m[3] = 0;
      m[4] = 0;
      m[5] = -1;
      m[6] = 0;
      m[7] = 0;
      m[8] = 0;
      m[9] = 0;
      m[10] = 1;
      m[11] = 0;
    } else {
      var v = Vector3.Cross(to, from);
      var k = 1 / (1 + c);
      m[0] = v._x * v._x * k + c;
      m[1] = v._y * v._x * k - v._z;
      m[2] = v._z * v._x * k + v._y;
      m[3] = 0;
      m[4] = v._x * v._y * k + v._z;
      m[5] = v._y * v._y * k + c;
      m[6] = v._z * v._y * k - v._x;
      m[7] = 0;
      m[8] = v._x * v._z * k - v._y;
      m[9] = v._y * v._z * k + v._x;
      m[10] = v._z * v._z * k + c;
      m[11] = 0;
    }
    m[12] = 0;
    m[13] = 0;
    m[14] = 0;
    m[15] = 1;
    result.markAsUpdated();
  };
  Matrix2.RotationYawPitchRoll = function(yaw, pitch, roll) {
    var result = new Matrix2();
    Matrix2.RotationYawPitchRollToRef(yaw, pitch, roll, result);
    return result;
  };
  Matrix2.RotationYawPitchRollToRef = function(yaw, pitch, roll, result) {
    Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);
    MathTmp.Quaternion[0].toRotationMatrix(result);
  };
  Matrix2.Scaling = function(x, y, z) {
    var result = new Matrix2();
    Matrix2.ScalingToRef(x, y, z, result);
    return result;
  };
  Matrix2.ScalingToRef = function(x, y, z, result) {
    Matrix2.FromValuesToRef(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1, result);
    result._updateIdentityStatus(x === 1 && y === 1 && z === 1);
  };
  Matrix2.Translation = function(x, y, z) {
    var result = new Matrix2();
    Matrix2.TranslationToRef(x, y, z, result);
    return result;
  };
  Matrix2.TranslationToRef = function(x, y, z, result) {
    Matrix2.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1, result);
    result._updateIdentityStatus(x === 0 && y === 0 && z === 0);
  };
  Matrix2.Lerp = function(startValue, endValue, gradient) {
    var result = new Matrix2();
    Matrix2.LerpToRef(startValue, endValue, gradient, result);
    return result;
  };
  Matrix2.LerpToRef = function(startValue, endValue, gradient, result) {
    var resultM = result._m;
    var startM = startValue.m;
    var endM = endValue.m;
    for (var index = 0; index < 16; index++) {
      resultM[index] = startM[index] * (1 - gradient) + endM[index] * gradient;
    }
    result.markAsUpdated();
  };
  Matrix2.DecomposeLerp = function(startValue, endValue, gradient) {
    var result = new Matrix2();
    Matrix2.DecomposeLerpToRef(startValue, endValue, gradient, result);
    return result;
  };
  Matrix2.DecomposeLerpToRef = function(startValue, endValue, gradient, result) {
    var startScale = MathTmp.Vector3[0];
    var startRotation = MathTmp.Quaternion[0];
    var startTranslation = MathTmp.Vector3[1];
    startValue.decompose(startScale, startRotation, startTranslation);
    var endScale = MathTmp.Vector3[2];
    var endRotation = MathTmp.Quaternion[1];
    var endTranslation = MathTmp.Vector3[3];
    endValue.decompose(endScale, endRotation, endTranslation);
    var resultScale = MathTmp.Vector3[4];
    Vector3.LerpToRef(startScale, endScale, gradient, resultScale);
    var resultRotation = MathTmp.Quaternion[2];
    Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);
    var resultTranslation = MathTmp.Vector3[5];
    Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);
    Matrix2.ComposeToRef(resultScale, resultRotation, resultTranslation, result);
  };
  Matrix2.LookAtLH = function(eye, target2, up) {
    var result = new Matrix2();
    Matrix2.LookAtLHToRef(eye, target2, up, result);
    return result;
  };
  Matrix2.LookAtLHToRef = function(eye, target2, up, result) {
    var xAxis = MathTmp.Vector3[0];
    var yAxis = MathTmp.Vector3[1];
    var zAxis = MathTmp.Vector3[2];
    target2.subtractToRef(eye, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    var xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    var ex = -Vector3.Dot(xAxis, eye);
    var ey = -Vector3.Dot(yAxis, eye);
    var ez = -Vector3.Dot(zAxis, eye);
    Matrix2.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
  };
  Matrix2.LookAtRH = function(eye, target2, up) {
    var result = new Matrix2();
    Matrix2.LookAtRHToRef(eye, target2, up, result);
    return result;
  };
  Matrix2.LookAtRHToRef = function(eye, target2, up, result) {
    var xAxis = MathTmp.Vector3[0];
    var yAxis = MathTmp.Vector3[1];
    var zAxis = MathTmp.Vector3[2];
    eye.subtractToRef(target2, zAxis);
    zAxis.normalize();
    Vector3.CrossToRef(up, zAxis, xAxis);
    var xSquareLength = xAxis.lengthSquared();
    if (xSquareLength === 0) {
      xAxis.x = 1;
    } else {
      xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
    }
    Vector3.CrossToRef(zAxis, xAxis, yAxis);
    yAxis.normalize();
    var ex = -Vector3.Dot(xAxis, eye);
    var ey = -Vector3.Dot(yAxis, eye);
    var ez = -Vector3.Dot(zAxis, eye);
    Matrix2.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
  };
  Matrix2.LookDirectionLH = function(forward, up) {
    var result = new Matrix2();
    Matrix2.LookDirectionLHToRef(forward, up, result);
    return result;
  };
  Matrix2.LookDirectionLHToRef = function(forward, up, result) {
    var back = MathTmp.Vector3[0];
    back.copyFrom(forward);
    back.scaleInPlace(-1);
    var left = MathTmp.Vector3[1];
    Vector3.CrossToRef(up, back, left);
    Matrix2.FromValuesToRef(left._x, left._y, left._z, 0, up._x, up._y, up._z, 0, back._x, back._y, back._z, 0, 0, 0, 0, 1, result);
  };
  Matrix2.LookDirectionRH = function(forward, up) {
    var result = new Matrix2();
    Matrix2.LookDirectionRHToRef(forward, up, result);
    return result;
  };
  Matrix2.LookDirectionRHToRef = function(forward, up, result) {
    var right = MathTmp.Vector3[2];
    Vector3.CrossToRef(up, forward, right);
    Matrix2.FromValuesToRef(right._x, right._y, right._z, 0, up._x, up._y, up._z, 0, forward._x, forward._y, forward._z, 0, 0, 0, 0, 1, result);
  };
  Matrix2.OrthoLH = function(width, height, znear, zfar, halfZRange) {
    var matrix = new Matrix2();
    Matrix2.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);
    return matrix;
  };
  Matrix2.OrthoLHToRef = function(width, height, znear, zfar, result, halfZRange) {
    var n = znear;
    var f = zfar;
    var a = 2 / width;
    var b = 2 / height;
    var c = 2 / (f - n);
    var d = -(f + n) / (f - n);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, d, 1, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);
  };
  Matrix2.OrthoOffCenterLH = function(left, right, bottom, top, znear, zfar, halfZRange) {
    var matrix = new Matrix2();
    Matrix2.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
    return matrix;
  };
  Matrix2.OrthoOffCenterLHToRef = function(left, right, bottom, top, znear, zfar, result, halfZRange) {
    var n = znear;
    var f = zfar;
    var a = 2 / (right - left);
    var b = 2 / (top - bottom);
    var c = 2 / (f - n);
    var d = -(f + n) / (f - n);
    var i0 = (left + right) / (left - right);
    var i1 = (top + bottom) / (bottom - top);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, i0, i1, d, 1, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result.markAsUpdated();
  };
  Matrix2.OrthoOffCenterRH = function(left, right, bottom, top, znear, zfar, halfZRange) {
    var matrix = new Matrix2();
    Matrix2.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
    return matrix;
  };
  Matrix2.OrthoOffCenterRHToRef = function(left, right, bottom, top, znear, zfar, result, halfZRange) {
    Matrix2.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);
    result._m[10] *= -1;
  };
  Matrix2.PerspectiveLH = function(width, height, znear, zfar, halfZRange, projectionPlaneTilt) {
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    var matrix = new Matrix2();
    var n = znear;
    var f = zfar;
    var a = 2 * n / width;
    var b = 2 * n / height;
    var c = (f + n) / (f - n);
    var d = -2 * f * n / (f - n);
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, matrix);
    if (halfZRange) {
      matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);
    }
    matrix._updateIdentityStatus(false);
    return matrix;
  };
  Matrix2.PerspectiveFovLH = function(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    if (reverseDepthBufferMode === void 0) {
      reverseDepthBufferMode = false;
    }
    var matrix = new Matrix2();
    Matrix2.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
    return matrix;
  };
  Matrix2.PerspectiveFovLHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    if (reverseDepthBufferMode === void 0) {
      reverseDepthBufferMode = false;
    }
    var n = znear;
    var f = zfar;
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;
    var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovReverseLHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, 1, 0, 0, 1, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovRH = function(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    if (reverseDepthBufferMode === void 0) {
      reverseDepthBufferMode = false;
    }
    var matrix = new Matrix2();
    Matrix2.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
    return matrix;
  };
  Matrix2.PerspectiveFovRHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt, reverseDepthBufferMode) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    if (reverseDepthBufferMode === void 0) {
      reverseDepthBufferMode = false;
    }
    var n = znear;
    var f = zfar;
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;
    var d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, -1, 0, 0, d, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovReverseRHToRef = function(fov, aspect, znear, zfar, result, isVerticalFovFixed, halfZRange, projectionPlaneTilt) {
    if (isVerticalFovFixed === void 0) {
      isVerticalFovFixed = true;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    var t = 1 / Math.tan(fov * 0.5);
    var a = isVerticalFovFixed ? t / aspect : t;
    var b = isVerticalFovFixed ? t : t * aspect;
    var rot = Math.tan(projectionPlaneTilt);
    Matrix2.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, -1, 0, 0, -1, 0, result);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result._updateIdentityStatus(false);
  };
  Matrix2.PerspectiveFovWebVRToRef = function(fov, znear, zfar, result, rightHanded, halfZRange, projectionPlaneTilt) {
    if (rightHanded === void 0) {
      rightHanded = false;
    }
    if (projectionPlaneTilt === void 0) {
      projectionPlaneTilt = 0;
    }
    var rightHandedFactor = rightHanded ? -1 : 1;
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    var rot = Math.tan(projectionPlaneTilt);
    var m = result._m;
    m[0] = xScale;
    m[1] = m[2] = m[3] = m[4] = 0;
    m[5] = yScale;
    m[6] = 0;
    m[7] = rot;
    m[8] = (leftTan - rightTan) * xScale * 0.5;
    m[9] = -((upTan - downTan) * yScale * 0.5);
    m[10] = -zfar / (znear - zfar);
    m[11] = 1 * rightHandedFactor;
    m[12] = m[13] = m[15] = 0;
    m[14] = -(2 * zfar * znear) / (zfar - znear);
    if (halfZRange) {
      result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
    }
    result.markAsUpdated();
  };
  Matrix2.GetFinalMatrix = function(viewport, world, view, projection, zmin, zmax) {
    var cw = viewport.width;
    var ch = viewport.height;
    var cx = viewport.x;
    var cy = viewport.y;
    var viewportMatrix = Matrix2.FromValues(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, zmax - zmin, 0, cx + cw / 2, ch / 2 + cy, zmin, 1);
    var matrix = MathTmp.Matrix[0];
    world.multiplyToRef(view, matrix);
    matrix.multiplyToRef(projection, matrix);
    return matrix.multiply(viewportMatrix);
  };
  Matrix2.GetAsMatrix2x2 = function(matrix) {
    var m = matrix.m;
    var arr = [m[0], m[1], m[4], m[5]];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  };
  Matrix2.GetAsMatrix3x3 = function(matrix) {
    var m = matrix.m;
    var arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];
    return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
  };
  Matrix2.Transpose = function(matrix) {
    var result = new Matrix2();
    Matrix2.TransposeToRef(matrix, result);
    return result;
  };
  Matrix2.TransposeToRef = function(matrix, result) {
    var rm = result._m;
    var mm = matrix.m;
    rm[0] = mm[0];
    rm[1] = mm[4];
    rm[2] = mm[8];
    rm[3] = mm[12];
    rm[4] = mm[1];
    rm[5] = mm[5];
    rm[6] = mm[9];
    rm[7] = mm[13];
    rm[8] = mm[2];
    rm[9] = mm[6];
    rm[10] = mm[10];
    rm[11] = mm[14];
    rm[12] = mm[3];
    rm[13] = mm[7];
    rm[14] = mm[11];
    rm[15] = mm[15];
    result.markAsUpdated();
    result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);
  };
  Matrix2.Reflection = function(plane) {
    var matrix = new Matrix2();
    Matrix2.ReflectionToRef(plane, matrix);
    return matrix;
  };
  Matrix2.ReflectionToRef = function(plane, result) {
    plane.normalize();
    var x = plane.normal.x;
    var y = plane.normal.y;
    var z = plane.normal.z;
    var temp = -2 * x;
    var temp2 = -2 * y;
    var temp3 = -2 * z;
    Matrix2.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0, temp * y, temp2 * y + 1, temp3 * y, 0, temp * z, temp2 * z, temp3 * z + 1, 0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1, result);
  };
  Matrix2.FromXYZAxesToRef = function(xaxis, yaxis, zaxis, result) {
    Matrix2.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0, yaxis._x, yaxis._y, yaxis._z, 0, zaxis._x, zaxis._y, zaxis._z, 0, 0, 0, 0, 1, result);
  };
  Matrix2.FromQuaternionToRef = function(quat, result) {
    var xx = quat._x * quat._x;
    var yy = quat._y * quat._y;
    var zz = quat._z * quat._z;
    var xy = quat._x * quat._y;
    var zw = quat._z * quat._w;
    var zx = quat._z * quat._x;
    var yw = quat._y * quat._w;
    var yz = quat._y * quat._z;
    var xw = quat._x * quat._w;
    result._m[0] = 1 - 2 * (yy + zz);
    result._m[1] = 2 * (xy + zw);
    result._m[2] = 2 * (zx - yw);
    result._m[3] = 0;
    result._m[4] = 2 * (xy - zw);
    result._m[5] = 1 - 2 * (zz + xx);
    result._m[6] = 2 * (yz + xw);
    result._m[7] = 0;
    result._m[8] = 2 * (zx + yw);
    result._m[9] = 2 * (yz - xw);
    result._m[10] = 1 - 2 * (yy + xx);
    result._m[11] = 0;
    result._m[12] = 0;
    result._m[13] = 0;
    result._m[14] = 0;
    result._m[15] = 1;
    result.markAsUpdated();
  };
  Matrix2._UpdateFlagSeed = 0;
  Matrix2._IdentityReadOnly = Matrix2.Identity();
  return Matrix2;
}();
var MathTmp = function() {
  function MathTmp2() {
  }
  MathTmp2.Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);
  MathTmp2.Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);
  MathTmp2.Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);
  return MathTmp2;
}();
var TmpVectors = function() {
  function TmpVectors2() {
  }
  TmpVectors2.Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero);
  TmpVectors2.Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero);
  TmpVectors2.Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero);
  TmpVectors2.Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero);
  TmpVectors2.Matrix = ArrayTools.BuildTuple(8, Matrix.Identity);
  return TmpVectors2;
}();
RegisterClass("BABYLON.Vector2", Vector2);
RegisterClass("BABYLON.Vector3", Vector3);
RegisterClass("BABYLON.Vector4", Vector4);
RegisterClass("BABYLON.Matrix", Matrix);
var mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
var Color3 = function() {
  function Color32(r, g, b) {
    if (r === void 0) {
      r = 0;
    }
    if (g === void 0) {
      g = 0;
    }
    if (b === void 0) {
      b = 0;
    }
    this.r = r;
    this.g = g;
    this.b = b;
  }
  Color32.prototype.toString = function() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
  };
  Color32.prototype.getClassName = function() {
    return "Color3";
  };
  Color32.prototype.getHashCode = function() {
    var hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    return hash;
  };
  Color32.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    return this;
  };
  Color32.prototype.fromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    Color32.FromArrayToRef(array, offset, this);
    return this;
  };
  Color32.prototype.toColor4 = function(alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    return new Color4(this.r, this.g, this.b, alpha);
  };
  Color32.prototype.asArray = function() {
    return [this.r, this.g, this.b];
  };
  Color32.prototype.toLuminance = function() {
    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
  };
  Color32.prototype.multiply = function(otherColor) {
    return new Color32(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);
  };
  Color32.prototype.multiplyToRef = function(otherColor, result) {
    result.r = this.r * otherColor.r;
    result.g = this.g * otherColor.g;
    result.b = this.b * otherColor.b;
    return this;
  };
  Color32.prototype.equals = function(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;
  };
  Color32.prototype.equalsFloats = function(r, g, b) {
    return this.r === r && this.g === g && this.b === b;
  };
  Color32.prototype.scale = function(scale) {
    return new Color32(this.r * scale, this.g * scale, this.b * scale);
  };
  Color32.prototype.scaleToRef = function(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    return this;
  };
  Color32.prototype.scaleAndAddToRef = function(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    return this;
  };
  Color32.prototype.clampToRef = function(min, max, result) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 1;
    }
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    return this;
  };
  Color32.prototype.add = function(otherColor) {
    return new Color32(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);
  };
  Color32.prototype.addToRef = function(otherColor, result) {
    result.r = this.r + otherColor.r;
    result.g = this.g + otherColor.g;
    result.b = this.b + otherColor.b;
    return this;
  };
  Color32.prototype.subtract = function(otherColor) {
    return new Color32(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);
  };
  Color32.prototype.subtractToRef = function(otherColor, result) {
    result.r = this.r - otherColor.r;
    result.g = this.g - otherColor.g;
    result.b = this.b - otherColor.b;
    return this;
  };
  Color32.prototype.clone = function() {
    return new Color32(this.r, this.g, this.b);
  };
  Color32.prototype.copyFrom = function(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    return this;
  };
  Color32.prototype.copyFromFloats = function(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
    return this;
  };
  Color32.prototype.set = function(r, g, b) {
    return this.copyFromFloats(r, g, b);
  };
  Color32.prototype.toHexString = function() {
    var intR = Math.round(this.r * 255);
    var intG = Math.round(this.g * 255);
    var intB = Math.round(this.b * 255);
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
  };
  Color32.prototype.toLinearSpace = function() {
    var convertedColor = new Color32();
    this.toLinearSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color32.prototype.toHSV = function() {
    var result = new Color32();
    this.toHSVToRef(result);
    return result;
  };
  Color32.prototype.toHSVToRef = function(result) {
    var r = this.r;
    var g = this.g;
    var b = this.b;
    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h = 0;
    var s = 0;
    var v = max;
    var dm = max - min;
    if (max !== 0) {
      s = dm / max;
    }
    if (max != min) {
      if (max == r) {
        h = (g - b) / dm;
        if (g < b) {
          h += 6;
        }
      } else if (max == g) {
        h = (b - r) / dm + 2;
      } else if (max == b) {
        h = (r - g) / dm + 4;
      }
      h *= 60;
    }
    result.r = h;
    result.g = s;
    result.b = v;
  };
  Color32.prototype.toLinearSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToLinearSpace);
    convertedColor.g = Math.pow(this.g, ToLinearSpace);
    convertedColor.b = Math.pow(this.b, ToLinearSpace);
    return this;
  };
  Color32.prototype.toGammaSpace = function() {
    var convertedColor = new Color32();
    this.toGammaSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color32.prototype.toGammaSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToGammaSpace);
    convertedColor.g = Math.pow(this.g, ToGammaSpace);
    convertedColor.b = Math.pow(this.b, ToGammaSpace);
    return this;
  };
  Color32.HSVtoRGBToRef = function(hue, saturation, value, result) {
    var chroma = value * saturation;
    var h = hue / 60;
    var x = chroma * (1 - Math.abs(h % 2 - 1));
    var r = 0;
    var g = 0;
    var b = 0;
    if (h >= 0 && h <= 1) {
      r = chroma;
      g = x;
    } else if (h >= 1 && h <= 2) {
      r = x;
      g = chroma;
    } else if (h >= 2 && h <= 3) {
      g = chroma;
      b = x;
    } else if (h >= 3 && h <= 4) {
      g = x;
      b = chroma;
    } else if (h >= 4 && h <= 5) {
      r = x;
      b = chroma;
    } else if (h >= 5 && h <= 6) {
      r = chroma;
      b = x;
    }
    var m = value - chroma;
    result.set(r + m, g + m, b + m);
  };
  Color32.FromHexString = function(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 7) {
      return new Color32(0, 0, 0);
    }
    var r = parseInt(hex.substring(1, 3), 16);
    var g = parseInt(hex.substring(3, 5), 16);
    var b = parseInt(hex.substring(5, 7), 16);
    return Color32.FromInts(r, g, b);
  };
  Color32.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Color32(array[offset], array[offset + 1], array[offset + 2]);
  };
  Color32.FromArrayToRef = function(array, offset, result) {
    if (offset === void 0) {
      offset = 0;
    }
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
  };
  Color32.FromInts = function(r, g, b) {
    return new Color32(r / 255, g / 255, b / 255);
  };
  Color32.Lerp = function(start, end, amount) {
    var result = new Color32(0, 0, 0);
    Color32.LerpToRef(start, end, amount, result);
    return result;
  };
  Color32.LerpToRef = function(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
  };
  Color32.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
    var g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
    var b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
    return new Color32(r, g, b);
  };
  Color32.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = Color32.Black();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Color32.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
  };
  Color32.Red = function() {
    return new Color32(1, 0, 0);
  };
  Color32.Green = function() {
    return new Color32(0, 1, 0);
  };
  Color32.Blue = function() {
    return new Color32(0, 0, 1);
  };
  Color32.Black = function() {
    return new Color32(0, 0, 0);
  };
  Object.defineProperty(Color32, "BlackReadOnly", {
    get: function() {
      return Color32._BlackReadOnly;
    },
    enumerable: false,
    configurable: true
  });
  Color32.White = function() {
    return new Color32(1, 1, 1);
  };
  Color32.Purple = function() {
    return new Color32(0.5, 0, 0.5);
  };
  Color32.Magenta = function() {
    return new Color32(1, 0, 1);
  };
  Color32.Yellow = function() {
    return new Color32(1, 1, 0);
  };
  Color32.Gray = function() {
    return new Color32(0.5, 0.5, 0.5);
  };
  Color32.Teal = function() {
    return new Color32(0, 1, 1);
  };
  Color32.Random = function() {
    return new Color32(Math.random(), Math.random(), Math.random());
  };
  Color32._BlackReadOnly = Color32.Black();
  return Color32;
}();
var Color4 = function() {
  function Color42(r, g, b, a) {
    if (r === void 0) {
      r = 0;
    }
    if (g === void 0) {
      g = 0;
    }
    if (b === void 0) {
      b = 0;
    }
    if (a === void 0) {
      a = 1;
    }
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  Color42.prototype.addInPlace = function(right) {
    this.r += right.r;
    this.g += right.g;
    this.b += right.b;
    this.a += right.a;
    return this;
  };
  Color42.prototype.asArray = function() {
    return [this.r, this.g, this.b, this.a];
  };
  Color42.prototype.toArray = function(array, index) {
    if (index === void 0) {
      index = 0;
    }
    array[index] = this.r;
    array[index + 1] = this.g;
    array[index + 2] = this.b;
    array[index + 3] = this.a;
    return this;
  };
  Color42.prototype.fromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    Color42.FromArrayToRef(array, offset, this);
    return this;
  };
  Color42.prototype.equals = function(otherColor) {
    return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;
  };
  Color42.prototype.add = function(right) {
    return new Color42(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);
  };
  Color42.prototype.subtract = function(right) {
    return new Color42(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);
  };
  Color42.prototype.subtractToRef = function(right, result) {
    result.r = this.r - right.r;
    result.g = this.g - right.g;
    result.b = this.b - right.b;
    result.a = this.a - right.a;
    return this;
  };
  Color42.prototype.scale = function(scale) {
    return new Color42(this.r * scale, this.g * scale, this.b * scale, this.a * scale);
  };
  Color42.prototype.scaleToRef = function(scale, result) {
    result.r = this.r * scale;
    result.g = this.g * scale;
    result.b = this.b * scale;
    result.a = this.a * scale;
    return this;
  };
  Color42.prototype.scaleAndAddToRef = function(scale, result) {
    result.r += this.r * scale;
    result.g += this.g * scale;
    result.b += this.b * scale;
    result.a += this.a * scale;
    return this;
  };
  Color42.prototype.clampToRef = function(min, max, result) {
    if (min === void 0) {
      min = 0;
    }
    if (max === void 0) {
      max = 1;
    }
    result.r = Scalar.Clamp(this.r, min, max);
    result.g = Scalar.Clamp(this.g, min, max);
    result.b = Scalar.Clamp(this.b, min, max);
    result.a = Scalar.Clamp(this.a, min, max);
    return this;
  };
  Color42.prototype.multiply = function(color) {
    return new Color42(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);
  };
  Color42.prototype.multiplyToRef = function(color, result) {
    result.r = this.r * color.r;
    result.g = this.g * color.g;
    result.b = this.b * color.b;
    result.a = this.a * color.a;
    return result;
  };
  Color42.prototype.toString = function() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
  };
  Color42.prototype.getClassName = function() {
    return "Color4";
  };
  Color42.prototype.getHashCode = function() {
    var hash = this.r * 255 | 0;
    hash = hash * 397 ^ (this.g * 255 | 0);
    hash = hash * 397 ^ (this.b * 255 | 0);
    hash = hash * 397 ^ (this.a * 255 | 0);
    return hash;
  };
  Color42.prototype.clone = function() {
    return new Color42(this.r, this.g, this.b, this.a);
  };
  Color42.prototype.copyFrom = function(source) {
    this.r = source.r;
    this.g = source.g;
    this.b = source.b;
    this.a = source.a;
    return this;
  };
  Color42.prototype.copyFromFloats = function(r, g, b, a) {
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
    return this;
  };
  Color42.prototype.set = function(r, g, b, a) {
    return this.copyFromFloats(r, g, b, a);
  };
  Color42.prototype.toHexString = function(returnAsColor3) {
    if (returnAsColor3 === void 0) {
      returnAsColor3 = false;
    }
    var intR = Math.round(this.r * 255);
    var intG = Math.round(this.g * 255);
    var intB = Math.round(this.b * 255);
    if (returnAsColor3) {
      return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
    }
    var intA = Math.round(this.a * 255);
    return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);
  };
  Color42.prototype.toLinearSpace = function() {
    var convertedColor = new Color42();
    this.toLinearSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color42.prototype.toLinearSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToLinearSpace);
    convertedColor.g = Math.pow(this.g, ToLinearSpace);
    convertedColor.b = Math.pow(this.b, ToLinearSpace);
    convertedColor.a = this.a;
    return this;
  };
  Color42.prototype.toGammaSpace = function() {
    var convertedColor = new Color42();
    this.toGammaSpaceToRef(convertedColor);
    return convertedColor;
  };
  Color42.prototype.toGammaSpaceToRef = function(convertedColor) {
    convertedColor.r = Math.pow(this.r, ToGammaSpace);
    convertedColor.g = Math.pow(this.g, ToGammaSpace);
    convertedColor.b = Math.pow(this.b, ToGammaSpace);
    convertedColor.a = this.a;
    return this;
  };
  Color42.FromHexString = function(hex) {
    if (hex.substring(0, 1) !== "#" || hex.length !== 9 && hex.length !== 7) {
      return new Color42(0, 0, 0, 0);
    }
    var r = parseInt(hex.substring(1, 3), 16);
    var g = parseInt(hex.substring(3, 5), 16);
    var b = parseInt(hex.substring(5, 7), 16);
    var a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;
    return Color42.FromInts(r, g, b, a);
  };
  Color42.Lerp = function(left, right, amount) {
    var result = new Color42(0, 0, 0, 0);
    Color42.LerpToRef(left, right, amount, result);
    return result;
  };
  Color42.LerpToRef = function(left, right, amount, result) {
    result.r = left.r + (right.r - left.r) * amount;
    result.g = left.g + (right.g - left.g) * amount;
    result.b = left.b + (right.b - left.b) * amount;
    result.a = left.a + (right.a - left.a) * amount;
  };
  Color42.Hermite = function(value1, tangent1, value2, tangent2, amount) {
    var squared = amount * amount;
    var cubed = amount * squared;
    var part1 = 2 * cubed - 3 * squared + 1;
    var part2 = -2 * cubed + 3 * squared;
    var part3 = cubed - 2 * squared + amount;
    var part4 = cubed - squared;
    var r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
    var g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
    var b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
    var a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;
    return new Color42(r, g, b, a);
  };
  Color42.Hermite1stDerivative = function(value1, tangent1, value2, tangent2, time) {
    var result = new Color42();
    this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
    return result;
  };
  Color42.Hermite1stDerivativeToRef = function(value1, tangent1, value2, tangent2, time, result) {
    var t2 = time * time;
    result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
    result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
    result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
    result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;
  };
  Color42.FromColor3 = function(color3, alpha) {
    if (alpha === void 0) {
      alpha = 1;
    }
    return new Color42(color3.r, color3.g, color3.b, alpha);
  };
  Color42.FromArray = function(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }
    return new Color42(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
  };
  Color42.FromArrayToRef = function(array, offset, result) {
    if (offset === void 0) {
      offset = 0;
    }
    result.r = array[offset];
    result.g = array[offset + 1];
    result.b = array[offset + 2];
    result.a = array[offset + 3];
  };
  Color42.FromInts = function(r, g, b, a) {
    return new Color42(r / 255, g / 255, b / 255, a / 255);
  };
  Color42.CheckColors4 = function(colors, count) {
    if (colors.length === count * 3) {
      var colors4 = [];
      for (var index = 0; index < colors.length; index += 3) {
        var newIndex = index / 3 * 4;
        colors4[newIndex] = colors[index];
        colors4[newIndex + 1] = colors[index + 1];
        colors4[newIndex + 2] = colors[index + 2];
        colors4[newIndex + 3] = 1;
      }
      return colors4;
    }
    return colors;
  };
  return Color42;
}();
var TmpColors = function() {
  function TmpColors2() {
  }
  TmpColors2.Color3 = ArrayTools.BuildArray(3, Color3.Black);
  TmpColors2.Color4 = ArrayTools.BuildArray(3, function() {
    return new Color4(0, 0, 0, 0);
  });
  return TmpColors2;
}();
RegisterClass("BABYLON.Color3", Color3);
RegisterClass("BABYLON.Color4", Color4);
var __decoratorInitialStore = {};
var __mergedStore = {};
var _copySource = function(creationFunction, source, instanciate) {
  var destination = creationFunction();
  if (Tags) {
    Tags.AddTagsTo(destination, source.tags);
  }
  var classStore = getMergedStore(destination);
  for (var property in classStore) {
    var propertyDescriptor = classStore[property];
    var sourceProperty = source[property];
    var propertyType = propertyDescriptor.type;
    if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
      switch (propertyType) {
        case 0:
        case 6:
        case 11:
          destination[property] = sourceProperty;
          break;
        case 1:
          destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 7:
        case 10:
        case 12:
          destination[property] = instanciate ? sourceProperty : sourceProperty.clone();
          break;
      }
    }
  }
  return destination;
};
function getDirectStore(target2) {
  var classKey = target2.getClassName();
  if (!__decoratorInitialStore[classKey]) {
    __decoratorInitialStore[classKey] = {};
  }
  return __decoratorInitialStore[classKey];
}
function getMergedStore(target2) {
  var classKey = target2.getClassName();
  if (__mergedStore[classKey]) {
    return __mergedStore[classKey];
  }
  __mergedStore[classKey] = {};
  var store = __mergedStore[classKey];
  var currentTarget = target2;
  var currentKey = classKey;
  while (currentKey) {
    var initialStore = __decoratorInitialStore[currentKey];
    for (var property in initialStore) {
      store[property] = initialStore[property];
    }
    var parent_1 = void 0;
    var done = false;
    do {
      parent_1 = Object.getPrototypeOf(currentTarget);
      if (!parent_1.getClassName) {
        done = true;
        break;
      }
      if (parent_1.getClassName() !== currentKey) {
        break;
      }
      currentTarget = parent_1;
    } while (parent_1);
    if (done) {
      break;
    }
    currentKey = parent_1.getClassName();
    currentTarget = parent_1;
  }
  return store;
}
function generateSerializableMember(type, sourceName) {
  return function(target2, propertyKey) {
    var classStore = getDirectStore(target2);
    if (!classStore[propertyKey]) {
      classStore[propertyKey] = { type, sourceName };
    }
  };
}
function generateExpandMember(setCallback, targetKey) {
  if (targetKey === void 0) {
    targetKey = null;
  }
  return function(target2, propertyKey) {
    var key = targetKey || "_" + propertyKey;
    Object.defineProperty(target2, propertyKey, {
      get: function() {
        return this[key];
      },
      set: function(value) {
        if (typeof this.equals === "function") {
          if (this.equals(value)) {
            return;
          }
        }
        if (this[key] === value) {
          return;
        }
        this[key] = value;
        target2[setCallback].apply(this);
      },
      enumerable: true,
      configurable: true
    });
  };
}
function expandToProperty(callback, targetKey) {
  if (targetKey === void 0) {
    targetKey = null;
  }
  return generateExpandMember(callback, targetKey);
}
function serialize(sourceName) {
  return generateSerializableMember(0, sourceName);
}
function serializeAsTexture(sourceName) {
  return generateSerializableMember(1, sourceName);
}
function serializeAsColor3(sourceName) {
  return generateSerializableMember(2, sourceName);
}
function serializeAsVector3(sourceName) {
  return generateSerializableMember(5, sourceName);
}
function serializeAsColorCurves(sourceName) {
  return generateSerializableMember(7, sourceName);
}
function serializeAsColor4(sourceName) {
  return generateSerializableMember(8, sourceName);
}
function serializeAsQuaternion(sourceName) {
  return generateSerializableMember(10, sourceName);
}
var SerializationHelper = function() {
  function SerializationHelper2() {
  }
  SerializationHelper2.AppendSerializedAnimations = function(source, destination) {
    if (source.animations) {
      destination.animations = [];
      for (var animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {
        var animation = source.animations[animationIndex];
        destination.animations.push(animation.serialize());
      }
    }
  };
  SerializationHelper2.Serialize = function(entity, serializationObject) {
    if (!serializationObject) {
      serializationObject = {};
    }
    if (Tags) {
      serializationObject.tags = Tags.GetTags(entity);
    }
    var serializedProperties = getMergedStore(entity);
    for (var property in serializedProperties) {
      var propertyDescriptor = serializedProperties[property];
      var targetPropertyName = propertyDescriptor.sourceName || property;
      var propertyType = propertyDescriptor.type;
      var sourceProperty = entity[property];
      if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper2.AllowLoadingUniqueId)) {
        switch (propertyType) {
          case 0:
            serializationObject[targetPropertyName] = sourceProperty;
            break;
          case 1:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 2:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 3:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 4:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 5:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 6:
            serializationObject[targetPropertyName] = sourceProperty.id;
            break;
          case 7:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 8:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 9:
            serializationObject[targetPropertyName] = sourceProperty.serialize();
            break;
          case 10:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
          case 11:
            serializationObject[targetPropertyName] = sourceProperty.id;
            break;
          case 12:
            serializationObject[targetPropertyName] = sourceProperty.asArray();
            break;
        }
      }
    }
    return serializationObject;
  };
  SerializationHelper2.Parse = function(creationFunction, source, scene, rootUrl) {
    if (rootUrl === void 0) {
      rootUrl = null;
    }
    var destination = creationFunction();
    if (!rootUrl) {
      rootUrl = "";
    }
    if (Tags) {
      Tags.AddTagsTo(destination, source.tags);
    }
    var classStore = getMergedStore(destination);
    for (var property in classStore) {
      var propertyDescriptor = classStore[property];
      var sourceProperty = source[propertyDescriptor.sourceName || property];
      var propertyType = propertyDescriptor.type;
      if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper2.AllowLoadingUniqueId)) {
        var dest = destination;
        switch (propertyType) {
          case 0:
            dest[property] = sourceProperty;
            break;
          case 1:
            if (scene) {
              dest[property] = SerializationHelper2._TextureParser(sourceProperty, scene, rootUrl);
            }
            break;
          case 2:
            dest[property] = Color3.FromArray(sourceProperty);
            break;
          case 3:
            dest[property] = SerializationHelper2._FresnelParametersParser(sourceProperty);
            break;
          case 4:
            dest[property] = Vector2.FromArray(sourceProperty);
            break;
          case 5:
            dest[property] = Vector3.FromArray(sourceProperty);
            break;
          case 6:
            if (scene) {
              dest[property] = scene.getLastMeshById(sourceProperty);
            }
            break;
          case 7:
            dest[property] = SerializationHelper2._ColorCurvesParser(sourceProperty);
            break;
          case 8:
            dest[property] = Color4.FromArray(sourceProperty);
            break;
          case 9:
            dest[property] = SerializationHelper2._ImageProcessingConfigurationParser(sourceProperty);
            break;
          case 10:
            dest[property] = Quaternion.FromArray(sourceProperty);
            break;
          case 11:
            if (scene) {
              dest[property] = scene.getCameraById(sourceProperty);
            }
            break;
          case 12:
            dest[property] = Matrix.FromArray(sourceProperty);
            break;
        }
      }
    }
    return destination;
  };
  SerializationHelper2.Clone = function(creationFunction, source) {
    return _copySource(creationFunction, source, false);
  };
  SerializationHelper2.Instanciate = function(creationFunction, source) {
    return _copySource(creationFunction, source, true);
  };
  SerializationHelper2.AllowLoadingUniqueId = false;
  SerializationHelper2._ImageProcessingConfigurationParser = function(sourceProperty) {
    throw _WarnImport("ImageProcessingConfiguration");
  };
  SerializationHelper2._FresnelParametersParser = function(sourceProperty) {
    throw _WarnImport("FresnelParameters");
  };
  SerializationHelper2._ColorCurvesParser = function(sourceProperty) {
    throw _WarnImport("ColorCurves");
  };
  SerializationHelper2._TextureParser = function(sourceProperty, scene, rootUrl) {
    throw _WarnImport("Texture");
  };
  return SerializationHelper2;
}();
function nativeOverride(target2, propertyKey, descriptor, predicate) {
  var jsFunc = descriptor.value;
  descriptor.value = function() {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      params[_i] = arguments[_i];
    }
    var func = jsFunc;
    if (typeof _native !== "undefined" && _native[propertyKey]) {
      var nativeFunc_1 = _native[propertyKey];
      if (predicate) {
        func = function() {
          var params2 = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            params2[_i2] = arguments[_i2];
          }
          return predicate.apply(void 0, params2) ? nativeFunc_1.apply(void 0, params2) : jsFunc.apply(void 0, params2);
        };
      } else {
        func = nativeFunc_1;
      }
    }
    target2[propertyKey] = func;
    return func.apply(void 0, params);
  };
}
nativeOverride.filter = function(predicate) {
  return function(target2, propertyKey, descriptor) {
    return nativeOverride(target2, propertyKey, descriptor, predicate);
  };
};
var _InternalNodeDataInfo = function() {
  function _InternalNodeDataInfo2() {
    this._doNotSerialize = false;
    this._isDisposed = false;
    this._sceneRootNodesIndex = -1;
    this._isEnabled = true;
    this._isParentEnabled = true;
    this._isReady = true;
    this._onEnabledStateChangedObservable = new Observable();
    this._onClonedObservable = new Observable();
  }
  return _InternalNodeDataInfo2;
}();
var Node = function() {
  function Node2(name2, scene) {
    if (scene === void 0) {
      scene = null;
    }
    this._isDirty = false;
    this._nodeDataStorage = new _InternalNodeDataInfo();
    this.state = "";
    this.metadata = null;
    this.reservedDataStore = null;
    this._parentContainer = null;
    this.animations = new Array();
    this._ranges = {};
    this.onReady = null;
    this._currentRenderId = -1;
    this._parentUpdateId = -1;
    this._childUpdateId = -1;
    this._waitingParentId = null;
    this._cache = {};
    this._parentNode = null;
    this._children = null;
    this._worldMatrix = Matrix.Identity();
    this._worldMatrixDeterminant = 0;
    this._worldMatrixDeterminantIsDirty = true;
    this._animationPropertiesOverride = null;
    this._isNode = true;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._behaviors = new Array();
    this.name = name2;
    this.id = name2;
    this._scene = scene || EngineStore.LastCreatedScene;
    this.uniqueId = this._scene.getUniqueId();
    this._initCache();
  }
  Node2.AddNodeConstructor = function(type, constructorFunc) {
    this._NodeConstructors[type] = constructorFunc;
  };
  Node2.Construct = function(type, name2, scene, options) {
    var constructorFunc = this._NodeConstructors[type];
    if (!constructorFunc) {
      return null;
    }
    return constructorFunc(name2, scene, options);
  };
  Object.defineProperty(Node2.prototype, "doNotSerialize", {
    get: function() {
      if (this._nodeDataStorage._doNotSerialize) {
        return true;
      }
      if (this._parentNode) {
        return this._parentNode.doNotSerialize;
      }
      return false;
    },
    set: function(value) {
      this._nodeDataStorage._doNotSerialize = value;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.isDisposed = function() {
    return this._nodeDataStorage._isDisposed;
  };
  Object.defineProperty(Node2.prototype, "parent", {
    get: function() {
      return this._parentNode;
    },
    set: function(parent) {
      if (this._parentNode === parent) {
        return;
      }
      var previousParentNode = this._parentNode;
      if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
        var index = this._parentNode._children.indexOf(this);
        if (index !== -1) {
          this._parentNode._children.splice(index, 1);
        }
        if (!parent && !this._nodeDataStorage._isDisposed) {
          this._addToSceneRootNodes();
        }
      }
      this._parentNode = parent;
      if (this._parentNode) {
        if (this._parentNode._children === void 0 || this._parentNode._children === null) {
          this._parentNode._children = new Array();
        }
        this._parentNode._children.push(this);
        if (!previousParentNode) {
          this._removeFromSceneRootNodes();
        }
      }
      this._syncParentEnabledState();
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype._addToSceneRootNodes = function() {
    if (this._nodeDataStorage._sceneRootNodesIndex === -1) {
      this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length;
      this._scene.rootNodes.push(this);
    }
  };
  Node2.prototype._removeFromSceneRootNodes = function() {
    if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
      var rootNodes = this._scene.rootNodes;
      var lastIdx = rootNodes.length - 1;
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex] = rootNodes[lastIdx];
      rootNodes[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex;
      this._scene.rootNodes.pop();
      this._nodeDataStorage._sceneRootNodesIndex = -1;
    }
  };
  Object.defineProperty(Node2.prototype, "animationPropertiesOverride", {
    get: function() {
      if (!this._animationPropertiesOverride) {
        return this._scene.animationPropertiesOverride;
      }
      return this._animationPropertiesOverride;
    },
    set: function(value) {
      this._animationPropertiesOverride = value;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.getClassName = function() {
    return "Node";
  };
  Object.defineProperty(Node2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node2.prototype, "onEnabledStateChangedObservable", {
    get: function() {
      return this._nodeDataStorage._onEnabledStateChangedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Node2.prototype, "onClonedObservable", {
    get: function() {
      return this._nodeDataStorage._onClonedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.getScene = function() {
    return this._scene;
  };
  Node2.prototype.getEngine = function() {
    return this._scene.getEngine();
  };
  Node2.prototype.addBehavior = function(behavior, attachImmediately) {
    var _this = this;
    if (attachImmediately === void 0) {
      attachImmediately = false;
    }
    var index = this._behaviors.indexOf(behavior);
    if (index !== -1) {
      return this;
    }
    behavior.init();
    if (this._scene.isLoading && !attachImmediately) {
      this._scene.onDataLoadedObservable.addOnce(function() {
        behavior.attach(_this);
      });
    } else {
      behavior.attach(this);
    }
    this._behaviors.push(behavior);
    return this;
  };
  Node2.prototype.removeBehavior = function(behavior) {
    var index = this._behaviors.indexOf(behavior);
    if (index === -1) {
      return this;
    }
    this._behaviors[index].detach();
    this._behaviors.splice(index, 1);
    return this;
  };
  Object.defineProperty(Node2.prototype, "behaviors", {
    get: function() {
      return this._behaviors;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype.getBehaviorByName = function(name2) {
    for (var _i = 0, _a2 = this._behaviors; _i < _a2.length; _i++) {
      var behavior = _a2[_i];
      if (behavior.name === name2) {
        return behavior;
      }
    }
    return null;
  };
  Node2.prototype.getWorldMatrix = function() {
    if (this._currentRenderId !== this._scene.getRenderId()) {
      this.computeWorldMatrix();
    }
    return this._worldMatrix;
  };
  Node2.prototype._getWorldMatrixDeterminant = function() {
    if (this._worldMatrixDeterminantIsDirty) {
      this._worldMatrixDeterminantIsDirty = false;
      this._worldMatrixDeterminant = this._worldMatrix.determinant();
    }
    return this._worldMatrixDeterminant;
  };
  Object.defineProperty(Node2.prototype, "worldMatrixFromCache", {
    get: function() {
      return this._worldMatrix;
    },
    enumerable: false,
    configurable: true
  });
  Node2.prototype._initCache = function() {
    this._cache = {};
    this._cache.parent = void 0;
  };
  Node2.prototype.updateCache = function(force) {
    if (!force && this.isSynchronized()) {
      return;
    }
    this._cache.parent = this.parent;
    this._updateCache();
  };
  Node2.prototype._getActionManagerForTrigger = function(trigger, initialCall) {
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  };
  Node2.prototype._updateCache = function(ignoreParentClass) {
  };
  Node2.prototype._isSynchronized = function() {
    return true;
  };
  Node2.prototype._markSyncedWithParent = function() {
    if (this._parentNode) {
      this._parentUpdateId = this._parentNode._childUpdateId;
    }
  };
  Node2.prototype.isSynchronizedWithParent = function() {
    if (!this._parentNode) {
      return true;
    }
    if (this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId) {
      return false;
    }
    return this._parentNode.isSynchronized();
  };
  Node2.prototype.isSynchronized = function() {
    if (this._cache.parent !== this._parentNode) {
      this._cache.parent = this._parentNode;
      return false;
    }
    if (this._parentNode && !this.isSynchronizedWithParent()) {
      return false;
    }
    return this._isSynchronized();
  };
  Node2.prototype.isReady = function(completeCheck) {
    return this._nodeDataStorage._isReady;
  };
  Node2.prototype.markAsDirty = function(property) {
    this._currentRenderId = Number.MAX_VALUE;
    this._isDirty = true;
    return this;
  };
  Node2.prototype.isEnabled = function(checkAncestors) {
    if (checkAncestors === void 0) {
      checkAncestors = true;
    }
    if (checkAncestors === false) {
      return this._nodeDataStorage._isEnabled;
    }
    if (!this._nodeDataStorage._isEnabled) {
      return false;
    }
    return this._nodeDataStorage._isParentEnabled;
  };
  Node2.prototype._syncParentEnabledState = function() {
    this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : true;
    if (this._children) {
      this._children.forEach(function(c) {
        c._syncParentEnabledState();
      });
    }
  };
  Node2.prototype.setEnabled = function(value) {
    if (this._nodeDataStorage._isEnabled === value) {
      return;
    }
    this._nodeDataStorage._isEnabled = value;
    this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(value);
    this._syncParentEnabledState();
  };
  Node2.prototype.isDescendantOf = function(ancestor) {
    if (this.parent) {
      if (this.parent === ancestor) {
        return true;
      }
      return this.parent.isDescendantOf(ancestor);
    }
    return false;
  };
  Node2.prototype._getDescendants = function(results, directDescendantsOnly, predicate) {
    if (directDescendantsOnly === void 0) {
      directDescendantsOnly = false;
    }
    if (!this._children) {
      return;
    }
    for (var index = 0; index < this._children.length; index++) {
      var item = this._children[index];
      if (!predicate || predicate(item)) {
        results.push(item);
      }
      if (!directDescendantsOnly) {
        item._getDescendants(results, false, predicate);
      }
    }
  };
  Node2.prototype.getDescendants = function(directDescendantsOnly, predicate) {
    var results = new Array();
    this._getDescendants(results, directDescendantsOnly, predicate);
    return results;
  };
  Node2.prototype.getChildMeshes = function(directDescendantsOnly, predicate) {
    var results = [];
    this._getDescendants(results, directDescendantsOnly, function(node) {
      return (!predicate || predicate(node)) && node.cullingStrategy !== void 0;
    });
    return results;
  };
  Node2.prototype.getChildren = function(predicate, directDescendantsOnly) {
    if (directDescendantsOnly === void 0) {
      directDescendantsOnly = true;
    }
    return this.getDescendants(directDescendantsOnly, predicate);
  };
  Node2.prototype._setReady = function(state) {
    if (state === this._nodeDataStorage._isReady) {
      return;
    }
    if (!state) {
      this._nodeDataStorage._isReady = false;
      return;
    }
    if (this.onReady) {
      this.onReady(this);
    }
    this._nodeDataStorage._isReady = true;
  };
  Node2.prototype.getAnimationByName = function(name2) {
    for (var i = 0; i < this.animations.length; i++) {
      var animation = this.animations[i];
      if (animation.name === name2) {
        return animation;
      }
    }
    return null;
  };
  Node2.prototype.createAnimationRange = function(name2, from, to) {
    if (!this._ranges[name2]) {
      this._ranges[name2] = Node2._AnimationRangeFactory(name2, from, to);
      for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
        if (this.animations[i]) {
          this.animations[i].createRange(name2, from, to);
        }
      }
    }
  };
  Node2.prototype.deleteAnimationRange = function(name2, deleteFrames) {
    if (deleteFrames === void 0) {
      deleteFrames = true;
    }
    for (var i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
      if (this.animations[i]) {
        this.animations[i].deleteRange(name2, deleteFrames);
      }
    }
    this._ranges[name2] = null;
  };
  Node2.prototype.getAnimationRange = function(name2) {
    return this._ranges[name2] || null;
  };
  Node2.prototype.getAnimationRanges = function() {
    var animationRanges = [];
    var name2;
    for (name2 in this._ranges) {
      animationRanges.push(this._ranges[name2]);
    }
    return animationRanges;
  };
  Node2.prototype.beginAnimation = function(name2, loop, speedRatio, onAnimationEnd) {
    var range = this.getAnimationRange(name2);
    if (!range) {
      return null;
    }
    return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
  };
  Node2.prototype.serializeAnimationRanges = function() {
    var serializationRanges = [];
    for (var name_1 in this._ranges) {
      var localRange = this._ranges[name_1];
      if (!localRange) {
        continue;
      }
      var range = {};
      range.name = name_1;
      range.from = localRange.from;
      range.to = localRange.to;
      serializationRanges.push(range);
    }
    return serializationRanges;
  };
  Node2.prototype.computeWorldMatrix = function(force) {
    if (!this._worldMatrix) {
      this._worldMatrix = Matrix.Identity();
    }
    return this._worldMatrix;
  };
  Node2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this._nodeDataStorage._isDisposed = true;
    if (!doNotRecurse) {
      var nodes = this.getDescendants(true);
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        node.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
    }
    if (!this.parent) {
      this._removeFromSceneRootNodes();
    } else {
      this.parent = null;
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onEnabledStateChangedObservable.clear();
    this.onClonedObservable.clear();
    for (var _a2 = 0, _b2 = this._behaviors; _a2 < _b2.length; _a2++) {
      var behavior = _b2[_a2];
      behavior.detach();
    }
    this._behaviors = [];
    this.metadata = null;
  };
  Node2.ParseAnimationRanges = function(node, parsedNode, scene) {
    if (parsedNode.ranges) {
      for (var index = 0; index < parsedNode.ranges.length; index++) {
        var data = parsedNode.ranges[index];
        node.createAnimationRange(data.name, data.from, data.to);
      }
    }
  };
  Node2.prototype.getHierarchyBoundingVectors = function(includeDescendants, predicate) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (predicate === void 0) {
      predicate = null;
    }
    this.getScene().incrementRenderId();
    this.computeWorldMatrix(true);
    var min;
    var max;
    var thisAbstractMesh = this;
    if (thisAbstractMesh.getBoundingInfo && thisAbstractMesh.subMeshes) {
      var boundingInfo = thisAbstractMesh.getBoundingInfo();
      min = boundingInfo.boundingBox.minimumWorld.clone();
      max = boundingInfo.boundingBox.maximumWorld.clone();
    } else {
      min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    }
    if (includeDescendants) {
      var descendants = this.getDescendants(false);
      for (var _i = 0, descendants_1 = descendants; _i < descendants_1.length; _i++) {
        var descendant = descendants_1[_i];
        var childMesh = descendant;
        childMesh.computeWorldMatrix(true);
        if (predicate && !predicate(childMesh)) {
          continue;
        }
        if (!childMesh.getBoundingInfo || childMesh.getTotalVertices() === 0) {
          continue;
        }
        var childBoundingInfo = childMesh.getBoundingInfo();
        var boundingBox = childBoundingInfo.boundingBox;
        var minBox = boundingBox.minimumWorld;
        var maxBox = boundingBox.maximumWorld;
        Vector3.CheckExtends(minBox, min, max);
        Vector3.CheckExtends(maxBox, min, max);
      }
    }
    return {
      min,
      max
    };
  };
  Node2._AnimationRangeFactory = function(name2, from, to) {
    throw _WarnImport("AnimationRange");
  };
  Node2._NodeConstructors = {};
  __decorate([
    serialize()
  ], Node2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "id", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "state", void 0);
  __decorate([
    serialize()
  ], Node2.prototype, "metadata", void 0);
  return Node2;
}();
var Buffer2 = function() {
  function Buffer3(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes, divisor) {
    if (stride === void 0) {
      stride = 0;
    }
    if (postponeInternalCreation === void 0) {
      postponeInternalCreation = false;
    }
    if (instanced === void 0) {
      instanced = false;
    }
    if (useBytes === void 0) {
      useBytes = false;
    }
    this._isAlreadyOwned = false;
    if (engine.getScene) {
      this._engine = engine.getScene().getEngine();
    } else {
      this._engine = engine;
    }
    this._updatable = updatable;
    this._instanced = instanced;
    this._divisor = divisor || 1;
    if (data instanceof DataBuffer) {
      this._data = null;
      this._buffer = data;
    } else {
      this._data = data;
      this._buffer = null;
    }
    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;
    if (!postponeInternalCreation) {
      this.create();
    }
  }
  Buffer3.prototype.createVertexBuffer = function(kind, offset, size, stride, instanced, useBytes, divisor) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    var byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;
    var byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === void 0 ? this._instanced : instanced, byteOffset, size, void 0, void 0, true, this._divisor || divisor);
  };
  Buffer3.prototype.isUpdatable = function() {
    return this._updatable;
  };
  Buffer3.prototype.getData = function() {
    return this._data;
  };
  Buffer3.prototype.getBuffer = function() {
    return this._buffer;
  };
  Buffer3.prototype.getStrideSize = function() {
    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
  };
  Buffer3.prototype.create = function(data) {
    if (data === void 0) {
      data = null;
    }
    if (!data && this._buffer) {
      return;
    }
    data = data || this._data;
    if (!data) {
      return;
    }
    if (!this._buffer) {
      if (this._updatable) {
        this._buffer = this._engine.createDynamicVertexBuffer(data);
        this._data = data;
      } else {
        this._buffer = this._engine.createVertexBuffer(data);
      }
    } else if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data);
      this._data = data;
    }
  };
  Buffer3.prototype._rebuild = function() {
    this._buffer = null;
    this.create(this._data);
  };
  Buffer3.prototype.update = function(data) {
    this.create(data);
  };
  Buffer3.prototype.updateDirectly = function(data, offset, vertexCount, useBytes) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    if (!this._buffer) {
      return;
    }
    if (this._updatable) {
      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : void 0);
      if (offset === 0 && vertexCount === void 0) {
        this._data = data;
      } else {
        this._data = null;
      }
    }
  };
  Buffer3.prototype._increaseReferences = function() {
    if (!this._buffer) {
      return;
    }
    if (!this._isAlreadyOwned) {
      this._isAlreadyOwned = true;
      return;
    }
    this._buffer.references++;
  };
  Buffer3.prototype.dispose = function() {
    if (!this._buffer) {
      return;
    }
    if (this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
      this._data = null;
    }
  };
  return Buffer3;
}();
var VertexBuffer = function() {
  function VertexBuffer2(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size, type, normalized, useBytes, divisor, takeBufferOwnership) {
    if (normalized === void 0) {
      normalized = false;
    }
    if (useBytes === void 0) {
      useBytes = false;
    }
    if (divisor === void 0) {
      divisor = 1;
    }
    if (takeBufferOwnership === void 0) {
      takeBufferOwnership = false;
    }
    if (data instanceof Buffer2) {
      this._buffer = data;
      this._ownsBuffer = takeBufferOwnership;
    } else {
      this._buffer = new Buffer2(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);
      this._ownsBuffer = true;
    }
    this.uniqueId = VertexBuffer2._Counter++;
    this._kind = kind;
    if (type == void 0) {
      var data_1 = this.getData();
      this.type = VertexBuffer2.FLOAT;
      if (data_1 instanceof Int8Array) {
        this.type = VertexBuffer2.BYTE;
      } else if (data_1 instanceof Uint8Array) {
        this.type = VertexBuffer2.UNSIGNED_BYTE;
      } else if (data_1 instanceof Int16Array) {
        this.type = VertexBuffer2.SHORT;
      } else if (data_1 instanceof Uint16Array) {
        this.type = VertexBuffer2.UNSIGNED_SHORT;
      } else if (data_1 instanceof Int32Array) {
        this.type = VertexBuffer2.INT;
      } else if (data_1 instanceof Uint32Array) {
        this.type = VertexBuffer2.UNSIGNED_INT;
      }
    } else {
      this.type = type;
    }
    var typeByteLength = VertexBuffer2.GetTypeByteLength(this.type);
    if (useBytes) {
      this._size = size || (stride ? stride / typeByteLength : VertexBuffer2.DeduceStride(kind));
      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = offset || 0;
    } else {
      this._size = size || stride || VertexBuffer2.DeduceStride(kind);
      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;
      this.byteOffset = (offset || 0) * typeByteLength;
    }
    this.normalized = normalized;
    this._instanced = instanced !== void 0 ? instanced : false;
    this._instanceDivisor = instanced ? divisor : 0;
    this._computeHashCode();
  }
  Object.defineProperty(VertexBuffer2.prototype, "instanceDivisor", {
    get: function() {
      return this._instanceDivisor;
    },
    set: function(value) {
      this._instanceDivisor = value;
      if (value == 0) {
        this._instanced = false;
      } else {
        this._instanced = true;
      }
      this._computeHashCode();
    },
    enumerable: false,
    configurable: true
  });
  VertexBuffer2.prototype._computeHashCode = function() {
    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12);
  };
  VertexBuffer2.prototype._rebuild = function() {
    if (!this._buffer) {
      return;
    }
    this._buffer._rebuild();
  };
  VertexBuffer2.prototype.getKind = function() {
    return this._kind;
  };
  VertexBuffer2.prototype.isUpdatable = function() {
    return this._buffer.isUpdatable();
  };
  VertexBuffer2.prototype.getData = function() {
    return this._buffer.getData();
  };
  VertexBuffer2.prototype.getFloatData = function(totalVertices, forceCopy) {
    var data = this.getData();
    if (!data) {
      return null;
    }
    var tightlyPackedByteStride = this.getSize() * VertexBuffer2.GetTypeByteLength(this.type);
    var count = totalVertices * this.getSize();
    if (this.type !== VertexBuffer2.FLOAT || this.byteStride !== tightlyPackedByteStride) {
      var copy_1 = new Float32Array(count);
      this.forEach(count, function(value, index) {
        return copy_1[index] = value;
      });
      return copy_1;
    }
    if (!(data instanceof Array || data instanceof Float32Array) || this.byteOffset !== 0 || data.length !== count) {
      if (data instanceof Array) {
        var offset = this.byteOffset / 4;
        return data.slice(offset, offset + count);
      } else if (data instanceof ArrayBuffer) {
        return new Float32Array(data, this.byteOffset, count);
      } else {
        var offset = data.byteOffset + this.byteOffset;
        if (forceCopy) {
          var result = new Float32Array(count);
          var source = new Float32Array(data.buffer, offset, count);
          result.set(source);
          return result;
        }
        var remainder = offset % 4;
        if (remainder) {
          offset = Math.max(0, offset - remainder);
        }
        return new Float32Array(data.buffer, offset, count);
      }
    }
    if (forceCopy) {
      return data.slice();
    }
    return data;
  };
  VertexBuffer2.prototype.getBuffer = function() {
    return this._buffer.getBuffer();
  };
  VertexBuffer2.prototype.getStrideSize = function() {
    return this.byteStride / VertexBuffer2.GetTypeByteLength(this.type);
  };
  VertexBuffer2.prototype.getOffset = function() {
    return this.byteOffset / VertexBuffer2.GetTypeByteLength(this.type);
  };
  VertexBuffer2.prototype.getSize = function(sizeInBytes) {
    if (sizeInBytes === void 0) {
      sizeInBytes = false;
    }
    return sizeInBytes ? this._size * VertexBuffer2.GetTypeByteLength(this.type) : this._size;
  };
  VertexBuffer2.prototype.getIsInstanced = function() {
    return this._instanced;
  };
  VertexBuffer2.prototype.getInstanceDivisor = function() {
    return this._instanceDivisor;
  };
  VertexBuffer2.prototype.create = function(data) {
    this._buffer.create(data);
  };
  VertexBuffer2.prototype.update = function(data) {
    this._buffer.update(data);
  };
  VertexBuffer2.prototype.updateDirectly = function(data, offset, useBytes) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    this._buffer.updateDirectly(data, offset, void 0, useBytes);
  };
  VertexBuffer2.prototype.dispose = function() {
    if (this._ownsBuffer) {
      this._buffer.dispose();
    }
  };
  VertexBuffer2.prototype.forEach = function(count, callback) {
    VertexBuffer2.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);
  };
  VertexBuffer2.DeduceStride = function(kind) {
    switch (kind) {
      case VertexBuffer2.UVKind:
      case VertexBuffer2.UV2Kind:
      case VertexBuffer2.UV3Kind:
      case VertexBuffer2.UV4Kind:
      case VertexBuffer2.UV5Kind:
      case VertexBuffer2.UV6Kind:
        return 2;
      case VertexBuffer2.NormalKind:
      case VertexBuffer2.PositionKind:
        return 3;
      case VertexBuffer2.ColorKind:
      case VertexBuffer2.MatricesIndicesKind:
      case VertexBuffer2.MatricesIndicesExtraKind:
      case VertexBuffer2.MatricesWeightsKind:
      case VertexBuffer2.MatricesWeightsExtraKind:
      case VertexBuffer2.TangentKind:
        return 4;
      default:
        throw new Error("Invalid kind '" + kind + "'");
    }
  };
  VertexBuffer2.GetTypeByteLength = function(type) {
    switch (type) {
      case VertexBuffer2.BYTE:
      case VertexBuffer2.UNSIGNED_BYTE:
        return 1;
      case VertexBuffer2.SHORT:
      case VertexBuffer2.UNSIGNED_SHORT:
        return 2;
      case VertexBuffer2.INT:
      case VertexBuffer2.UNSIGNED_INT:
      case VertexBuffer2.FLOAT:
        return 4;
      default:
        throw new Error("Invalid type '".concat(type, "'"));
    }
  };
  VertexBuffer2.ForEach = function(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
    if (data instanceof Array) {
      var offset = byteOffset / 4;
      var stride = byteStride / 4;
      for (var index = 0; index < count; index += componentCount) {
        for (var componentIndex = 0; componentIndex < componentCount; componentIndex++) {
          callback(data[offset + componentIndex], index + componentIndex);
        }
        offset += stride;
      }
    } else {
      var dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);
      var componentByteLength = VertexBuffer2.GetTypeByteLength(componentType);
      for (var index = 0; index < count; index += componentCount) {
        var componentByteOffset = byteOffset;
        for (var componentIndex = 0; componentIndex < componentCount; componentIndex++) {
          var value = VertexBuffer2._GetFloatValue(dataView, componentType, componentByteOffset, normalized);
          callback(value, index + componentIndex);
          componentByteOffset += componentByteLength;
        }
        byteOffset += byteStride;
      }
    }
  };
  VertexBuffer2._GetFloatValue = function(dataView, type, byteOffset, normalized) {
    switch (type) {
      case VertexBuffer2.BYTE: {
        var value = dataView.getInt8(byteOffset);
        if (normalized) {
          value = Math.max(value / 127, -1);
        }
        return value;
      }
      case VertexBuffer2.UNSIGNED_BYTE: {
        var value = dataView.getUint8(byteOffset);
        if (normalized) {
          value = value / 255;
        }
        return value;
      }
      case VertexBuffer2.SHORT: {
        var value = dataView.getInt16(byteOffset, true);
        if (normalized) {
          value = Math.max(value / 32767, -1);
        }
        return value;
      }
      case VertexBuffer2.UNSIGNED_SHORT: {
        var value = dataView.getUint16(byteOffset, true);
        if (normalized) {
          value = value / 65535;
        }
        return value;
      }
      case VertexBuffer2.INT: {
        return dataView.getInt32(byteOffset, true);
      }
      case VertexBuffer2.UNSIGNED_INT: {
        return dataView.getUint32(byteOffset, true);
      }
      case VertexBuffer2.FLOAT: {
        return dataView.getFloat32(byteOffset, true);
      }
      default: {
        throw new Error("Invalid component type ".concat(type));
      }
    }
  };
  VertexBuffer2._Counter = 0;
  VertexBuffer2.BYTE = 5120;
  VertexBuffer2.UNSIGNED_BYTE = 5121;
  VertexBuffer2.SHORT = 5122;
  VertexBuffer2.UNSIGNED_SHORT = 5123;
  VertexBuffer2.INT = 5124;
  VertexBuffer2.UNSIGNED_INT = 5125;
  VertexBuffer2.FLOAT = 5126;
  VertexBuffer2.PositionKind = "position";
  VertexBuffer2.NormalKind = "normal";
  VertexBuffer2.TangentKind = "tangent";
  VertexBuffer2.UVKind = "uv";
  VertexBuffer2.UV2Kind = "uv2";
  VertexBuffer2.UV3Kind = "uv3";
  VertexBuffer2.UV4Kind = "uv4";
  VertexBuffer2.UV5Kind = "uv5";
  VertexBuffer2.UV6Kind = "uv6";
  VertexBuffer2.ColorKind = "color";
  VertexBuffer2.ColorInstanceKind = "instanceColor";
  VertexBuffer2.MatricesIndicesKind = "matricesIndices";
  VertexBuffer2.MatricesWeightsKind = "matricesWeights";
  VertexBuffer2.MatricesIndicesExtraKind = "matricesIndicesExtra";
  VertexBuffer2.MatricesWeightsExtraKind = "matricesWeightsExtra";
  return VertexBuffer2;
}();
var VertexData = function() {
  function VertexData2() {
    this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));
  }
  VertexData2.prototype.set = function(data, kind) {
    if (!data.length) {
      Logger.Warn("Setting vertex data kind '".concat(kind, "' with an empty array"));
    }
    switch (kind) {
      case VertexBuffer.PositionKind:
        this.positions = data;
        break;
      case VertexBuffer.NormalKind:
        this.normals = data;
        break;
      case VertexBuffer.TangentKind:
        this.tangents = data;
        break;
      case VertexBuffer.UVKind:
        this.uvs = data;
        break;
      case VertexBuffer.UV2Kind:
        this.uvs2 = data;
        break;
      case VertexBuffer.UV3Kind:
        this.uvs3 = data;
        break;
      case VertexBuffer.UV4Kind:
        this.uvs4 = data;
        break;
      case VertexBuffer.UV5Kind:
        this.uvs5 = data;
        break;
      case VertexBuffer.UV6Kind:
        this.uvs6 = data;
        break;
      case VertexBuffer.ColorKind:
        this.colors = data;
        break;
      case VertexBuffer.MatricesIndicesKind:
        this.matricesIndices = data;
        break;
      case VertexBuffer.MatricesWeightsKind:
        this.matricesWeights = data;
        break;
      case VertexBuffer.MatricesIndicesExtraKind:
        this.matricesIndicesExtra = data;
        break;
      case VertexBuffer.MatricesWeightsExtraKind:
        this.matricesWeightsExtra = data;
        break;
    }
  };
  VertexData2.prototype.applyToMesh = function(mesh, updatable) {
    this._applyTo(mesh, updatable, false);
    return this;
  };
  VertexData2.prototype.applyToGeometry = function(geometry, updatable) {
    this._applyTo(geometry, updatable, false);
    return this;
  };
  VertexData2.prototype.updateMesh = function(mesh) {
    this._update(mesh);
    return this;
  };
  VertexData2.prototype.updateGeometry = function(geometry) {
    this._update(geometry);
    return this;
  };
  VertexData2.prototype._applyToCoroutine = function(meshOrGeometry, updatable, isAsync) {
    if (updatable === void 0) {
      updatable = false;
    }
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          if (!this.positions)
            return [3, 2];
          meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);
          if (!isAsync)
            return [3, 2];
          return [4];
        case 1:
          _a2.sent();
          _a2.label = 2;
        case 2:
          if (!this.normals)
            return [3, 4];
          meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);
          if (!isAsync)
            return [3, 4];
          return [4];
        case 3:
          _a2.sent();
          _a2.label = 4;
        case 4:
          if (!this.tangents)
            return [3, 6];
          meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);
          if (!isAsync)
            return [3, 6];
          return [4];
        case 5:
          _a2.sent();
          _a2.label = 6;
        case 6:
          if (!this.uvs)
            return [3, 8];
          meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);
          if (!isAsync)
            return [3, 8];
          return [4];
        case 7:
          _a2.sent();
          _a2.label = 8;
        case 8:
          if (!this.uvs2)
            return [3, 10];
          meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);
          if (!isAsync)
            return [3, 10];
          return [4];
        case 9:
          _a2.sent();
          _a2.label = 10;
        case 10:
          if (!this.uvs3)
            return [3, 12];
          meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);
          if (!isAsync)
            return [3, 12];
          return [4];
        case 11:
          _a2.sent();
          _a2.label = 12;
        case 12:
          if (!this.uvs4)
            return [3, 14];
          meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);
          if (!isAsync)
            return [3, 14];
          return [4];
        case 13:
          _a2.sent();
          _a2.label = 14;
        case 14:
          if (!this.uvs5)
            return [3, 16];
          meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);
          if (!isAsync)
            return [3, 16];
          return [4];
        case 15:
          _a2.sent();
          _a2.label = 16;
        case 16:
          if (!this.uvs6)
            return [3, 18];
          meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);
          if (!isAsync)
            return [3, 18];
          return [4];
        case 17:
          _a2.sent();
          _a2.label = 18;
        case 18:
          if (!this.colors)
            return [3, 20];
          meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);
          if (!isAsync)
            return [3, 20];
          return [4];
        case 19:
          _a2.sent();
          _a2.label = 20;
        case 20:
          if (!this.matricesIndices)
            return [3, 22];
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);
          if (!isAsync)
            return [3, 22];
          return [4];
        case 21:
          _a2.sent();
          _a2.label = 22;
        case 22:
          if (!this.matricesWeights)
            return [3, 24];
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);
          if (!isAsync)
            return [3, 24];
          return [4];
        case 23:
          _a2.sent();
          _a2.label = 24;
        case 24:
          if (!this.matricesIndicesExtra)
            return [3, 26];
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);
          if (!isAsync)
            return [3, 26];
          return [4];
        case 25:
          _a2.sent();
          _a2.label = 26;
        case 26:
          if (!this.matricesWeightsExtra)
            return [3, 28];
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);
          if (!isAsync)
            return [3, 28];
          return [4];
        case 27:
          _a2.sent();
          _a2.label = 28;
        case 28:
          if (!this.indices)
            return [3, 31];
          meshOrGeometry.setIndices(this.indices, null, updatable);
          if (!isAsync)
            return [3, 30];
          return [4];
        case 29:
          _a2.sent();
          _a2.label = 30;
        case 30:
          return [3, 32];
        case 31:
          meshOrGeometry.setIndices([], null);
          _a2.label = 32;
        case 32:
          return [2, this];
      }
    });
  };
  VertexData2.prototype._update = function(meshOrGeometry, updateExtends, makeItUnique) {
    if (this.positions) {
      meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);
    }
    if (this.normals) {
      meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);
    }
    if (this.tangents) {
      meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);
    }
    if (this.uvs) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);
    }
    if (this.uvs2) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);
    }
    if (this.uvs3) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);
    }
    if (this.uvs4) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);
    }
    if (this.uvs5) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);
    }
    if (this.uvs6) {
      meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);
    }
    if (this.colors) {
      meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);
    }
    if (this.matricesIndices) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);
    }
    if (this.matricesWeights) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);
    }
    if (this.matricesIndicesExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);
    }
    if (this.matricesWeightsExtra) {
      meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);
    }
    if (this.indices) {
      meshOrGeometry.setIndices(this.indices, null);
    }
    return this;
  };
  VertexData2._TransformVector3Coordinates = function(coordinates, transformation, offset, length) {
    if (offset === void 0) {
      offset = 0;
    }
    if (length === void 0) {
      length = coordinates.length;
    }
    var coordinate = TmpVectors.Vector3[0];
    var transformedCoordinate = TmpVectors.Vector3[1];
    for (var index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(coordinates, index, coordinate);
      Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);
      coordinates[index] = transformedCoordinate.x;
      coordinates[index + 1] = transformedCoordinate.y;
      coordinates[index + 2] = transformedCoordinate.z;
    }
  };
  VertexData2._TransformVector3Normals = function(normals, transformation, offset, length) {
    if (offset === void 0) {
      offset = 0;
    }
    if (length === void 0) {
      length = normals.length;
    }
    var normal = TmpVectors.Vector3[0];
    var transformedNormal = TmpVectors.Vector3[1];
    for (var index = offset; index < offset + length; index += 3) {
      Vector3.FromArrayToRef(normals, index, normal);
      Vector3.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
    }
  };
  VertexData2._TransformVector4Normals = function(normals, transformation, offset, length) {
    if (offset === void 0) {
      offset = 0;
    }
    if (length === void 0) {
      length = normals.length;
    }
    var normal = TmpVectors.Vector4[0];
    var transformedNormal = TmpVectors.Vector4[1];
    for (var index = offset; index < offset + length; index += 4) {
      Vector4.FromArrayToRef(normals, index, normal);
      Vector4.TransformNormalToRef(normal, transformation, transformedNormal);
      normals[index] = transformedNormal.x;
      normals[index + 1] = transformedNormal.y;
      normals[index + 2] = transformedNormal.z;
      normals[index + 3] = transformedNormal.w;
    }
  };
  VertexData2._FlipFaces = function(indices, offset, length) {
    if (offset === void 0) {
      offset = 0;
    }
    if (length === void 0) {
      length = indices.length;
    }
    for (var index = offset; index < offset + length; index += 3) {
      var tmp = indices[index + 1];
      indices[index + 1] = indices[index + 2];
      indices[index + 2] = tmp;
    }
  };
  VertexData2.prototype.transform = function(matrix) {
    var flip = matrix.determinant() < 0;
    if (this.positions) {
      VertexData2._TransformVector3Coordinates(this.positions, matrix);
    }
    if (this.normals) {
      VertexData2._TransformVector3Normals(this.normals, matrix);
    }
    if (this.tangents) {
      VertexData2._TransformVector4Normals(this.tangents, matrix);
    }
    if (flip && this.indices) {
      VertexData2._FlipFaces(this.indices);
    }
    return this;
  };
  VertexData2.prototype.merge = function(others, use32BitsIndices, forceCloneIndices) {
    if (use32BitsIndices === void 0) {
      use32BitsIndices = false;
    }
    if (forceCloneIndices === void 0) {
      forceCloneIndices = false;
    }
    var vertexDatas = Array.isArray(others) ? others.map(function(other) {
      return [other, void 0];
    }) : [[others, void 0]];
    return runCoroutineSync(this._mergeCoroutine(void 0, vertexDatas, use32BitsIndices, false, forceCloneIndices));
  };
  VertexData2.prototype._mergeCoroutine = function(transform2, vertexDatas, use32BitsIndices, isAsync, forceCloneIndices) {
    var others, _i, others_1, other, totalIndices, sliceIndices, indices, indicesOffset, temp, positionsOffset, _a2, vertexDatas_1, _b2, other, transform_1, index;
    var _this = this;
    var _c2, _d, _e, _f;
    if (use32BitsIndices === void 0) {
      use32BitsIndices = false;
    }
    return __generator(this, function(_g) {
      switch (_g.label) {
        case 0:
          this._validate();
          others = vertexDatas.map(function(vertexData) {
            return vertexData[0];
          });
          for (_i = 0, others_1 = others; _i < others_1.length; _i++) {
            other = others_1[_i];
            other._validate();
            if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {
              throw new Error("Cannot merge vertex data that do not have the same set of attributes");
            }
          }
          totalIndices = others.reduce(function(indexSum, vertexData) {
            var _a3, _b3;
            return indexSum + ((_b3 = (_a3 = vertexData.indices) === null || _a3 === void 0 ? void 0 : _a3.length) !== null && _b3 !== void 0 ? _b3 : 0);
          }, (_d = (_c2 = this.indices) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d !== void 0 ? _d : 0);
          sliceIndices = forceCloneIndices || others.some(function(vertexData) {
            return vertexData.indices === _this.indices;
          });
          indices = sliceIndices ? (_e = this.indices) === null || _e === void 0 ? void 0 : _e.slice() : this.indices;
          if (!(totalIndices > 0))
            return [3, 4];
          indicesOffset = (_f = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _f !== void 0 ? _f : 0;
          if (!indices) {
            indices = new Array(totalIndices);
          }
          if (indices.length !== totalIndices) {
            if (Array.isArray(indices)) {
              indices.length = totalIndices;
            } else {
              temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);
              temp.set(indices);
              indices = temp;
            }
            if (transform2 && transform2.determinant() < 0) {
              VertexData2._FlipFaces(indices, 0, indicesOffset);
            }
          }
          positionsOffset = this.positions ? this.positions.length / 3 : 0;
          _a2 = 0, vertexDatas_1 = vertexDatas;
          _g.label = 1;
        case 1:
          if (!(_a2 < vertexDatas_1.length))
            return [3, 4];
          _b2 = vertexDatas_1[_a2], other = _b2[0], transform_1 = _b2[1];
          if (!other.indices)
            return [3, 3];
          for (index = 0; index < other.indices.length; index++) {
            indices[indicesOffset + index] = other.indices[index] + positionsOffset;
          }
          if (transform_1 && transform_1.determinant() < 0) {
            VertexData2._FlipFaces(indices, indicesOffset, other.indices.length);
          }
          positionsOffset += other.positions.length / 3;
          indicesOffset += other.indices.length;
          if (!isAsync)
            return [3, 3];
          return [4];
        case 2:
          _g.sent();
          _g.label = 3;
        case 3:
          _a2++;
          return [3, 1];
        case 4:
          this.indices = indices;
          this.positions = VertexData2._MergeElement(VertexBuffer.PositionKind, this.positions, transform2, vertexDatas.map(function(other2) {
            return [other2[0].positions, other2[1]];
          }));
          if (!isAsync)
            return [3, 6];
          return [4];
        case 5:
          _g.sent();
          _g.label = 6;
        case 6:
          this.normals = VertexData2._MergeElement(VertexBuffer.NormalKind, this.normals, transform2, vertexDatas.map(function(other2) {
            return [other2[0].normals, other2[1]];
          }));
          if (!isAsync)
            return [3, 8];
          return [4];
        case 7:
          _g.sent();
          _g.label = 8;
        case 8:
          this.tangents = VertexData2._MergeElement(VertexBuffer.TangentKind, this.tangents, transform2, vertexDatas.map(function(other2) {
            return [other2[0].tangents, other2[1]];
          }));
          if (!isAsync)
            return [3, 10];
          return [4];
        case 9:
          _g.sent();
          _g.label = 10;
        case 10:
          this.uvs = VertexData2._MergeElement(VertexBuffer.UVKind, this.uvs, transform2, vertexDatas.map(function(other2) {
            return [other2[0].uvs, other2[1]];
          }));
          if (!isAsync)
            return [3, 12];
          return [4];
        case 11:
          _g.sent();
          _g.label = 12;
        case 12:
          this.uvs2 = VertexData2._MergeElement(VertexBuffer.UV2Kind, this.uvs2, transform2, vertexDatas.map(function(other2) {
            return [other2[0].uvs2, other2[1]];
          }));
          if (!isAsync)
            return [3, 14];
          return [4];
        case 13:
          _g.sent();
          _g.label = 14;
        case 14:
          this.uvs3 = VertexData2._MergeElement(VertexBuffer.UV3Kind, this.uvs3, transform2, vertexDatas.map(function(other2) {
            return [other2[0].uvs3, other2[1]];
          }));
          if (!isAsync)
            return [3, 16];
          return [4];
        case 15:
          _g.sent();
          _g.label = 16;
        case 16:
          this.uvs4 = VertexData2._MergeElement(VertexBuffer.UV4Kind, this.uvs4, transform2, vertexDatas.map(function(other2) {
            return [other2[0].uvs4, other2[1]];
          }));
          if (!isAsync)
            return [3, 18];
          return [4];
        case 17:
          _g.sent();
          _g.label = 18;
        case 18:
          this.uvs5 = VertexData2._MergeElement(VertexBuffer.UV5Kind, this.uvs5, transform2, vertexDatas.map(function(other2) {
            return [other2[0].uvs5, other2[1]];
          }));
          if (!isAsync)
            return [3, 20];
          return [4];
        case 19:
          _g.sent();
          _g.label = 20;
        case 20:
          this.uvs6 = VertexData2._MergeElement(VertexBuffer.UV6Kind, this.uvs6, transform2, vertexDatas.map(function(other2) {
            return [other2[0].uvs6, other2[1]];
          }));
          if (!isAsync)
            return [3, 22];
          return [4];
        case 21:
          _g.sent();
          _g.label = 22;
        case 22:
          this.colors = VertexData2._MergeElement(VertexBuffer.ColorKind, this.colors, transform2, vertexDatas.map(function(other2) {
            return [other2[0].colors, other2[1]];
          }));
          if (!isAsync)
            return [3, 24];
          return [4];
        case 23:
          _g.sent();
          _g.label = 24;
        case 24:
          this.matricesIndices = VertexData2._MergeElement(VertexBuffer.MatricesIndicesKind, this.matricesIndices, transform2, vertexDatas.map(function(other2) {
            return [other2[0].matricesIndices, other2[1]];
          }));
          if (!isAsync)
            return [3, 26];
          return [4];
        case 25:
          _g.sent();
          _g.label = 26;
        case 26:
          this.matricesWeights = VertexData2._MergeElement(VertexBuffer.MatricesWeightsKind, this.matricesWeights, transform2, vertexDatas.map(function(other2) {
            return [other2[0].matricesWeights, other2[1]];
          }));
          if (!isAsync)
            return [3, 28];
          return [4];
        case 27:
          _g.sent();
          _g.label = 28;
        case 28:
          this.matricesIndicesExtra = VertexData2._MergeElement(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, transform2, vertexDatas.map(function(other2) {
            return [other2[0].matricesIndicesExtra, other2[1]];
          }));
          if (!isAsync)
            return [3, 30];
          return [4];
        case 29:
          _g.sent();
          _g.label = 30;
        case 30:
          this.matricesWeightsExtra = VertexData2._MergeElement(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, transform2, vertexDatas.map(function(other2) {
            return [other2[0].matricesWeightsExtra, other2[1]];
          }));
          return [2, this];
      }
    });
  };
  VertexData2._MergeElement = function(kind, source, transform2, others) {
    var nonNullOthers = others.filter(function(other) {
      return other[0] !== null && other[0] !== void 0;
    });
    if (!source && nonNullOthers.length == 0) {
      return source;
    }
    if (!source) {
      return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));
    }
    var len = nonNullOthers.reduce(function(sumLen, elements) {
      return sumLen + elements[0].length;
    }, source.length);
    var transformRange = kind === VertexBuffer.PositionKind ? VertexData2._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? VertexData2._TransformVector3Normals : kind === VertexBuffer.TangentKind ? VertexData2._TransformVector4Normals : function() {
    };
    if (source instanceof Float32Array) {
      var ret32 = new Float32Array(len);
      ret32.set(source);
      transform2 && transformRange(ret32, transform2, 0, source.length);
      var offset = source.length;
      for (var _i = 0, nonNullOthers_1 = nonNullOthers; _i < nonNullOthers_1.length; _i++) {
        var _a2 = nonNullOthers_1[_i], vertexData = _a2[0], transform_2 = _a2[1];
        ret32.set(vertexData, offset);
        transform_2 && transformRange(ret32, transform_2, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret32;
    } else {
      var ret = new Array(len);
      for (var i = 0; i < source.length; i++) {
        ret[i] = source[i];
      }
      transform2 && transformRange(ret, transform2, 0, source.length);
      var offset = source.length;
      for (var _b2 = 0, nonNullOthers_2 = nonNullOthers; _b2 < nonNullOthers_2.length; _b2++) {
        var _c2 = nonNullOthers_2[_b2], vertexData = _c2[0], transform_3 = _c2[1];
        for (var i = 0; i < vertexData.length; i++) {
          ret[offset + i] = vertexData[i];
        }
        transform_3 && transformRange(ret, transform_3, offset, vertexData.length);
        offset += vertexData.length;
      }
      return ret;
    }
  };
  VertexData2.prototype._validate = function() {
    if (!this.positions) {
      throw new RuntimeError("Positions are required", ErrorCodes.MeshInvalidPositionsError);
    }
    var getElementCount = function(kind, values) {
      var stride = VertexBuffer.DeduceStride(kind);
      if (values.length % stride !== 0) {
        throw new Error("The " + kind + "s array count must be a multiple of " + stride);
      }
      return values.length / stride;
    };
    var positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);
    var validateElementCount = function(kind, values) {
      var elementCount = getElementCount(kind, values);
      if (elementCount !== positionsElementCount) {
        throw new Error("The " + kind + "s element count (" + elementCount + ") does not match the positions count (" + positionsElementCount + ")");
      }
    };
    if (this.normals) {
      validateElementCount(VertexBuffer.NormalKind, this.normals);
    }
    if (this.tangents) {
      validateElementCount(VertexBuffer.TangentKind, this.tangents);
    }
    if (this.uvs) {
      validateElementCount(VertexBuffer.UVKind, this.uvs);
    }
    if (this.uvs2) {
      validateElementCount(VertexBuffer.UV2Kind, this.uvs2);
    }
    if (this.uvs3) {
      validateElementCount(VertexBuffer.UV3Kind, this.uvs3);
    }
    if (this.uvs4) {
      validateElementCount(VertexBuffer.UV4Kind, this.uvs4);
    }
    if (this.uvs5) {
      validateElementCount(VertexBuffer.UV5Kind, this.uvs5);
    }
    if (this.uvs6) {
      validateElementCount(VertexBuffer.UV6Kind, this.uvs6);
    }
    if (this.colors) {
      validateElementCount(VertexBuffer.ColorKind, this.colors);
    }
    if (this.matricesIndices) {
      validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);
    }
    if (this.matricesWeights) {
      validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);
    }
    if (this.matricesIndicesExtra) {
      validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);
    }
    if (this.matricesWeightsExtra) {
      validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);
    }
  };
  VertexData2.prototype.serialize = function() {
    var serializationObject = {};
    if (this.positions) {
      serializationObject.positions = this.positions;
    }
    if (this.normals) {
      serializationObject.normals = this.normals;
    }
    if (this.tangents) {
      serializationObject.tangents = this.tangents;
    }
    if (this.uvs) {
      serializationObject.uvs = this.uvs;
    }
    if (this.uvs2) {
      serializationObject.uvs2 = this.uvs2;
    }
    if (this.uvs3) {
      serializationObject.uvs3 = this.uvs3;
    }
    if (this.uvs4) {
      serializationObject.uvs4 = this.uvs4;
    }
    if (this.uvs5) {
      serializationObject.uvs5 = this.uvs5;
    }
    if (this.uvs6) {
      serializationObject.uvs6 = this.uvs6;
    }
    if (this.colors) {
      serializationObject.colors = this.colors;
    }
    if (this.matricesIndices) {
      serializationObject.matricesIndices = this.matricesIndices;
      serializationObject.matricesIndices._isExpanded = true;
    }
    if (this.matricesWeights) {
      serializationObject.matricesWeights = this.matricesWeights;
    }
    if (this.matricesIndicesExtra) {
      serializationObject.matricesIndicesExtra = this.matricesIndicesExtra;
      serializationObject.matricesIndicesExtra._isExpanded = true;
    }
    if (this.matricesWeightsExtra) {
      serializationObject.matricesWeightsExtra = this.matricesWeightsExtra;
    }
    serializationObject.indices = this.indices;
    return serializationObject;
  };
  VertexData2.ExtractFromMesh = function(mesh, copyWhenShared, forceCopy) {
    return VertexData2._ExtractFrom(mesh, copyWhenShared, forceCopy);
  };
  VertexData2.ExtractFromGeometry = function(geometry, copyWhenShared, forceCopy) {
    return VertexData2._ExtractFrom(geometry, copyWhenShared, forceCopy);
  };
  VertexData2._ExtractFrom = function(meshOrGeometry, copyWhenShared, forceCopy) {
    var result = new VertexData2();
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {
      result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {
      result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);
    }
    if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
      result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);
    }
    result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);
    return result;
  };
  VertexData2.CreateRibbon = function(options) {
    throw _WarnImport("ribbonBuilder");
  };
  VertexData2.CreateBox = function(options) {
    throw _WarnImport("boxBuilder");
  };
  VertexData2.CreateTiledBox = function(options) {
    throw _WarnImport("tiledBoxBuilder");
  };
  VertexData2.CreateTiledPlane = function(options) {
    throw _WarnImport("tiledPlaneBuilder");
  };
  VertexData2.CreateSphere = function(options) {
    throw _WarnImport("sphereBuilder");
  };
  VertexData2.CreateCylinder = function(options) {
    throw _WarnImport("cylinderBuilder");
  };
  VertexData2.CreateTorus = function(options) {
    throw _WarnImport("torusBuilder");
  };
  VertexData2.CreateLineSystem = function(options) {
    throw _WarnImport("linesBuilder");
  };
  VertexData2.CreateDashedLines = function(options) {
    throw _WarnImport("linesBuilder");
  };
  VertexData2.CreateGround = function(options) {
    throw _WarnImport("groundBuilder");
  };
  VertexData2.CreateTiledGround = function(options) {
    throw _WarnImport("groundBuilder");
  };
  VertexData2.CreateGroundFromHeightMap = function(options) {
    throw _WarnImport("groundBuilder");
  };
  VertexData2.CreatePlane = function(options) {
    throw _WarnImport("planeBuilder");
  };
  VertexData2.CreateDisc = function(options) {
    throw _WarnImport("discBuilder");
  };
  VertexData2.CreatePolygon = function(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {
    throw _WarnImport("polygonBuilder");
  };
  VertexData2.CreateIcoSphere = function(options) {
    throw _WarnImport("icoSphereBuilder");
  };
  VertexData2.CreatePolyhedron = function(options) {
    throw _WarnImport("polyhedronBuilder");
  };
  VertexData2.CreateCapsule = function(options) {
    if (options === void 0) {
      options = {
        orientation: Vector3.Up(),
        subdivisions: 2,
        tessellation: 16,
        height: 1,
        radius: 0.25,
        capSubdivisions: 6
      };
    }
    throw _WarnImport("capsuleBuilder");
  };
  VertexData2.CreateTorusKnot = function(options) {
    throw _WarnImport("torusKnotBuilder");
  };
  VertexData2.ComputeNormals = function(positions, indices, normals, options) {
    var index = 0;
    var p1p2x = 0;
    var p1p2y = 0;
    var p1p2z = 0;
    var p3p2x = 0;
    var p3p2y = 0;
    var p3p2z = 0;
    var faceNormalx = 0;
    var faceNormaly = 0;
    var faceNormalz = 0;
    var length = 0;
    var v1x = 0;
    var v1y = 0;
    var v1z = 0;
    var v2x = 0;
    var v2y = 0;
    var v2z = 0;
    var v3x = 0;
    var v3y = 0;
    var v3z = 0;
    var computeFacetNormals = false;
    var computeFacetPositions = false;
    var computeFacetPartitioning = false;
    var computeDepthSort = false;
    var faceNormalSign = 1;
    var ratio = 0;
    var distanceTo = null;
    if (options) {
      computeFacetNormals = options.facetNormals ? true : false;
      computeFacetPositions = options.facetPositions ? true : false;
      computeFacetPartitioning = options.facetPartitioning ? true : false;
      faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;
      ratio = options.ratio || 0;
      computeDepthSort = options.depthSort ? true : false;
      distanceTo = options.distanceTo;
      if (computeDepthSort) {
        if (distanceTo === void 0) {
          distanceTo = Vector3.Zero();
        }
      }
    }
    var xSubRatio = 0;
    var ySubRatio = 0;
    var zSubRatio = 0;
    var subSq = 0;
    if (computeFacetPartitioning && options && options.bbSize) {
      xSubRatio = options.subDiv.X * ratio / options.bbSize.x;
      ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;
      zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;
      subSq = options.subDiv.max * options.subDiv.max;
      options.facetPartitioning.length = 0;
    }
    for (index = 0; index < positions.length; index++) {
      normals[index] = 0;
    }
    var nbFaces = indices.length / 3 | 0;
    for (index = 0; index < nbFaces; index++) {
      v1x = indices[index * 3] * 3;
      v1y = v1x + 1;
      v1z = v1x + 2;
      v2x = indices[index * 3 + 1] * 3;
      v2y = v2x + 1;
      v2z = v2x + 2;
      v3x = indices[index * 3 + 2] * 3;
      v3y = v3x + 1;
      v3z = v3x + 2;
      p1p2x = positions[v1x] - positions[v2x];
      p1p2y = positions[v1y] - positions[v2y];
      p1p2z = positions[v1z] - positions[v2z];
      p3p2x = positions[v3x] - positions[v2x];
      p3p2y = positions[v3y] - positions[v2y];
      p3p2z = positions[v3z] - positions[v2z];
      faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);
      faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);
      faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      if (computeFacetNormals && options) {
        options.facetNormals[index].x = faceNormalx;
        options.facetNormals[index].y = faceNormaly;
        options.facetNormals[index].z = faceNormalz;
      }
      if (computeFacetPositions && options) {
        options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3;
        options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3;
        options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3;
      }
      if (computeFacetPartitioning && options) {
        var ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);
        var oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);
        var oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);
        var b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        var b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        var b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        var b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        var b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        var b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        var b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);
        var b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);
        var b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);
        var block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;
        var block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;
        var block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;
        var block_idx_o = ox + options.subDiv.max * oy + subSq * oz;
        options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();
        options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();
        options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();
        options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();
        options.facetPartitioning[block_idx_v1].push(index);
        if (block_idx_v2 != block_idx_v1) {
          options.facetPartitioning[block_idx_v2].push(index);
        }
        if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {
          options.facetPartitioning[block_idx_v3].push(index);
        }
        if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {
          options.facetPartitioning[block_idx_o].push(index);
        }
      }
      if (computeDepthSort && options && options.facetPositions) {
        var dsf = options.depthSortedFacets[index];
        dsf.ind = index * 3;
        dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);
      }
      normals[v1x] += faceNormalx;
      normals[v1y] += faceNormaly;
      normals[v1z] += faceNormalz;
      normals[v2x] += faceNormalx;
      normals[v2y] += faceNormaly;
      normals[v2z] += faceNormalz;
      normals[v3x] += faceNormalx;
      normals[v3y] += faceNormaly;
      normals[v3z] += faceNormalz;
    }
    for (index = 0; index < normals.length / 3; index++) {
      faceNormalx = normals[index * 3];
      faceNormaly = normals[index * 3 + 1];
      faceNormalz = normals[index * 3 + 2];
      length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
      length = length === 0 ? 1 : length;
      faceNormalx /= length;
      faceNormaly /= length;
      faceNormalz /= length;
      normals[index * 3] = faceNormalx;
      normals[index * 3 + 1] = faceNormaly;
      normals[index * 3 + 2] = faceNormalz;
    }
  };
  VertexData2._ComputeSides = function(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {
    var li = indices.length;
    var ln = normals.length;
    var i;
    var n;
    sideOrientation = sideOrientation || VertexData2.DEFAULTSIDE;
    switch (sideOrientation) {
      case VertexData2.FRONTSIDE:
        break;
      case VertexData2.BACKSIDE:
        for (i = 0; i < li; i += 3) {
          var tmp = indices[i];
          indices[i] = indices[i + 2];
          indices[i + 2] = tmp;
        }
        for (n = 0; n < ln; n++) {
          normals[n] = -normals[n];
        }
        break;
      case VertexData2.DOUBLESIDE: {
        var lp = positions.length;
        var l = lp / 3;
        for (var p = 0; p < lp; p++) {
          positions[lp + p] = positions[p];
        }
        for (i = 0; i < li; i += 3) {
          indices[i + li] = indices[i + 2] + l;
          indices[i + 1 + li] = indices[i + 1] + l;
          indices[i + 2 + li] = indices[i] + l;
        }
        for (n = 0; n < ln; n++) {
          normals[ln + n] = -normals[n];
        }
        var lu = uvs.length;
        var u = 0;
        for (u = 0; u < lu; u++) {
          uvs[u + lu] = uvs[u];
        }
        frontUVs = frontUVs ? frontUVs : new Vector4(0, 0, 1, 1);
        backUVs = backUVs ? backUVs : new Vector4(0, 0, 1, 1);
        u = 0;
        for (i = 0; i < lu / 2; i++) {
          uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];
          uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];
          uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];
          uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];
          u += 2;
        }
        break;
      }
    }
  };
  VertexData2.ImportVertexData = function(parsedVertexData, geometry) {
    var vertexData = new VertexData2();
    var positions = parsedVertexData.positions;
    if (positions) {
      vertexData.set(positions, VertexBuffer.PositionKind);
    }
    var normals = parsedVertexData.normals;
    if (normals) {
      vertexData.set(normals, VertexBuffer.NormalKind);
    }
    var tangents = parsedVertexData.tangents;
    if (tangents) {
      vertexData.set(tangents, VertexBuffer.TangentKind);
    }
    var uvs = parsedVertexData.uvs;
    if (uvs) {
      vertexData.set(uvs, VertexBuffer.UVKind);
    }
    var uv2s = parsedVertexData.uv2s;
    if (uv2s) {
      vertexData.set(uv2s, VertexBuffer.UV2Kind);
    }
    var uv3s = parsedVertexData.uv3s;
    if (uv3s) {
      vertexData.set(uv3s, VertexBuffer.UV3Kind);
    }
    var uv4s = parsedVertexData.uv4s;
    if (uv4s) {
      vertexData.set(uv4s, VertexBuffer.UV4Kind);
    }
    var uv5s = parsedVertexData.uv5s;
    if (uv5s) {
      vertexData.set(uv5s, VertexBuffer.UV5Kind);
    }
    var uv6s = parsedVertexData.uv6s;
    if (uv6s) {
      vertexData.set(uv6s, VertexBuffer.UV6Kind);
    }
    var colors = parsedVertexData.colors;
    if (colors) {
      vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);
    }
    var matricesIndices = parsedVertexData.matricesIndices;
    if (matricesIndices) {
      vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);
    }
    var matricesWeights = parsedVertexData.matricesWeights;
    if (matricesWeights) {
      vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);
    }
    var indices = parsedVertexData.indices;
    if (indices) {
      vertexData.indices = indices;
    }
    geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);
  };
  VertexData2.FRONTSIDE = 0;
  VertexData2.BACKSIDE = 1;
  VertexData2.DOUBLESIDE = 2;
  VertexData2.DEFAULTSIDE = 0;
  __decorate([
    nativeOverride.filter(function() {
      var _a2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a2[_i] = arguments[_i];
      }
      var coordinates = _a2[0];
      return !Array.isArray(coordinates);
    })
  ], VertexData2, "_TransformVector3Coordinates", null);
  __decorate([
    nativeOverride.filter(function() {
      var _a2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a2[_i] = arguments[_i];
      }
      var normals = _a2[0];
      return !Array.isArray(normals);
    })
  ], VertexData2, "_TransformVector3Normals", null);
  __decorate([
    nativeOverride.filter(function() {
      var _a2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a2[_i] = arguments[_i];
      }
      var normals = _a2[0];
      return !Array.isArray(normals);
    })
  ], VertexData2, "_TransformVector4Normals", null);
  __decorate([
    nativeOverride.filter(function() {
      var _a2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a2[_i] = arguments[_i];
      }
      var indices = _a2[0];
      return !Array.isArray(indices);
    })
  ], VertexData2, "_FlipFaces", null);
  return VertexData2;
}();
var IntersectionInfo = function() {
  function IntersectionInfo2(bu, bv, distance) {
    this.bu = bu;
    this.bv = bv;
    this.distance = distance;
    this.faceId = 0;
    this.subMeshId = 0;
  }
  return IntersectionInfo2;
}();
var BoundingBox = function() {
  function BoundingBox2(min, max, worldMatrix) {
    this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.extendSize = Vector3.Zero();
    this.extendSizeWorld = Vector3.Zero();
    this.directions = ArrayTools.BuildArray(3, Vector3.Zero);
    this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);
    this.minimumWorld = Vector3.Zero();
    this.maximumWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this._drawWrapperFront = null;
    this._drawWrapperBack = null;
    this.reConstruct(min, max, worldMatrix);
  }
  BoundingBox2.prototype.reConstruct = function(min, max, worldMatrix) {
    var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    var vectors = this.vectors;
    this.minimum.copyFromFloats(minX, minY, minZ);
    this.maximum.copyFromFloats(maxX, maxY, maxZ);
    vectors[0].copyFromFloats(minX, minY, minZ);
    vectors[1].copyFromFloats(maxX, maxY, maxZ);
    vectors[2].copyFromFloats(maxX, minY, minZ);
    vectors[3].copyFromFloats(minX, maxY, minZ);
    vectors[4].copyFromFloats(minX, minY, maxZ);
    vectors[5].copyFromFloats(maxX, maxY, minZ);
    vectors[6].copyFromFloats(minX, maxY, maxZ);
    vectors[7].copyFromFloats(maxX, minY, maxZ);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);
    this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;
    this._update(this._worldMatrix);
  };
  BoundingBox2.prototype.scale = function(factor) {
    var tmpVectors = BoundingBox2._TmpVector3;
    var diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);
    var len = diff.length();
    diff.normalizeFromLength(len);
    var distance = len * factor;
    var newRadius = diff.scaleInPlace(distance * 0.5);
    var min = this.center.subtractToRef(newRadius, tmpVectors[1]);
    var max = this.center.addToRef(newRadius, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  };
  BoundingBox2.prototype.getWorldMatrix = function() {
    return this._worldMatrix;
  };
  BoundingBox2.prototype._update = function(world) {
    var minWorld = this.minimumWorld;
    var maxWorld = this.maximumWorld;
    var directions = this.directions;
    var vectorsWorld = this.vectorsWorld;
    var vectors = this.vectors;
    if (!world.isIdentity()) {
      minWorld.setAll(Number.MAX_VALUE);
      maxWorld.setAll(-Number.MAX_VALUE);
      for (var index = 0; index < 8; ++index) {
        var v = vectorsWorld[index];
        Vector3.TransformCoordinatesToRef(vectors[index], world, v);
        minWorld.minimizeInPlace(v);
        maxWorld.maximizeInPlace(v);
      }
      maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);
      maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);
    } else {
      minWorld.copyFrom(this.minimum);
      maxWorld.copyFrom(this.maximum);
      for (var index = 0; index < 8; ++index) {
        vectorsWorld[index].copyFrom(vectors[index]);
      }
      this.extendSizeWorld.copyFrom(this.extendSize);
      this.centerWorld.copyFrom(this.center);
    }
    Vector3.FromArrayToRef(world.m, 0, directions[0]);
    Vector3.FromArrayToRef(world.m, 4, directions[1]);
    Vector3.FromArrayToRef(world.m, 8, directions[2]);
    this._worldMatrix = world;
  };
  BoundingBox2.prototype.isInFrustum = function(frustumPlanes) {
    return BoundingBox2.IsInFrustum(this.vectorsWorld, frustumPlanes);
  };
  BoundingBox2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    return BoundingBox2.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);
  };
  BoundingBox2.prototype.intersectsPoint = function(point) {
    var min = this.minimumWorld;
    var max = this.maximumWorld;
    var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    var pointX = point.x, pointY = point.y, pointZ = point.z;
    var delta = -Epsilon;
    if (maxX - pointX < delta || delta > pointX - minX) {
      return false;
    }
    if (maxY - pointY < delta || delta > pointY - minY) {
      return false;
    }
    if (maxZ - pointZ < delta || delta > pointZ - minZ) {
      return false;
    }
    return true;
  };
  BoundingBox2.prototype.intersectsSphere = function(sphere) {
    return BoundingBox2.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);
  };
  BoundingBox2.prototype.intersectsMinMax = function(min, max) {
    var myMin = this.minimumWorld;
    var myMax = this.maximumWorld;
    var myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;
    var minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
    if (myMaxX < minX || myMinX > maxX) {
      return false;
    }
    if (myMaxY < minY || myMinY > maxY) {
      return false;
    }
    if (myMaxZ < minZ || myMinZ > maxZ) {
      return false;
    }
    return true;
  };
  BoundingBox2.prototype.dispose = function() {
    var _a2, _b2;
    (_a2 = this._drawWrapperFront) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    (_b2 = this._drawWrapperBack) === null || _b2 === void 0 ? void 0 : _b2.dispose();
  };
  BoundingBox2.Intersects = function(box0, box1) {
    return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);
  };
  BoundingBox2.IntersectsSphere = function(minPoint, maxPoint, sphereCenter, sphereRadius) {
    var vector = BoundingBox2._TmpVector3[0];
    Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);
    var num = Vector3.DistanceSquared(sphereCenter, vector);
    return num <= sphereRadius * sphereRadius;
  };
  BoundingBox2.IsCompletelyInFrustum = function(boundingVectors, frustumPlanes) {
    for (var p = 0; p < 6; ++p) {
      var frustumPlane = frustumPlanes[p];
      for (var i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {
          return false;
        }
      }
    }
    return true;
  };
  BoundingBox2.IsInFrustum = function(boundingVectors, frustumPlanes) {
    for (var p = 0; p < 6; ++p) {
      var canReturnFalse = true;
      var frustumPlane = frustumPlanes[p];
      for (var i = 0; i < 8; ++i) {
        if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {
          canReturnFalse = false;
          break;
        }
      }
      if (canReturnFalse) {
        return false;
      }
    }
    return true;
  };
  BoundingBox2._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
  return BoundingBox2;
}();
var BoundingSphere = function() {
  function BoundingSphere2(min, max, worldMatrix) {
    this.center = Vector3.Zero();
    this.centerWorld = Vector3.Zero();
    this.minimum = Vector3.Zero();
    this.maximum = Vector3.Zero();
    this.reConstruct(min, max, worldMatrix);
  }
  BoundingSphere2.prototype.reConstruct = function(min, max, worldMatrix) {
    this.minimum.copyFrom(min);
    this.maximum.copyFrom(max);
    var distance = Vector3.Distance(min, max);
    max.addToRef(min, this.center).scaleInPlace(0.5);
    this.radius = distance * 0.5;
    this._update(worldMatrix || Matrix.IdentityReadOnly);
  };
  BoundingSphere2.prototype.scale = function(factor) {
    var newRadius = this.radius * factor;
    var tmpVectors = BoundingSphere2._TmpVector3;
    var tempRadiusVector = tmpVectors[0].setAll(newRadius);
    var min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);
    var max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);
    this.reConstruct(min, max, this._worldMatrix);
    return this;
  };
  BoundingSphere2.prototype.getWorldMatrix = function() {
    return this._worldMatrix;
  };
  BoundingSphere2.prototype._update = function(worldMatrix) {
    if (!worldMatrix.isIdentity()) {
      Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);
      var tempVector = BoundingSphere2._TmpVector3[0];
      Vector3.TransformNormalFromFloatsToRef(1, 1, 1, worldMatrix, tempVector);
      this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;
    } else {
      this.centerWorld.copyFrom(this.center);
      this.radiusWorld = this.radius;
    }
  };
  BoundingSphere2.prototype.isInFrustum = function(frustumPlanes) {
    var center = this.centerWorld;
    var radius = this.radiusWorld;
    for (var i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) <= -radius) {
        return false;
      }
    }
    return true;
  };
  BoundingSphere2.prototype.isCenterInFrustum = function(frustumPlanes) {
    var center = this.centerWorld;
    for (var i = 0; i < 6; i++) {
      if (frustumPlanes[i].dotCoordinate(center) < 0) {
        return false;
      }
    }
    return true;
  };
  BoundingSphere2.prototype.intersectsPoint = function(point) {
    var squareDistance = Vector3.DistanceSquared(this.centerWorld, point);
    if (this.radiusWorld * this.radiusWorld < squareDistance) {
      return false;
    }
    return true;
  };
  BoundingSphere2.Intersects = function(sphere0, sphere1) {
    var squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);
    var radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;
    if (radiusSum * radiusSum < squareDistance) {
      return false;
    }
    return true;
  };
  BoundingSphere2.CreateFromCenterAndRadius = function(center, radius, matrix) {
    this._TmpVector3[0].copyFrom(center);
    this._TmpVector3[1].copyFromFloats(0, 0, radius);
    this._TmpVector3[2].copyFrom(center);
    this._TmpVector3[0].addInPlace(this._TmpVector3[1]);
    this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
    var sphere = new BoundingSphere2(this._TmpVector3[0], this._TmpVector3[2]);
    if (matrix) {
      sphere._worldMatrix = matrix;
    } else {
      sphere._worldMatrix = Matrix.Identity();
    }
    return sphere;
  };
  BoundingSphere2._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
  return BoundingSphere2;
}();
var _result0 = { min: 0, max: 0 };
var _result1 = { min: 0, max: 0 };
var computeBoxExtents = function(axis, box, result) {
  var p = Vector3.Dot(box.centerWorld, axis);
  var r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;
  var r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;
  var r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;
  var r = r0 + r1 + r2;
  result.min = p - r;
  result.max = p + r;
};
var axisOverlap = function(axis, box0, box1) {
  computeBoxExtents(axis, box0, _result0);
  computeBoxExtents(axis, box1, _result1);
  return !(_result0.min > _result1.max || _result1.min > _result0.max);
};
var BoundingInfo = function() {
  function BoundingInfo2(minimum, maximum, worldMatrix) {
    this._isLocked = false;
    this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);
    this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);
  }
  BoundingInfo2.prototype.reConstruct = function(min, max, worldMatrix) {
    this.boundingBox.reConstruct(min, max, worldMatrix);
    this.boundingSphere.reConstruct(min, max, worldMatrix);
  };
  Object.defineProperty(BoundingInfo2.prototype, "minimum", {
    get: function() {
      return this.boundingBox.minimum;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BoundingInfo2.prototype, "maximum", {
    get: function() {
      return this.boundingBox.maximum;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BoundingInfo2.prototype, "isLocked", {
    get: function() {
      return this._isLocked;
    },
    set: function(value) {
      this._isLocked = value;
    },
    enumerable: false,
    configurable: true
  });
  BoundingInfo2.prototype.update = function(world) {
    if (this._isLocked) {
      return;
    }
    this.boundingBox._update(world);
    this.boundingSphere._update(world);
  };
  BoundingInfo2.prototype.centerOn = function(center, extend) {
    var minimum = BoundingInfo2._TmpVector3[0].copyFrom(center).subtractInPlace(extend);
    var maximum = BoundingInfo2._TmpVector3[1].copyFrom(center).addInPlace(extend);
    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  };
  BoundingInfo2.prototype.encapsulate = function(point) {
    var minimum = Vector3.Minimize(this.minimum, point);
    var maximum = Vector3.Maximize(this.maximum, point);
    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
    return this;
  };
  BoundingInfo2.prototype.encapsulateBoundingInfo = function(toEncapsulate) {
    this.encapsulate(toEncapsulate.boundingBox.centerWorld.subtract(toEncapsulate.boundingBox.extendSizeWorld));
    this.encapsulate(toEncapsulate.boundingBox.centerWorld.add(toEncapsulate.boundingBox.extendSizeWorld));
    return this;
  };
  BoundingInfo2.prototype.scale = function(factor) {
    this.boundingBox.scale(factor);
    this.boundingSphere.scale(factor);
    return this;
  };
  BoundingInfo2.prototype.isInFrustum = function(frustumPlanes, strategy) {
    if (strategy === void 0) {
      strategy = 0;
    }
    var inclusionTest = strategy === 2 || strategy === 3;
    if (inclusionTest) {
      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {
        return true;
      }
    }
    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {
      return false;
    }
    var bSphereOnlyTest = strategy === 1 || strategy === 3;
    if (bSphereOnlyTest) {
      return true;
    }
    return this.boundingBox.isInFrustum(frustumPlanes);
  };
  Object.defineProperty(BoundingInfo2.prototype, "diagonalLength", {
    get: function() {
      var boundingBox = this.boundingBox;
      var diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo2._TmpVector3[0]);
      return diag.length();
    },
    enumerable: false,
    configurable: true
  });
  BoundingInfo2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);
  };
  BoundingInfo2.prototype._checkCollision = function(collider) {
    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  };
  BoundingInfo2.prototype.intersectsPoint = function(point) {
    if (!this.boundingSphere.centerWorld) {
      return false;
    }
    if (!this.boundingSphere.intersectsPoint(point)) {
      return false;
    }
    if (!this.boundingBox.intersectsPoint(point)) {
      return false;
    }
    return true;
  };
  BoundingInfo2.prototype.intersects = function(boundingInfo, precise) {
    if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {
      return false;
    }
    if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {
      return false;
    }
    if (!precise) {
      return true;
    }
    var box0 = this.boundingBox;
    var box1 = boundingInfo.boundingBox;
    if (!axisOverlap(box0.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box0.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[0], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[1], box0, box1)) {
      return false;
    }
    if (!axisOverlap(box1.directions[2], box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {
      return false;
    }
    if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {
      return false;
    }
    return true;
  };
  BoundingInfo2._TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);
  return BoundingInfo2;
}();
var MathHelpers = function() {
  function MathHelpers2() {
  }
  MathHelpers2.extractMinAndMaxIndexed = function(positions, indices, indexStart, indexCount, minimum, maximum) {
    for (var index = indexStart; index < indexStart + indexCount; index++) {
      var offset = indices[index] * 3;
      var x = positions[offset];
      var y = positions[offset + 1];
      var z = positions[offset + 2];
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
    }
  };
  MathHelpers2.extractMinAndMax = function(positions, start, count, stride, minimum, maximum) {
    for (var index = start, offset = start * stride; index < start + count; index++, offset += stride) {
      var x = positions[offset];
      var y = positions[offset + 1];
      var z = positions[offset + 2];
      minimum.minimizeInPlaceFromFloats(x, y, z);
      maximum.maximizeInPlaceFromFloats(x, y, z);
    }
  };
  __decorate([
    nativeOverride.filter(function() {
      var _a2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a2[_i] = arguments[_i];
      }
      var positions = _a2[0], indices = _a2[1];
      return !Array.isArray(positions) && !Array.isArray(indices);
    })
  ], MathHelpers2, "extractMinAndMaxIndexed", null);
  __decorate([
    nativeOverride.filter(function() {
      var _a2 = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        _a2[_i] = arguments[_i];
      }
      var positions = _a2[0];
      return !Array.isArray(positions);
    })
  ], MathHelpers2, "extractMinAndMax", null);
  return MathHelpers2;
}();
function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias) {
  if (bias === void 0) {
    bias = null;
  }
  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
function extractMinAndMax(positions, start, count, bias, stride) {
  if (bias === void 0) {
    bias = null;
  }
  var minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  var maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  if (!stride) {
    stride = 3;
  }
  MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
var SubMesh = function() {
  function SubMesh2(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox, addToMesh) {
    if (createBoundingBox === void 0) {
      createBoundingBox = true;
    }
    if (addToMesh === void 0) {
      addToMesh = true;
    }
    this.materialIndex = materialIndex;
    this.verticesStart = verticesStart;
    this.verticesCount = verticesCount;
    this.indexStart = indexStart;
    this.indexCount = indexCount;
    this._mainDrawWrapperOverride = null;
    this._linesIndexCount = 0;
    this._linesIndexBuffer = null;
    this._lastColliderWorldVertices = null;
    this._lastColliderTransformMatrix = null;
    this._renderId = 0;
    this._alphaIndex = 0;
    this._distanceToCamera = 0;
    this._currentMaterial = null;
    this._mesh = mesh;
    this._renderingMesh = renderingMesh || mesh;
    if (addToMesh) {
      mesh.subMeshes.push(this);
    }
    this._engine = this._mesh.getScene().getEngine();
    this.resetDrawCache();
    this._trianglePlanes = [];
    this._id = mesh.subMeshes.length - 1;
    if (createBoundingBox) {
      this.refreshBoundingInfo();
      mesh.computeWorldMatrix(true);
    }
  }
  Object.defineProperty(SubMesh2.prototype, "materialDefines", {
    get: function() {
      var _a2;
      return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a2 = this._getDrawWrapper()) === null || _a2 === void 0 ? void 0 : _a2.defines;
    },
    set: function(defines) {
      var _a2;
      var drawWrapper = (_a2 = this._mainDrawWrapperOverride) !== null && _a2 !== void 0 ? _a2 : this._getDrawWrapper(void 0, true);
      drawWrapper.defines = defines;
    },
    enumerable: false,
    configurable: true
  });
  SubMesh2.prototype._getDrawWrapper = function(passId, createIfNotExisting) {
    if (createIfNotExisting === void 0) {
      createIfNotExisting = false;
    }
    passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;
    var drawWrapper = this._drawWrappers[passId];
    if (!drawWrapper && createIfNotExisting) {
      this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());
    }
    return drawWrapper;
  };
  SubMesh2.prototype._removeDrawWrapper = function(passId, disposeWrapper) {
    var _a2;
    if (disposeWrapper === void 0) {
      disposeWrapper = true;
    }
    if (disposeWrapper) {
      (_a2 = this._drawWrappers[passId]) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    }
    this._drawWrappers[passId] = void 0;
  };
  Object.defineProperty(SubMesh2.prototype, "effect", {
    get: function() {
      var _a2, _b2;
      return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b2 = (_a2 = this._getDrawWrapper()) === null || _a2 === void 0 ? void 0 : _a2.effect) !== null && _b2 !== void 0 ? _b2 : null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubMesh2.prototype, "_drawWrapper", {
    get: function() {
      var _a2;
      return (_a2 = this._mainDrawWrapperOverride) !== null && _a2 !== void 0 ? _a2 : this._getDrawWrapper(void 0, true);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SubMesh2.prototype, "_drawWrapperOverride", {
    get: function() {
      return this._mainDrawWrapperOverride;
    },
    enumerable: false,
    configurable: true
  });
  SubMesh2.prototype._setMainDrawWrapperOverride = function(wrapper) {
    this._mainDrawWrapperOverride = wrapper;
  };
  SubMesh2.prototype.setEffect = function(effect, defines, materialContext, resetContext) {
    if (defines === void 0) {
      defines = null;
    }
    if (resetContext === void 0) {
      resetContext = true;
    }
    var drawWrapper = this._drawWrapper;
    drawWrapper.setEffect(effect, defines, resetContext);
    if (materialContext !== void 0) {
      drawWrapper.materialContext = materialContext;
    }
    if (!effect) {
      drawWrapper.defines = null;
      drawWrapper.materialContext = void 0;
    }
  };
  SubMesh2.prototype.resetDrawCache = function(passId) {
    if (this._drawWrappers) {
      if (passId !== void 0) {
        this._removeDrawWrapper(passId);
        return;
      } else {
        for (var _i = 0, _a2 = this._drawWrappers; _i < _a2.length; _i++) {
          var drawWrapper = _a2[_i];
          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();
        }
      }
    }
    this._drawWrappers = [];
  };
  SubMesh2.AddToMesh = function(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox) {
    if (createBoundingBox === void 0) {
      createBoundingBox = true;
    }
    return new SubMesh2(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);
  };
  Object.defineProperty(SubMesh2.prototype, "IsGlobal", {
    get: function() {
      return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();
    },
    enumerable: false,
    configurable: true
  });
  SubMesh2.prototype.getBoundingInfo = function() {
    if (this.IsGlobal) {
      return this._mesh.getBoundingInfo();
    }
    return this._boundingInfo;
  };
  SubMesh2.prototype.setBoundingInfo = function(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  };
  SubMesh2.prototype.getMesh = function() {
    return this._mesh;
  };
  SubMesh2.prototype.getRenderingMesh = function() {
    return this._renderingMesh;
  };
  SubMesh2.prototype.getReplacementMesh = function() {
    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
  };
  SubMesh2.prototype.getEffectiveMesh = function() {
    var replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
    return replacementMesh ? replacementMesh : this._renderingMesh;
  };
  SubMesh2.prototype.getMaterial = function() {
    var _a2;
    var rootMaterial = (_a2 = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a2 !== void 0 ? _a2 : this._renderingMesh.material;
    if (!rootMaterial) {
      return this._mesh.getScene().defaultMaterial;
    } else if (this._isMultiMaterial(rootMaterial)) {
      var effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);
      if (this._currentMaterial !== effectiveMaterial) {
        this._currentMaterial = effectiveMaterial;
        this.resetDrawCache();
      }
      return effectiveMaterial;
    }
    return rootMaterial;
  };
  SubMesh2.prototype._isMultiMaterial = function(material) {
    return material.getSubMaterial !== void 0;
  };
  SubMesh2.prototype.refreshBoundingInfo = function(data) {
    if (data === void 0) {
      data = null;
    }
    this._lastColliderWorldVertices = null;
    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {
      return this;
    }
    if (!data) {
      data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);
    }
    if (!data) {
      this._boundingInfo = this._mesh.getBoundingInfo();
      return this;
    }
    var indices = this._renderingMesh.getIndices();
    var extend;
    if (this.indexStart === 0 && this.indexCount === indices.length) {
      var boundingInfo = this._renderingMesh.getBoundingInfo();
      extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };
    } else {
      extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
    }
    if (this._boundingInfo) {
      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
    } else {
      this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
    }
    return this;
  };
  SubMesh2.prototype._checkCollision = function(collider) {
    var boundingInfo = this.getBoundingInfo();
    return boundingInfo._checkCollision(collider);
  };
  SubMesh2.prototype.updateBoundingInfo = function(world) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      this.refreshBoundingInfo();
      boundingInfo = this.getBoundingInfo();
    }
    if (boundingInfo) {
      boundingInfo.update(world);
    }
    return this;
  };
  SubMesh2.prototype.isInFrustum = function(frustumPlanes) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);
  };
  SubMesh2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return boundingInfo.isCompletelyInFrustum(frustumPlanes);
  };
  SubMesh2.prototype.render = function(enableAlphaMode) {
    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0);
    return this;
  };
  SubMesh2.prototype._getLinesIndexBuffer = function(indices, engine) {
    if (!this._linesIndexBuffer) {
      var linesIndices = [];
      for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {
        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);
      }
      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);
      this._linesIndexCount = linesIndices.length;
    }
    return this._linesIndexBuffer;
  };
  SubMesh2.prototype.canIntersects = function(ray) {
    var boundingInfo = this.getBoundingInfo();
    if (!boundingInfo) {
      return false;
    }
    return ray.intersectsBox(boundingInfo.boundingBox);
  };
  SubMesh2.prototype.intersects = function(ray, positions, indices, fastCheck, trianglePredicate) {
    var material = this.getMaterial();
    if (!material) {
      return null;
    }
    var step = 3;
    var checkStopper = false;
    switch (material.fillMode) {
      case 3:
      case 5:
      case 6:
      case 8:
        return null;
      case 7:
        step = 1;
        checkStopper = true;
        break;
    }
    if (material.fillMode === 4) {
      if (!indices.length) {
        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
      }
      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
    } else {
      if (!indices.length && this._mesh._unIndexed) {
        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);
      }
      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);
    }
  };
  SubMesh2.prototype._intersectLines = function(ray, positions, indices, intersectionThreshold, fastCheck) {
    var intersectInfo = null;
    for (var index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {
      var p0 = positions[indices[index]];
      var p1 = positions[indices[index + 1]];
      var length_1 = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length_1 < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length_1 < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length_1);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._intersectUnIndexedLines = function(ray, positions, indices, intersectionThreshold, fastCheck) {
    var intersectInfo = null;
    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {
      var p0 = positions[index];
      var p1 = positions[index + 1];
      var length_2 = ray.intersectionSegment(p0, p1, intersectionThreshold);
      if (length_2 < 0) {
        continue;
      }
      if (fastCheck || !intersectInfo || length_2 < intersectInfo.distance) {
        intersectInfo = new IntersectionInfo(null, null, length_2);
        intersectInfo.faceId = index / 2;
        if (fastCheck) {
          break;
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._intersectTriangles = function(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {
    var intersectInfo = null;
    var faceId = -1;
    for (var index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {
      faceId++;
      var indexA = indices[index];
      var indexB = indices[index + 1];
      var indexC = indices[index + 2];
      if (checkStopper && indexC === 4294967295) {
        index += 2;
        continue;
      }
      var p0 = positions[indexA];
      var p1 = positions[indexB];
      var p2 = positions[indexC];
      if (!p0 || !p1 || !p2) {
        continue;
      }
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {
        continue;
      }
      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = faceId;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._intersectUnIndexedTriangles = function(ray, positions, indices, fastCheck, trianglePredicate) {
    var intersectInfo = null;
    for (var index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
      var p0 = positions[index];
      var p1 = positions[index + 1];
      var p2 = positions[index + 2];
      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray)) {
        continue;
      }
      var currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
      if (currentIntersectInfo) {
        if (currentIntersectInfo.distance < 0) {
          continue;
        }
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.faceId = index / 3;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    return intersectInfo;
  };
  SubMesh2.prototype._rebuild = function() {
    if (this._linesIndexBuffer) {
      this._linesIndexBuffer = null;
    }
  };
  SubMesh2.prototype.clone = function(newMesh, newRenderingMesh) {
    var result = new SubMesh2(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);
    if (!this.IsGlobal) {
      var boundingInfo = this.getBoundingInfo();
      if (!boundingInfo) {
        return result;
      }
      result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);
    }
    return result;
  };
  SubMesh2.prototype.dispose = function() {
    if (this._linesIndexBuffer) {
      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);
      this._linesIndexBuffer = null;
    }
    var index = this._mesh.subMeshes.indexOf(this);
    this._mesh.subMeshes.splice(index, 1);
    this.resetDrawCache();
  };
  SubMesh2.prototype.getClassName = function() {
    return "SubMesh";
  };
  SubMesh2.CreateFromIndices = function(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox) {
    if (createBoundingBox === void 0) {
      createBoundingBox = true;
    }
    var minVertexIndex = Number.MAX_VALUE;
    var maxVertexIndex = -Number.MAX_VALUE;
    var whatWillRender = renderingMesh || mesh;
    var indices = whatWillRender.getIndices();
    for (var index = startIndex; index < startIndex + indexCount; index++) {
      var vertexIndex = indices[index];
      if (vertexIndex < minVertexIndex) {
        minVertexIndex = vertexIndex;
      }
      if (vertexIndex > maxVertexIndex) {
        maxVertexIndex = vertexIndex;
      }
    }
    return new SubMesh2(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);
  };
  return SubMesh2;
}();
var SceneLoaderFlags = function() {
  function SceneLoaderFlags2() {
  }
  Object.defineProperty(SceneLoaderFlags2, "ForceFullSceneLoadingForIncremental", {
    get: function() {
      return SceneLoaderFlags2._ForceFullSceneLoadingForIncremental;
    },
    set: function(value) {
      SceneLoaderFlags2._ForceFullSceneLoadingForIncremental = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoaderFlags2, "ShowLoadingScreen", {
    get: function() {
      return SceneLoaderFlags2._ShowLoadingScreen;
    },
    set: function(value) {
      SceneLoaderFlags2._ShowLoadingScreen = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoaderFlags2, "loggingLevel", {
    get: function() {
      return SceneLoaderFlags2._LoggingLevel;
    },
    set: function(value) {
      SceneLoaderFlags2._LoggingLevel = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(SceneLoaderFlags2, "CleanBoneMatrixWeights", {
    get: function() {
      return SceneLoaderFlags2._CleanBoneMatrixWeights;
    },
    set: function(value) {
      SceneLoaderFlags2._CleanBoneMatrixWeights = value;
    },
    enumerable: false,
    configurable: true
  });
  SceneLoaderFlags2._ForceFullSceneLoadingForIncremental = false;
  SceneLoaderFlags2._ShowLoadingScreen = true;
  SceneLoaderFlags2._CleanBoneMatrixWeights = false;
  SceneLoaderFlags2._LoggingLevel = 0;
  return SceneLoaderFlags2;
}();
var CompatibilityOptions = function() {
  function CompatibilityOptions2() {
  }
  CompatibilityOptions2.UseOpenGLOrientationForUV = false;
  return CompatibilityOptions2;
}();
var Geometry = function() {
  function Geometry2(id, scene, vertexData, updatable, mesh) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (mesh === void 0) {
      mesh = null;
    }
    this.delayLoadState = 0;
    this._totalVertices = 0;
    this._isDisposed = false;
    this._indexBufferIsUpdatable = false;
    this._positionsCache = [];
    this._parentContainer = null;
    this.useBoundingInfoFromGeometry = false;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
    this.id = id;
    this.uniqueId = this._scene.getUniqueId();
    this._engine = this._scene.getEngine();
    this._meshes = [];
    this._vertexBuffers = {};
    this._indices = [];
    this._updatable = updatable;
    if (vertexData) {
      this.setAllVerticesData(vertexData, updatable);
    } else {
      this._totalVertices = 0;
      this._indices = [];
    }
    if (this._engine.getCaps().vertexArrayObject) {
      this._vertexArrayObjects = {};
    }
    if (mesh) {
      this.applyToMesh(mesh);
      mesh.computeWorldMatrix(true);
    }
  }
  Object.defineProperty(Geometry2.prototype, "boundingBias", {
    get: function() {
      return this._boundingBias;
    },
    set: function(value) {
      if (this._boundingBias) {
        this._boundingBias.copyFrom(value);
      } else {
        this._boundingBias = value.clone();
      }
      this._updateBoundingInfo(true, null);
    },
    enumerable: false,
    configurable: true
  });
  Geometry2.CreateGeometryForMesh = function(mesh) {
    var geometry = new Geometry2(Geometry2.RandomId(), mesh.getScene());
    geometry.applyToMesh(mesh);
    return geometry;
  };
  Object.defineProperty(Geometry2.prototype, "meshes", {
    get: function() {
      return this._meshes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Geometry2.prototype, "extend", {
    get: function() {
      return this._extend;
    },
    enumerable: false,
    configurable: true
  });
  Geometry2.prototype.getScene = function() {
    return this._scene;
  };
  Geometry2.prototype.getEngine = function() {
    return this._engine;
  };
  Geometry2.prototype.isReady = function() {
    return this.delayLoadState === 1 || this.delayLoadState === 0;
  };
  Object.defineProperty(Geometry2.prototype, "doNotSerialize", {
    get: function() {
      for (var index = 0; index < this._meshes.length; index++) {
        if (!this._meshes[index].doNotSerialize) {
          return false;
        }
      }
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Geometry2.prototype._rebuild = function() {
    if (this._vertexArrayObjects) {
      this._vertexArrayObjects = {};
    }
    if (this._meshes.length !== 0 && this._indices) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
    }
    for (var key in this._vertexBuffers) {
      var vertexBuffer = this._vertexBuffers[key];
      vertexBuffer._rebuild();
    }
  };
  Geometry2.prototype.setAllVerticesData = function(vertexData, updatable) {
    vertexData.applyToGeometry(this, updatable);
    this._notifyUpdate();
  };
  Geometry2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (updatable && Array.isArray(data)) {
      data = new Float32Array(data);
    }
    var buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);
    this.setVerticesBuffer(buffer);
  };
  Geometry2.prototype.removeVerticesData = function(kind) {
    if (this._vertexBuffers[kind]) {
      this._vertexBuffers[kind].dispose();
      delete this._vertexBuffers[kind];
    }
    if (this._vertexArrayObjects) {
      this._disposeVertexArrayObjects();
    }
  };
  Geometry2.prototype.setVerticesBuffer = function(buffer, totalVertices, disposeExistingBuffer) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (disposeExistingBuffer === void 0) {
      disposeExistingBuffer = true;
    }
    var kind = buffer.getKind();
    if (this._vertexBuffers[kind] && disposeExistingBuffer) {
      this._vertexBuffers[kind].dispose();
    }
    if (buffer._buffer) {
      buffer._buffer._increaseReferences();
    }
    this._vertexBuffers[kind] = buffer;
    var meshes = this._meshes;
    var numOfMeshes = meshes.length;
    if (kind === VertexBuffer.PositionKind) {
      var data = buffer.getData();
      if (totalVertices != null) {
        this._totalVertices = totalVertices;
      } else {
        if (data != null) {
          this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);
        }
      }
      this._updateExtend(data);
      this._resetPointsArrayCache();
      for (var index = 0; index < numOfMeshes; index++) {
        var mesh = meshes[index];
        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        mesh._createGlobalSubMesh(mesh.isUnIndexed);
        mesh.computeWorldMatrix(true);
        mesh.synchronizeInstances();
      }
    }
    this._notifyUpdate(kind);
  };
  Geometry2.prototype.updateVerticesDataDirectly = function(kind, data, offset, useBytes) {
    if (useBytes === void 0) {
      useBytes = false;
    }
    var vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return;
    }
    vertexBuffer.updateDirectly(data, offset, useBytes);
    this._notifyUpdate(kind);
  };
  Geometry2.prototype.updateVerticesData = function(kind, data, updateExtends) {
    if (updateExtends === void 0) {
      updateExtends = false;
    }
    var vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return;
    }
    vertexBuffer.update(data);
    if (kind === VertexBuffer.PositionKind) {
      this._updateBoundingInfo(updateExtends, data);
    }
    this._notifyUpdate(kind);
  };
  Geometry2.prototype._updateBoundingInfo = function(updateExtends, data) {
    if (updateExtends) {
      this._updateExtend(data);
    }
    this._resetPointsArrayCache();
    if (updateExtends) {
      var meshes = this._meshes;
      for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
        var mesh = meshes_1[_i];
        if (mesh.hasBoundingInfo) {
          mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);
        } else {
          mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        }
        var subMeshes = mesh.subMeshes;
        for (var _a2 = 0, subMeshes_1 = subMeshes; _a2 < subMeshes_1.length; _a2++) {
          var subMesh = subMeshes_1[_a2];
          subMesh.refreshBoundingInfo();
        }
      }
    }
  };
  Geometry2.prototype._bind = function(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {
    if (!effect) {
      return;
    }
    if (indexToBind === void 0) {
      indexToBind = this._indexBuffer;
    }
    var vbs = this.getVertexBuffers();
    if (!vbs) {
      return;
    }
    if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {
      this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);
      return;
    }
    var vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;
    if (!vaos[effect.key]) {
      vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);
    }
    this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);
  };
  Geometry2.prototype.getTotalVertices = function() {
    if (!this.isReady()) {
      return 0;
    }
    return this._totalVertices;
  };
  Geometry2.prototype.getVerticesData = function(kind, copyWhenShared, forceCopy) {
    var vertexBuffer = this.getVertexBuffer(kind);
    if (!vertexBuffer) {
      return null;
    }
    return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);
  };
  Geometry2.prototype.isVertexBufferUpdatable = function(kind) {
    var vb = this._vertexBuffers[kind];
    if (!vb) {
      return false;
    }
    return vb.isUpdatable();
  };
  Geometry2.prototype.getVertexBuffer = function(kind) {
    if (!this.isReady()) {
      return null;
    }
    return this._vertexBuffers[kind];
  };
  Geometry2.prototype.getVertexBuffers = function() {
    if (!this.isReady()) {
      return null;
    }
    return this._vertexBuffers;
  };
  Geometry2.prototype.isVerticesDataPresent = function(kind) {
    if (!this._vertexBuffers) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return this._vertexBuffers[kind] !== void 0;
  };
  Geometry2.prototype.getVerticesDataKinds = function() {
    var result = [];
    var kind;
    if (!this._vertexBuffers && this._delayInfo) {
      for (kind in this._delayInfo) {
        result.push(kind);
      }
    } else {
      for (kind in this._vertexBuffers) {
        result.push(kind);
      }
    }
    return result;
  };
  Geometry2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
    if (gpuMemoryOnly === void 0) {
      gpuMemoryOnly = false;
    }
    if (!this._indexBuffer) {
      return;
    }
    if (!this._indexBufferIsUpdatable) {
      this.setIndices(indices, null, true);
    } else {
      var needToUpdateSubMeshes = indices.length !== this._indices.length;
      if (!gpuMemoryOnly) {
        this._indices = indices.slice();
      }
      this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);
      if (needToUpdateSubMeshes) {
        for (var _i = 0, _a2 = this._meshes; _i < _a2.length; _i++) {
          var mesh = _a2[_i];
          mesh._createGlobalSubMesh(true);
        }
      }
    }
  };
  Geometry2.prototype.setIndices = function(indices, totalVertices, updatable) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (updatable === void 0) {
      updatable = false;
    }
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
    }
    this._indices = indices;
    this._indexBufferIsUpdatable = updatable;
    if (this._meshes.length !== 0 && this._indices) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);
    }
    if (totalVertices != void 0) {
      this._totalVertices = totalVertices;
    }
    for (var _i = 0, _a2 = this._meshes; _i < _a2.length; _i++) {
      var mesh = _a2[_i];
      mesh._createGlobalSubMesh(true);
      mesh.synchronizeInstances();
    }
    this._notifyUpdate();
  };
  Geometry2.prototype.getTotalIndices = function() {
    if (!this.isReady()) {
      return 0;
    }
    return this._indices.length;
  };
  Geometry2.prototype.getIndices = function(copyWhenShared, forceCopy) {
    if (!this.isReady()) {
      return null;
    }
    var orig = this._indices;
    if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {
      return orig;
    } else {
      return orig.slice();
    }
  };
  Geometry2.prototype.getIndexBuffer = function() {
    if (!this.isReady()) {
      return null;
    }
    return this._indexBuffer;
  };
  Geometry2.prototype._releaseVertexArrayObject = function(effect) {
    if (effect === void 0) {
      effect = null;
    }
    if (!effect || !this._vertexArrayObjects) {
      return;
    }
    if (this._vertexArrayObjects[effect.key]) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);
      delete this._vertexArrayObjects[effect.key];
    }
  };
  Geometry2.prototype.releaseForMesh = function(mesh, shouldDispose) {
    var meshes = this._meshes;
    var index = meshes.indexOf(mesh);
    if (index === -1) {
      return;
    }
    meshes.splice(index, 1);
    if (this._vertexArrayObjects) {
      mesh._invalidateInstanceVertexArrayObject();
    }
    mesh._geometry = null;
    if (meshes.length === 0 && shouldDispose) {
      this.dispose();
    }
  };
  Geometry2.prototype.applyToMesh = function(mesh) {
    if (mesh._geometry === this) {
      return;
    }
    var previousGeometry = mesh._geometry;
    if (previousGeometry) {
      previousGeometry.releaseForMesh(mesh);
    }
    if (this._vertexArrayObjects) {
      mesh._invalidateInstanceVertexArrayObject();
    }
    var meshes = this._meshes;
    mesh._geometry = this;
    mesh._internalAbstractMeshDataInfo._positions = null;
    this._scene.pushGeometry(this);
    meshes.push(mesh);
    if (this.isReady()) {
      this._applyToMesh(mesh);
    } else if (this._boundingInfo) {
      mesh.setBoundingInfo(this._boundingInfo);
    }
  };
  Geometry2.prototype._updateExtend = function(data) {
    if (data === void 0) {
      data = null;
    }
    if (this.useBoundingInfoFromGeometry && this._boundingInfo) {
      this._extend = {
        minimum: this._boundingInfo.minimum.clone(),
        maximum: this._boundingInfo.maximum.clone()
      };
    } else {
      if (!data) {
        data = this.getVerticesData(VertexBuffer.PositionKind);
        if (!data) {
          return;
        }
      }
      this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);
    }
  };
  Geometry2.prototype._applyToMesh = function(mesh) {
    var numOfMeshes = this._meshes.length;
    for (var kind in this._vertexBuffers) {
      if (numOfMeshes === 1) {
        this._vertexBuffers[kind].create();
      }
      if (kind === VertexBuffer.PositionKind) {
        if (!this._extend) {
          this._updateExtend();
        }
        mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        mesh._createGlobalSubMesh(mesh.isUnIndexed);
        mesh._updateBoundingInfo();
      }
    }
    if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {
      this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
    }
    mesh._syncGeometryWithMorphTargetManager();
    mesh.synchronizeInstances();
  };
  Geometry2.prototype._notifyUpdate = function(kind) {
    if (this.onGeometryUpdated) {
      this.onGeometryUpdated(this, kind);
    }
    if (this._vertexArrayObjects) {
      this._disposeVertexArrayObjects();
    }
    for (var _i = 0, _a2 = this._meshes; _i < _a2.length; _i++) {
      var mesh = _a2[_i];
      mesh._markSubMeshesAsAttributesDirty();
    }
  };
  Geometry2.prototype.load = function(scene, onLoaded) {
    if (this.delayLoadState === 2) {
      return;
    }
    if (this.isReady()) {
      if (onLoaded) {
        onLoaded();
      }
      return;
    }
    this.delayLoadState = 2;
    this._queueLoad(scene, onLoaded);
  };
  Geometry2.prototype._queueLoad = function(scene, onLoaded) {
    var _this = this;
    if (!this.delayLoadingFile) {
      return;
    }
    scene._addPendingData(this);
    scene._loadFile(this.delayLoadingFile, function(data) {
      if (!_this._delayLoadingFunction) {
        return;
      }
      _this._delayLoadingFunction(JSON.parse(data), _this);
      _this.delayLoadState = 1;
      _this._delayInfo = [];
      scene._removePendingData(_this);
      var meshes = _this._meshes;
      var numOfMeshes = meshes.length;
      for (var index = 0; index < numOfMeshes; index++) {
        _this._applyToMesh(meshes[index]);
      }
      if (onLoaded) {
        onLoaded();
      }
    }, void 0, true);
  };
  Geometry2.prototype.toLeftHanded = function() {
    var tIndices = this.getIndices(false);
    if (tIndices != null && tIndices.length > 0) {
      for (var i = 0; i < tIndices.length; i += 3) {
        var tTemp = tIndices[i + 0];
        tIndices[i + 0] = tIndices[i + 2];
        tIndices[i + 2] = tTemp;
      }
      this.setIndices(tIndices);
    }
    var tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);
    if (tPositions != null && tPositions.length > 0) {
      for (var i = 0; i < tPositions.length; i += 3) {
        tPositions[i + 2] = -tPositions[i + 2];
      }
      this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);
    }
    var tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);
    if (tNormals != null && tNormals.length > 0) {
      for (var i = 0; i < tNormals.length; i += 3) {
        tNormals[i + 2] = -tNormals[i + 2];
      }
      this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);
    }
  };
  Geometry2.prototype._resetPointsArrayCache = function() {
    this._positions = null;
  };
  Geometry2.prototype._generatePointsArray = function() {
    if (this._positions) {
      return true;
    }
    var data = this.getVerticesData(VertexBuffer.PositionKind);
    if (!data || data.length === 0) {
      return false;
    }
    for (var index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {
      this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);
    }
    for (var index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {
      this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);
    }
    this._positionsCache.length = data.length / 3;
    this._positions = this._positionsCache;
    return true;
  };
  Geometry2.prototype.isDisposed = function() {
    return this._isDisposed;
  };
  Geometry2.prototype._disposeVertexArrayObjects = function() {
    if (this._vertexArrayObjects) {
      for (var kind in this._vertexArrayObjects) {
        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);
      }
      this._vertexArrayObjects = {};
      var meshes = this._meshes;
      var numOfMeshes = meshes.length;
      for (var index = 0; index < numOfMeshes; index++) {
        meshes[index]._invalidateInstanceVertexArrayObject();
      }
    }
  };
  Geometry2.prototype.dispose = function() {
    var meshes = this._meshes;
    var numOfMeshes = meshes.length;
    var index;
    for (index = 0; index < numOfMeshes; index++) {
      this.releaseForMesh(meshes[index]);
    }
    this._meshes = [];
    this._disposeVertexArrayObjects();
    for (var kind in this._vertexBuffers) {
      this._vertexBuffers[kind].dispose();
    }
    this._vertexBuffers = {};
    this._totalVertices = 0;
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
    }
    this._indexBuffer = null;
    this._indices = [];
    this.delayLoadState = 0;
    this.delayLoadingFile = null;
    this._delayLoadingFunction = null;
    this._delayInfo = [];
    this._boundingInfo = null;
    this._scene.removeGeometry(this);
    if (this._parentContainer) {
      var index_1 = this._parentContainer.geometries.indexOf(this);
      if (index_1 > -1) {
        this._parentContainer.geometries.splice(index_1, 1);
      }
      this._parentContainer = null;
    }
    this._isDisposed = true;
  };
  Geometry2.prototype.copy = function(id) {
    var vertexData = new VertexData();
    vertexData.indices = [];
    var indices = this.getIndices();
    if (indices) {
      for (var index = 0; index < indices.length; index++) {
        vertexData.indices.push(indices[index]);
      }
    }
    var updatable = false;
    var stopChecking = false;
    var kind;
    for (kind in this._vertexBuffers) {
      var data = this.getVerticesData(kind);
      if (data) {
        if (data instanceof Float32Array) {
          vertexData.set(new Float32Array(data), kind);
        } else {
          vertexData.set(data.slice(0), kind);
        }
        if (!stopChecking) {
          var vb = this.getVertexBuffer(kind);
          if (vb) {
            updatable = vb.isUpdatable();
            stopChecking = !updatable;
          }
        }
      }
    }
    var geometry = new Geometry2(id, this._scene, vertexData, updatable);
    geometry.delayLoadState = this.delayLoadState;
    geometry.delayLoadingFile = this.delayLoadingFile;
    geometry._delayLoadingFunction = this._delayLoadingFunction;
    for (kind in this._delayInfo) {
      geometry._delayInfo = geometry._delayInfo || [];
      geometry._delayInfo.push(kind);
    }
    geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
    return geometry;
  };
  Geometry2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.updatable = this._updatable;
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    return serializationObject;
  };
  Geometry2.prototype._toNumberArray = function(origin2) {
    if (Array.isArray(origin2)) {
      return origin2;
    } else {
      return Array.prototype.slice.call(origin2);
    }
  };
  Geometry2.prototype.clearCachedData = function() {
    this._indices = [];
    this._resetPointsArrayCache();
    for (var vbName in this._vertexBuffers) {
      if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {
        continue;
      }
      this._vertexBuffers[vbName]._buffer._data = null;
    }
  };
  Geometry2.prototype.serializeVerticeData = function() {
    var serializationObject = this.serialize();
    if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
        serializationObject.positions._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
        serializationObject.normals._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {
        serializationObject.tangents._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {
      serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {
        serializationObject.uvs._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
      serializationObject.uv2s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {
        serializationObject.uv2s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
      serializationObject.uv3s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {
        serializationObject.uv3s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
      serializationObject.uv4s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {
        serializationObject.uv4s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
      serializationObject.uv5s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {
        serializationObject.uv5s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
      serializationObject.uv6s = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));
      if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {
        serializationObject.uv6s._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {
      serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {
        serializationObject.colors._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));
      serializationObject.matricesIndices._isExpanded = true;
      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {
        serializationObject.matricesIndices._updatable = true;
      }
    }
    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));
      if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {
        serializationObject.matricesWeights._updatable = true;
      }
    }
    serializationObject.indices = this._toNumberArray(this.getIndices());
    return serializationObject;
  };
  Geometry2.ExtractFromMesh = function(mesh, id) {
    var geometry = mesh._geometry;
    if (!geometry) {
      return null;
    }
    return geometry.copy(id);
  };
  Geometry2.RandomId = function() {
    return Tools.RandomId();
  };
  Geometry2._GetGeometryByLoadedUniqueId = function(uniqueId, scene) {
    for (var index = 0; index < scene.geometries.length; index++) {
      if (scene.geometries[index]._loadedUniqueId === uniqueId) {
        return scene.geometries[index];
      }
    }
    return null;
  };
  Geometry2._ImportGeometry = function(parsedGeometry, mesh) {
    var scene = mesh.getScene();
    var geometryUniqueId = parsedGeometry.geometryUniqueId;
    var geometryId = parsedGeometry.geometryId;
    if (geometryUniqueId || geometryId) {
      var geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);
      if (geometry) {
        geometry.applyToMesh(mesh);
      }
    } else if (parsedGeometry instanceof ArrayBuffer) {
      var binaryInfo = mesh._binaryInfo;
      if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {
        var positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);
      }
      if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {
        var normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);
      }
      if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {
        var tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);
      }
      if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {
        var uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvsData.length; index += 2) {
            uvsData[index] = 1 - uvsData[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);
      }
      if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {
        var uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs2Data.length; index += 2) {
            uvs2Data[index] = 1 - uvs2Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);
      }
      if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {
        var uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs3Data.length; index += 2) {
            uvs3Data[index] = 1 - uvs3Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);
      }
      if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {
        var uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs4Data.length; index += 2) {
            uvs4Data[index] = 1 - uvs4Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);
      }
      if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {
        var uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs5Data.length; index += 2) {
            uvs5Data[index] = 1 - uvs5Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);
      }
      if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {
        var uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);
        if (CompatibilityOptions.UseOpenGLOrientationForUV) {
          for (var index = 1; index < uvs6Data.length; index += 2) {
            uvs6Data[index] = 1 - uvs6Data[index];
          }
        }
        mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);
      }
      if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {
        var colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);
      }
      if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {
        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);
        var floatIndices = [];
        for (var i = 0; i < matricesIndicesData.length; i++) {
          var index = matricesIndicesData[i];
          floatIndices.push(index & 255);
          floatIndices.push((index & 65280) >> 8);
          floatIndices.push((index & 16711680) >> 16);
          floatIndices.push(index >> 24 & 255);
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);
      }
      if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {
        var matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);
        var floatIndices = [];
        for (var i = 0; i < matricesIndicesData.length; i++) {
          var index = matricesIndicesData[i];
          floatIndices.push(index & 255);
          floatIndices.push((index & 65280) >> 8);
          floatIndices.push((index & 16711680) >> 16);
          floatIndices.push(index >> 24 & 255);
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);
      }
      if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {
        var matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);
        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);
      }
      if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {
        var indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);
        mesh.setIndices(indicesData, null);
      }
      if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {
        var subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);
        mesh.subMeshes = [];
        for (var i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {
          var materialIndex = subMeshesData[i * 5 + 0];
          var verticesStart = subMeshesData[i * 5 + 1];
          var verticesCount = subMeshesData[i * 5 + 2];
          var indexStart = subMeshesData[i * 5 + 3];
          var indexCount = subMeshesData[i * 5 + 4];
          SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);
        }
      }
    } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {
      mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);
      mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);
      if (parsedGeometry.tangents) {
        mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);
      }
      if (parsedGeometry.uvs) {
        mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);
      }
      if (parsedGeometry.uvs2) {
        mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);
      }
      if (parsedGeometry.uvs3) {
        mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);
      }
      if (parsedGeometry.uvs4) {
        mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);
      }
      if (parsedGeometry.uvs5) {
        mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);
      }
      if (parsedGeometry.uvs6) {
        mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);
      }
      if (parsedGeometry.colors) {
        mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);
      }
      if (parsedGeometry.matricesIndices) {
        if (!parsedGeometry.matricesIndices._isExpanded) {
          var floatIndices = [];
          for (var i = 0; i < parsedGeometry.matricesIndices.length; i++) {
            var matricesIndex = parsedGeometry.matricesIndices[i];
            floatIndices.push(matricesIndex & 255);
            floatIndices.push((matricesIndex & 65280) >> 8);
            floatIndices.push((matricesIndex & 16711680) >> 16);
            floatIndices.push(matricesIndex >> 24 & 255);
          }
          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);
        } else {
          delete parsedGeometry.matricesIndices._isExpanded;
          mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);
        }
      }
      if (parsedGeometry.matricesIndicesExtra) {
        if (!parsedGeometry.matricesIndicesExtra._isExpanded) {
          var floatIndices = [];
          for (var i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {
            var matricesIndex = parsedGeometry.matricesIndicesExtra[i];
            floatIndices.push(matricesIndex & 255);
            floatIndices.push((matricesIndex & 65280) >> 8);
            floatIndices.push((matricesIndex & 16711680) >> 16);
            floatIndices.push(matricesIndex >> 24 & 255);
          }
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);
        } else {
          delete parsedGeometry.matricesIndices._isExpanded;
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);
        }
      }
      if (parsedGeometry.matricesWeights) {
        Geometry2._CleanMatricesWeights(parsedGeometry, mesh);
        mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);
      }
      if (parsedGeometry.matricesWeightsExtra) {
        mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);
      }
      mesh.setIndices(parsedGeometry.indices, null);
    }
    if (parsedGeometry.subMeshes) {
      mesh.subMeshes = [];
      for (var subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {
        var parsedSubMesh = parsedGeometry.subMeshes[subIndex];
        SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);
      }
    }
    if (mesh._shouldGenerateFlatShading) {
      mesh.convertToFlatShadedMesh();
      mesh._shouldGenerateFlatShading = false;
    }
    mesh.computeWorldMatrix(true);
    scene.onMeshImportedObservable.notifyObservers(mesh);
  };
  Geometry2._CleanMatricesWeights = function(parsedGeometry, mesh) {
    var epsilon = 1e-3;
    if (!SceneLoaderFlags.CleanBoneMatrixWeights) {
      return;
    }
    var noInfluenceBoneIndex = 0;
    if (parsedGeometry.skeletonId > -1) {
      var skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);
      if (!skeleton) {
        return;
      }
      noInfluenceBoneIndex = skeleton.bones.length;
    } else {
      return;
    }
    var matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
    var matricesWeights = parsedGeometry.matricesWeights;
    var matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;
    var influencers = parsedGeometry.numBoneInfluencer;
    var size = matricesWeights.length;
    for (var i = 0; i < size; i += 4) {
      var weight = 0;
      var firstZeroWeight = -1;
      for (var j = 0; j < 4; j++) {
        var w = matricesWeights[i + j];
        weight += w;
        if (w < epsilon && firstZeroWeight < 0) {
          firstZeroWeight = j;
        }
      }
      if (matricesWeightsExtra) {
        for (var j = 0; j < 4; j++) {
          var w = matricesWeightsExtra[i + j];
          weight += w;
          if (w < epsilon && firstZeroWeight < 0) {
            firstZeroWeight = j + 4;
          }
        }
      }
      if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {
        firstZeroWeight = influencers - 1;
      }
      if (weight > epsilon) {
        var mweight = 1 / weight;
        for (var j = 0; j < 4; j++) {
          matricesWeights[i + j] *= mweight;
        }
        if (matricesWeightsExtra) {
          for (var j = 0; j < 4; j++) {
            matricesWeightsExtra[i + j] *= mweight;
          }
        }
      } else {
        if (firstZeroWeight >= 4) {
          matricesWeightsExtra[i + firstZeroWeight - 4] = 1 - weight;
          matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;
        } else {
          matricesWeights[i + firstZeroWeight] = 1 - weight;
          matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;
        }
      }
    }
    mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);
    if (parsedGeometry.matricesWeightsExtra) {
      mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);
    }
  };
  Geometry2.Parse = function(parsedVertexData, scene, rootUrl) {
    var geometry = new Geometry2(parsedVertexData.id, scene, void 0, parsedVertexData.updatable);
    geometry._loadedUniqueId = parsedVertexData.uniqueId;
    if (Tags) {
      Tags.AddTagsTo(geometry, parsedVertexData.tags);
    }
    if (parsedVertexData.delayLoadingFile) {
      geometry.delayLoadState = 4;
      geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;
      geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));
      geometry._delayInfo = [];
      if (parsedVertexData.hasUVs) {
        geometry._delayInfo.push(VertexBuffer.UVKind);
      }
      if (parsedVertexData.hasUVs2) {
        geometry._delayInfo.push(VertexBuffer.UV2Kind);
      }
      if (parsedVertexData.hasUVs3) {
        geometry._delayInfo.push(VertexBuffer.UV3Kind);
      }
      if (parsedVertexData.hasUVs4) {
        geometry._delayInfo.push(VertexBuffer.UV4Kind);
      }
      if (parsedVertexData.hasUVs5) {
        geometry._delayInfo.push(VertexBuffer.UV5Kind);
      }
      if (parsedVertexData.hasUVs6) {
        geometry._delayInfo.push(VertexBuffer.UV6Kind);
      }
      if (parsedVertexData.hasColors) {
        geometry._delayInfo.push(VertexBuffer.ColorKind);
      }
      if (parsedVertexData.hasMatricesIndices) {
        geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);
      }
      if (parsedVertexData.hasMatricesWeights) {
        geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);
      }
      geometry._delayLoadingFunction = VertexData.ImportVertexData;
    } else {
      VertexData.ImportVertexData(parsedVertexData, geometry);
    }
    scene.pushGeometry(geometry, true);
    return geometry;
  };
  return Geometry2;
}();
var PerformanceMonitor = function() {
  function PerformanceMonitor2(frameSampleSize) {
    if (frameSampleSize === void 0) {
      frameSampleSize = 30;
    }
    this._enabled = true;
    this._rollingFrameTime = new RollingAverage(frameSampleSize);
  }
  PerformanceMonitor2.prototype.sampleFrame = function(timeMs) {
    if (timeMs === void 0) {
      timeMs = PrecisionDate.Now;
    }
    if (!this._enabled) {
      return;
    }
    if (this._lastFrameTimeMs != null) {
      var dt = timeMs - this._lastFrameTimeMs;
      this._rollingFrameTime.add(dt);
    }
    this._lastFrameTimeMs = timeMs;
  };
  Object.defineProperty(PerformanceMonitor2.prototype, "averageFrameTime", {
    get: function() {
      return this._rollingFrameTime.average;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "averageFrameTimeVariance", {
    get: function() {
      return this._rollingFrameTime.variance;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "instantaneousFrameTime", {
    get: function() {
      return this._rollingFrameTime.history(0);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "averageFPS", {
    get: function() {
      return 1e3 / this._rollingFrameTime.average;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "instantaneousFPS", {
    get: function() {
      var history = this._rollingFrameTime.history(0);
      if (history === 0) {
        return 0;
      }
      return 1e3 / history;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerformanceMonitor2.prototype, "isSaturated", {
    get: function() {
      return this._rollingFrameTime.isSaturated();
    },
    enumerable: false,
    configurable: true
  });
  PerformanceMonitor2.prototype.enable = function() {
    this._enabled = true;
  };
  PerformanceMonitor2.prototype.disable = function() {
    this._enabled = false;
    this._lastFrameTimeMs = null;
  };
  Object.defineProperty(PerformanceMonitor2.prototype, "isEnabled", {
    get: function() {
      return this._enabled;
    },
    enumerable: false,
    configurable: true
  });
  PerformanceMonitor2.prototype.reset = function() {
    this._lastFrameTimeMs = null;
    this._rollingFrameTime.reset();
  };
  return PerformanceMonitor2;
}();
var RollingAverage = function() {
  function RollingAverage2(length) {
    this._samples = new Array(length);
    this.reset();
  }
  RollingAverage2.prototype.add = function(v) {
    var delta;
    if (this.isSaturated()) {
      var bottomValue = this._samples[this._pos];
      delta = bottomValue - this.average;
      this.average -= delta / (this._sampleCount - 1);
      this._m2 -= delta * (bottomValue - this.average);
    } else {
      this._sampleCount++;
    }
    delta = v - this.average;
    this.average += delta / this._sampleCount;
    this._m2 += delta * (v - this.average);
    this.variance = this._m2 / (this._sampleCount - 1);
    this._samples[this._pos] = v;
    this._pos++;
    this._pos %= this._samples.length;
  };
  RollingAverage2.prototype.history = function(i) {
    if (i >= this._sampleCount || i >= this._samples.length) {
      return 0;
    }
    var i0 = this._wrapPosition(this._pos - 1);
    return this._samples[this._wrapPosition(i0 - i)];
  };
  RollingAverage2.prototype.isSaturated = function() {
    return this._sampleCount >= this._samples.length;
  };
  RollingAverage2.prototype.reset = function() {
    this.average = 0;
    this.variance = 0;
    this._sampleCount = 0;
    this._pos = 0;
    this._m2 = 0;
  };
  RollingAverage2.prototype._wrapPosition = function(i) {
    var max = this._samples.length;
    return (i % max + max) % max;
  };
  return RollingAverage2;
}();
var PerfCounter = function() {
  function PerfCounter2() {
    this._startMonitoringTime = 0;
    this._min = 0;
    this._max = 0;
    this._average = 0;
    this._lastSecAverage = 0;
    this._current = 0;
    this._totalValueCount = 0;
    this._totalAccumulated = 0;
    this._lastSecAccumulated = 0;
    this._lastSecTime = 0;
    this._lastSecValueCount = 0;
  }
  Object.defineProperty(PerfCounter2.prototype, "min", {
    get: function() {
      return this._min;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "max", {
    get: function() {
      return this._max;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "average", {
    get: function() {
      return this._average;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "lastSecAverage", {
    get: function() {
      return this._lastSecAverage;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "current", {
    get: function() {
      return this._current;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "total", {
    get: function() {
      return this._totalAccumulated;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(PerfCounter2.prototype, "count", {
    get: function() {
      return this._totalValueCount;
    },
    enumerable: false,
    configurable: true
  });
  PerfCounter2.prototype.fetchNewFrame = function() {
    this._totalValueCount++;
    this._current = 0;
    this._lastSecValueCount++;
  };
  PerfCounter2.prototype.addCount = function(newCount, fetchResult) {
    if (!PerfCounter2.Enabled) {
      return;
    }
    this._current += newCount;
    if (fetchResult) {
      this._fetchResult();
    }
  };
  PerfCounter2.prototype.beginMonitoring = function() {
    if (!PerfCounter2.Enabled) {
      return;
    }
    this._startMonitoringTime = PrecisionDate.Now;
  };
  PerfCounter2.prototype.endMonitoring = function(newFrame) {
    if (newFrame === void 0) {
      newFrame = true;
    }
    if (!PerfCounter2.Enabled) {
      return;
    }
    if (newFrame) {
      this.fetchNewFrame();
    }
    var currentTime = PrecisionDate.Now;
    this._current = currentTime - this._startMonitoringTime;
    if (newFrame) {
      this._fetchResult();
    }
  };
  PerfCounter2.prototype._fetchResult = function() {
    this._totalAccumulated += this._current;
    this._lastSecAccumulated += this._current;
    this._min = Math.min(this._min, this._current);
    this._max = Math.max(this._max, this._current);
    this._average = this._totalAccumulated / this._totalValueCount;
    var now2 = PrecisionDate.Now;
    if (now2 - this._lastSecTime > 1e3) {
      this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;
      this._lastSecTime = now2;
      this._lastSecAccumulated = 0;
      this._lastSecValueCount = 0;
    }
  };
  PerfCounter2.Enabled = true;
  return PerfCounter2;
}();
ThinEngine.prototype.setAlphaConstants = function(r, g, b, a) {
  this._alphaState.setAlphaBlendConstants(r, g, b, a);
};
ThinEngine.prototype.setAlphaMode = function(mode, noDepthWriteChange) {
  if (noDepthWriteChange === void 0) {
    noDepthWriteChange = false;
  }
  if (this._alphaMode === mode) {
    return;
  }
  switch (mode) {
    case 0:
      this._alphaState.alphaBlend = false;
      break;
    case 7:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 8:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 2:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 6:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 1:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 3:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 4:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 5:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 9:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 10:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 11:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 12:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO);
      this._alphaState.alphaBlend = true;
      break;
    case 13:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 14:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
    case 15:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO);
      this._alphaState.alphaBlend = true;
      break;
    case 16:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE);
      this._alphaState.alphaBlend = true;
      break;
    case 17:
      this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
      this._alphaState.alphaBlend = true;
      break;
  }
  if (!noDepthWriteChange) {
    this.depthCullingState.depthMask = mode === 0;
  }
  this._alphaMode = mode;
};
ThinEngine.prototype.getAlphaMode = function() {
  return this._alphaMode;
};
ThinEngine.prototype.setAlphaEquation = function(equation) {
  if (this._alphaEquation === equation) {
    return;
  }
  switch (equation) {
    case 0:
      this._alphaState.setAlphaEquationParameters(32774, 32774);
      break;
    case 1:
      this._alphaState.setAlphaEquationParameters(32778, 32778);
      break;
    case 2:
      this._alphaState.setAlphaEquationParameters(32779, 32779);
      break;
    case 3:
      this._alphaState.setAlphaEquationParameters(32776, 32776);
      break;
    case 4:
      this._alphaState.setAlphaEquationParameters(32775, 32775);
      break;
    case 5:
      this._alphaState.setAlphaEquationParameters(32775, 32774);
      break;
  }
  this._alphaEquation = equation;
};
ThinEngine.prototype.getAlphaEquation = function() {
  return this._alphaEquation;
};
function allocateAndCopyTypedBuffer(type, sizeOrDstBuffer, sizeInBytes, copyBuffer) {
  if (sizeInBytes === void 0) {
    sizeInBytes = false;
  }
  switch (type) {
    case 3: {
      var buffer_1 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_1.set(new Int8Array(copyBuffer));
      }
      return buffer_1;
    }
    case 0: {
      var buffer_2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_2.set(new Uint8Array(copyBuffer));
      }
      return buffer_2;
    }
    case 4: {
      var buffer_3 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_3.set(new Int16Array(copyBuffer));
      }
      return buffer_3;
    }
    case 5:
    case 8:
    case 9:
    case 10:
    case 2: {
      var buffer_4 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_4.set(new Uint16Array(copyBuffer));
      }
      return buffer_4;
    }
    case 6: {
      var buffer_5 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_5.set(new Int32Array(copyBuffer));
      }
      return buffer_5;
    }
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15: {
      var buffer_6 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_6.set(new Uint32Array(copyBuffer));
      }
      return buffer_6;
    }
    case 1: {
      var buffer_7 = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer_7.set(new Float32Array(copyBuffer));
      }
      return buffer_7;
    }
  }
  var buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
  if (copyBuffer) {
    buffer.set(new Uint8Array(copyBuffer));
  }
  return buffer;
}
ThinEngine.prototype._readTexturePixelsSync = function(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y) {
  var _a2, _b2;
  if (faceIndex === void 0) {
    faceIndex = -1;
  }
  if (level === void 0) {
    level = 0;
  }
  if (buffer === void 0) {
    buffer = null;
  }
  if (flushRenderer === void 0) {
    flushRenderer = true;
  }
  if (noDataConversion === void 0) {
    noDataConversion = false;
  }
  if (x === void 0) {
    x = 0;
  }
  if (y === void 0) {
    y = 0;
  }
  var gl = this._gl;
  if (!gl) {
    throw new Error("Engine does not have gl rendering context.");
  }
  if (!this._dummyFramebuffer) {
    var dummy = gl.createFramebuffer();
    if (!dummy) {
      throw new Error("Unable to create dummy framebuffer");
    }
    this._dummyFramebuffer = dummy;
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);
  if (faceIndex > -1) {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_a2 = texture._hardwareTexture) === null || _a2 === void 0 ? void 0 : _a2.underlyingResource, level);
  } else {
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, (_b2 = texture._hardwareTexture) === null || _b2 === void 0 ? void 0 : _b2.underlyingResource, level);
  }
  var readType = texture.type !== void 0 ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;
  if (!noDataConversion) {
    switch (readType) {
      case gl.UNSIGNED_BYTE:
        if (!buffer) {
          buffer = new Uint8Array(4 * width * height);
        }
        readType = gl.UNSIGNED_BYTE;
        break;
      default:
        if (!buffer) {
          buffer = new Float32Array(4 * width * height);
        }
        readType = gl.FLOAT;
        break;
    }
  } else if (!buffer) {
    buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);
  }
  if (flushRenderer) {
    this.flushFramebuffer();
  }
  gl.readPixels(x, y, width, height, gl.RGBA, readType, buffer);
  gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);
  return buffer;
};
ThinEngine.prototype._readTexturePixels = function(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y) {
  if (faceIndex === void 0) {
    faceIndex = -1;
  }
  if (level === void 0) {
    level = 0;
  }
  if (buffer === void 0) {
    buffer = null;
  }
  if (flushRenderer === void 0) {
    flushRenderer = true;
  }
  if (noDataConversion === void 0) {
    noDataConversion = false;
  }
  if (x === void 0) {
    x = 0;
  }
  if (y === void 0) {
    y = 0;
  }
  return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));
};
ThinEngine.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset) {
  this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;
  this.bindIndexBuffer(indexBuffer);
  var view;
  if (indexBuffer.is32Bits) {
    view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);
  } else {
    view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);
  }
  this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, view, this._gl.DYNAMIC_DRAW);
  this._resetIndexBufferBinding();
};
ThinEngine.prototype.updateDynamicVertexBuffer = function(vertexBuffer, data, byteOffset, byteLength) {
  this.bindArrayBuffer(vertexBuffer);
  if (byteOffset === void 0) {
    byteOffset = 0;
  }
  var dataLength = data.byteLength || data.length;
  if (byteLength === void 0 || byteLength >= dataLength && byteOffset === 0) {
    if (data instanceof Array) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));
    } else {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
    }
  } else {
    if (data instanceof Array) {
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(data).subarray(byteOffset, byteOffset + byteLength));
    } else {
      if (data instanceof ArrayBuffer) {
        data = new Uint8Array(data, byteOffset, byteLength);
      } else {
        data = new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
      }
      this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
    }
  }
  this._resetVertexBufferBinding();
};
var Engine = function(_super) {
  __extends(Engine2, _super);
  function Engine2(canvasOrContext, antialias, options, adaptToDeviceRatio) {
    if (adaptToDeviceRatio === void 0) {
      adaptToDeviceRatio = false;
    }
    var _this = _super.call(this, canvasOrContext, antialias, options, adaptToDeviceRatio) || this;
    _this.enableOfflineSupport = false;
    _this.disableManifestCheck = false;
    _this.scenes = new Array();
    _this._virtualScenes = new Array();
    _this.onNewSceneAddedObservable = new Observable();
    _this.postProcesses = new Array();
    _this.isPointerLock = false;
    _this.onResizeObservable = new Observable();
    _this.onCanvasBlurObservable = new Observable();
    _this.onCanvasFocusObservable = new Observable();
    _this.onCanvasPointerOutObservable = new Observable();
    _this.onBeginFrameObservable = new Observable();
    _this.customAnimationFrameRequester = null;
    _this.onEndFrameObservable = new Observable();
    _this.onBeforeShaderCompilationObservable = new Observable();
    _this.onAfterShaderCompilationObservable = new Observable();
    _this._deterministicLockstep = false;
    _this._lockstepMaxSteps = 4;
    _this._timeStep = 1 / 60;
    _this._fps = 60;
    _this._deltaTime = 0;
    _this._drawCalls = new PerfCounter();
    _this.canvasTabIndex = 1;
    _this.disablePerformanceMonitorInBackground = false;
    _this._performanceMonitor = new PerformanceMonitor();
    _this._compatibilityMode = true;
    _this.currentRenderPassId = 0;
    _this._renderPassNames = ["main"];
    Engine2.Instances.push(_this);
    if (!canvasOrContext) {
      return _this;
    }
    _this._features.supportRenderPasses = true;
    options = _this._creationOptions;
    if (canvasOrContext.getContext) {
      var canvas_1 = canvasOrContext;
      _this._sharedInit(canvas_1, !!options.doNotHandleTouchAction, options.audioEngine);
      if (IsWindowObjectExist()) {
        var anyDoc_1 = document;
        _this._onFullscreenChange = function() {
          if (anyDoc_1.fullscreen !== void 0) {
            _this.isFullscreen = anyDoc_1.fullscreen;
          } else if (anyDoc_1.mozFullScreen !== void 0) {
            _this.isFullscreen = anyDoc_1.mozFullScreen;
          } else if (anyDoc_1.webkitIsFullScreen !== void 0) {
            _this.isFullscreen = anyDoc_1.webkitIsFullScreen;
          } else if (anyDoc_1.msIsFullScreen !== void 0) {
            _this.isFullscreen = anyDoc_1.msIsFullScreen;
          }
          if (_this.isFullscreen && _this._pointerLockRequested && canvas_1) {
            Engine2._RequestPointerlock(canvas_1);
          }
        };
        document.addEventListener("fullscreenchange", _this._onFullscreenChange, false);
        document.addEventListener("mozfullscreenchange", _this._onFullscreenChange, false);
        document.addEventListener("webkitfullscreenchange", _this._onFullscreenChange, false);
        document.addEventListener("msfullscreenchange", _this._onFullscreenChange, false);
        _this._onPointerLockChange = function() {
          _this.isPointerLock = anyDoc_1.mozPointerLockElement === canvas_1 || anyDoc_1.webkitPointerLockElement === canvas_1 || anyDoc_1.msPointerLockElement === canvas_1 || anyDoc_1.pointerLockElement === canvas_1;
        };
        document.addEventListener("pointerlockchange", _this._onPointerLockChange, false);
        document.addEventListener("mspointerlockchange", _this._onPointerLockChange, false);
        document.addEventListener("mozpointerlockchange", _this._onPointerLockChange, false);
        document.addEventListener("webkitpointerlockchange", _this._onPointerLockChange, false);
        if (!Engine2.audioEngine && options.audioEngine && Engine2.AudioEngineFactory) {
          Engine2.audioEngine = Engine2.AudioEngineFactory(_this.getRenderingCanvas(), _this.getAudioContext(), _this.getAudioDestination());
        }
      }
      _this._connectVREvents();
      _this.enableOfflineSupport = Engine2.OfflineProviderFactory !== void 0;
      _this._deterministicLockstep = !!options.deterministicLockstep;
      _this._lockstepMaxSteps = options.lockstepMaxSteps || 0;
      _this._timeStep = options.timeStep || 1 / 60;
    }
    _this._prepareVRComponent();
    if (options.autoEnableWebVR) {
      _this.initWebVR();
    }
    return _this;
  }
  Object.defineProperty(Engine2, "NpmPackage", {
    get: function() {
      return ThinEngine.NpmPackage;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "Version", {
    get: function() {
      return ThinEngine.Version;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "Instances", {
    get: function() {
      return EngineStore.Instances;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "LastCreatedEngine", {
    get: function() {
      return EngineStore.LastCreatedEngine;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2, "LastCreatedScene", {
    get: function() {
      return EngineStore.LastCreatedScene;
    },
    enumerable: false,
    configurable: true
  });
  Engine2.prototype._createImageBitmapFromSource = function(imageSource, options) {
    var _this = this;
    var promise = new Promise(function(resolve, reject) {
      var image = new Image();
      image.onload = function() {
        image.decode().then(function() {
          _this.createImageBitmap(image, options).then(function(imageBitmap) {
            resolve(imageBitmap);
          });
        });
      };
      image.onerror = function() {
        reject("Error loading image ".concat(image.src));
      };
      image.src = imageSource;
    });
    return promise;
  };
  Engine2.prototype.createImageBitmap = function(image, options) {
    return createImageBitmap(image, options);
  };
  Engine2.prototype.resizeImageBitmap = function(image, bufferWidth, bufferHeight) {
    var canvas = this.createCanvas(bufferWidth, bufferHeight);
    var context = canvas.getContext("2d");
    if (!context) {
      throw new Error("Unable to get 2d context for resizeImageBitmap");
    }
    context.drawImage(image, 0, 0);
    var buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;
    return buffer;
  };
  Engine2.MarkAllMaterialsAsDirty = function(flag, predicate) {
    for (var engineIndex = 0; engineIndex < Engine2.Instances.length; engineIndex++) {
      var engine = Engine2.Instances[engineIndex];
      for (var sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {
        engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);
      }
    }
  };
  Engine2.DefaultLoadingScreenFactory = function(canvas) {
    throw _WarnImport("LoadingScreen");
  };
  Object.defineProperty(Engine2.prototype, "_supportsHardwareTextureRescaling", {
    get: function() {
      return !!Engine2._RescalePostProcessFactory;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "performanceMonitor", {
    get: function() {
      return this._performanceMonitor;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "compatibilityMode", {
    get: function() {
      return this._compatibilityMode;
    },
    set: function(mode) {
      this._compatibilityMode = true;
    },
    enumerable: false,
    configurable: true
  });
  Engine2.prototype.getInputElement = function() {
    return this._renderingCanvas;
  };
  Engine2.prototype._sharedInit = function(canvas, doNotHandleTouchAction, audioEngine) {
    var _this = this;
    _super.prototype._sharedInit.call(this, canvas, doNotHandleTouchAction, audioEngine);
    this._onCanvasFocus = function() {
      _this.onCanvasFocusObservable.notifyObservers(_this);
    };
    this._onCanvasBlur = function() {
      _this.onCanvasBlurObservable.notifyObservers(_this);
    };
    canvas.addEventListener("focus", this._onCanvasFocus);
    canvas.addEventListener("blur", this._onCanvasBlur);
    this._onBlur = function() {
      if (_this.disablePerformanceMonitorInBackground) {
        _this._performanceMonitor.disable();
      }
      _this._windowIsBackground = true;
    };
    this._onFocus = function() {
      if (_this.disablePerformanceMonitorInBackground) {
        _this._performanceMonitor.enable();
      }
      _this._windowIsBackground = false;
    };
    this._onCanvasPointerOut = function(ev) {
      if (document.elementFromPoint(ev.clientX, ev.clientY) !== canvas) {
        _this.onCanvasPointerOutObservable.notifyObservers(ev);
      }
    };
    if (IsWindowObjectExist()) {
      var hostWindow = this.getHostWindow();
      if (hostWindow) {
        hostWindow.addEventListener("blur", this._onBlur);
        hostWindow.addEventListener("focus", this._onFocus);
      }
    }
    canvas.addEventListener("pointerout", this._onCanvasPointerOut);
    if (!doNotHandleTouchAction) {
      this._disableTouchAction();
    }
    if (!Engine2.audioEngine && audioEngine && Engine2.AudioEngineFactory) {
      Engine2.audioEngine = Engine2.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination());
    }
  };
  Engine2.prototype.getAspectRatio = function(viewportOwner, useScreen) {
    if (useScreen === void 0) {
      useScreen = false;
    }
    var viewport = viewportOwner.viewport;
    return this.getRenderWidth(useScreen) * viewport.width / (this.getRenderHeight(useScreen) * viewport.height);
  };
  Engine2.prototype.getScreenAspectRatio = function() {
    return this.getRenderWidth(true) / this.getRenderHeight(true);
  };
  Engine2.prototype.getRenderingCanvasClientRect = function() {
    if (!this._renderingCanvas) {
      return null;
    }
    return this._renderingCanvas.getBoundingClientRect();
  };
  Engine2.prototype.getInputElementClientRect = function() {
    if (!this._renderingCanvas) {
      return null;
    }
    return this.getInputElement().getBoundingClientRect();
  };
  Engine2.prototype.isDeterministicLockStep = function() {
    return this._deterministicLockstep;
  };
  Engine2.prototype.getLockstepMaxSteps = function() {
    return this._lockstepMaxSteps;
  };
  Engine2.prototype.getTimeStep = function() {
    return this._timeStep * 1e3;
  };
  Engine2.prototype.generateMipMapsForCubemap = function(texture, unbind) {
    if (unbind === void 0) {
      unbind = true;
    }
    if (texture.generateMipMaps) {
      var gl = this._gl;
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      if (unbind) {
        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      }
    }
  };
  Engine2.prototype.getDepthBuffer = function() {
    return this._depthCullingState.depthTest;
  };
  Engine2.prototype.setDepthBuffer = function(enable) {
    this._depthCullingState.depthTest = enable;
  };
  Engine2.prototype.getDepthWrite = function() {
    return this._depthCullingState.depthMask;
  };
  Engine2.prototype.setDepthWrite = function(enable) {
    this._depthCullingState.depthMask = enable;
  };
  Engine2.prototype.getStencilBuffer = function() {
    return this._stencilState.stencilTest;
  };
  Engine2.prototype.setStencilBuffer = function(enable) {
    this._stencilState.stencilTest = enable;
  };
  Engine2.prototype.getStencilMask = function() {
    return this._stencilState.stencilMask;
  };
  Engine2.prototype.setStencilMask = function(mask) {
    this._stencilState.stencilMask = mask;
  };
  Engine2.prototype.getStencilFunction = function() {
    return this._stencilState.stencilFunc;
  };
  Engine2.prototype.getStencilFunctionReference = function() {
    return this._stencilState.stencilFuncRef;
  };
  Engine2.prototype.getStencilFunctionMask = function() {
    return this._stencilState.stencilFuncMask;
  };
  Engine2.prototype.setStencilFunction = function(stencilFunc) {
    this._stencilState.stencilFunc = stencilFunc;
  };
  Engine2.prototype.setStencilFunctionReference = function(reference) {
    this._stencilState.stencilFuncRef = reference;
  };
  Engine2.prototype.setStencilFunctionMask = function(mask) {
    this._stencilState.stencilFuncMask = mask;
  };
  Engine2.prototype.getStencilOperationFail = function() {
    return this._stencilState.stencilOpStencilFail;
  };
  Engine2.prototype.getStencilOperationDepthFail = function() {
    return this._stencilState.stencilOpDepthFail;
  };
  Engine2.prototype.getStencilOperationPass = function() {
    return this._stencilState.stencilOpStencilDepthPass;
  };
  Engine2.prototype.setStencilOperationFail = function(operation) {
    this._stencilState.stencilOpStencilFail = operation;
  };
  Engine2.prototype.setStencilOperationDepthFail = function(operation) {
    this._stencilState.stencilOpDepthFail = operation;
  };
  Engine2.prototype.setStencilOperationPass = function(operation) {
    this._stencilState.stencilOpStencilDepthPass = operation;
  };
  Engine2.prototype.setDitheringState = function(value) {
    if (value) {
      this._gl.enable(this._gl.DITHER);
    } else {
      this._gl.disable(this._gl.DITHER);
    }
  };
  Engine2.prototype.setRasterizerState = function(value) {
    if (value) {
      this._gl.disable(this._gl.RASTERIZER_DISCARD);
    } else {
      this._gl.enable(this._gl.RASTERIZER_DISCARD);
    }
  };
  Engine2.prototype.getDepthFunction = function() {
    return this._depthCullingState.depthFunc;
  };
  Engine2.prototype.setDepthFunction = function(depthFunc) {
    this._depthCullingState.depthFunc = depthFunc;
  };
  Engine2.prototype.setDepthFunctionToGreater = function() {
    this.setDepthFunction(516);
  };
  Engine2.prototype.setDepthFunctionToGreaterOrEqual = function() {
    this.setDepthFunction(518);
  };
  Engine2.prototype.setDepthFunctionToLess = function() {
    this.setDepthFunction(513);
  };
  Engine2.prototype.setDepthFunctionToLessOrEqual = function() {
    this.setDepthFunction(515);
  };
  Engine2.prototype.cacheStencilState = function() {
    this._cachedStencilBuffer = this.getStencilBuffer();
    this._cachedStencilFunction = this.getStencilFunction();
    this._cachedStencilMask = this.getStencilMask();
    this._cachedStencilOperationPass = this.getStencilOperationPass();
    this._cachedStencilOperationFail = this.getStencilOperationFail();
    this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();
    this._cachedStencilReference = this.getStencilFunctionReference();
  };
  Engine2.prototype.restoreStencilState = function() {
    this.setStencilFunction(this._cachedStencilFunction);
    this.setStencilMask(this._cachedStencilMask);
    this.setStencilBuffer(this._cachedStencilBuffer);
    this.setStencilOperationPass(this._cachedStencilOperationPass);
    this.setStencilOperationFail(this._cachedStencilOperationFail);
    this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);
    this.setStencilFunctionReference(this._cachedStencilReference);
  };
  Engine2.prototype.setDirectViewport = function(x, y, width, height) {
    var currentViewport = this._cachedViewport;
    this._cachedViewport = null;
    this._viewport(x, y, width, height);
    return currentViewport;
  };
  Engine2.prototype.scissorClear = function(x, y, width, height, clearColor) {
    this.enableScissor(x, y, width, height);
    this.clear(clearColor, true, true, true);
    this.disableScissor();
  };
  Engine2.prototype.enableScissor = function(x, y, width, height) {
    var gl = this._gl;
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(x, y, width, height);
  };
  Engine2.prototype.disableScissor = function() {
    var gl = this._gl;
    gl.disable(gl.SCISSOR_TEST);
  };
  Engine2.prototype._reportDrawCall = function(numDrawCalls) {
    if (numDrawCalls === void 0) {
      numDrawCalls = 1;
    }
    this._drawCalls.addCount(numDrawCalls, false);
  };
  Engine2.prototype.initWebVR = function() {
    throw _WarnImport("WebVRCamera");
  };
  Engine2.prototype._prepareVRComponent = function() {
  };
  Engine2.prototype._connectVREvents = function(canvas, document2) {
  };
  Engine2.prototype._submitVRFrame = function() {
  };
  Engine2.prototype.disableVR = function() {
  };
  Engine2.prototype.isVRPresenting = function() {
    return false;
  };
  Engine2.prototype._requestVRFrame = function() {
  };
  Engine2.prototype._loadFileAsync = function(url, offlineProvider, useArrayBuffer) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._loadFile(url, function(data) {
        resolve(data);
      }, void 0, offlineProvider, useArrayBuffer, function(request, exception) {
        reject(exception);
      });
    });
  };
  Engine2.prototype.getVertexShaderSource = function(program) {
    var shaders = this._gl.getAttachedShaders(program);
    if (!shaders) {
      return null;
    }
    return this._gl.getShaderSource(shaders[0]);
  };
  Engine2.prototype.getFragmentShaderSource = function(program) {
    var shaders = this._gl.getAttachedShaders(program);
    if (!shaders) {
      return null;
    }
    return this._gl.getShaderSource(shaders[1]);
  };
  Engine2.prototype.setDepthStencilTexture = function(channel, uniform, texture, name2) {
    if (channel === void 0) {
      return;
    }
    if (uniform) {
      this._boundUniforms[channel] = uniform;
    }
    if (!texture || !texture.depthStencilTexture) {
      this._setTexture(channel, null, void 0, void 0, name2);
    } else {
      this._setTexture(channel, texture, false, true, name2);
    }
  };
  Engine2.prototype.setTextureFromPostProcess = function(channel, postProcess, name2) {
    var _a2;
    var postProcessInput = null;
    if (postProcess) {
      if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {
        postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];
      } else if (postProcess._forcedOutputTexture) {
        postProcessInput = postProcess._forcedOutputTexture;
      }
    }
    this._bindTexture(channel, (_a2 = postProcessInput === null || postProcessInput === void 0 ? void 0 : postProcessInput.texture) !== null && _a2 !== void 0 ? _a2 : null, name2);
  };
  Engine2.prototype.setTextureFromPostProcessOutput = function(channel, postProcess, name2) {
    var _a2, _b2;
    this._bindTexture(channel, (_b2 = (_a2 = postProcess === null || postProcess === void 0 ? void 0 : postProcess._outputTexture) === null || _a2 === void 0 ? void 0 : _a2.texture) !== null && _b2 !== void 0 ? _b2 : null, name2);
  };
  Engine2.prototype._rebuildBuffers = function() {
    for (var _i = 0, _a2 = this.scenes; _i < _a2.length; _i++) {
      var scene = _a2[_i];
      scene.resetCachedMaterial();
      scene._rebuildGeometries();
      scene._rebuildTextures();
    }
    for (var _b2 = 0, _c2 = this._virtualScenes; _b2 < _c2.length; _b2++) {
      var scene = _c2[_b2];
      scene.resetCachedMaterial();
      scene._rebuildGeometries();
      scene._rebuildTextures();
    }
    _super.prototype._rebuildBuffers.call(this);
  };
  Engine2.prototype._renderFrame = function() {
    for (var index = 0; index < this._activeRenderLoops.length; index++) {
      var renderFunction = this._activeRenderLoops[index];
      renderFunction();
    }
  };
  Engine2.prototype._renderLoop = function() {
    if (!this._contextWasLost) {
      var shouldRender = true;
      if (!this.renderEvenInBackground && this._windowIsBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        if (!this._renderViews()) {
          this._renderFrame();
        }
        this.endFrame();
      }
    }
    if (this._activeRenderLoops.length > 0) {
      if (this.customAnimationFrameRequester) {
        this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester);
        this._frameHandler = this.customAnimationFrameRequester.requestID;
      } else if (this.isVRPresenting()) {
        this._requestVRFrame();
      } else {
        this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
      }
    } else {
      this._renderingQueueLaunched = false;
    }
  };
  Engine2.prototype._renderViews = function() {
    return false;
  };
  Engine2.prototype.switchFullscreen = function(requestPointerLock) {
    if (this.isFullscreen) {
      this.exitFullscreen();
    } else {
      this.enterFullscreen(requestPointerLock);
    }
  };
  Engine2.prototype.enterFullscreen = function(requestPointerLock) {
    if (!this.isFullscreen) {
      this._pointerLockRequested = requestPointerLock;
      if (this._renderingCanvas) {
        Engine2._RequestFullscreen(this._renderingCanvas);
      }
    }
  };
  Engine2.prototype.exitFullscreen = function() {
    if (this.isFullscreen) {
      Engine2._ExitFullscreen();
    }
  };
  Engine2.prototype.enterPointerlock = function() {
    if (this._renderingCanvas) {
      Engine2._RequestPointerlock(this._renderingCanvas);
    }
  };
  Engine2.prototype.exitPointerlock = function() {
    Engine2._ExitPointerlock();
  };
  Engine2.prototype.beginFrame = function() {
    this._measureFps();
    this.onBeginFrameObservable.notifyObservers(this);
    _super.prototype.beginFrame.call(this);
  };
  Engine2.prototype.endFrame = function() {
    _super.prototype.endFrame.call(this);
    this._submitVRFrame();
    this.onEndFrameObservable.notifyObservers(this);
  };
  Engine2.prototype.resize = function(forceSetSize) {
    if (forceSetSize === void 0) {
      forceSetSize = false;
    }
    if (this.isVRPresenting()) {
      return;
    }
    _super.prototype.resize.call(this, forceSetSize);
  };
  Engine2.prototype.setSize = function(width, height, forceSetSize) {
    if (forceSetSize === void 0) {
      forceSetSize = false;
    }
    if (!this._renderingCanvas) {
      return false;
    }
    if (!_super.prototype.setSize.call(this, width, height, forceSetSize)) {
      return false;
    }
    if (this.scenes) {
      for (var index = 0; index < this.scenes.length; index++) {
        var scene = this.scenes[index];
        for (var camIndex = 0; camIndex < scene.cameras.length; camIndex++) {
          var cam = scene.cameras[camIndex];
          cam._currentRenderId = 0;
        }
      }
      if (this.onResizeObservable.hasObservers()) {
        this.onResizeObservable.notifyObservers(this);
      }
    }
    return true;
  };
  Engine2.prototype._deletePipelineContext = function(pipelineContext) {
    var webGLPipelineContext = pipelineContext;
    if (webGLPipelineContext && webGLPipelineContext.program) {
      if (webGLPipelineContext.transformFeedback) {
        this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);
        webGLPipelineContext.transformFeedback = null;
      }
    }
    _super.prototype._deletePipelineContext.call(this, pipelineContext);
  };
  Engine2.prototype.createShaderProgram = function(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    context = context || this._gl;
    this.onBeforeShaderCompilationObservable.notifyObservers(this);
    var program = _super.prototype.createShaderProgram.call(this, pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);
    this.onAfterShaderCompilationObservable.notifyObservers(this);
    return program;
  };
  Engine2.prototype._createShaderProgram = function(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings) {
    if (transformFeedbackVaryings === void 0) {
      transformFeedbackVaryings = null;
    }
    var shaderProgram = context.createProgram();
    pipelineContext.program = shaderProgram;
    if (!shaderProgram) {
      throw new Error("Unable to create program");
    }
    context.attachShader(shaderProgram, vertexShader);
    context.attachShader(shaderProgram, fragmentShader);
    if (this.webGLVersion > 1 && transformFeedbackVaryings) {
      var transformFeedback = this.createTransformFeedback();
      this.bindTransformFeedback(transformFeedback);
      this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);
      pipelineContext.transformFeedback = transformFeedback;
    }
    context.linkProgram(shaderProgram);
    if (this.webGLVersion > 1 && transformFeedbackVaryings) {
      this.bindTransformFeedback(null);
    }
    pipelineContext.context = context;
    pipelineContext.vertexShader = vertexShader;
    pipelineContext.fragmentShader = fragmentShader;
    if (!pipelineContext.isParallelCompiled) {
      this._finalizePipelineContext(pipelineContext);
    }
    return shaderProgram;
  };
  Engine2.prototype._releaseTexture = function(texture) {
    _super.prototype._releaseTexture.call(this, texture);
  };
  Engine2.prototype._releaseRenderTargetWrapper = function(rtWrapper) {
    _super.prototype._releaseRenderTargetWrapper.call(this, rtWrapper);
    this.scenes.forEach(function(scene) {
      scene.postProcesses.forEach(function(postProcess) {
        if (postProcess._outputTexture === rtWrapper) {
          postProcess._outputTexture = null;
        }
      });
      scene.cameras.forEach(function(camera) {
        camera._postProcesses.forEach(function(postProcess) {
          if (postProcess) {
            if (postProcess._outputTexture === rtWrapper) {
              postProcess._outputTexture = null;
            }
          }
        });
      });
    });
  };
  Engine2.prototype.getRenderPassNames = function() {
    return this._renderPassNames;
  };
  Engine2.prototype.getCurrentRenderPassName = function() {
    return this._renderPassNames[this.currentRenderPassId];
  };
  Engine2.prototype.createRenderPassId = function(name2) {
    var id = ++Engine2._RenderPassIdCounter;
    this._renderPassNames[id] = name2 !== null && name2 !== void 0 ? name2 : "NONAME";
    return id;
  };
  Engine2.prototype.releaseRenderPassId = function(id) {
    this._renderPassNames[id] = void 0;
    for (var s = 0; s < this.scenes.length; ++s) {
      var scene = this.scenes[s];
      for (var m = 0; m < scene.meshes.length; ++m) {
        var mesh = scene.meshes[m];
        if (mesh.subMeshes) {
          for (var b = 0; b < mesh.subMeshes.length; ++b) {
            var subMesh = mesh.subMeshes[b];
            subMesh._removeDrawWrapper(id);
          }
        }
      }
    }
  };
  Engine2.prototype._rescaleTexture = function(source, destination, scene, internalFormat, onComplete) {
    var _this = this;
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
    var rtt = this.createRenderTargetTexture({
      width: destination.width,
      height: destination.height
    }, {
      generateMipMaps: false,
      type: 0,
      samplingMode: 2,
      generateDepthBuffer: false,
      generateStencilBuffer: false
    });
    if (!this._rescalePostProcess && Engine2._RescalePostProcessFactory) {
      this._rescalePostProcess = Engine2._RescalePostProcessFactory(this);
    }
    this._rescalePostProcess.externalTextureSamplerBinding = true;
    this._rescalePostProcess.getEffect().executeWhenCompiled(function() {
      _this._rescalePostProcess.onApply = function(effect) {
        effect._bindTexture("textureSampler", source);
      };
      var hostingScene = scene;
      if (!hostingScene) {
        hostingScene = _this.scenes[_this.scenes.length - 1];
      }
      hostingScene.postProcessManager.directRender([_this._rescalePostProcess], rtt, true);
      _this._bindTextureDirectly(_this._gl.TEXTURE_2D, destination, true);
      _this._gl.copyTexImage2D(_this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);
      _this.unBindFramebuffer(rtt);
      rtt.dispose();
      if (onComplete) {
        onComplete();
      }
    });
  };
  Engine2.prototype.getFps = function() {
    return this._fps;
  };
  Engine2.prototype.getDeltaTime = function() {
    return this._deltaTime;
  };
  Engine2.prototype._measureFps = function() {
    this._performanceMonitor.sampleFrame();
    this._fps = this._performanceMonitor.averageFPS;
    this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
  };
  Engine2.prototype.wrapWebGLTexture = function(texture) {
    var hardwareTexture = new WebGLHardwareTexture(texture, this._gl);
    var internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);
    internalTexture._hardwareTexture = hardwareTexture;
    internalTexture.isReady = true;
    return internalTexture;
  };
  Engine2.prototype._uploadImageToTexture = function(texture, image, faceIndex, lod) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lod === void 0) {
      lod = 0;
    }
    var gl = this._gl;
    var textureType = this._getWebGLTextureType(texture.type);
    var format = this._getInternalFormat(texture.format);
    var internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);
    var bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
    this._bindTextureDirectly(bindTarget, texture, true);
    this._unpackFlipY(texture.invertY);
    var target2 = gl.TEXTURE_2D;
    if (texture.isCube) {
      target2 = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
    }
    gl.texImage2D(target2, lod, internalFormat, format, textureType, image);
    this._bindTextureDirectly(bindTarget, null, true);
  };
  Engine2.prototype.updateTextureComparisonFunction = function(texture, comparisonFunction) {
    if (this.webGLVersion === 1) {
      Logger.Error("WebGL 1 does not support texture comparison.");
      return;
    }
    var gl = this._gl;
    if (texture.isCube) {
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
      if (comparisonFunction === 0) {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
    } else {
      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
      if (comparisonFunction === 0) {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, 515);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);
      } else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
    }
    texture._comparisonFunction = comparisonFunction;
  };
  Engine2.prototype.createInstancesBuffer = function(capacity) {
    var buffer = this._gl.createBuffer();
    if (!buffer) {
      throw new Error("Unable to create instance buffer");
    }
    var result = new WebGLDataBuffer(buffer);
    result.capacity = capacity;
    this.bindArrayBuffer(result);
    this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);
    result.references = 1;
    return result;
  };
  Engine2.prototype.deleteInstancesBuffer = function(buffer) {
    this._gl.deleteBuffer(buffer);
  };
  Engine2.prototype._clientWaitAsync = function(sync, flags, intervalms) {
    if (flags === void 0) {
      flags = 0;
    }
    if (intervalms === void 0) {
      intervalms = 10;
    }
    var gl = this._gl;
    return new Promise(function(resolve, reject) {
      var check = function() {
        var res = gl.clientWaitSync(sync, flags, 0);
        if (res == gl.WAIT_FAILED) {
          reject();
          return;
        }
        if (res == gl.TIMEOUT_EXPIRED) {
          setTimeout(check, intervalms);
          return;
        }
        resolve();
      };
      check();
    });
  };
  Engine2.prototype._readPixelsAsync = function(x, y, w, h, format, type, outputBuffer) {
    if (this._webGLVersion < 2) {
      throw new Error("_readPixelsAsync only work on WebGL2+");
    }
    var gl = this._gl;
    var buf = gl.createBuffer();
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
    gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);
    gl.readPixels(x, y, w, h, format, type, 0);
    gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
    var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
    if (!sync) {
      return null;
    }
    gl.flush();
    return this._clientWaitAsync(sync, 0, 10).then(function() {
      gl.deleteSync(sync);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
      gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);
      gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
      gl.deleteBuffer(buf);
      return outputBuffer;
    });
  };
  Engine2.prototype.dispose = function() {
    this.hideLoadingUI();
    this.onNewSceneAddedObservable.clear();
    while (this.postProcesses.length) {
      this.postProcesses[0].dispose();
    }
    if (this._rescalePostProcess) {
      this._rescalePostProcess.dispose();
    }
    while (this.scenes.length) {
      this.scenes[0].dispose();
    }
    while (this._virtualScenes.length) {
      this._virtualScenes[0].dispose();
    }
    if (Engine2.Instances.length === 1 && Engine2.audioEngine) {
      Engine2.audioEngine.dispose();
      Engine2.audioEngine = null;
    }
    this.disableVR();
    if (IsWindowObjectExist()) {
      window.removeEventListener("blur", this._onBlur);
      window.removeEventListener("focus", this._onFocus);
      if (this._renderingCanvas) {
        this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus);
        this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur);
        this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut);
      }
      if (IsDocumentAvailable()) {
        document.removeEventListener("fullscreenchange", this._onFullscreenChange);
        document.removeEventListener("mozfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("msfullscreenchange", this._onFullscreenChange);
        document.removeEventListener("pointerlockchange", this._onPointerLockChange);
        document.removeEventListener("mspointerlockchange", this._onPointerLockChange);
        document.removeEventListener("mozpointerlockchange", this._onPointerLockChange);
        document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange);
      }
    }
    _super.prototype.dispose.call(this);
    var index = Engine2.Instances.indexOf(this);
    if (index >= 0) {
      Engine2.Instances.splice(index, 1);
    }
    this.onResizeObservable.clear();
    this.onCanvasBlurObservable.clear();
    this.onCanvasFocusObservable.clear();
    this.onCanvasPointerOutObservable.clear();
    this.onBeginFrameObservable.clear();
    this.onEndFrameObservable.clear();
  };
  Engine2.prototype._disableTouchAction = function() {
    if (!this._renderingCanvas || !this._renderingCanvas.setAttribute) {
      return;
    }
    this._renderingCanvas.setAttribute("touch-action", "none");
    this._renderingCanvas.style.touchAction = "none";
    this._renderingCanvas.style.msTouchAction = "none";
    this._renderingCanvas.style.webkitTapHighlightColor = "transparent";
  };
  Engine2.prototype.displayLoadingUI = function() {
    if (!IsWindowObjectExist()) {
      return;
    }
    var loadingScreen = this.loadingScreen;
    if (loadingScreen) {
      loadingScreen.displayLoadingUI();
    }
  };
  Engine2.prototype.hideLoadingUI = function() {
    if (!IsWindowObjectExist()) {
      return;
    }
    var loadingScreen = this._loadingScreen;
    if (loadingScreen) {
      loadingScreen.hideLoadingUI();
    }
  };
  Object.defineProperty(Engine2.prototype, "loadingScreen", {
    get: function() {
      if (!this._loadingScreen && this._renderingCanvas) {
        this._loadingScreen = Engine2.DefaultLoadingScreenFactory(this._renderingCanvas);
      }
      return this._loadingScreen;
    },
    set: function(loadingScreen) {
      this._loadingScreen = loadingScreen;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "loadingUIText", {
    set: function(text) {
      this.loadingScreen.loadingUIText = text;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Engine2.prototype, "loadingUIBackgroundColor", {
    set: function(color) {
      this.loadingScreen.loadingUIBackgroundColor = color;
    },
    enumerable: false,
    configurable: true
  });
  Engine2.prototype.createVideoElement = function(constraints) {
    return document.createElement("video");
  };
  Engine2._RequestPointerlock = function(element) {
    element.requestPointerLock = element.requestPointerLock || element.msRequestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
    if (element.requestPointerLock) {
      element.requestPointerLock();
      element.focus();
    }
  };
  Engine2._ExitPointerlock = function() {
    var anyDoc = document;
    document.exitPointerLock = document.exitPointerLock || anyDoc.msExitPointerLock || anyDoc.mozExitPointerLock || anyDoc.webkitExitPointerLock;
    if (document.exitPointerLock) {
      document.exitPointerLock();
    }
  };
  Engine2._RequestFullscreen = function(element) {
    var requestFunction = element.requestFullscreen || element.msRequestFullscreen || element.webkitRequestFullscreen || element.mozRequestFullScreen;
    if (!requestFunction) {
      return;
    }
    requestFunction.call(element);
  };
  Engine2._ExitFullscreen = function() {
    var anyDoc = document;
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (anyDoc.mozCancelFullScreen) {
      anyDoc.mozCancelFullScreen();
    } else if (anyDoc.webkitCancelFullScreen) {
      anyDoc.webkitCancelFullScreen();
    } else if (anyDoc.msCancelFullScreen) {
      anyDoc.msCancelFullScreen();
    }
  };
  Engine2.prototype.getFontOffset = function(font) {
    var text = document.createElement("span");
    text.innerHTML = "Hg";
    text.setAttribute("style", "font: ".concat(font, " !important"));
    var block = document.createElement("div");
    block.style.display = "inline-block";
    block.style.width = "1px";
    block.style.height = "0px";
    block.style.verticalAlign = "bottom";
    var div = document.createElement("div");
    div.style.whiteSpace = "nowrap";
    div.appendChild(text);
    div.appendChild(block);
    document.body.appendChild(div);
    var fontAscent = 0;
    var fontHeight = 0;
    try {
      fontHeight = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
      block.style.verticalAlign = "baseline";
      fontAscent = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
    } finally {
      document.body.removeChild(div);
    }
    return { ascent: fontAscent, height: fontHeight, descent: fontHeight - fontAscent };
  };
  Engine2.ALPHA_DISABLE = 0;
  Engine2.ALPHA_ADD = 1;
  Engine2.ALPHA_COMBINE = 2;
  Engine2.ALPHA_SUBTRACT = 3;
  Engine2.ALPHA_MULTIPLY = 4;
  Engine2.ALPHA_MAXIMIZED = 5;
  Engine2.ALPHA_ONEONE = 6;
  Engine2.ALPHA_PREMULTIPLIED = 7;
  Engine2.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
  Engine2.ALPHA_INTERPOLATE = 9;
  Engine2.ALPHA_SCREENMODE = 10;
  Engine2.DELAYLOADSTATE_NONE = 0;
  Engine2.DELAYLOADSTATE_LOADED = 1;
  Engine2.DELAYLOADSTATE_LOADING = 2;
  Engine2.DELAYLOADSTATE_NOTLOADED = 4;
  Engine2.NEVER = 512;
  Engine2.ALWAYS = 519;
  Engine2.LESS = 513;
  Engine2.EQUAL = 514;
  Engine2.LEQUAL = 515;
  Engine2.GREATER = 516;
  Engine2.GEQUAL = 518;
  Engine2.NOTEQUAL = 517;
  Engine2.KEEP = 7680;
  Engine2.REPLACE = 7681;
  Engine2.INCR = 7682;
  Engine2.DECR = 7683;
  Engine2.INVERT = 5386;
  Engine2.INCR_WRAP = 34055;
  Engine2.DECR_WRAP = 34056;
  Engine2.TEXTURE_CLAMP_ADDRESSMODE = 0;
  Engine2.TEXTURE_WRAP_ADDRESSMODE = 1;
  Engine2.TEXTURE_MIRROR_ADDRESSMODE = 2;
  Engine2.TEXTUREFORMAT_ALPHA = 0;
  Engine2.TEXTUREFORMAT_LUMINANCE = 1;
  Engine2.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
  Engine2.TEXTUREFORMAT_RGB = 4;
  Engine2.TEXTUREFORMAT_RGBA = 5;
  Engine2.TEXTUREFORMAT_RED = 6;
  Engine2.TEXTUREFORMAT_R = 6;
  Engine2.TEXTUREFORMAT_RG = 7;
  Engine2.TEXTUREFORMAT_RED_INTEGER = 8;
  Engine2.TEXTUREFORMAT_R_INTEGER = 8;
  Engine2.TEXTUREFORMAT_RG_INTEGER = 9;
  Engine2.TEXTUREFORMAT_RGB_INTEGER = 10;
  Engine2.TEXTUREFORMAT_RGBA_INTEGER = 11;
  Engine2.TEXTURETYPE_UNSIGNED_BYTE = 0;
  Engine2.TEXTURETYPE_UNSIGNED_INT = 0;
  Engine2.TEXTURETYPE_FLOAT = 1;
  Engine2.TEXTURETYPE_HALF_FLOAT = 2;
  Engine2.TEXTURETYPE_BYTE = 3;
  Engine2.TEXTURETYPE_SHORT = 4;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT = 5;
  Engine2.TEXTURETYPE_INT = 6;
  Engine2.TEXTURETYPE_UNSIGNED_INTEGER = 7;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
  Engine2.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
  Engine2.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
  Engine2.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
  Engine2.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
  Engine2.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
  Engine2.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
  Engine2.TEXTURE_NEAREST_SAMPLINGMODE = 1;
  Engine2.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
  Engine2.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
  Engine2.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
  Engine2.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
  Engine2.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
  Engine2.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
  Engine2.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
  Engine2.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
  Engine2.TEXTURE_NEAREST_LINEAR = 7;
  Engine2.TEXTURE_NEAREST_NEAREST = 1;
  Engine2.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
  Engine2.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
  Engine2.TEXTURE_LINEAR_LINEAR = 2;
  Engine2.TEXTURE_LINEAR_NEAREST = 12;
  Engine2.TEXTURE_EXPLICIT_MODE = 0;
  Engine2.TEXTURE_SPHERICAL_MODE = 1;
  Engine2.TEXTURE_PLANAR_MODE = 2;
  Engine2.TEXTURE_CUBIC_MODE = 3;
  Engine2.TEXTURE_PROJECTION_MODE = 4;
  Engine2.TEXTURE_SKYBOX_MODE = 5;
  Engine2.TEXTURE_INVCUBIC_MODE = 6;
  Engine2.TEXTURE_EQUIRECTANGULAR_MODE = 7;
  Engine2.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
  Engine2.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
  Engine2.SCALEMODE_FLOOR = 1;
  Engine2.SCALEMODE_NEAREST = 2;
  Engine2.SCALEMODE_CEILING = 3;
  Engine2._RescalePostProcessFactory = null;
  Engine2._RenderPassIdCounter = 0;
  return Engine2;
}(ThinEngine);
var Space;
(function(Space2) {
  Space2[Space2["LOCAL"] = 0] = "LOCAL";
  Space2[Space2["WORLD"] = 1] = "WORLD";
  Space2[Space2["BONE"] = 2] = "BONE";
})(Space || (Space = {}));
var Axis = function() {
  function Axis2() {
  }
  Axis2.X = new Vector3(1, 0, 0);
  Axis2.Y = new Vector3(0, 1, 0);
  Axis2.Z = new Vector3(0, 0, 1);
  return Axis2;
}();
var Coordinate;
(function(Coordinate2) {
  Coordinate2[Coordinate2["X"] = 0] = "X";
  Coordinate2[Coordinate2["Y"] = 1] = "Y";
  Coordinate2[Coordinate2["Z"] = 2] = "Z";
})(Coordinate || (Coordinate = {}));
var TransformNode = function(_super) {
  __extends(TransformNode2, _super);
  function TransformNode2(name2, scene, isPure) {
    if (scene === void 0) {
      scene = null;
    }
    if (isPure === void 0) {
      isPure = true;
    }
    var _this = _super.call(this, name2, scene) || this;
    _this._forward = new Vector3(0, 0, 1);
    _this._up = new Vector3(0, 1, 0);
    _this._right = new Vector3(1, 0, 0);
    _this._position = Vector3.Zero();
    _this._rotation = Vector3.Zero();
    _this._rotationQuaternion = null;
    _this._scaling = Vector3.One();
    _this._transformToBoneReferal = null;
    _this._isAbsoluteSynced = false;
    _this._billboardMode = TransformNode2.BILLBOARDMODE_NONE;
    _this._preserveParentRotationForBillboard = false;
    _this.scalingDeterminant = 1;
    _this._infiniteDistance = false;
    _this.ignoreNonUniformScaling = false;
    _this.reIntegrateRotationIntoRotationQuaternion = false;
    _this._poseMatrix = null;
    _this._localMatrix = Matrix.Zero();
    _this._usePivotMatrix = false;
    _this._absolutePosition = Vector3.Zero();
    _this._absoluteScaling = Vector3.Zero();
    _this._absoluteRotationQuaternion = Quaternion.Identity();
    _this._pivotMatrix = Matrix.Identity();
    _this._postMultiplyPivotMatrix = false;
    _this._isWorldMatrixFrozen = false;
    _this._indexInSceneTransformNodesArray = -1;
    _this.onAfterWorldMatrixUpdateObservable = new Observable();
    _this._nonUniformScaling = false;
    if (isPure) {
      _this.getScene().addTransformNode(_this);
    }
    return _this;
  }
  Object.defineProperty(TransformNode2.prototype, "billboardMode", {
    get: function() {
      return this._billboardMode;
    },
    set: function(value) {
      if (this._billboardMode === value) {
        return;
      }
      this._billboardMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "preserveParentRotationForBillboard", {
    get: function() {
      return this._preserveParentRotationForBillboard;
    },
    set: function(value) {
      if (value === this._preserveParentRotationForBillboard) {
        return;
      }
      this._preserveParentRotationForBillboard = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "infiniteDistance", {
    get: function() {
      return this._infiniteDistance;
    },
    set: function(value) {
      if (this._infiniteDistance === value) {
        return;
      }
      this._infiniteDistance = value;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.getClassName = function() {
    return "TransformNode";
  };
  Object.defineProperty(TransformNode2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(newPosition) {
      this._position = newPosition;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.isUsingPivotMatrix = function() {
    return this._usePivotMatrix;
  };
  Object.defineProperty(TransformNode2.prototype, "rotation", {
    get: function() {
      return this._rotation;
    },
    set: function(newRotation) {
      this._rotation = newRotation;
      this._rotationQuaternion = null;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "scaling", {
    get: function() {
      return this._scaling;
    },
    set: function(newScaling) {
      this._scaling = newScaling;
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "rotationQuaternion", {
    get: function() {
      return this._rotationQuaternion;
    },
    set: function(quaternion) {
      this._rotationQuaternion = quaternion;
      if (quaternion) {
        this._rotation.setAll(0);
      }
      this._isDirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "forward", {
    get: function() {
      Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward);
      return this._forward.normalize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "up", {
    get: function() {
      Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);
      return this._up.normalize();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "right", {
    get: function() {
      Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right);
      return this._right.normalize();
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.updatePoseMatrix = function(matrix) {
    if (!this._poseMatrix) {
      this._poseMatrix = matrix.clone();
      return this;
    }
    this._poseMatrix.copyFrom(matrix);
    return this;
  };
  TransformNode2.prototype.getPoseMatrix = function() {
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Identity();
    }
    return this._poseMatrix;
  };
  TransformNode2.prototype._isSynchronized = function() {
    var cache = this._cache;
    if (this._billboardMode !== cache.billboardMode || this._billboardMode !== TransformNode2.BILLBOARDMODE_NONE) {
      return false;
    }
    if (cache.pivotMatrixUpdated) {
      return false;
    }
    if (this._infiniteDistance) {
      return false;
    }
    if (this._position._isDirty) {
      return false;
    }
    if (this._scaling._isDirty) {
      return false;
    }
    if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty) {
      return false;
    }
    return true;
  };
  TransformNode2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    var cache = this._cache;
    cache.localMatrixUpdated = false;
    cache.billboardMode = -1;
    cache.infiniteDistance = false;
  };
  Object.defineProperty(TransformNode2.prototype, "absolutePosition", {
    get: function() {
      return this.getAbsolutePosition();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "absoluteScaling", {
    get: function() {
      this._syncAbsoluteScalingAndRotation();
      return this._absoluteScaling;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(TransformNode2.prototype, "absoluteRotationQuaternion", {
    get: function() {
      this._syncAbsoluteScalingAndRotation();
      return this._absoluteRotationQuaternion;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.setPreTransformMatrix = function(matrix) {
    return this.setPivotMatrix(matrix, false);
  };
  TransformNode2.prototype.setPivotMatrix = function(matrix, postMultiplyPivotMatrix) {
    if (postMultiplyPivotMatrix === void 0) {
      postMultiplyPivotMatrix = true;
    }
    this._pivotMatrix.copyFrom(matrix);
    this._usePivotMatrix = !this._pivotMatrix.isIdentity();
    this._cache.pivotMatrixUpdated = true;
    this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;
    if (this._postMultiplyPivotMatrix) {
      if (!this._pivotMatrixInverse) {
        this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);
      } else {
        this._pivotMatrix.invertToRef(this._pivotMatrixInverse);
      }
    }
    return this;
  };
  TransformNode2.prototype.getPivotMatrix = function() {
    return this._pivotMatrix;
  };
  TransformNode2.prototype.instantiateHierarchy = function(newParent, options, onNewNodeCreated) {
    if (newParent === void 0) {
      newParent = null;
    }
    var clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
    if (clone) {
      if (onNewNodeCreated) {
        onNewNodeCreated(this, clone);
      }
    }
    for (var _i = 0, _a2 = this.getChildTransformNodes(true); _i < _a2.length; _i++) {
      var child = _a2[_i];
      child.instantiateHierarchy(clone, options, onNewNodeCreated);
    }
    return clone;
  };
  TransformNode2.prototype.freezeWorldMatrix = function(newWorldMatrix, decompose) {
    if (newWorldMatrix === void 0) {
      newWorldMatrix = null;
    }
    if (decompose === void 0) {
      decompose = false;
    }
    if (newWorldMatrix) {
      if (decompose) {
        this._rotation.setAll(0);
        this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();
        newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);
        this.computeWorldMatrix(true);
      } else {
        this._worldMatrix = newWorldMatrix;
        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
        this._afterComputeWorldMatrix();
      }
    } else {
      this._isWorldMatrixFrozen = false;
      this.computeWorldMatrix(true);
    }
    this._isDirty = false;
    this._isWorldMatrixFrozen = true;
    return this;
  };
  TransformNode2.prototype.unfreezeWorldMatrix = function() {
    this._isWorldMatrixFrozen = false;
    this.computeWorldMatrix(true);
    return this;
  };
  Object.defineProperty(TransformNode2.prototype, "isWorldMatrixFrozen", {
    get: function() {
      return this._isWorldMatrixFrozen;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype.getAbsolutePosition = function() {
    this.computeWorldMatrix();
    return this._absolutePosition;
  };
  TransformNode2.prototype.setAbsolutePosition = function(absolutePosition) {
    if (!absolutePosition) {
      return this;
    }
    var absolutePositionX;
    var absolutePositionY;
    var absolutePositionZ;
    if (absolutePosition.x === void 0) {
      if (arguments.length < 3) {
        return this;
      }
      absolutePositionX = arguments[0];
      absolutePositionY = arguments[1];
      absolutePositionZ = arguments[2];
    } else {
      absolutePositionX = absolutePosition.x;
      absolutePositionY = absolutePosition.y;
      absolutePositionZ = absolutePosition.z;
    }
    if (this.parent) {
      var invertParentWorldMatrix = TmpVectors.Matrix[0];
      this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
      Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);
    } else {
      this.position.x = absolutePositionX;
      this.position.y = absolutePositionY;
      this.position.z = absolutePositionZ;
    }
    this._absolutePosition.copyFrom(absolutePosition);
    return this;
  };
  TransformNode2.prototype.setPositionWithLocalVector = function(vector3) {
    this.computeWorldMatrix();
    this.position = Vector3.TransformNormal(vector3, this._localMatrix);
    return this;
  };
  TransformNode2.prototype.getPositionExpressedInLocalSpace = function() {
    this.computeWorldMatrix();
    var invLocalWorldMatrix = TmpVectors.Matrix[0];
    this._localMatrix.invertToRef(invLocalWorldMatrix);
    return Vector3.TransformNormal(this.position, invLocalWorldMatrix);
  };
  TransformNode2.prototype.locallyTranslate = function(vector3) {
    this.computeWorldMatrix(true);
    this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);
    return this;
  };
  TransformNode2.prototype.lookAt = function(targetPoint, yawCor, pitchCor, rollCor, space) {
    if (yawCor === void 0) {
      yawCor = 0;
    }
    if (pitchCor === void 0) {
      pitchCor = 0;
    }
    if (rollCor === void 0) {
      rollCor = 0;
    }
    if (space === void 0) {
      space = Space.LOCAL;
    }
    var dv = TransformNode2._LookAtVectorCache;
    var pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();
    targetPoint.subtractToRef(pos, dv);
    this.setDirection(dv, yawCor, pitchCor, rollCor);
    if (space === Space.WORLD && this.parent) {
      if (this.rotationQuaternion) {
        var rotationMatrix = TmpVectors.Matrix[0];
        this.rotationQuaternion.toRotationMatrix(rotationMatrix);
        var parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        this.rotationQuaternion.fromRotationMatrix(rotationMatrix);
      } else {
        var quaternionRotation = TmpVectors.Quaternion[0];
        Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);
        var rotationMatrix = TmpVectors.Matrix[0];
        quaternionRotation.toRotationMatrix(rotationMatrix);
        var parentRotationMatrix = TmpVectors.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
        parentRotationMatrix.invert();
        rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
        quaternionRotation.fromRotationMatrix(rotationMatrix);
        quaternionRotation.toEulerAnglesToRef(this.rotation);
      }
    }
    return this;
  };
  TransformNode2.prototype.getDirection = function(localAxis) {
    var result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  };
  TransformNode2.prototype.getDirectionToRef = function(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
    return this;
  };
  TransformNode2.prototype.setDirection = function(localAxis, yawCor, pitchCor, rollCor) {
    if (yawCor === void 0) {
      yawCor = 0;
    }
    if (pitchCor === void 0) {
      pitchCor = 0;
    }
    if (rollCor === void 0) {
      rollCor = 0;
    }
    var yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
    var len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
    var pitch = -Math.atan2(localAxis.y, len);
    if (this.rotationQuaternion) {
      Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);
    } else {
      this.rotation.x = pitch + pitchCor;
      this.rotation.y = yaw + yawCor;
      this.rotation.z = rollCor;
    }
    return this;
  };
  TransformNode2.prototype.setPivotPoint = function(point, space) {
    if (space === void 0) {
      space = Space.LOCAL;
    }
    if (this.getScene().getRenderId() == 0) {
      this.computeWorldMatrix(true);
    }
    var wm = this.getWorldMatrix();
    if (space == Space.WORLD) {
      var tmat = TmpVectors.Matrix[0];
      wm.invertToRef(tmat);
      point = Vector3.TransformCoordinates(point, tmat);
    }
    return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);
  };
  TransformNode2.prototype.getPivotPoint = function() {
    var point = Vector3.Zero();
    this.getPivotPointToRef(point);
    return point;
  };
  TransformNode2.prototype.getPivotPointToRef = function(result) {
    result.x = -this._pivotMatrix.m[12];
    result.y = -this._pivotMatrix.m[13];
    result.z = -this._pivotMatrix.m[14];
    return this;
  };
  TransformNode2.prototype.getAbsolutePivotPoint = function() {
    var point = Vector3.Zero();
    this.getAbsolutePivotPointToRef(point);
    return point;
  };
  TransformNode2.prototype.getAbsolutePivotPointToRef = function(result) {
    this.getPivotPointToRef(result);
    Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);
    return this;
  };
  TransformNode2.prototype.markAsDirty = function(property) {
    if (this._children) {
      for (var _i = 0, _a2 = this._children; _i < _a2.length; _i++) {
        var child = _a2[_i];
        child.markAsDirty(property);
      }
    }
    return _super.prototype.markAsDirty.call(this, property);
  };
  TransformNode2.prototype.setParent = function(node, preserveScalingSign) {
    if (preserveScalingSign === void 0) {
      preserveScalingSign = false;
    }
    if (!node && !this.parent) {
      return this;
    }
    var quatRotation = TmpVectors.Quaternion[0];
    var position = TmpVectors.Vector3[0];
    var scale = TmpVectors.Vector3[1];
    var invParentMatrix = TmpVectors.Matrix[1];
    Matrix.IdentityToRef(invParentMatrix);
    var composedMatrix = TmpVectors.Matrix[0];
    this.computeWorldMatrix(true);
    var currentRotation = this.rotationQuaternion;
    if (!currentRotation) {
      currentRotation = TransformNode2._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);
    }
    Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);
    if (this.parent) {
      composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);
    }
    if (node) {
      node.computeWorldMatrix(true).invertToRef(invParentMatrix);
      composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);
    }
    composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : void 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion.copyFrom(quatRotation);
    } else {
      quatRotation.toEulerAnglesToRef(this.rotation);
    }
    this.scaling.copyFrom(scale);
    this.position.copyFrom(position);
    this.parent = node;
    return this;
  };
  Object.defineProperty(TransformNode2.prototype, "nonUniformScaling", {
    get: function() {
      return this._nonUniformScaling;
    },
    enumerable: false,
    configurable: true
  });
  TransformNode2.prototype._updateNonUniformScalingState = function(value) {
    if (this._nonUniformScaling === value) {
      return false;
    }
    this._nonUniformScaling = value;
    return true;
  };
  TransformNode2.prototype.attachToBone = function(bone, affectedTransformNode) {
    this._currentParentWhenAttachingToBone = this.parent;
    this._transformToBoneReferal = affectedTransformNode;
    this.parent = bone;
    bone.getSkeleton().prepare();
    if (bone.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    return this;
  };
  TransformNode2.prototype.detachFromBone = function(resetToPreviousParent) {
    if (resetToPreviousParent === void 0) {
      resetToPreviousParent = false;
    }
    if (!this.parent) {
      if (resetToPreviousParent) {
        this.parent = this._currentParentWhenAttachingToBone;
      }
      return this;
    }
    if (this.parent.getWorldMatrix().determinant() < 0) {
      this.scalingDeterminant *= -1;
    }
    this._transformToBoneReferal = null;
    if (resetToPreviousParent) {
      this.parent = this._currentParentWhenAttachingToBone;
    } else {
      this.parent = null;
    }
    return this;
  };
  TransformNode2.prototype.rotate = function(axis, amount, space) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = this.rotation.toQuaternion();
      this.rotation.setAll(0);
    }
    var rotationQuaternion;
    if (!space || space === Space.LOCAL) {
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode2._RotationAxisCache);
      this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);
    } else {
      if (this.parent) {
        var invertParentWorldMatrix = TmpVectors.Matrix[0];
        this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
        axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);
      }
      rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode2._RotationAxisCache);
      rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
    return this;
  };
  TransformNode2.prototype.rotateAround = function(point, axis, amount) {
    axis.normalize();
    if (!this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
      this.rotation.setAll(0);
    }
    var tmpVector = TmpVectors.Vector3[0];
    var finalScale = TmpVectors.Vector3[1];
    var finalTranslation = TmpVectors.Vector3[2];
    var finalRotation = TmpVectors.Quaternion[0];
    var translationMatrix = TmpVectors.Matrix[0];
    var translationMatrixInv = TmpVectors.Matrix[1];
    var rotationMatrix = TmpVectors.Matrix[2];
    var finalMatrix = TmpVectors.Matrix[3];
    point.subtractToRef(this.position, tmpVector);
    Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix);
    Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv);
    Matrix.RotationAxisToRef(axis, amount, rotationMatrix);
    translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
    finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
    finalMatrix.decompose(finalScale, finalRotation, finalTranslation);
    this.position.addInPlace(finalTranslation);
    finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    return this;
  };
  TransformNode2.prototype.translate = function(axis, distance, space) {
    var displacementVector = axis.scale(distance);
    if (!space || space === Space.LOCAL) {
      var tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);
      this.setPositionWithLocalVector(tempV3);
    } else {
      this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));
    }
    return this;
  };
  TransformNode2.prototype.addRotation = function(x, y, z) {
    var rotationQuaternion;
    if (this.rotationQuaternion) {
      rotationQuaternion = this.rotationQuaternion;
    } else {
      rotationQuaternion = TmpVectors.Quaternion[1];
      Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);
    }
    var accumulation = TmpVectors.Quaternion[0];
    Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);
    rotationQuaternion.multiplyInPlace(accumulation);
    if (!this.rotationQuaternion) {
      rotationQuaternion.toEulerAnglesToRef(this.rotation);
    }
    return this;
  };
  TransformNode2.prototype._getEffectiveParent = function() {
    return this.parent;
  };
  TransformNode2.prototype.computeWorldMatrix = function(force) {
    if (this._isWorldMatrixFrozen && !this._isDirty) {
      return this._worldMatrix;
    }
    var currentRenderId = this.getScene().getRenderId();
    if (!this._isDirty && !force && (this._currentRenderId === currentRenderId || this.isSynchronized())) {
      this._currentRenderId = currentRenderId;
      return this._worldMatrix;
    }
    var camera = this.getScene().activeCamera;
    var useBillboardPosition = (this._billboardMode & TransformNode2.BILLBOARDMODE_USE_POSITION) !== 0;
    var useBillboardPath = this._billboardMode !== TransformNode2.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
    this._updateCache();
    var cache = this._cache;
    cache.pivotMatrixUpdated = false;
    cache.billboardMode = this.billboardMode;
    cache.infiniteDistance = this.infiniteDistance;
    cache.parent = this._parentNode;
    this._currentRenderId = currentRenderId;
    this._childUpdateId += 1;
    this._isDirty = false;
    this._position._isDirty = false;
    this._rotation._isDirty = false;
    this._scaling._isDirty = false;
    var parent = this._getEffectiveParent();
    var scaling = TransformNode2._TmpScaling;
    var translation = this._position;
    if (this._infiniteDistance) {
      if (!this.parent && camera) {
        var cameraWorldMatrix = camera.getWorldMatrix();
        var cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);
        translation = TransformNode2._TmpTranslation;
        translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);
      }
    }
    scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
    var rotation;
    if (this._rotationQuaternion) {
      this._rotationQuaternion._isDirty = false;
      rotation = this._rotationQuaternion;
      if (this.reIntegrateRotationIntoRotationQuaternion) {
        var len = this.rotation.lengthSquared();
        if (len) {
          this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));
          this._rotation.copyFromFloats(0, 0, 0);
        }
      }
    } else {
      rotation = TransformNode2._TmpRotation;
      Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);
    }
    if (this._usePivotMatrix) {
      var scaleMatrix = TmpVectors.Matrix[1];
      Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);
      var rotationMatrix = TmpVectors.Matrix[0];
      rotation.toRotationMatrix(rotationMatrix);
      this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
      TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);
      if (this._postMultiplyPivotMatrix) {
        this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);
      }
      this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);
    } else {
      Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);
    }
    if (parent && parent.getWorldMatrix) {
      if (force) {
        parent.computeWorldMatrix(force);
      }
      if (useBillboardPath) {
        if (this._transformToBoneReferal) {
          parent.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);
        } else {
          TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());
        }
        var translation_1 = TmpVectors.Vector3[5];
        var scale = TmpVectors.Vector3[6];
        TmpVectors.Matrix[7].decompose(scale, void 0, translation_1);
        Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);
        TmpVectors.Matrix[7].setTranslation(translation_1);
        this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);
      } else {
        if (this._transformToBoneReferal) {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), TmpVectors.Matrix[6]);
          TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);
        } else {
          this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);
        }
      }
      this._markSyncedWithParent();
    } else {
      this._worldMatrix.copyFrom(this._localMatrix);
    }
    if (useBillboardPath && camera && this.billboardMode && !useBillboardPosition) {
      var storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());
      TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);
      TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);
      if ((this.billboardMode & TransformNode2.BILLBOARDMODE_ALL) !== TransformNode2.BILLBOARDMODE_ALL) {
        TmpVectors.Matrix[0].decompose(void 0, TmpVectors.Quaternion[0], void 0);
        var eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_X) !== TransformNode2.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Y) !== TransformNode2.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Z) !== TransformNode2.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    } else if (useBillboardPath && camera && this.billboardMode && useBillboardPosition) {
      var storedTranslation = TmpVectors.Vector3[0];
      this._worldMatrix.getTranslationToRef(storedTranslation);
      var cameraPosition = camera.globalPosition;
      this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);
      var camInObjSpace = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);
      camInObjSpace.normalize();
      var yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;
      var len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);
      var pitch = -Math.atan2(camInObjSpace.y, len);
      Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);
      if ((this.billboardMode & TransformNode2.BILLBOARDMODE_ALL) !== TransformNode2.BILLBOARDMODE_ALL) {
        var eulerAngles = TmpVectors.Vector3[1];
        TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_X) !== TransformNode2.BILLBOARDMODE_X) {
          eulerAngles.x = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Y) !== TransformNode2.BILLBOARDMODE_Y) {
          eulerAngles.y = 0;
        }
        if ((this.billboardMode & TransformNode2.BILLBOARDMODE_Z) !== TransformNode2.BILLBOARDMODE_Z) {
          eulerAngles.z = 0;
        }
        Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
      } else {
        Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0);
      this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
      this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
    }
    if (!this.ignoreNonUniformScaling) {
      if (this._scaling.isNonUniformWithinEpsilon(1e-6)) {
        this._updateNonUniformScalingState(true);
      } else if (parent && parent._nonUniformScaling) {
        this._updateNonUniformScalingState(parent._nonUniformScaling);
      } else {
        this._updateNonUniformScalingState(false);
      }
    } else {
      this._updateNonUniformScalingState(false);
    }
    this._afterComputeWorldMatrix();
    this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
    this._isAbsoluteSynced = false;
    this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);
    if (!this._poseMatrix) {
      this._poseMatrix = Matrix.Invert(this._worldMatrix);
    }
    this._worldMatrixDeterminantIsDirty = true;
    return this._worldMatrix;
  };
  TransformNode2.prototype.resetLocalMatrix = function(independentOfChildren) {
    if (independentOfChildren === void 0) {
      independentOfChildren = true;
    }
    this.computeWorldMatrix();
    if (independentOfChildren) {
      var children = this.getChildren();
      for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        if (child) {
          child.computeWorldMatrix();
          var bakedMatrix = TmpVectors.Matrix[0];
          child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);
          var tmpRotationQuaternion = TmpVectors.Quaternion[0];
          bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);
          if (child.rotationQuaternion) {
            child.rotationQuaternion.copyFrom(tmpRotationQuaternion);
          } else {
            tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);
          }
        }
      }
    }
    this.scaling.copyFromFloats(1, 1, 1);
    this.position.copyFromFloats(0, 0, 0);
    this.rotation.copyFromFloats(0, 0, 0);
    if (this.rotationQuaternion) {
      this.rotationQuaternion = Quaternion.Identity();
    }
    this._worldMatrix = Matrix.Identity();
  };
  TransformNode2.prototype._afterComputeWorldMatrix = function() {
  };
  TransformNode2.prototype.registerAfterWorldMatrixUpdate = function(func) {
    this.onAfterWorldMatrixUpdateObservable.add(func);
    return this;
  };
  TransformNode2.prototype.unregisterAfterWorldMatrixUpdate = function(func) {
    this.onAfterWorldMatrixUpdateObservable.removeCallback(func);
    return this;
  };
  TransformNode2.prototype.getPositionInCameraSpace = function(camera) {
    if (camera === void 0) {
      camera = null;
    }
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());
  };
  TransformNode2.prototype.getDistanceToCamera = function(camera) {
    if (camera === void 0) {
      camera = null;
    }
    if (!camera) {
      camera = this.getScene().activeCamera;
    }
    return this.getAbsolutePosition().subtract(camera.globalPosition).length();
  };
  TransformNode2.prototype.clone = function(name2, newParent, doNotCloneChildren) {
    var _this = this;
    var result = SerializationHelper.Clone(function() {
      return new TransformNode2(name2, _this.getScene());
    }, this);
    result.name = name2;
    result.id = name2;
    if (newParent) {
      result.parent = newParent;
    }
    if (!doNotCloneChildren) {
      var directDescendants = this.getDescendants(true);
      for (var index = 0; index < directDescendants.length; index++) {
        var child = directDescendants[index];
        if (child.clone) {
          child.clone(name2 + "." + child.name, result);
        }
      }
    }
    return result;
  };
  TransformNode2.prototype.serialize = function(currentSerializationObject) {
    var serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);
    serializationObject.type = this.getClassName();
    serializationObject.uniqueId = this.uniqueId;
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    serializationObject.localMatrix = this.getPivotMatrix().asArray();
    serializationObject.isEnabled = this.isEnabled();
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    return serializationObject;
  };
  TransformNode2.Parse = function(parsedTransformNode, scene, rootUrl) {
    var transformNode = SerializationHelper.Parse(function() {
      return new TransformNode2(parsedTransformNode.name, scene);
    }, parsedTransformNode, scene, rootUrl);
    if (parsedTransformNode.localMatrix) {
      transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));
    } else if (parsedTransformNode.pivotMatrix) {
      transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));
    }
    transformNode.setEnabled(parsedTransformNode.isEnabled);
    if (parsedTransformNode.parentId !== void 0) {
      transformNode._waitingParentId = parsedTransformNode.parentId;
    }
    return transformNode;
  };
  TransformNode2.prototype.getChildTransformNodes = function(directDescendantsOnly, predicate) {
    var results = [];
    this._getDescendants(results, directDescendantsOnly, function(node) {
      return (!predicate || predicate(node)) && node instanceof TransformNode2;
    });
    return results;
  };
  TransformNode2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeTransformNode(this);
    if (this._parentContainer) {
      var index = this._parentContainer.transformNodes.indexOf(this);
      if (index > -1) {
        this._parentContainer.transformNodes.splice(index, 1);
      }
      this._parentContainer = null;
    }
    this.onAfterWorldMatrixUpdateObservable.clear();
    if (doNotRecurse) {
      var transformNodes = this.getChildTransformNodes(true);
      for (var _i = 0, transformNodes_1 = transformNodes; _i < transformNodes_1.length; _i++) {
        var transformNode = transformNodes_1[_i];
        transformNode.parent = null;
        transformNode.computeWorldMatrix(true);
      }
    }
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  TransformNode2.prototype.normalizeToUnitCube = function(includeDescendants, ignoreRotation, predicate) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (ignoreRotation === void 0) {
      ignoreRotation = false;
    }
    var storedRotation = null;
    var storedRotationQuaternion = null;
    if (ignoreRotation) {
      if (this.rotationQuaternion) {
        storedRotationQuaternion = this.rotationQuaternion.clone();
        this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
      } else if (this.rotation) {
        storedRotation = this.rotation.clone();
        this.rotation.copyFromFloats(0, 0, 0);
      }
    }
    var boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);
    var sizeVec = boundingVectors.max.subtract(boundingVectors.min);
    var maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
    if (maxDimension === 0) {
      return this;
    }
    var scale = 1 / maxDimension;
    this.scaling.scaleInPlace(scale);
    if (ignoreRotation) {
      if (this.rotationQuaternion && storedRotationQuaternion) {
        this.rotationQuaternion.copyFrom(storedRotationQuaternion);
      } else if (this.rotation && storedRotation) {
        this.rotation.copyFrom(storedRotation);
      }
    }
    return this;
  };
  TransformNode2.prototype._syncAbsoluteScalingAndRotation = function() {
    if (!this._isAbsoluteSynced) {
      this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);
      this._isAbsoluteSynced = true;
    }
  };
  TransformNode2.BILLBOARDMODE_NONE = 0;
  TransformNode2.BILLBOARDMODE_X = 1;
  TransformNode2.BILLBOARDMODE_Y = 2;
  TransformNode2.BILLBOARDMODE_Z = 4;
  TransformNode2.BILLBOARDMODE_ALL = 7;
  TransformNode2.BILLBOARDMODE_USE_POSITION = 128;
  TransformNode2._TmpRotation = Quaternion.Zero();
  TransformNode2._TmpScaling = Vector3.Zero();
  TransformNode2._TmpTranslation = Vector3.Zero();
  TransformNode2._LookAtVectorCache = new Vector3(0, 0, 0);
  TransformNode2._RotationAxisCache = new Quaternion();
  __decorate([
    serializeAsVector3("position")
  ], TransformNode2.prototype, "_position", void 0);
  __decorate([
    serializeAsVector3("rotation")
  ], TransformNode2.prototype, "_rotation", void 0);
  __decorate([
    serializeAsQuaternion("rotationQuaternion")
  ], TransformNode2.prototype, "_rotationQuaternion", void 0);
  __decorate([
    serializeAsVector3("scaling")
  ], TransformNode2.prototype, "_scaling", void 0);
  __decorate([
    serialize("billboardMode")
  ], TransformNode2.prototype, "_billboardMode", void 0);
  __decorate([
    serialize()
  ], TransformNode2.prototype, "scalingDeterminant", void 0);
  __decorate([
    serialize("infiniteDistance")
  ], TransformNode2.prototype, "_infiniteDistance", void 0);
  __decorate([
    serialize()
  ], TransformNode2.prototype, "ignoreNonUniformScaling", void 0);
  __decorate([
    serialize()
  ], TransformNode2.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);
  return TransformNode2;
}(Node);
var PickingInfo = function() {
  function PickingInfo2() {
    this._pickingUnavailable = false;
    this.hit = false;
    this.distance = 0;
    this.pickedPoint = null;
    this.pickedMesh = null;
    this.bu = 0;
    this.bv = 0;
    this.faceId = -1;
    this.subMeshFaceId = -1;
    this.subMeshId = 0;
    this.pickedSprite = null;
    this.thinInstanceIndex = -1;
    this.ray = null;
    this.originMesh = null;
    this.aimTransform = null;
    this.gripTransform = null;
  }
  PickingInfo2.prototype.getNormal = function(useWorldCoordinates, useVerticesNormals) {
    if (useWorldCoordinates === void 0) {
      useWorldCoordinates = false;
    }
    if (useVerticesNormals === void 0) {
      useVerticesNormals = true;
    }
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      return null;
    }
    var indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    var result;
    if (useVerticesNormals) {
      var normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);
      var normal0 = Vector3.FromArray(normals, indices[this.faceId * 3] * 3);
      var normal1 = Vector3.FromArray(normals, indices[this.faceId * 3 + 1] * 3);
      var normal2 = Vector3.FromArray(normals, indices[this.faceId * 3 + 2] * 3);
      normal0 = normal0.scale(this.bu);
      normal1 = normal1.scale(this.bv);
      normal2 = normal2.scale(1 - this.bu - this.bv);
      result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);
    } else {
      var positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);
      var vertex1 = Vector3.FromArray(positions, indices[this.faceId * 3] * 3);
      var vertex2 = Vector3.FromArray(positions, indices[this.faceId * 3 + 1] * 3);
      var vertex3 = Vector3.FromArray(positions, indices[this.faceId * 3 + 2] * 3);
      var p1p2 = vertex1.subtract(vertex2);
      var p3p2 = vertex3.subtract(vertex2);
      result = Vector3.Cross(p1p2, p3p2);
    }
    if (useWorldCoordinates) {
      var wm = this.pickedMesh.getWorldMatrix();
      if (this.pickedMesh.nonUniformScaling) {
        TmpVectors.Matrix[0].copyFrom(wm);
        wm = TmpVectors.Matrix[0];
        wm.setTranslationFromFloats(0, 0, 0);
        wm.invert();
        wm.transposeToRef(TmpVectors.Matrix[1]);
        wm = TmpVectors.Matrix[1];
      }
      result = Vector3.TransformNormal(result, wm);
    }
    result.normalize();
    return result;
  };
  PickingInfo2.prototype.getTextureCoordinates = function() {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
      return null;
    }
    var indices = this.pickedMesh.getIndices();
    if (!indices) {
      return null;
    }
    var uvs = this.pickedMesh.getVerticesData(VertexBuffer.UVKind);
    if (!uvs) {
      return null;
    }
    var uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);
    var uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);
    var uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);
    uv0 = uv0.scale(this.bu);
    uv1 = uv1.scale(this.bv);
    uv2 = uv2.scale(1 - this.bu - this.bv);
    return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);
  };
  return PickingInfo2;
}();
ThinEngine.prototype.createUniformBuffer = function(elements) {
  var ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create uniform buffer");
  }
  var result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.createDynamicUniformBuffer = function(elements) {
  var ubo = this._gl.createBuffer();
  if (!ubo) {
    throw new Error("Unable to create dynamic uniform buffer");
  }
  var result = new WebGLDataBuffer(ubo);
  this.bindUniformBuffer(result);
  if (elements instanceof Float32Array) {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);
  } else {
    this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);
  }
  this.bindUniformBuffer(null);
  result.references = 1;
  return result;
};
ThinEngine.prototype.updateUniformBuffer = function(uniformBuffer, elements, offset, count) {
  this.bindUniformBuffer(uniformBuffer);
  if (offset === void 0) {
    offset = 0;
  }
  if (count === void 0) {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));
    }
  } else {
    if (elements instanceof Float32Array) {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));
    } else {
      this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));
    }
  }
  this.bindUniformBuffer(null);
};
ThinEngine.prototype.bindUniformBuffer = function(buffer) {
  this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBufferBase = function(buffer, location2, name2) {
  this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location2, buffer ? buffer.underlyingResource : null);
};
ThinEngine.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
  var program = pipelineContext.program;
  var uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
  if (uniformLocation !== 4294967295) {
    this._gl.uniformBlockBinding(program, uniformLocation, index);
  }
};
var UniformBuffer = function() {
  function UniformBuffer2(engine, data, dynamic, name2, forceNoUniformBuffer) {
    if (forceNoUniformBuffer === void 0) {
      forceNoUniformBuffer = false;
    }
    this._valueCache = {};
    this._engine = engine;
    this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;
    this._dynamic = dynamic;
    this._name = name2 !== null && name2 !== void 0 ? name2 : "no-name";
    this._data = data || [];
    this._uniformLocations = {};
    this._uniformSizes = {};
    this._uniformArraySizes = {};
    this._uniformLocationPointer = 0;
    this._needSync = false;
    if (this._engine._features.trackUbosInFrame) {
      this._buffers = [];
      this._bufferIndex = -1;
      this._createBufferOnWrite = false;
      this._currentFrameId = 0;
    }
    if (this._noUBO) {
      this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;
      this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;
      this.updateFloat = this._updateFloatForEffect;
      this.updateFloat2 = this._updateFloat2ForEffect;
      this.updateFloat3 = this._updateFloat3ForEffect;
      this.updateFloat4 = this._updateFloat4ForEffect;
      this.updateFloatArray = this._updateFloatArrayForEffect;
      this.updateArray = this._updateArrayForEffect;
      this.updateIntArray = this._updateIntArrayForEffect;
      this.updateMatrix = this._updateMatrixForEffect;
      this.updateMatrices = this._updateMatricesForEffect;
      this.updateVector3 = this._updateVector3ForEffect;
      this.updateVector4 = this._updateVector4ForEffect;
      this.updateColor3 = this._updateColor3ForEffect;
      this.updateColor4 = this._updateColor4ForEffect;
      this.updateDirectColor4 = this._updateDirectColor4ForEffect;
      this.updateInt = this._updateIntForEffect;
      this.updateInt2 = this._updateInt2ForEffect;
      this.updateInt3 = this._updateInt3ForEffect;
      this.updateInt4 = this._updateInt4ForEffect;
    } else {
      this._engine._uniformBuffers.push(this);
      this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;
      this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;
      this.updateFloat = this._updateFloatForUniform;
      this.updateFloat2 = this._updateFloat2ForUniform;
      this.updateFloat3 = this._updateFloat3ForUniform;
      this.updateFloat4 = this._updateFloat4ForUniform;
      this.updateFloatArray = this._updateFloatArrayForUniform;
      this.updateArray = this._updateArrayForUniform;
      this.updateIntArray = this._updateIntArrayForUniform;
      this.updateMatrix = this._updateMatrixForUniform;
      this.updateMatrices = this._updateMatricesForUniform;
      this.updateVector3 = this._updateVector3ForUniform;
      this.updateVector4 = this._updateVector4ForUniform;
      this.updateColor3 = this._updateColor3ForUniform;
      this.updateColor4 = this._updateColor4ForUniform;
      this.updateDirectColor4 = this._updateDirectColor4ForUniform;
      this.updateInt = this._updateIntForUniform;
      this.updateInt2 = this._updateInt2ForUniform;
      this.updateInt3 = this._updateInt3ForUniform;
      this.updateInt4 = this._updateInt4ForUniform;
    }
  }
  Object.defineProperty(UniformBuffer2.prototype, "useUbo", {
    get: function() {
      return !this._noUBO;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(UniformBuffer2.prototype, "isSync", {
    get: function() {
      return !this._needSync;
    },
    enumerable: false,
    configurable: true
  });
  UniformBuffer2.prototype.isDynamic = function() {
    return this._dynamic !== void 0;
  };
  UniformBuffer2.prototype.getData = function() {
    return this._bufferData;
  };
  UniformBuffer2.prototype.getBuffer = function() {
    return this._buffer;
  };
  UniformBuffer2.prototype._fillAlignment = function(size) {
    var alignment;
    if (size <= 2) {
      alignment = size;
    } else {
      alignment = 4;
    }
    if (this._uniformLocationPointer % alignment !== 0) {
      var oldPointer = this._uniformLocationPointer;
      this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;
      var diff = this._uniformLocationPointer - oldPointer;
      for (var i = 0; i < diff; i++) {
        this._data.push(0);
      }
    }
  };
  UniformBuffer2.prototype.addUniform = function(name2, size, arraySize) {
    if (arraySize === void 0) {
      arraySize = 0;
    }
    if (this._noUBO) {
      return;
    }
    if (this._uniformLocations[name2] !== void 0) {
      return;
    }
    var data;
    if (arraySize > 0) {
      if (size instanceof Array) {
        throw "addUniform should not be use with Array in UBO: " + name2;
      }
      this._fillAlignment(4);
      this._uniformArraySizes[name2] = { strideSize: size, arraySize };
      if (size == 16) {
        size = size * arraySize;
      } else {
        var perElementPadding = 4 - size;
        var totalPadding = perElementPadding * arraySize;
        size = size * arraySize + totalPadding;
      }
      data = [];
      for (var i = 0; i < size; i++) {
        data.push(0);
      }
    } else {
      if (size instanceof Array) {
        data = size;
        size = data.length;
      } else {
        size = size;
        data = [];
        for (var i = 0; i < size; i++) {
          data.push(0);
        }
      }
      this._fillAlignment(size);
    }
    this._uniformSizes[name2] = size;
    this._uniformLocations[name2] = this._uniformLocationPointer;
    this._uniformLocationPointer += size;
    for (var i = 0; i < size; i++) {
      this._data.push(data[i]);
    }
    this._needSync = true;
  };
  UniformBuffer2.prototype.addMatrix = function(name2, mat) {
    this.addUniform(name2, Array.prototype.slice.call(mat.toArray()));
  };
  UniformBuffer2.prototype.addFloat2 = function(name2, x, y) {
    var temp = [x, y];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addFloat3 = function(name2, x, y, z) {
    var temp = [x, y, z];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addColor3 = function(name2, color) {
    var temp = [color.r, color.g, color.b];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addColor4 = function(name2, color, alpha) {
    var temp = [color.r, color.g, color.b, alpha];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addVector3 = function(name2, vector) {
    var temp = [vector.x, vector.y, vector.z];
    this.addUniform(name2, temp);
  };
  UniformBuffer2.prototype.addMatrix3x3 = function(name2) {
    this.addUniform(name2, 12);
  };
  UniformBuffer2.prototype.addMatrix2x2 = function(name2) {
    this.addUniform(name2, 8);
  };
  UniformBuffer2.prototype.create = function() {
    if (this._noUBO) {
      return;
    }
    if (this._buffer) {
      return;
    }
    this._fillAlignment(4);
    this._bufferData = new Float32Array(this._data);
    this._rebuild();
    this._needSync = true;
  };
  UniformBuffer2.prototype._rebuild = function() {
    if (this._noUBO || !this._bufferData) {
      return;
    }
    if (this._dynamic) {
      this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);
    } else {
      this._buffer = this._engine.createUniformBuffer(this._bufferData);
    }
    if (this._engine._features.trackUbosInFrame) {
      this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]);
      this._bufferIndex = this._buffers.length - 1;
      this._createBufferOnWrite = false;
    }
  };
  Object.defineProperty(UniformBuffer2.prototype, "_numBuffers", {
    get: function() {
      return this._buffers.length;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(UniformBuffer2.prototype, "_indexBuffer", {
    get: function() {
      return this._bufferIndex;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(UniformBuffer2.prototype, "name", {
    get: function() {
      return this._name;
    },
    enumerable: false,
    configurable: true
  });
  UniformBuffer2.prototype._buffersEqual = function(buf1, buf2) {
    for (var i = 0; i < buf1.length; ++i) {
      if (buf1[i] !== buf2[i]) {
        return false;
      }
    }
    return true;
  };
  UniformBuffer2.prototype._copyBuffer = function(src, dst) {
    for (var i = 0; i < src.length; ++i) {
      dst[i] = src[i];
    }
  };
  UniformBuffer2.prototype.update = function() {
    if (this._noUBO) {
      return;
    }
    this.bindUniformBuffer();
    if (!this._buffer) {
      this.create();
      return;
    }
    if (!this._dynamic && !this._needSync) {
      this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
      return;
    }
    if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {
      if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
        this._needSync = false;
        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
        return;
      } else {
        this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
      }
    }
    this._engine.updateUniformBuffer(this._buffer, this._bufferData);
    if (this._engine._features._collectUbosUpdatedInFrame) {
      if (!UniformBuffer2._UpdatedUbosInFrame[this._name]) {
        UniformBuffer2._UpdatedUbosInFrame[this._name] = 0;
      }
      UniformBuffer2._UpdatedUbosInFrame[this._name]++;
    }
    this._needSync = false;
    this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
  };
  UniformBuffer2.prototype._createNewBuffer = function() {
    if (this._bufferIndex + 1 < this._buffers.length) {
      this._bufferIndex++;
      this._buffer = this._buffers[this._bufferIndex][0];
      this._createBufferOnWrite = false;
      this._needSync = true;
    } else {
      this._rebuild();
    }
  };
  UniformBuffer2.prototype._checkNewFrame = function() {
    if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {
      this._currentFrameId = this._engine.frameId;
      this._createBufferOnWrite = false;
      if (this._buffers && this._buffers.length > 0) {
        this._needSync = this._bufferIndex !== 0;
        this._bufferIndex = 0;
        this._buffer = this._buffers[this._bufferIndex][0];
      } else {
        this._bufferIndex = -1;
      }
    }
  };
  UniformBuffer2.prototype.updateUniform = function(uniformName, data, size) {
    this._checkNewFrame();
    var location2 = this._uniformLocations[uniformName];
    if (location2 === void 0) {
      if (this._buffer) {
        Logger.Error("Cannot add an uniform after UBO has been created.");
        return;
      }
      this.addUniform(uniformName, size);
      location2 = this._uniformLocations[uniformName];
    }
    if (!this._buffer) {
      this.create();
    }
    if (!this._dynamic) {
      var changed = false;
      for (var i = 0; i < size; i++) {
        if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location2 + i] !== Tools.FloatRound(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location2 + i] = data[i];
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (var i = 0; i < size; i++) {
        this._bufferData[location2 + i] = data[i];
      }
    }
  };
  UniformBuffer2.prototype.updateUniformArray = function(uniformName, data, size) {
    this._checkNewFrame();
    var location2 = this._uniformLocations[uniformName];
    if (location2 === void 0) {
      Logger.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform.");
      return;
    }
    if (!this._buffer) {
      this.create();
    }
    var arraySizes = this._uniformArraySizes[uniformName];
    if (!this._dynamic) {
      var changed = false;
      var countToFour = 0;
      var baseStride = 0;
      for (var i = 0; i < size; i++) {
        if (this._bufferData[location2 + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {
          changed = true;
          if (this._createBufferOnWrite) {
            this._createNewBuffer();
          }
          this._bufferData[location2 + baseStride * 4 + countToFour] = data[i];
        }
        countToFour++;
        if (countToFour === arraySizes.strideSize) {
          for (; countToFour < 4; countToFour++) {
            this._bufferData[location2 + baseStride * 4 + countToFour] = 0;
          }
          countToFour = 0;
          baseStride++;
        }
      }
      this._needSync = this._needSync || changed;
    } else {
      for (var i = 0; i < size; i++) {
        this._bufferData[location2 + i] = data[i];
      }
    }
  };
  UniformBuffer2.prototype._cacheMatrix = function(name2, matrix) {
    this._checkNewFrame();
    var cache = this._valueCache[name2];
    var flag = matrix.updateFlag;
    if (cache !== void 0 && cache === flag) {
      return false;
    }
    this._valueCache[name2] = flag;
    return true;
  };
  UniformBuffer2.prototype._updateMatrix3x3ForUniform = function(name2, matrix) {
    for (var i = 0; i < 3; i++) {
      UniformBuffer2._TempBuffer[i * 4] = matrix[i * 3];
      UniformBuffer2._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];
      UniformBuffer2._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];
      UniformBuffer2._TempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 12);
  };
  UniformBuffer2.prototype._updateMatrix3x3ForEffect = function(name2, matrix) {
    this._currentEffect.setMatrix3x3(name2, matrix);
  };
  UniformBuffer2.prototype._updateMatrix2x2ForEffect = function(name2, matrix) {
    this._currentEffect.setMatrix2x2(name2, matrix);
  };
  UniformBuffer2.prototype._updateMatrix2x2ForUniform = function(name2, matrix) {
    for (var i = 0; i < 2; i++) {
      UniformBuffer2._TempBuffer[i * 4] = matrix[i * 2];
      UniformBuffer2._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];
      UniformBuffer2._TempBuffer[i * 4 + 2] = 0;
      UniformBuffer2._TempBuffer[i * 4 + 3] = 0;
    }
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 8);
  };
  UniformBuffer2.prototype._updateFloatForEffect = function(name2, x) {
    this._currentEffect.setFloat(name2, x);
  };
  UniformBuffer2.prototype._updateFloatForUniform = function(name2, x) {
    UniformBuffer2._TempBuffer[0] = x;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 1);
  };
  UniformBuffer2.prototype._updateFloat2ForEffect = function(name2, x, y, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setFloat2(name2 + suffix, x, y);
  };
  UniformBuffer2.prototype._updateFloat2ForUniform = function(name2, x, y) {
    UniformBuffer2._TempBuffer[0] = x;
    UniformBuffer2._TempBuffer[1] = y;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 2);
  };
  UniformBuffer2.prototype._updateFloat3ForEffect = function(name2, x, y, z, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setFloat3(name2 + suffix, x, y, z);
  };
  UniformBuffer2.prototype._updateFloat3ForUniform = function(name2, x, y, z) {
    UniformBuffer2._TempBuffer[0] = x;
    UniformBuffer2._TempBuffer[1] = y;
    UniformBuffer2._TempBuffer[2] = z;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 3);
  };
  UniformBuffer2.prototype._updateFloat4ForEffect = function(name2, x, y, z, w, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setFloat4(name2 + suffix, x, y, z, w);
  };
  UniformBuffer2.prototype._updateFloat4ForUniform = function(name2, x, y, z, w) {
    UniformBuffer2._TempBuffer[0] = x;
    UniformBuffer2._TempBuffer[1] = y;
    UniformBuffer2._TempBuffer[2] = z;
    UniformBuffer2._TempBuffer[3] = w;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 4);
  };
  UniformBuffer2.prototype._updateFloatArrayForEffect = function(name2, array) {
    this._currentEffect.setFloatArray(name2, array);
  };
  UniformBuffer2.prototype._updateFloatArrayForUniform = function(name2, array) {
    this.updateUniformArray(name2, array, array.length);
  };
  UniformBuffer2.prototype._updateArrayForEffect = function(name2, array) {
    this._currentEffect.setArray(name2, array);
  };
  UniformBuffer2.prototype._updateArrayForUniform = function(name2, array) {
    this.updateUniformArray(name2, array, array.length);
  };
  UniformBuffer2.prototype._updateIntArrayForEffect = function(name2, array) {
    this._currentEffect.setIntArray(name2, array);
  };
  UniformBuffer2.prototype._updateIntArrayForUniform = function(name2, array) {
    UniformBuffer2._TempBufferInt32View.set(array);
    this.updateUniformArray(name2, UniformBuffer2._TempBuffer, array.length);
  };
  UniformBuffer2.prototype._updateMatrixForEffect = function(name2, mat) {
    this._currentEffect.setMatrix(name2, mat);
  };
  UniformBuffer2.prototype._updateMatrixForUniform = function(name2, mat) {
    if (this._cacheMatrix(name2, mat)) {
      this.updateUniform(name2, mat.toArray(), 16);
    }
  };
  UniformBuffer2.prototype._updateMatricesForEffect = function(name2, mat) {
    this._currentEffect.setMatrices(name2, mat);
  };
  UniformBuffer2.prototype._updateMatricesForUniform = function(name2, mat) {
    this.updateUniform(name2, mat, mat.length);
  };
  UniformBuffer2.prototype._updateVector3ForEffect = function(name2, vector) {
    this._currentEffect.setVector3(name2, vector);
  };
  UniformBuffer2.prototype._updateVector3ForUniform = function(name2, vector) {
    UniformBuffer2._TempBuffer[0] = vector.x;
    UniformBuffer2._TempBuffer[1] = vector.y;
    UniformBuffer2._TempBuffer[2] = vector.z;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 3);
  };
  UniformBuffer2.prototype._updateVector4ForEffect = function(name2, vector) {
    this._currentEffect.setVector4(name2, vector);
  };
  UniformBuffer2.prototype._updateVector4ForUniform = function(name2, vector) {
    UniformBuffer2._TempBuffer[0] = vector.x;
    UniformBuffer2._TempBuffer[1] = vector.y;
    UniformBuffer2._TempBuffer[2] = vector.z;
    UniformBuffer2._TempBuffer[3] = vector.w;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 4);
  };
  UniformBuffer2.prototype._updateColor3ForEffect = function(name2, color, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setColor3(name2 + suffix, color);
  };
  UniformBuffer2.prototype._updateColor3ForUniform = function(name2, color) {
    UniformBuffer2._TempBuffer[0] = color.r;
    UniformBuffer2._TempBuffer[1] = color.g;
    UniformBuffer2._TempBuffer[2] = color.b;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 3);
  };
  UniformBuffer2.prototype._updateColor4ForEffect = function(name2, color, alpha, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setColor4(name2 + suffix, color, alpha);
  };
  UniformBuffer2.prototype._updateDirectColor4ForEffect = function(name2, color, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setDirectColor4(name2 + suffix, color);
  };
  UniformBuffer2.prototype._updateColor4ForUniform = function(name2, color, alpha) {
    UniformBuffer2._TempBuffer[0] = color.r;
    UniformBuffer2._TempBuffer[1] = color.g;
    UniformBuffer2._TempBuffer[2] = color.b;
    UniformBuffer2._TempBuffer[3] = alpha;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 4);
  };
  UniformBuffer2.prototype._updateDirectColor4ForUniform = function(name2, color) {
    UniformBuffer2._TempBuffer[0] = color.r;
    UniformBuffer2._TempBuffer[1] = color.g;
    UniformBuffer2._TempBuffer[2] = color.b;
    UniformBuffer2._TempBuffer[3] = color.a;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 4);
  };
  UniformBuffer2.prototype._updateIntForEffect = function(name2, x, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setInt(name2 + suffix, x);
  };
  UniformBuffer2.prototype._updateIntForUniform = function(name2, x) {
    UniformBuffer2._TempBufferInt32View[0] = x;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 1);
  };
  UniformBuffer2.prototype._updateInt2ForEffect = function(name2, x, y, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setInt2(name2 + suffix, x, y);
  };
  UniformBuffer2.prototype._updateInt2ForUniform = function(name2, x, y) {
    UniformBuffer2._TempBufferInt32View[0] = x;
    UniformBuffer2._TempBufferInt32View[1] = y;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 2);
  };
  UniformBuffer2.prototype._updateInt3ForEffect = function(name2, x, y, z, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setInt3(name2 + suffix, x, y, z);
  };
  UniformBuffer2.prototype._updateInt3ForUniform = function(name2, x, y, z) {
    UniformBuffer2._TempBufferInt32View[0] = x;
    UniformBuffer2._TempBufferInt32View[1] = y;
    UniformBuffer2._TempBufferInt32View[2] = z;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 3);
  };
  UniformBuffer2.prototype._updateInt4ForEffect = function(name2, x, y, z, w, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    this._currentEffect.setInt4(name2 + suffix, x, y, z, w);
  };
  UniformBuffer2.prototype._updateInt4ForUniform = function(name2, x, y, z, w) {
    UniformBuffer2._TempBufferInt32View[0] = x;
    UniformBuffer2._TempBufferInt32View[1] = y;
    UniformBuffer2._TempBufferInt32View[2] = z;
    UniformBuffer2._TempBufferInt32View[3] = w;
    this.updateUniform(name2, UniformBuffer2._TempBuffer, 4);
  };
  UniformBuffer2.prototype.setTexture = function(name2, texture) {
    this._currentEffect.setTexture(name2, texture);
  };
  UniformBuffer2.prototype.updateUniformDirectly = function(uniformName, data) {
    this.updateUniform(uniformName, data, data.length);
    this.update();
  };
  UniformBuffer2.prototype.bindToEffect = function(effect, name2) {
    this._currentEffect = effect;
    this._currentEffectName = name2;
  };
  UniformBuffer2.prototype.bindUniformBuffer = function() {
    if (!this._noUBO && this._buffer && this._currentEffect) {
      this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
    }
  };
  UniformBuffer2.prototype.unbindEffect = function() {
    this._currentEffect = void 0;
    this._currentEffectName = void 0;
  };
  UniformBuffer2.prototype.setDataBuffer = function(dataBuffer) {
    if (!this._buffers) {
      return this._buffer === dataBuffer;
    }
    for (var b = 0; b < this._buffers.length; ++b) {
      var buffer = this._buffers[b];
      if (buffer[0] === dataBuffer) {
        this._bufferIndex = b;
        this._buffer = dataBuffer;
        this._createBufferOnWrite = false;
        this._currentEffect = void 0;
        return true;
      }
    }
    return false;
  };
  UniformBuffer2.prototype.dispose = function() {
    if (this._noUBO) {
      return;
    }
    var uniformBuffers = this._engine._uniformBuffers;
    var index = uniformBuffers.indexOf(this);
    if (index !== -1) {
      uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];
      uniformBuffers.pop();
    }
    if (this._engine._features.trackUbosInFrame && this._buffers) {
      for (var i = 0; i < this._buffers.length; ++i) {
        var buffer = this._buffers[i][0];
        this._engine._releaseBuffer(buffer);
      }
    } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {
      this._buffer = null;
    }
  };
  UniformBuffer2._UpdatedUbosInFrame = {};
  UniformBuffer2._MAX_UNIFORM_SIZE = 256;
  UniformBuffer2._TempBuffer = new Float32Array(UniformBuffer2._MAX_UNIFORM_SIZE);
  UniformBuffer2._TempBufferInt32View = new Uint32Array(UniformBuffer2._TempBuffer.buffer);
  return UniformBuffer2;
}();
var _MeshCollisionData = function() {
  function _MeshCollisionData2() {
    this._checkCollisions = false;
    this._collisionMask = -1;
    this._collisionGroup = -1;
    this._surroundingMeshes = null;
    this._collider = null;
    this._oldPositionForCollisions = new Vector3(0, 0, 0);
    this._diffPositionForCollisions = new Vector3(0, 0, 0);
    this._collisionResponse = true;
  }
  return _MeshCollisionData2;
}();
var _FacetDataStorage = function() {
  function _FacetDataStorage2() {
    this.facetNb = 0;
    this.partitioningSubdivisions = 10;
    this.partitioningBBoxRatio = 1.01;
    this.facetDataEnabled = false;
    this.facetParameters = {};
    this.bbSize = Vector3.Zero();
    this.subDiv = {
      max: 1,
      X: 1,
      Y: 1,
      Z: 1
    };
    this.facetDepthSort = false;
    this.facetDepthSortEnabled = false;
  }
  return _FacetDataStorage2;
}();
var _InternalAbstractMeshDataInfo = function() {
  function _InternalAbstractMeshDataInfo2() {
    this._hasVertexAlpha = false;
    this._useVertexColors = true;
    this._numBoneInfluencers = 4;
    this._applyFog = true;
    this._receiveShadows = false;
    this._facetData = new _FacetDataStorage();
    this._visibility = 1;
    this._skeleton = null;
    this._layerMask = 268435455;
    this._computeBonesUsingShaders = true;
    this._isActive = false;
    this._onlyForInstances = false;
    this._isActiveIntermediate = false;
    this._onlyForInstancesIntermediate = false;
    this._actAsRegularMesh = false;
    this._currentLOD = null;
    this._currentLODIsUpToDate = false;
    this._collisionRetryCount = 3;
    this._morphTargetManager = null;
    this._renderingGroupId = 0;
    this._bakedVertexAnimationManager = null;
    this._material = null;
    this._positions = null;
    this._meshCollisionData = new _MeshCollisionData();
    this._enableDistantPicking = false;
  }
  return _InternalAbstractMeshDataInfo2;
}();
var AbstractMesh = function(_super) {
  __extends(AbstractMesh2, _super);
  function AbstractMesh2(name2, scene) {
    if (scene === void 0) {
      scene = null;
    }
    var _this = _super.call(this, name2, scene, false) || this;
    _this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();
    _this._waitingMaterialId = null;
    _this.cullingStrategy = AbstractMesh2.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
    _this.onCollideObservable = new Observable();
    _this.onCollisionPositionChangeObservable = new Observable();
    _this.onMaterialChangedObservable = new Observable();
    _this.definedFacingForward = true;
    _this._occlusionQuery = null;
    _this._renderingGroup = null;
    _this.alphaIndex = Number.MAX_VALUE;
    _this.isVisible = true;
    _this.isPickable = true;
    _this.isNearPickable = false;
    _this.isNearGrabbable = false;
    _this.showSubMeshesBoundingBox = false;
    _this.isBlocker = false;
    _this.enablePointerMoveEvents = false;
    _this.outlineColor = Color3.Red();
    _this.outlineWidth = 0.02;
    _this.overlayColor = Color3.Red();
    _this.overlayAlpha = 0.5;
    _this.useOctreeForRenderingSelection = true;
    _this.useOctreeForPicking = true;
    _this.useOctreeForCollisions = true;
    _this.alwaysSelectAsActiveMesh = false;
    _this.doNotSyncBoundingInfo = false;
    _this.actionManager = null;
    _this.ellipsoid = new Vector3(0.5, 1, 0.5);
    _this.ellipsoidOffset = new Vector3(0, 0, 0);
    _this.edgesWidth = 1;
    _this.edgesColor = new Color4(1, 0, 0, 1);
    _this._edgesRenderer = null;
    _this._masterMesh = null;
    _this._boundingInfo = null;
    _this._boundingInfoIsDirty = true;
    _this._renderId = 0;
    _this._intersectionsInProgress = new Array();
    _this._unIndexed = false;
    _this._lightSources = new Array();
    _this._waitingData = {
      lods: null,
      actions: null,
      freezeWorldMatrix: null
    };
    _this._bonesTransformMatrices = null;
    _this._transformMatrixTexture = null;
    _this.onRebuildObservable = new Observable();
    _this._onCollisionPositionChange = function(collisionId, newPosition, collidedMesh) {
      if (collidedMesh === void 0) {
        collidedMesh = null;
      }
      newPosition.subtractToRef(_this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, _this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      if (_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {
        _this.position.addInPlace(_this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
      }
      if (collidedMesh) {
        _this.onCollideObservable.notifyObservers(collidedMesh);
      }
      _this.onCollisionPositionChangeObservable.notifyObservers(_this.position);
    };
    _this.getScene().addMesh(_this);
    _this._resyncLightSources();
    _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine(), void 0, void 0, name2, !_this.getScene().getEngine().isWebGPU);
    _this._buildUniformLayout();
    return _this;
  }
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_NONE", {
    get: function() {
      return TransformNode.BILLBOARDMODE_NONE;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_X", {
    get: function() {
      return TransformNode.BILLBOARDMODE_X;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_Y", {
    get: function() {
      return TransformNode.BILLBOARDMODE_Y;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_Z", {
    get: function() {
      return TransformNode.BILLBOARDMODE_Z;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_ALL", {
    get: function() {
      return TransformNode.BILLBOARDMODE_ALL;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2, "BILLBOARDMODE_USE_POSITION", {
    get: function() {
      return TransformNode.BILLBOARDMODE_USE_POSITION;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "facetNb", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetNb;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "partitioningSubdivisions", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
    },
    set: function(nb) {
      this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "partitioningBBoxRatio", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
    },
    set: function(ratio) {
      this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "mustDepthSortFacets", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
    },
    set: function(sort) {
      this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "facetDepthSortFrom", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
    },
    set: function(location2) {
      this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location2;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionRetryCount", {
    get: function() {
      return this._internalAbstractMeshDataInfo._collisionRetryCount;
    },
    set: function(retryCount) {
      this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "isFacetDataEnabled", {
    get: function() {
      return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "morphTargetManager", {
    get: function() {
      return this._internalAbstractMeshDataInfo._morphTargetManager;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._morphTargetManager = value;
      this._syncGeometryWithMorphTargetManager();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "bakedVertexAnimationManager", {
    get: function() {
      return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype._syncGeometryWithMorphTargetManager = function() {
  };
  AbstractMesh2.prototype._updateNonUniformScalingState = function(value) {
    if (!_super.prototype._updateNonUniformScalingState.call(this, value)) {
      return false;
    }
    this._markSubMeshesAsMiscDirty();
    return true;
  };
  Object.defineProperty(AbstractMesh2.prototype, "onCollide", {
    set: function(callback) {
      if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {
        this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);
      }
      this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "onCollisionPositionChange", {
    set: function(callback) {
      if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {
        this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);
      }
      this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "visibility", {
    get: function() {
      return this._internalAbstractMeshDataInfo._visibility;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._visibility === value) {
        return;
      }
      var oldValue = this._internalAbstractMeshDataInfo._visibility;
      this._internalAbstractMeshDataInfo._visibility = value;
      if (oldValue === 1 && value !== 1 || oldValue !== 1 && value === 1) {
        this._markSubMeshesAsMiscDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "renderingGroupId", {
    get: function() {
      return this._internalAbstractMeshDataInfo._renderingGroupId;
    },
    set: function(value) {
      this._internalAbstractMeshDataInfo._renderingGroupId = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "material", {
    get: function() {
      return this._internalAbstractMeshDataInfo._material;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._material === value) {
        return;
      }
      if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
        this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
      }
      this._internalAbstractMeshDataInfo._material = value;
      if (value && value.meshMap) {
        value.meshMap[this.uniqueId] = this;
      }
      if (this.onMaterialChangedObservable.hasObservers()) {
        this.onMaterialChangedObservable.notifyObservers(this);
      }
      if (!this.subMeshes) {
        return;
      }
      this.resetDrawCache();
      this._unBindEffect();
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.getMaterialForRenderPass = function(renderPassId) {
    var _a2;
    return (_a2 = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a2 === void 0 ? void 0 : _a2[renderPassId];
  };
  AbstractMesh2.prototype.setMaterialForRenderPass = function(renderPassId, material) {
    this.resetDrawCache(renderPassId);
    if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {
      this._internalAbstractMeshDataInfo._materialForRenderPass = [];
    }
    this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;
  };
  Object.defineProperty(AbstractMesh2.prototype, "receiveShadows", {
    get: function() {
      return this._internalAbstractMeshDataInfo._receiveShadows;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._receiveShadows === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._receiveShadows = value;
      this._markSubMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "hasVertexAlpha", {
    get: function() {
      return this._internalAbstractMeshDataInfo._hasVertexAlpha;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._hasVertexAlpha = value;
      this._markSubMeshesAsAttributesDirty();
      this._markSubMeshesAsMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "useVertexColors", {
    get: function() {
      return this._internalAbstractMeshDataInfo._useVertexColors;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._useVertexColors === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._useVertexColors = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "computeBonesUsingShaders", {
    get: function() {
      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "numBoneInfluencers", {
    get: function() {
      return this._internalAbstractMeshDataInfo._numBoneInfluencers;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._numBoneInfluencers = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "applyFog", {
    get: function() {
      return this._internalAbstractMeshDataInfo._applyFog;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._applyFog === value) {
        return;
      }
      this._internalAbstractMeshDataInfo._applyFog = value;
      this._markSubMeshesAsMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "enableDistantPicking", {
    get: function() {
      return this._internalAbstractMeshDataInfo._enableDistantPicking;
    },
    set: function(value) {
      this._internalAbstractMeshDataInfo._enableDistantPicking = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "layerMask", {
    get: function() {
      return this._internalAbstractMeshDataInfo._layerMask;
    },
    set: function(value) {
      if (value === this._internalAbstractMeshDataInfo._layerMask) {
        return;
      }
      this._internalAbstractMeshDataInfo._layerMask = value;
      this._resyncLightSources();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionMask", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
    },
    set: function(mask) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionResponse", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
    },
    set: function(response) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collisionGroup", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
    },
    set: function(mask) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "surroundingMeshes", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
    },
    set: function(meshes) {
      this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "lightSources", {
    get: function() {
      return this._lightSources;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "_positions", {
    get: function() {
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "skeleton", {
    get: function() {
      return this._internalAbstractMeshDataInfo._skeleton;
    },
    set: function(value) {
      var skeleton = this._internalAbstractMeshDataInfo._skeleton;
      if (skeleton && skeleton.needInitialSkinMatrix) {
        skeleton._unregisterMeshWithPoseMatrix(this);
      }
      if (value && value.needInitialSkinMatrix) {
        value._registerMeshWithPoseMatrix(this);
      }
      this._internalAbstractMeshDataInfo._skeleton = value;
      if (!this._internalAbstractMeshDataInfo._skeleton) {
        this._bonesTransformMatrices = null;
      }
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype._buildUniformLayout = function() {
    this._uniformBuffer.addUniform("world", 16);
    this._uniformBuffer.addUniform("visibility", 1);
    this._uniformBuffer.create();
  };
  AbstractMesh2.prototype.transferToEffect = function(world) {
    var ubo = this._uniformBuffer;
    ubo.updateMatrix("world", world);
    ubo.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility);
    ubo.update();
  };
  AbstractMesh2.prototype.getMeshUniformBuffer = function() {
    return this._uniformBuffer;
  };
  AbstractMesh2.prototype.getClassName = function() {
    return "AbstractMesh";
  };
  AbstractMesh2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
    ret += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
    var skeleton = this._internalAbstractMeshDataInfo._skeleton;
    if (skeleton) {
      ret += ", skeleton: " + skeleton.name;
    }
    if (fullDetails) {
      ret += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode];
      ret += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO");
    }
    return ret;
  };
  AbstractMesh2.prototype._getEffectiveParent = function() {
    if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh;
    }
    return _super.prototype._getEffectiveParent.call(this);
  };
  AbstractMesh2.prototype._getActionManagerForTrigger = function(trigger, initialCall) {
    if (initialCall === void 0) {
      initialCall = true;
    }
    if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {
      if (trigger) {
        if (this.actionManager.hasSpecificTrigger(trigger)) {
          return this.actionManager;
        }
      } else {
        return this.actionManager;
      }
    }
    if (!this.parent) {
      return null;
    }
    return this.parent._getActionManagerForTrigger(trigger, false);
  };
  AbstractMesh2.prototype._rebuild = function(dispose) {
    this.onRebuildObservable.notifyObservers(this);
    if (this._occlusionQuery !== null) {
      this._occlusionQuery = null;
    }
    if (!this.subMeshes) {
      return;
    }
    for (var _i = 0, _a2 = this.subMeshes; _i < _a2.length; _i++) {
      var subMesh = _a2[_i];
      subMesh._rebuild();
    }
  };
  AbstractMesh2.prototype._resyncLightSources = function() {
    this._lightSources.length = 0;
    for (var _i = 0, _a2 = this.getScene().lights; _i < _a2.length; _i++) {
      var light = _a2[_i];
      if (!light.isEnabled()) {
        continue;
      }
      if (light.canAffectMesh(this)) {
        this._lightSources.push(light);
      }
    }
    this._markSubMeshesAsLightDirty();
  };
  AbstractMesh2.prototype._resyncLightSource = function(light) {
    var isIn = light.isEnabled() && light.canAffectMesh(this);
    var index = this._lightSources.indexOf(light);
    var removed = false;
    if (index === -1) {
      if (!isIn) {
        return;
      }
      this._lightSources.push(light);
    } else {
      if (isIn) {
        return;
      }
      removed = true;
      this._lightSources.splice(index, 1);
    }
    this._markSubMeshesAsLightDirty(removed);
  };
  AbstractMesh2.prototype._unBindEffect = function() {
    for (var _i = 0, _a2 = this.subMeshes; _i < _a2.length; _i++) {
      var subMesh = _a2[_i];
      subMesh.setEffect(null);
    }
  };
  AbstractMesh2.prototype._removeLightSource = function(light, dispose) {
    var index = this._lightSources.indexOf(light);
    if (index === -1) {
      return;
    }
    this._lightSources.splice(index, 1);
    this._markSubMeshesAsLightDirty(dispose);
  };
  AbstractMesh2.prototype._markSubMeshesAsDirty = function(func) {
    if (!this.subMeshes) {
      return;
    }
    for (var _i = 0, _a2 = this.subMeshes; _i < _a2.length; _i++) {
      var subMesh = _a2[_i];
      for (var i = 0; i < subMesh._drawWrappers.length; ++i) {
        var drawWrapper = subMesh._drawWrappers[i];
        if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
          continue;
        }
        func(drawWrapper.defines);
      }
    }
  };
  AbstractMesh2.prototype._markSubMeshesAsLightDirty = function(dispose) {
    if (dispose === void 0) {
      dispose = false;
    }
    this._markSubMeshesAsDirty(function(defines) {
      return defines.markAsLightDirty(dispose);
    });
  };
  AbstractMesh2.prototype._markSubMeshesAsAttributesDirty = function() {
    this._markSubMeshesAsDirty(function(defines) {
      return defines.markAsAttributesDirty();
    });
  };
  AbstractMesh2.prototype._markSubMeshesAsMiscDirty = function() {
    this._markSubMeshesAsDirty(function(defines) {
      return defines.markAsMiscDirty();
    });
  };
  AbstractMesh2.prototype.markAsDirty = function(property) {
    this._currentRenderId = Number.MAX_VALUE;
    this._isDirty = true;
    return this;
  };
  AbstractMesh2.prototype.resetDrawCache = function(passId) {
    if (!this.subMeshes) {
      return;
    }
    for (var _i = 0, _a2 = this.subMeshes; _i < _a2.length; _i++) {
      var subMesh = _a2[_i];
      subMesh.resetDrawCache(passId);
    }
  };
  Object.defineProperty(AbstractMesh2.prototype, "isBlocked", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.getLOD = function(camera) {
    return this;
  };
  AbstractMesh2.prototype.getTotalVertices = function() {
    return 0;
  };
  AbstractMesh2.prototype.getTotalIndices = function() {
    return 0;
  };
  AbstractMesh2.prototype.getIndices = function() {
    return null;
  };
  AbstractMesh2.prototype.getVerticesData = function(kind) {
    return null;
  };
  AbstractMesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    return this;
  };
  AbstractMesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
    return this;
  };
  AbstractMesh2.prototype.setIndices = function(indices, totalVertices) {
    return this;
  };
  AbstractMesh2.prototype.isVerticesDataPresent = function(kind) {
    return false;
  };
  AbstractMesh2.prototype.getBoundingInfo = function() {
    if (this._masterMesh) {
      return this._masterMesh.getBoundingInfo();
    }
    if (this._boundingInfoIsDirty) {
      this._boundingInfoIsDirty = false;
      this._updateBoundingInfo();
    }
    return this._boundingInfo;
  };
  AbstractMesh2.prototype.setBoundingInfo = function(boundingInfo) {
    this._boundingInfo = boundingInfo;
    return this;
  };
  Object.defineProperty(AbstractMesh2.prototype, "hasBoundingInfo", {
    get: function() {
      return this._boundingInfo !== null;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.buildBoundingInfo = function(minimum, maximum, worldMatrix) {
    this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);
    return this._boundingInfo;
  };
  AbstractMesh2.prototype.normalizeToUnitCube = function(includeDescendants, ignoreRotation, predicate) {
    if (includeDescendants === void 0) {
      includeDescendants = true;
    }
    if (ignoreRotation === void 0) {
      ignoreRotation = false;
    }
    return _super.prototype.normalizeToUnitCube.call(this, includeDescendants, ignoreRotation, predicate);
  };
  Object.defineProperty(AbstractMesh2.prototype, "useBones", {
    get: function() {
      return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype._preActivate = function() {
  };
  AbstractMesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
  };
  AbstractMesh2.prototype._activate = function(renderId, intermediateRendering) {
    this._renderId = renderId;
    return true;
  };
  AbstractMesh2.prototype._postActivate = function() {
  };
  AbstractMesh2.prototype._freeze = function() {
  };
  AbstractMesh2.prototype._unFreeze = function() {
  };
  AbstractMesh2.prototype.getWorldMatrix = function() {
    if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {
      return this._masterMesh.getWorldMatrix();
    }
    return _super.prototype.getWorldMatrix.call(this);
  };
  AbstractMesh2.prototype._getWorldMatrixDeterminant = function() {
    if (this._masterMesh) {
      return this._masterMesh._getWorldMatrixDeterminant();
    }
    return _super.prototype._getWorldMatrixDeterminant.call(this);
  };
  Object.defineProperty(AbstractMesh2.prototype, "isAnInstance", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "hasInstances", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "hasThinInstances", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.movePOV = function(amountRight, amountUp, amountForward) {
    this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));
    return this;
  };
  AbstractMesh2.prototype.calcMovePOV = function(amountRight, amountUp, amountForward) {
    var rotMatrix = new Matrix();
    var rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
    rotQuaternion.toRotationMatrix(rotMatrix);
    var translationDelta = Vector3.Zero();
    var defForwardMult = this.definedFacingForward ? -1 : 1;
    Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);
    return translationDelta;
  };
  AbstractMesh2.prototype.rotatePOV = function(flipBack, twirlClockwise, tiltRight) {
    this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));
    return this;
  };
  AbstractMesh2.prototype.calcRotatePOV = function(flipBack, twirlClockwise, tiltRight) {
    var defForwardMult = this.definedFacingForward ? 1 : -1;
    return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);
  };
  AbstractMesh2.prototype.refreshBoundingInfo = function(applySkeleton, applyMorph) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (applyMorph === void 0) {
      applyMorph = false;
    }
    if (this._boundingInfo && this._boundingInfo.isLocked) {
      return this;
    }
    this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), null);
    return this;
  };
  AbstractMesh2.prototype._refreshBoundingInfo = function(data, bias) {
    if (data) {
      var extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);
      if (this._boundingInfo) {
        this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
      } else {
        this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
      }
    }
    if (this.subMeshes) {
      for (var index = 0; index < this.subMeshes.length; index++) {
        this.subMeshes[index].refreshBoundingInfo(data);
      }
    }
    this._updateBoundingInfo();
  };
  AbstractMesh2.prototype._getData = function(applySkeleton, applyMorph, data, kind) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (applyMorph === void 0) {
      applyMorph = false;
    }
    if (kind === void 0) {
      kind = VertexBuffer.PositionKind;
    }
    data = data !== null && data !== void 0 ? data : this.getVerticesData(kind).slice();
    if (data && applyMorph && this.morphTargetManager) {
      var faceIndexCount = 0;
      var positionIndex = 0;
      for (var vertexCount = 0; vertexCount < data.length; vertexCount++) {
        for (var targetCount = 0; targetCount < this.morphTargetManager.numTargets; targetCount++) {
          var targetMorph = this.morphTargetManager.getTarget(targetCount);
          var influence = targetMorph.influence;
          if (influence > 0) {
            var morphTargetPositions = targetMorph.getPositions();
            if (morphTargetPositions) {
              data[vertexCount] += (morphTargetPositions[vertexCount] - data[vertexCount]) * influence;
            }
          }
        }
        faceIndexCount++;
        if (kind === VertexBuffer.PositionKind) {
          if (this._positions && faceIndexCount === 3) {
            faceIndexCount = 0;
            var index = positionIndex * 3;
            this._positions[positionIndex++].copyFromFloats(data[index], data[index + 1], data[index + 2]);
          }
        }
      }
    }
    if (data && applySkeleton && this.skeleton) {
      var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
      var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
      if (matricesWeightsData && matricesIndicesData) {
        var needExtras = this.numBoneInfluencers > 4;
        var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
        var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
        var skeletonMatrices = this.skeleton.getTransformMatrices(this);
        var tempVector = TmpVectors.Vector3[0];
        var finalMatrix = TmpVectors.Matrix[0];
        var tempMatrix = TmpVectors.Matrix[1];
        var matWeightIdx = 0;
        for (var index = 0; index < data.length; index += 3, matWeightIdx += 4) {
          finalMatrix.reset();
          var inf = void 0;
          var weight = void 0;
          for (inf = 0; inf < 4; inf++) {
            weight = matricesWeightsData[matWeightIdx + inf];
            if (weight > 0) {
              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
              finalMatrix.addToSelf(tempMatrix);
            }
          }
          if (needExtras) {
            for (inf = 0; inf < 4; inf++) {
              weight = matricesWeightsExtraData[matWeightIdx + inf];
              if (weight > 0) {
                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
                finalMatrix.addToSelf(tempMatrix);
              }
            }
          }
          if (kind === VertexBuffer.NormalKind) {
            Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
          } else {
            Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
          }
          tempVector.toArray(data, index);
          if (kind === VertexBuffer.PositionKind && this._positions) {
            this._positions[index / 3].copyFrom(tempVector);
          }
        }
      }
    }
    return data;
  };
  AbstractMesh2.prototype.getNormalsData = function(applySkeleton, applyMorph) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (applyMorph === void 0) {
      applyMorph = false;
    }
    return this._getData(applySkeleton, applyMorph, null, VertexBuffer.NormalKind);
  };
  AbstractMesh2.prototype.getPositionData = function(applySkeleton, applyMorph, data) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (applyMorph === void 0) {
      applyMorph = false;
    }
    return this._getData(applySkeleton, applyMorph, data, VertexBuffer.PositionKind);
  };
  AbstractMesh2.prototype._getPositionData = function(applySkeleton, applyMorph) {
    var _a2;
    var data = this.getVerticesData(VertexBuffer.PositionKind);
    if (this._internalAbstractMeshDataInfo._positions) {
      this._internalAbstractMeshDataInfo._positions = null;
    }
    if (data && (applySkeleton && this.skeleton || applyMorph && this.morphTargetManager)) {
      data = data.slice();
      this._generatePointsArray();
      if (this._positions) {
        var pos = this._positions;
        this._internalAbstractMeshDataInfo._positions = new Array(pos.length);
        for (var i = 0; i < pos.length; i++) {
          this._internalAbstractMeshDataInfo._positions[i] = ((_a2 = pos[i]) === null || _a2 === void 0 ? void 0 : _a2.clone()) || new Vector3();
        }
      }
      return this.getPositionData(applySkeleton, applyMorph, data);
    }
    return data;
  };
  AbstractMesh2.prototype._updateBoundingInfo = function() {
    if (this._boundingInfo) {
      this._boundingInfo.update(this.worldMatrixFromCache);
    } else {
      this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);
    }
    this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
    return this;
  };
  AbstractMesh2.prototype._updateSubMeshesBoundingInfo = function(matrix) {
    if (!this.subMeshes) {
      return this;
    }
    var count = this.subMeshes.length;
    for (var subIndex = 0; subIndex < count; subIndex++) {
      var subMesh = this.subMeshes[subIndex];
      if (count > 1 || !subMesh.IsGlobal) {
        subMesh.updateBoundingInfo(matrix);
      }
    }
    return this;
  };
  AbstractMesh2.prototype._afterComputeWorldMatrix = function() {
    if (this.doNotSyncBoundingInfo) {
      return;
    }
    this._boundingInfoIsDirty = true;
  };
  AbstractMesh2.prototype.isInFrustum = function(frustumPlanes) {
    return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);
  };
  AbstractMesh2.prototype.isCompletelyInFrustum = function(frustumPlanes) {
    return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);
  };
  AbstractMesh2.prototype.intersectsMesh = function(mesh, precise, includeDescendants) {
    if (precise === void 0) {
      precise = false;
    }
    var boundingInfo = this.getBoundingInfo();
    var otherBoundingInfo = mesh.getBoundingInfo();
    if (boundingInfo.intersects(otherBoundingInfo, precise)) {
      return true;
    }
    if (includeDescendants) {
      for (var _i = 0, _a2 = this.getChildMeshes(); _i < _a2.length; _i++) {
        var child = _a2[_i];
        if (child.intersectsMesh(mesh, precise, true)) {
          return true;
        }
      }
    }
    return false;
  };
  AbstractMesh2.prototype.intersectsPoint = function(point) {
    return this.getBoundingInfo().intersectsPoint(point);
  };
  Object.defineProperty(AbstractMesh2.prototype, "checkCollisions", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
    },
    set: function(collisionEnabled) {
      this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractMesh2.prototype, "collider", {
    get: function() {
      return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
    },
    enumerable: false,
    configurable: true
  });
  AbstractMesh2.prototype.moveWithCollisions = function(displacement) {
    var globalPosition = this.getAbsolutePosition();
    globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
    var coordinator = this.getScene().collisionCoordinator;
    if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {
      this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();
    }
    this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;
    coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);
    return this;
  };
  AbstractMesh2.prototype._collideForSubMesh = function(subMesh, transformMatrix, collider) {
    var _a2;
    this._generatePointsArray();
    if (!this._positions) {
      return this;
    }
    if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {
      subMesh._lastColliderTransformMatrix = transformMatrix.clone();
      subMesh._lastColliderWorldVertices = [];
      subMesh._trianglePlanes = [];
      var start = subMesh.verticesStart;
      var end = subMesh.verticesStart + subMesh.verticesCount;
      for (var i = start; i < end; i++) {
        subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));
      }
    }
    collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), ((_a2 = subMesh.getMaterial()) === null || _a2 === void 0 ? void 0 : _a2.fillMode) === 7);
    return this;
  };
  AbstractMesh2.prototype._processCollisionsForSubMeshes = function(collider, transformMatrix) {
    var subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);
    var len = subMeshes.length;
    for (var index = 0; index < len; index++) {
      var subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh._checkCollision(collider)) {
        continue;
      }
      this._collideForSubMesh(subMesh, transformMatrix, collider);
    }
    return this;
  };
  AbstractMesh2.prototype._shouldConvertRHS = function() {
    return false;
  };
  AbstractMesh2.prototype._checkCollision = function(collider) {
    if (!this.getBoundingInfo()._checkCollision(collider)) {
      return this;
    }
    var collisionsScalingMatrix = TmpVectors.Matrix[0];
    var collisionsTransformMatrix = TmpVectors.Matrix[1];
    Matrix.ScalingToRef(1 / collider._radius.x, 1 / collider._radius.y, 1 / collider._radius.z, collisionsScalingMatrix);
    this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);
    this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);
    return this;
  };
  AbstractMesh2.prototype._generatePointsArray = function() {
    return false;
  };
  AbstractMesh2.prototype.intersects = function(ray, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo) {
    if (onlyBoundingInfo === void 0) {
      onlyBoundingInfo = false;
    }
    if (skipBoundingInfo === void 0) {
      skipBoundingInfo = false;
    }
    var pickingInfo = new PickingInfo();
    var intersectionThreshold = this.getClassName() === "InstancedLinesMesh" || this.getClassName() === "LinesMesh" ? this.intersectionThreshold : 0;
    var boundingInfo = this.getBoundingInfo();
    if (!this.subMeshes) {
      return pickingInfo;
    }
    if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {
      return pickingInfo;
    }
    if (onlyBoundingInfo) {
      pickingInfo.hit = skipBoundingInfo ? false : true;
      pickingInfo.pickedMesh = skipBoundingInfo ? null : this;
      pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = 0;
      return pickingInfo;
    }
    if (!this._generatePointsArray()) {
      return pickingInfo;
    }
    var intersectInfo = null;
    var subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);
    var len = subMeshes.length;
    var anySubmeshSupportIntersect = false;
    for (var index = 0; index < len; index++) {
      var subMesh = subMeshes.data[index];
      var material = subMesh.getMaterial();
      if (!material) {
        continue;
      }
      if (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2 || material.fillMode == 4) {
        anySubmeshSupportIntersect = true;
        break;
      }
    }
    if (!anySubmeshSupportIntersect) {
      pickingInfo.hit = true;
      pickingInfo.pickedMesh = this;
      pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
      pickingInfo.subMeshId = -1;
      return pickingInfo;
    }
    for (var index = 0; index < len; index++) {
      var subMesh = subMeshes.data[index];
      if (len > 1 && !subMesh.canIntersects(ray)) {
        continue;
      }
      var currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);
      if (currentIntersectInfo) {
        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
          intersectInfo = currentIntersectInfo;
          intersectInfo.subMeshId = index;
          if (fastCheck) {
            break;
          }
        }
      }
    }
    if (intersectInfo) {
      var world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.getWorldMatrix();
      var worldOrigin = TmpVectors.Vector3[0];
      var direction = TmpVectors.Vector3[1];
      Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);
      ray.direction.scaleToRef(intersectInfo.distance, direction);
      var worldDirection = Vector3.TransformNormal(direction, world);
      var pickedPoint = worldDirection.addInPlace(worldOrigin);
      pickingInfo.hit = true;
      pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);
      pickingInfo.pickedPoint = pickedPoint;
      pickingInfo.pickedMesh = this;
      pickingInfo.bu = intersectInfo.bu || 0;
      pickingInfo.bv = intersectInfo.bv || 0;
      pickingInfo.subMeshFaceId = intersectInfo.faceId;
      pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3);
      pickingInfo.subMeshId = intersectInfo.subMeshId;
      return pickingInfo;
    }
    return pickingInfo;
  };
  AbstractMesh2.prototype.clone = function(name2, newParent, doNotCloneChildren) {
    return null;
  };
  AbstractMesh2.prototype.releaseSubMeshes = function() {
    if (this.subMeshes) {
      while (this.subMeshes.length) {
        this.subMeshes[0].dispose();
      }
    } else {
      this.subMeshes = new Array();
    }
    return this;
  };
  AbstractMesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    var _this = this;
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    var index;
    if (this._scene.useMaterialMeshMap) {
      if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
        this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
      }
    }
    this.getScene().freeActiveMeshes();
    this.getScene().freeRenderingGroups();
    if (this.actionManager !== void 0 && this.actionManager !== null) {
      this.actionManager.dispose();
      this.actionManager = null;
    }
    this._internalAbstractMeshDataInfo._skeleton = null;
    if (this._transformMatrixTexture) {
      this._transformMatrixTexture.dispose();
      this._transformMatrixTexture = null;
    }
    for (index = 0; index < this._intersectionsInProgress.length; index++) {
      var other = this._intersectionsInProgress[index];
      var pos = other._intersectionsInProgress.indexOf(this);
      other._intersectionsInProgress.splice(pos, 1);
    }
    this._intersectionsInProgress = [];
    var lights = this.getScene().lights;
    lights.forEach(function(light) {
      var meshIndex = light.includedOnlyMeshes.indexOf(_this);
      if (meshIndex !== -1) {
        light.includedOnlyMeshes.splice(meshIndex, 1);
      }
      meshIndex = light.excludedMeshes.indexOf(_this);
      if (meshIndex !== -1) {
        light.excludedMeshes.splice(meshIndex, 1);
      }
      var generator = light.getShadowGenerator();
      if (generator) {
        var shadowMap = generator.getShadowMap();
        if (shadowMap && shadowMap.renderList) {
          meshIndex = shadowMap.renderList.indexOf(_this);
          if (meshIndex !== -1) {
            shadowMap.renderList.splice(meshIndex, 1);
          }
        }
      }
    });
    if (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") {
      this.releaseSubMeshes();
    }
    var engine = this.getScene().getEngine();
    if (this._occlusionQuery !== null) {
      this.isOcclusionQueryInProgress = false;
      engine.deleteQuery(this._occlusionQuery);
      this._occlusionQuery = null;
    }
    engine.wipeCaches();
    this.getScene().removeMesh(this);
    if (this._parentContainer) {
      var index_1 = this._parentContainer.meshes.indexOf(this);
      if (index_1 > -1) {
        this._parentContainer.meshes.splice(index_1, 1);
      }
      this._parentContainer = null;
    }
    if (disposeMaterialAndTextures) {
      if (this.material) {
        if (this.material.getClassName() === "MultiMaterial") {
          this.material.dispose(false, true, true);
        } else {
          this.material.dispose(false, true);
        }
      }
    }
    if (!doNotRecurse) {
      for (index = 0; index < this.getScene().particleSystems.length; index++) {
        if (this.getScene().particleSystems[index].emitter === this) {
          this.getScene().particleSystems[index].dispose();
          index--;
        }
      }
    }
    if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {
      this.disableFacetData();
    }
    this._uniformBuffer.dispose();
    this.onAfterWorldMatrixUpdateObservable.clear();
    this.onCollideObservable.clear();
    this.onCollisionPositionChangeObservable.clear();
    this.onRebuildObservable.clear();
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  AbstractMesh2.prototype.addChild = function(mesh, preserveScalingSign) {
    if (preserveScalingSign === void 0) {
      preserveScalingSign = false;
    }
    mesh.setParent(this, preserveScalingSign);
    return this;
  };
  AbstractMesh2.prototype.removeChild = function(mesh, preserveScalingSign) {
    if (preserveScalingSign === void 0) {
      preserveScalingSign = false;
    }
    mesh.setParent(null, preserveScalingSign);
    return this;
  };
  AbstractMesh2.prototype._initFacetData = function() {
    var data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetNormals) {
      data.facetNormals = new Array();
    }
    if (!data.facetPositions) {
      data.facetPositions = new Array();
    }
    if (!data.facetPartitioning) {
      data.facetPartitioning = new Array();
    }
    data.facetNb = this.getIndices().length / 3 | 0;
    data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10;
    data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01;
    for (var f = 0; f < data.facetNb; f++) {
      data.facetNormals[f] = Vector3.Zero();
      data.facetPositions[f] = Vector3.Zero();
    }
    data.facetDataEnabled = true;
    return this;
  };
  AbstractMesh2.prototype.updateFacetData = function() {
    var data = this._internalAbstractMeshDataInfo._facetData;
    if (!data.facetDataEnabled) {
      this._initFacetData();
    }
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    var indices = this.getIndices();
    var normals = this.getVerticesData(VertexBuffer.NormalKind);
    var bInfo = this.getBoundingInfo();
    if (data.facetDepthSort && !data.facetDepthSortEnabled) {
      data.facetDepthSortEnabled = true;
      if (indices instanceof Uint16Array) {
        data.depthSortedIndices = new Uint16Array(indices);
      } else if (indices instanceof Uint32Array) {
        data.depthSortedIndices = new Uint32Array(indices);
      } else {
        var needs32bits = false;
        for (var i = 0; i < indices.length; i++) {
          if (indices[i] > 65535) {
            needs32bits = true;
            break;
          }
        }
        if (needs32bits) {
          data.depthSortedIndices = new Uint32Array(indices);
        } else {
          data.depthSortedIndices = new Uint16Array(indices);
        }
      }
      data.facetDepthSortFunction = function(f1, f2) {
        return f2.sqDistance - f1.sqDistance;
      };
      if (!data.facetDepthSortFrom) {
        var camera = this.getScene().activeCamera;
        data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();
      }
      data.depthSortedFacets = [];
      for (var f = 0; f < data.facetNb; f++) {
        var depthSortedFacet = { ind: f * 3, sqDistance: 0 };
        data.depthSortedFacets.push(depthSortedFacet);
      }
      data.invertedMatrix = Matrix.Identity();
      data.facetDepthSortOrigin = Vector3.Zero();
    }
    data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;
    data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;
    data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;
    var bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;
    bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;
    data.subDiv.max = data.partitioningSubdivisions;
    data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax);
    data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax);
    data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);
    data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X;
    data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;
    data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;
    data.facetParameters.facetNormals = this.getFacetLocalNormals();
    data.facetParameters.facetPositions = this.getFacetLocalPositions();
    data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();
    data.facetParameters.bInfo = bInfo;
    data.facetParameters.bbSize = data.bbSize;
    data.facetParameters.subDiv = data.subDiv;
    data.facetParameters.ratio = this.partitioningBBoxRatio;
    data.facetParameters.depthSort = data.facetDepthSort;
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      this.computeWorldMatrix(true);
      this._worldMatrix.invertToRef(data.invertedMatrix);
      Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);
      data.facetParameters.distanceTo = data.facetDepthSortOrigin;
    }
    data.facetParameters.depthSortedFacets = data.depthSortedFacets;
    if (normals) {
      VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);
    }
    if (data.facetDepthSort && data.facetDepthSortEnabled) {
      data.depthSortedFacets.sort(data.facetDepthSortFunction);
      var l = data.depthSortedIndices.length / 3 | 0;
      for (var f = 0; f < l; f++) {
        var sind = data.depthSortedFacets[f].ind;
        data.depthSortedIndices[f * 3] = indices[sind];
        data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];
        data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];
      }
      this.updateIndices(data.depthSortedIndices, void 0, true);
    }
    return this;
  };
  AbstractMesh2.prototype.getFacetLocalNormals = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetNormals) {
      this.updateFacetData();
    }
    return facetData.facetNormals;
  };
  AbstractMesh2.prototype.getFacetLocalPositions = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPositions) {
      this.updateFacetData();
    }
    return facetData.facetPositions;
  };
  AbstractMesh2.prototype.getFacetLocalPartitioning = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (!facetData.facetPartitioning) {
      this.updateFacetData();
    }
    return facetData.facetPartitioning;
  };
  AbstractMesh2.prototype.getFacetPosition = function(i) {
    var pos = Vector3.Zero();
    this.getFacetPositionToRef(i, pos);
    return pos;
  };
  AbstractMesh2.prototype.getFacetPositionToRef = function(i, ref) {
    var localPos = this.getFacetLocalPositions()[i];
    var world = this.getWorldMatrix();
    Vector3.TransformCoordinatesToRef(localPos, world, ref);
    return this;
  };
  AbstractMesh2.prototype.getFacetNormal = function(i) {
    var norm = Vector3.Zero();
    this.getFacetNormalToRef(i, norm);
    return norm;
  };
  AbstractMesh2.prototype.getFacetNormalToRef = function(i, ref) {
    var localNorm = this.getFacetLocalNormals()[i];
    Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);
    return this;
  };
  AbstractMesh2.prototype.getFacetsAtLocalCoordinates = function(x, y, z) {
    var bInfo = this.getBoundingInfo();
    var data = this._internalAbstractMeshDataInfo._facetData;
    var ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);
    var oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);
    var oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);
    if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {
      return null;
    }
    return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];
  };
  AbstractMesh2.prototype.getClosestFacetAtCoordinates = function(x, y, z, projected, checkFace, facing) {
    if (checkFace === void 0) {
      checkFace = false;
    }
    if (facing === void 0) {
      facing = true;
    }
    var world = this.getWorldMatrix();
    var invMat = TmpVectors.Matrix[5];
    world.invertToRef(invMat);
    var invVect = TmpVectors.Vector3[8];
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect);
    var closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);
    if (projected) {
      Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);
    }
    return closest;
  };
  AbstractMesh2.prototype.getClosestFacetAtLocalCoordinates = function(x, y, z, projected, checkFace, facing) {
    if (checkFace === void 0) {
      checkFace = false;
    }
    if (facing === void 0) {
      facing = true;
    }
    var closest = null;
    var tmpx = 0;
    var tmpy = 0;
    var tmpz = 0;
    var d = 0;
    var t0 = 0;
    var projx = 0;
    var projy = 0;
    var projz = 0;
    var facetPositions = this.getFacetLocalPositions();
    var facetNormals = this.getFacetLocalNormals();
    var facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);
    if (!facetsInBlock) {
      return null;
    }
    var shortest = Number.MAX_VALUE;
    var tmpDistance = shortest;
    var fib;
    var norm;
    var p0;
    for (var idx = 0; idx < facetsInBlock.length; idx++) {
      fib = facetsInBlock[idx];
      norm = facetNormals[fib];
      p0 = facetPositions[fib];
      d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;
      if (!checkFace || checkFace && facing && d >= 0 || checkFace && !facing && d <= 0) {
        d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;
        t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);
        projx = x + norm.x * t0;
        projy = y + norm.y * t0;
        projz = z + norm.z * t0;
        tmpx = projx - x;
        tmpy = projy - y;
        tmpz = projz - z;
        tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz;
        if (tmpDistance < shortest) {
          shortest = tmpDistance;
          closest = fib;
          if (projected) {
            projected.x = projx;
            projected.y = projy;
            projected.z = projz;
          }
        }
      }
    }
    return closest;
  };
  AbstractMesh2.prototype.getFacetDataParameters = function() {
    return this._internalAbstractMeshDataInfo._facetData.facetParameters;
  };
  AbstractMesh2.prototype.disableFacetData = function() {
    var facetData = this._internalAbstractMeshDataInfo._facetData;
    if (facetData.facetDataEnabled) {
      facetData.facetDataEnabled = false;
      facetData.facetPositions = new Array();
      facetData.facetNormals = new Array();
      facetData.facetPartitioning = new Array();
      facetData.facetParameters = null;
      facetData.depthSortedIndices = new Uint32Array(0);
    }
    return this;
  };
  AbstractMesh2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
    return this;
  };
  AbstractMesh2.prototype.createNormals = function(updatable) {
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    var indices = this.getIndices();
    var normals;
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      normals = this.getVerticesData(VertexBuffer.NormalKind);
    } else {
      normals = [];
    }
    VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);
    return this;
  };
  AbstractMesh2.prototype.alignWithNormal = function(normal, upDirection) {
    if (!upDirection) {
      upDirection = Axis.Y;
    }
    var axisX = TmpVectors.Vector3[0];
    var axisZ = TmpVectors.Vector3[1];
    Vector3.CrossToRef(upDirection, normal, axisZ);
    Vector3.CrossToRef(normal, axisZ, axisX);
    if (this.rotationQuaternion) {
      Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);
    } else {
      Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);
    }
    return this;
  };
  AbstractMesh2.prototype._checkOcclusionQuery = function() {
    return false;
  };
  AbstractMesh2.prototype.disableEdgesRendering = function() {
    throw _WarnImport("EdgesRenderer");
  };
  AbstractMesh2.prototype.enableEdgesRendering = function(epsilon, checkVerticesInsteadOfIndices, options) {
    throw _WarnImport("EdgesRenderer");
  };
  AbstractMesh2.prototype.getConnectedParticleSystems = function() {
    var _this = this;
    return this._scene.particleSystems.filter(function(particleSystem) {
      return particleSystem.emitter === _this;
    });
  };
  AbstractMesh2.OCCLUSION_TYPE_NONE = 0;
  AbstractMesh2.OCCLUSION_TYPE_OPTIMISTIC = 1;
  AbstractMesh2.OCCLUSION_TYPE_STRICT = 2;
  AbstractMesh2.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
  AbstractMesh2.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
  AbstractMesh2.CULLINGSTRATEGY_STANDARD = 0;
  AbstractMesh2.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
  AbstractMesh2.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
  AbstractMesh2.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
  return AbstractMesh2;
}(TransformNode);
RegisterClass("BABYLON.AbstractMesh", AbstractMesh);
var Plane = function() {
  function Plane2(a, b, c, d) {
    this.normal = new Vector3(a, b, c);
    this.d = d;
  }
  Plane2.prototype.asArray = function() {
    return [this.normal.x, this.normal.y, this.normal.z, this.d];
  };
  Plane2.prototype.clone = function() {
    return new Plane2(this.normal.x, this.normal.y, this.normal.z, this.d);
  };
  Plane2.prototype.getClassName = function() {
    return "Plane";
  };
  Plane2.prototype.getHashCode = function() {
    var hash = this.normal.getHashCode();
    hash = hash * 397 ^ (this.d | 0);
    return hash;
  };
  Plane2.prototype.normalize = function() {
    var norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
    var magnitude = 0;
    if (norm !== 0) {
      magnitude = 1 / norm;
    }
    this.normal.x *= magnitude;
    this.normal.y *= magnitude;
    this.normal.z *= magnitude;
    this.d *= magnitude;
    return this;
  };
  Plane2.prototype.transform = function(transformation) {
    var invertedMatrix = Plane2._TmpMatrix;
    transformation.invertToRef(invertedMatrix);
    var m = invertedMatrix.m;
    var x = this.normal.x;
    var y = this.normal.y;
    var z = this.normal.z;
    var d = this.d;
    var normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];
    var normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];
    var normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];
    var finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];
    return new Plane2(normalX, normalY, normalZ, finalD);
  };
  Plane2.prototype.dotCoordinate = function(point) {
    return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;
  };
  Plane2.prototype.copyFromPoints = function(point1, point2, point3) {
    var x1 = point2.x - point1.x;
    var y1 = point2.y - point1.y;
    var z1 = point2.z - point1.z;
    var x2 = point3.x - point1.x;
    var y2 = point3.y - point1.y;
    var z2 = point3.z - point1.z;
    var yz = y1 * z2 - z1 * y2;
    var xz = z1 * x2 - x1 * z2;
    var xy = x1 * y2 - y1 * x2;
    var pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);
    var invPyth;
    if (pyth !== 0) {
      invPyth = 1 / pyth;
    } else {
      invPyth = 0;
    }
    this.normal.x = yz * invPyth;
    this.normal.y = xz * invPyth;
    this.normal.z = xy * invPyth;
    this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);
    return this;
  };
  Plane2.prototype.isFrontFacingTo = function(direction, epsilon) {
    var dot = Vector3.Dot(this.normal, direction);
    return dot <= epsilon;
  };
  Plane2.prototype.signedDistanceTo = function(point) {
    return Vector3.Dot(point, this.normal) + this.d;
  };
  Plane2.FromArray = function(array) {
    return new Plane2(array[0], array[1], array[2], array[3]);
  };
  Plane2.FromPoints = function(point1, point2, point3) {
    var result = new Plane2(0, 0, 0, 0);
    result.copyFromPoints(point1, point2, point3);
    return result;
  };
  Plane2.FromPositionAndNormal = function(origin2, normal) {
    var result = new Plane2(0, 0, 0, 0);
    normal.normalize();
    result.normal = normal;
    result.d = -(normal.x * origin2.x + normal.y * origin2.y + normal.z * origin2.z);
    return result;
  };
  Plane2.SignedDistanceToPlaneFromPositionAndNormal = function(origin2, normal, point) {
    var d = -(normal.x * origin2.x + normal.y * origin2.y + normal.z * origin2.z);
    return Vector3.Dot(point, normal) + d;
  };
  Plane2._TmpMatrix = Matrix.Identity();
  return Plane2;
}();
var SmartArray = function() {
  function SmartArray2(capacity) {
    this.length = 0;
    this.data = new Array(capacity);
    this._id = SmartArray2._GlobalId++;
  }
  SmartArray2.prototype.push = function(value) {
    this.data[this.length++] = value;
    if (this.length > this.data.length) {
      this.data.length *= 2;
    }
  };
  SmartArray2.prototype.forEach = function(func) {
    for (var index = 0; index < this.length; index++) {
      func(this.data[index]);
    }
  };
  SmartArray2.prototype.sort = function(compareFn) {
    this.data.sort(compareFn);
  };
  SmartArray2.prototype.reset = function() {
    this.length = 0;
  };
  SmartArray2.prototype.dispose = function() {
    this.reset();
    if (this.data) {
      this.data.length = 0;
      this.data = [];
    }
  };
  SmartArray2.prototype.concat = function(array) {
    if (array.length === 0) {
      return;
    }
    if (this.length + array.length > this.data.length) {
      this.data.length = (this.length + array.length) * 2;
    }
    for (var index = 0; index < array.length; index++) {
      this.data[this.length++] = (array.data || array)[index];
    }
  };
  SmartArray2.prototype.indexOf = function(value) {
    var position = this.data.indexOf(value);
    if (position >= this.length) {
      return -1;
    }
    return position;
  };
  SmartArray2.prototype.contains = function(value) {
    return this.indexOf(value) !== -1;
  };
  SmartArray2._GlobalId = 0;
  return SmartArray2;
}();
var SmartArrayNoDuplicate = function(_super) {
  __extends(SmartArrayNoDuplicate2, _super);
  function SmartArrayNoDuplicate2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._duplicateId = 0;
    return _this;
  }
  SmartArrayNoDuplicate2.prototype.push = function(value) {
    _super.prototype.push.call(this, value);
    if (!value.__smartArrayFlags) {
      value.__smartArrayFlags = {};
    }
    value.__smartArrayFlags[this._id] = this._duplicateId;
  };
  SmartArrayNoDuplicate2.prototype.pushNoDuplicate = function(value) {
    if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {
      return false;
    }
    this.push(value);
    return true;
  };
  SmartArrayNoDuplicate2.prototype.reset = function() {
    _super.prototype.reset.call(this);
    this._duplicateId++;
  };
  SmartArrayNoDuplicate2.prototype.concatWithNoDuplicate = function(array) {
    if (array.length === 0) {
      return;
    }
    if (this.length + array.length > this.data.length) {
      this.data.length = (this.length + array.length) * 2;
    }
    for (var index = 0; index < array.length; index++) {
      var item = (array.data || array)[index];
      this.pushNoDuplicate(item);
    }
  };
  return SmartArrayNoDuplicate2;
}(SmartArray);
var Viewport = function() {
  function Viewport2(x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  Viewport2.prototype.toGlobal = function(renderWidth, renderHeight) {
    return new Viewport2(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);
  };
  Viewport2.prototype.toGlobalToRef = function(renderWidth, renderHeight, ref) {
    ref.x = this.x * renderWidth;
    ref.y = this.y * renderHeight;
    ref.width = this.width * renderWidth;
    ref.height = this.height * renderHeight;
    return this;
  };
  Viewport2.prototype.clone = function() {
    return new Viewport2(this.x, this.y, this.width, this.height);
  };
  return Viewport2;
}();
var Frustum = function() {
  function Frustum2() {
  }
  Frustum2.GetPlanes = function(transform2) {
    var frustumPlanes = [];
    for (var index = 0; index < 6; index++) {
      frustumPlanes.push(new Plane(0, 0, 0, 0));
    }
    Frustum2.GetPlanesToRef(transform2, frustumPlanes);
    return frustumPlanes;
  };
  Frustum2.GetNearPlaneToRef = function(transform2, frustumPlane) {
    var m = transform2.m;
    frustumPlane.normal.x = m[3] + m[2];
    frustumPlane.normal.y = m[7] + m[6];
    frustumPlane.normal.z = m[11] + m[10];
    frustumPlane.d = m[15] + m[14];
    frustumPlane.normalize();
  };
  Frustum2.GetFarPlaneToRef = function(transform2, frustumPlane) {
    var m = transform2.m;
    frustumPlane.normal.x = m[3] - m[2];
    frustumPlane.normal.y = m[7] - m[6];
    frustumPlane.normal.z = m[11] - m[10];
    frustumPlane.d = m[15] - m[14];
    frustumPlane.normalize();
  };
  Frustum2.GetLeftPlaneToRef = function(transform2, frustumPlane) {
    var m = transform2.m;
    frustumPlane.normal.x = m[3] + m[0];
    frustumPlane.normal.y = m[7] + m[4];
    frustumPlane.normal.z = m[11] + m[8];
    frustumPlane.d = m[15] + m[12];
    frustumPlane.normalize();
  };
  Frustum2.GetRightPlaneToRef = function(transform2, frustumPlane) {
    var m = transform2.m;
    frustumPlane.normal.x = m[3] - m[0];
    frustumPlane.normal.y = m[7] - m[4];
    frustumPlane.normal.z = m[11] - m[8];
    frustumPlane.d = m[15] - m[12];
    frustumPlane.normalize();
  };
  Frustum2.GetTopPlaneToRef = function(transform2, frustumPlane) {
    var m = transform2.m;
    frustumPlane.normal.x = m[3] - m[1];
    frustumPlane.normal.y = m[7] - m[5];
    frustumPlane.normal.z = m[11] - m[9];
    frustumPlane.d = m[15] - m[13];
    frustumPlane.normalize();
  };
  Frustum2.GetBottomPlaneToRef = function(transform2, frustumPlane) {
    var m = transform2.m;
    frustumPlane.normal.x = m[3] + m[1];
    frustumPlane.normal.y = m[7] + m[5];
    frustumPlane.normal.z = m[11] + m[9];
    frustumPlane.d = m[15] + m[13];
    frustumPlane.normalize();
  };
  Frustum2.GetPlanesToRef = function(transform2, frustumPlanes) {
    Frustum2.GetNearPlaneToRef(transform2, frustumPlanes[0]);
    Frustum2.GetFarPlaneToRef(transform2, frustumPlanes[1]);
    Frustum2.GetLeftPlaneToRef(transform2, frustumPlanes[2]);
    Frustum2.GetRightPlaneToRef(transform2, frustumPlanes[3]);
    Frustum2.GetTopPlaneToRef(transform2, frustumPlanes[4]);
    Frustum2.GetBottomPlaneToRef(transform2, frustumPlanes[5]);
  };
  return Frustum2;
}();
var Camera = function(_super) {
  __extends(Camera2, _super);
  function Camera2(name2, position, scene, setActiveOnSceneIfNoneActive) {
    if (setActiveOnSceneIfNoneActive === void 0) {
      setActiveOnSceneIfNoneActive = true;
    }
    var _this = _super.call(this, name2, scene) || this;
    _this._position = Vector3.Zero();
    _this._upVector = Vector3.Up();
    _this.orthoLeft = null;
    _this.orthoRight = null;
    _this.orthoBottom = null;
    _this.orthoTop = null;
    _this.fov = 0.8;
    _this.projectionPlaneTilt = 0;
    _this.minZ = 1;
    _this.maxZ = 1e4;
    _this.inertia = 0.9;
    _this.mode = Camera2.PERSPECTIVE_CAMERA;
    _this.isIntermediate = false;
    _this.viewport = new Viewport(0, 0, 1, 1);
    _this.layerMask = 268435455;
    _this.fovMode = Camera2.FOVMODE_VERTICAL_FIXED;
    _this.cameraRigMode = Camera2.RIG_MODE_NONE;
    _this.customRenderTargets = new Array();
    _this.outputRenderTarget = null;
    _this.onViewMatrixChangedObservable = new Observable();
    _this.onProjectionMatrixChangedObservable = new Observable();
    _this.onAfterCheckInputsObservable = new Observable();
    _this.onRestoreStateObservable = new Observable();
    _this.isRigCamera = false;
    _this._rigCameras = new Array();
    _this._webvrViewMatrix = Matrix.Identity();
    _this._skipRendering = false;
    _this._projectionMatrix = new Matrix();
    _this._postProcesses = new Array();
    _this._activeMeshes = new SmartArray(256);
    _this._globalPosition = Vector3.Zero();
    _this._computedViewMatrix = Matrix.Identity();
    _this._doNotComputeProjectionMatrix = false;
    _this._transformMatrix = Matrix.Zero();
    _this._refreshFrustumPlanes = true;
    _this._absoluteRotation = Quaternion.Identity();
    _this._isCamera = true;
    _this._isLeftCamera = false;
    _this._isRightCamera = false;
    _this.getScene().addCamera(_this);
    if (setActiveOnSceneIfNoneActive && !_this.getScene().activeCamera) {
      _this.getScene().activeCamera = _this;
    }
    _this.position = position;
    _this.renderPassId = _this.getScene().getEngine().createRenderPassId("Camera ".concat(name2));
    return _this;
  }
  Object.defineProperty(Camera2.prototype, "position", {
    get: function() {
      return this._position;
    },
    set: function(newPosition) {
      this._position = newPosition;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "upVector", {
    get: function() {
      return this._upVector;
    },
    set: function(vec) {
      this._upVector = vec;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "screenArea", {
    get: function() {
      var _a2, _b2, _c2, _d;
      var x = 0;
      var y = 0;
      if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
        if (this.fovMode === Camera2.FOVMODE_VERTICAL_FIXED) {
          y = this.minZ * 2 * Math.tan(this.fov / 2);
          x = this.getEngine().getAspectRatio(this) * y;
        } else {
          x = this.minZ * 2 * Math.tan(this.fov / 2);
          y = x / this.getEngine().getAspectRatio(this);
        }
      } else {
        var halfWidth = this.getEngine().getRenderWidth() / 2;
        var halfHeight = this.getEngine().getRenderHeight() / 2;
        x = ((_a2 = this.orthoRight) !== null && _a2 !== void 0 ? _a2 : halfWidth) - ((_b2 = this.orthoLeft) !== null && _b2 !== void 0 ? _b2 : -halfWidth);
        y = ((_c2 = this.orthoTop) !== null && _c2 !== void 0 ? _c2 : halfHeight) - ((_d = this.orthoBottom) !== null && _d !== void 0 ? _d : -halfHeight);
      }
      return x * y;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.storeState = function() {
    this._stateStored = true;
    this._storedFov = this.fov;
    return this;
  };
  Camera2.prototype._restoreStateValues = function() {
    if (!this._stateStored) {
      return false;
    }
    this.fov = this._storedFov;
    return true;
  };
  Camera2.prototype.restoreState = function() {
    if (this._restoreStateValues()) {
      this.onRestoreStateObservable.notifyObservers(this);
      return true;
    }
    return false;
  };
  Camera2.prototype.getClassName = function() {
    return "Camera";
  };
  Camera2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    ret += ", type: " + this.getClassName();
    if (this.animations) {
      for (var i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  };
  Camera2.prototype.applyVerticalCorrection = function() {
    var rot = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
  };
  Object.defineProperty(Camera2.prototype, "globalPosition", {
    get: function() {
      return this._globalPosition;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.getActiveMeshes = function() {
    return this._activeMeshes;
  };
  Camera2.prototype.isActiveMesh = function(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  };
  Camera2.prototype.isReady = function(completeCheck) {
    if (completeCheck === void 0) {
      completeCheck = false;
    }
    if (completeCheck) {
      for (var _i = 0, _a2 = this._postProcesses; _i < _a2.length; _i++) {
        var pp = _a2[_i];
        if (pp && !pp.isReady()) {
          return false;
        }
      }
    }
    return _super.prototype.isReady.call(this, completeCheck);
  };
  Camera2.prototype._initCache = function() {
    _super.prototype._initCache.call(this);
    this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    this._cache.mode = void 0;
    this._cache.minZ = void 0;
    this._cache.maxZ = void 0;
    this._cache.fov = void 0;
    this._cache.fovMode = void 0;
    this._cache.aspectRatio = void 0;
    this._cache.orthoLeft = void 0;
    this._cache.orthoRight = void 0;
    this._cache.orthoBottom = void 0;
    this._cache.orthoTop = void 0;
    this._cache.renderWidth = void 0;
    this._cache.renderHeight = void 0;
  };
  Camera2.prototype._updateCache = function(ignoreParentClass) {
    if (!ignoreParentClass) {
      _super.prototype._updateCache.call(this);
    }
    this._cache.position.copyFrom(this.position);
    this._cache.upVector.copyFrom(this.upVector);
  };
  Camera2.prototype._isSynchronized = function() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  };
  Camera2.prototype._isSynchronizedViewMatrix = function() {
    if (!_super.prototype._isSynchronized.call(this)) {
      return false;
    }
    return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
  };
  Camera2.prototype._isSynchronizedProjectionMatrix = function() {
    var check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!check) {
      return false;
    }
    var engine = this.getEngine();
    if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
      check = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
    } else {
      check = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
    }
    return check;
  };
  Camera2.prototype.attachControl = function(_ignored, _noPreventDefault) {
  };
  Camera2.prototype.detachControl = function(_ignored) {
  };
  Camera2.prototype.update = function() {
    this._checkInputs();
    if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
      this._updateRigCameras();
    }
  };
  Camera2.prototype._checkInputs = function() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  };
  Object.defineProperty(Camera2.prototype, "rigCameras", {
    get: function() {
      return this._rigCameras;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "rigPostProcess", {
    get: function() {
      return this._rigPostProcess;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype._getFirstPostProcess = function() {
    for (var ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
      if (this._postProcesses[ppIndex] !== null) {
        return this._postProcesses[ppIndex];
      }
    }
    return null;
  };
  Camera2.prototype._cascadePostProcessesToRigCams = function() {
    var firstPostProcess = this._getFirstPostProcess();
    if (firstPostProcess) {
      firstPostProcess.markTextureDirty();
    }
    for (var i = 0, len = this._rigCameras.length; i < len; i++) {
      var cam = this._rigCameras[i];
      var rigPostProcess = cam._rigPostProcess;
      if (rigPostProcess) {
        var isPass = rigPostProcess.getEffectName() === "pass";
        if (isPass) {
          cam.isIntermediate = this._postProcesses.length === 0;
        }
        cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
        rigPostProcess.markTextureDirty();
      } else {
        cam._postProcesses = this._postProcesses.slice(0);
      }
    }
  };
  Camera2.prototype.attachPostProcess = function(postProcess, insertAt) {
    if (insertAt === void 0) {
      insertAt = null;
    }
    if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
      Logger.Error("You're trying to reuse a post process not defined as reusable.");
      return 0;
    }
    if (insertAt == null || insertAt < 0) {
      this._postProcesses.push(postProcess);
    } else if (this._postProcesses[insertAt] === null) {
      this._postProcesses[insertAt] = postProcess;
    } else {
      this._postProcesses.splice(insertAt, 0, postProcess);
    }
    this._cascadePostProcessesToRigCams();
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    return this._postProcesses.indexOf(postProcess);
  };
  Camera2.prototype.detachPostProcess = function(postProcess) {
    var idx = this._postProcesses.indexOf(postProcess);
    if (idx !== -1) {
      this._postProcesses[idx] = null;
    }
    if (this._scene.prePassRenderer) {
      this._scene.prePassRenderer.markAsDirty();
    }
    this._cascadePostProcessesToRigCams();
  };
  Camera2.prototype.getWorldMatrix = function() {
    if (this._isSynchronizedViewMatrix()) {
      return this._worldMatrix;
    }
    this.getViewMatrix();
    return this._worldMatrix;
  };
  Camera2.prototype._getViewMatrix = function() {
    return Matrix.Identity();
  };
  Camera2.prototype.getViewMatrix = function(force) {
    if (!force && this._isSynchronizedViewMatrix()) {
      return this._computedViewMatrix;
    }
    this.updateCache();
    this._computedViewMatrix = this._getViewMatrix();
    this._currentRenderId = this.getScene().getRenderId();
    this._childUpdateId++;
    this._refreshFrustumPlanes = true;
    if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
      this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
    }
    if (this.parent && this.parent.onViewMatrixChangedObservable) {
      this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
    }
    this.onViewMatrixChangedObservable.notifyObservers(this);
    this._computedViewMatrix.invertToRef(this._worldMatrix);
    return this._computedViewMatrix;
  };
  Camera2.prototype.freezeProjectionMatrix = function(projection) {
    this._doNotComputeProjectionMatrix = true;
    if (projection !== void 0) {
      this._projectionMatrix = projection;
    }
  };
  Camera2.prototype.unfreezeProjectionMatrix = function() {
    this._doNotComputeProjectionMatrix = false;
  };
  Camera2.prototype.getProjectionMatrix = function(force) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h;
    if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
      return this._projectionMatrix;
    }
    this._cache.mode = this.mode;
    this._cache.minZ = this.minZ;
    this._cache.maxZ = this.maxZ;
    this._refreshFrustumPlanes = true;
    var engine = this.getEngine();
    var scene = this.getScene();
    if (this.mode === Camera2.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov;
      this._cache.fovMode = this.fovMode;
      this._cache.aspectRatio = engine.getAspectRatio(this);
      this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
      if (this.minZ <= 0) {
        this.minZ = 0.1;
      }
      var reverseDepth = engine.useReverseDepthBuffer;
      var getProjectionMatrix = void 0;
      if (scene.useRightHandedSystem) {
        getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
      } else {
        getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
      }
      getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Camera2.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, engine.useReverseDepthBuffer);
    } else {
      var halfWidth = engine.getRenderWidth() / 2;
      var halfHeight = engine.getRenderHeight() / 2;
      if (scene.useRightHandedSystem) {
        Matrix.OrthoOffCenterRHToRef((_a2 = this.orthoLeft) !== null && _a2 !== void 0 ? _a2 : -halfWidth, (_b2 = this.orthoRight) !== null && _b2 !== void 0 ? _b2 : halfWidth, (_c2 = this.orthoBottom) !== null && _c2 !== void 0 ? _c2 : -halfHeight, (_d = this.orthoTop) !== null && _d !== void 0 ? _d : halfHeight, this.minZ, this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
      } else {
        Matrix.OrthoOffCenterLHToRef((_e = this.orthoLeft) !== null && _e !== void 0 ? _e : -halfWidth, (_f = this.orthoRight) !== null && _f !== void 0 ? _f : halfWidth, (_g = this.orthoBottom) !== null && _g !== void 0 ? _g : -halfHeight, (_h = this.orthoTop) !== null && _h !== void 0 ? _h : halfHeight, this.minZ, this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
      }
      this._cache.orthoLeft = this.orthoLeft;
      this._cache.orthoRight = this.orthoRight;
      this._cache.orthoBottom = this.orthoBottom;
      this._cache.orthoTop = this.orthoTop;
      this._cache.renderWidth = engine.getRenderWidth();
      this._cache.renderHeight = engine.getRenderHeight();
    }
    this.onProjectionMatrixChangedObservable.notifyObservers(this);
    return this._projectionMatrix;
  };
  Camera2.prototype.getTransformationMatrix = function() {
    this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    return this._transformMatrix;
  };
  Camera2.prototype._updateFrustumPlanes = function() {
    if (!this._refreshFrustumPlanes) {
      return;
    }
    this.getTransformationMatrix();
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    this._refreshFrustumPlanes = false;
  };
  Camera2.prototype.isInFrustum = function(target2, checkRigCameras) {
    if (checkRigCameras === void 0) {
      checkRigCameras = false;
    }
    this._updateFrustumPlanes();
    if (checkRigCameras && this.rigCameras.length > 0) {
      var result_1 = false;
      this.rigCameras.forEach(function(cam) {
        cam._updateFrustumPlanes();
        result_1 = result_1 || target2.isInFrustum(cam._frustumPlanes);
      });
      return result_1;
    } else {
      return target2.isInFrustum(this._frustumPlanes);
    }
  };
  Camera2.prototype.isCompletelyInFrustum = function(target2) {
    this._updateFrustumPlanes();
    return target2.isCompletelyInFrustum(this._frustumPlanes);
  };
  Camera2.prototype.getForwardRay = function(length, transform2, origin2) {
    throw _WarnImport("Ray");
  };
  Camera2.prototype.getForwardRayToRef = function(refRay, length, transform2, origin2) {
    throw _WarnImport("Ray");
  };
  Camera2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this.onViewMatrixChangedObservable.clear();
    this.onProjectionMatrixChangedObservable.clear();
    this.onAfterCheckInputsObservable.clear();
    this.onRestoreStateObservable.clear();
    if (this.inputs) {
      this.inputs.clear();
    }
    this.getScene().stopAnimation(this);
    this.getScene().removeCamera(this);
    while (this._rigCameras.length > 0) {
      var camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    if (this._parentContainer) {
      var index = this._parentContainer.cameras.indexOf(this);
      if (index > -1) {
        this._parentContainer.cameras.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (this._rigPostProcess) {
      this._rigPostProcess.dispose(this);
      this._rigPostProcess = null;
      this._postProcesses = [];
    } else if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
      this._rigPostProcess = null;
      this._postProcesses = [];
    } else {
      var i_1 = this._postProcesses.length;
      while (--i_1 >= 0) {
        var postProcess = this._postProcesses[i_1];
        if (postProcess) {
          postProcess.dispose(this);
        }
      }
    }
    var i = this.customRenderTargets.length;
    while (--i >= 0) {
      this.customRenderTargets[i].dispose();
    }
    this.customRenderTargets = [];
    this._activeMeshes.dispose();
    this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  Object.defineProperty(Camera2.prototype, "isLeftCamera", {
    get: function() {
      return this._isLeftCamera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "isRightCamera", {
    get: function() {
      return this._isRightCamera;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "leftCamera", {
    get: function() {
      if (this._rigCameras.length < 1) {
        return null;
      }
      return this._rigCameras[0];
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Camera2.prototype, "rightCamera", {
    get: function() {
      if (this._rigCameras.length < 2) {
        return null;
      }
      return this._rigCameras[1];
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.getLeftTarget = function() {
    if (this._rigCameras.length < 1) {
      return null;
    }
    return this._rigCameras[0].getTarget();
  };
  Camera2.prototype.getRightTarget = function() {
    if (this._rigCameras.length < 2) {
      return null;
    }
    return this._rigCameras[1].getTarget();
  };
  Camera2.prototype.setCameraRigMode = function(mode, rigParams) {
    if (this.cameraRigMode === mode) {
      return;
    }
    while (this._rigCameras.length > 0) {
      var camera = this._rigCameras.pop();
      if (camera) {
        camera.dispose();
      }
    }
    this.cameraRigMode = mode;
    this._cameraRigParams = {};
    this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
    this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
    if (this.cameraRigMode !== Camera2.RIG_MODE_NONE) {
      var leftCamera = this.createRigCamera(this.name + "_L", 0);
      if (leftCamera) {
        leftCamera._isLeftCamera = true;
      }
      var rightCamera = this.createRigCamera(this.name + "_R", 1);
      if (rightCamera) {
        rightCamera._isRightCamera = true;
      }
      if (leftCamera && rightCamera) {
        this._rigCameras.push(leftCamera);
        this._rigCameras.push(rightCamera);
      }
    }
    this._setRigMode(rigParams);
    this._cascadePostProcessesToRigCams();
    this.update();
  };
  Camera2.prototype._setRigMode = function(rigParams) {
  };
  Camera2.prototype._getVRProjectionMatrix = function() {
    Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
    this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
    return this._projectionMatrix;
  };
  Camera2.prototype._updateCameraRotationMatrix = function() {
  };
  Camera2.prototype._updateWebVRCameraRotationMatrix = function() {
  };
  Camera2.prototype._getWebVRProjectionMatrix = function() {
    return Matrix.Identity();
  };
  Camera2.prototype._getWebVRViewMatrix = function() {
    return Matrix.Identity();
  };
  Camera2.prototype.setCameraRigParameter = function(name2, value) {
    if (!this._cameraRigParams) {
      this._cameraRigParams = {};
    }
    this._cameraRigParams[name2] = value;
    if (name2 === "interaxialDistance") {
      this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
    }
  };
  Camera2.prototype.createRigCamera = function(name2, cameraIndex) {
    return null;
  };
  Camera2.prototype._updateRigCameras = function() {
    for (var i = 0; i < this._rigCameras.length; i++) {
      this._rigCameras[i].minZ = this.minZ;
      this._rigCameras[i].maxZ = this.maxZ;
      this._rigCameras[i].fov = this.fov;
      this._rigCameras[i].upVector.copyFrom(this.upVector);
    }
    if (this.cameraRigMode === Camera2.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
      this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
    }
  };
  Camera2.prototype._setupInputs = function() {
  };
  Camera2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    if (this.inputs) {
      this.inputs.serialize(serializationObject);
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  };
  Camera2.prototype.clone = function(name2, newParent) {
    if (newParent === void 0) {
      newParent = null;
    }
    var camera = SerializationHelper.Clone(Camera2.GetConstructorFromName(this.getClassName(), name2, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    camera.name = name2;
    camera.parent = newParent;
    this.onClonedObservable.notifyObservers(camera);
    return camera;
  };
  Camera2.prototype.getDirection = function(localAxis) {
    var result = Vector3.Zero();
    this.getDirectionToRef(localAxis, result);
    return result;
  };
  Object.defineProperty(Camera2.prototype, "absoluteRotation", {
    get: function() {
      this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
      return this._absoluteRotation;
    },
    enumerable: false,
    configurable: true
  });
  Camera2.prototype.getDirectionToRef = function(localAxis, result) {
    Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
  };
  Camera2.GetConstructorFromName = function(type, name2, scene, interaxial_distance, isStereoscopicSideBySide) {
    if (interaxial_distance === void 0) {
      interaxial_distance = 0;
    }
    if (isStereoscopicSideBySide === void 0) {
      isStereoscopicSideBySide = true;
    }
    var constructorFunc = Node.Construct(type, name2, scene, {
      interaxial_distance,
      isStereoscopicSideBySide
    });
    if (constructorFunc) {
      return constructorFunc;
    }
    return function() {
      return Camera2._CreateDefaultParsedCamera(name2, scene);
    };
  };
  Camera2.prototype.computeWorldMatrix = function() {
    return this.getWorldMatrix();
  };
  Camera2.Parse = function(parsedCamera, scene) {
    var type = parsedCamera.type;
    var construct = Camera2.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
    var camera = SerializationHelper.Parse(construct, parsedCamera, scene);
    if (parsedCamera.parentId !== void 0) {
      camera._waitingParentId = parsedCamera.parentId;
    }
    if (camera.inputs) {
      camera.inputs.parse(parsedCamera);
      camera._setupInputs();
    }
    if (parsedCamera.upVector) {
      camera.upVector = Vector3.FromArray(parsedCamera.upVector);
    }
    if (camera.setPosition) {
      camera.position.copyFromFloats(0, 0, 0);
      camera.setPosition(Vector3.FromArray(parsedCamera.position));
    }
    if (parsedCamera.target) {
      if (camera.setTarget) {
        camera.setTarget(Vector3.FromArray(parsedCamera.target));
      }
    }
    if (parsedCamera.cameraRigMode) {
      var rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
      camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
    }
    if (parsedCamera.animations) {
      for (var animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
        var parsedAnimation = parsedCamera.animations[animationIndex];
        var internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          camera.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(camera, parsedCamera, scene);
    }
    if (parsedCamera.autoAnimate) {
      scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
    }
    if (parsedCamera.isEnabled !== void 0) {
      camera.setEnabled(parsedCamera.isEnabled);
    }
    return camera;
  };
  Camera2._CreateDefaultParsedCamera = function(name2, scene) {
    throw _WarnImport("UniversalCamera");
  };
  Camera2.PERSPECTIVE_CAMERA = 0;
  Camera2.ORTHOGRAPHIC_CAMERA = 1;
  Camera2.FOVMODE_VERTICAL_FIXED = 0;
  Camera2.FOVMODE_HORIZONTAL_FIXED = 1;
  Camera2.RIG_MODE_NONE = 0;
  Camera2.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
  Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
  Camera2.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
  Camera2.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
  Camera2.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
  Camera2.RIG_MODE_VR = 20;
  Camera2.RIG_MODE_WEBVR = 21;
  Camera2.RIG_MODE_CUSTOM = 22;
  Camera2.ForceAttachControlToAlwaysPreventDefault = false;
  __decorate([
    serializeAsVector3("position")
  ], Camera2.prototype, "_position", void 0);
  __decorate([
    serializeAsVector3("upVector")
  ], Camera2.prototype, "_upVector", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoLeft", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoRight", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoBottom", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "orthoTop", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "fov", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "projectionPlaneTilt", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "minZ", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "maxZ", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "inertia", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "mode", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "layerMask", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "fovMode", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "cameraRigMode", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "interaxialDistance", void 0);
  __decorate([
    serialize()
  ], Camera2.prototype, "isStereoscopicSideBySide", void 0);
  return Camera2;
}(Node);
var StringDictionary = function() {
  function StringDictionary2() {
    this._count = 0;
    this._data = {};
  }
  StringDictionary2.prototype.copyFrom = function(source) {
    var _this = this;
    this.clear();
    source.forEach(function(t, v) {
      return _this.add(t, v);
    });
  };
  StringDictionary2.prototype.get = function(key) {
    var val = this._data[key];
    if (val !== void 0) {
      return val;
    }
    return void 0;
  };
  StringDictionary2.prototype.getOrAddWithFactory = function(key, factory) {
    var val = this.get(key);
    if (val !== void 0) {
      return val;
    }
    val = factory(key);
    if (val) {
      this.add(key, val);
    }
    return val;
  };
  StringDictionary2.prototype.getOrAdd = function(key, val) {
    var curVal = this.get(key);
    if (curVal !== void 0) {
      return curVal;
    }
    this.add(key, val);
    return val;
  };
  StringDictionary2.prototype.contains = function(key) {
    return this._data[key] !== void 0;
  };
  StringDictionary2.prototype.add = function(key, value) {
    if (this._data[key] !== void 0) {
      return false;
    }
    this._data[key] = value;
    ++this._count;
    return true;
  };
  StringDictionary2.prototype.set = function(key, value) {
    if (this._data[key] === void 0) {
      return false;
    }
    this._data[key] = value;
    return true;
  };
  StringDictionary2.prototype.getAndRemove = function(key) {
    var val = this.get(key);
    if (val !== void 0) {
      delete this._data[key];
      --this._count;
      return val;
    }
    return null;
  };
  StringDictionary2.prototype.remove = function(key) {
    if (this.contains(key)) {
      delete this._data[key];
      --this._count;
      return true;
    }
    return false;
  };
  StringDictionary2.prototype.clear = function() {
    this._data = {};
    this._count = 0;
  };
  Object.defineProperty(StringDictionary2.prototype, "count", {
    get: function() {
      return this._count;
    },
    enumerable: false,
    configurable: true
  });
  StringDictionary2.prototype.forEach = function(callback) {
    for (var cur in this._data) {
      var val = this._data[cur];
      callback(cur, val);
    }
  };
  StringDictionary2.prototype.first = function(callback) {
    for (var cur in this._data) {
      var val = this._data[cur];
      var res = callback(cur, val);
      if (res) {
        return res;
      }
    }
    return null;
  };
  return StringDictionary2;
}();
var AbstractScene = function() {
  function AbstractScene2() {
    this.rootNodes = new Array();
    this.cameras = new Array();
    this.lights = new Array();
    this.meshes = new Array();
    this.skeletons = new Array();
    this.particleSystems = new Array();
    this.animations = [];
    this.animationGroups = new Array();
    this.multiMaterials = new Array();
    this.materials = new Array();
    this.morphTargetManagers = new Array();
    this.geometries = new Array();
    this.transformNodes = new Array();
    this.actionManagers = new Array();
    this.textures = new Array();
    this._environmentTexture = null;
    this.postProcesses = new Array();
  }
  AbstractScene2.AddParser = function(name2, parser) {
    this._BabylonFileParsers[name2] = parser;
  };
  AbstractScene2.GetParser = function(name2) {
    if (this._BabylonFileParsers[name2]) {
      return this._BabylonFileParsers[name2];
    }
    return null;
  };
  AbstractScene2.AddIndividualParser = function(name2, parser) {
    this._IndividualBabylonFileParsers[name2] = parser;
  };
  AbstractScene2.GetIndividualParser = function(name2) {
    if (this._IndividualBabylonFileParsers[name2]) {
      return this._IndividualBabylonFileParsers[name2];
    }
    return null;
  };
  AbstractScene2.Parse = function(jsonData, scene, container, rootUrl) {
    for (var parserName in this._BabylonFileParsers) {
      if (Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, parserName)) {
        this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);
      }
    }
  };
  Object.defineProperty(AbstractScene2.prototype, "environmentTexture", {
    get: function() {
      return this._environmentTexture;
    },
    set: function(value) {
      this._environmentTexture = value;
    },
    enumerable: false,
    configurable: true
  });
  AbstractScene2.prototype.getNodes = function() {
    var nodes = new Array();
    nodes = nodes.concat(this.meshes);
    nodes = nodes.concat(this.lights);
    nodes = nodes.concat(this.cameras);
    nodes = nodes.concat(this.transformNodes);
    this.skeletons.forEach(function(skeleton) {
      return nodes = nodes.concat(skeleton.bones);
    });
    return nodes;
  };
  AbstractScene2._BabylonFileParsers = {};
  AbstractScene2._IndividualBabylonFileParsers = {};
  return AbstractScene2;
}();
var MaterialDefines = function() {
  function MaterialDefines2(externalProperties) {
    this._isDirty = true;
    this._areLightsDirty = true;
    this._areLightsDisposed = false;
    this._areAttributesDirty = true;
    this._areTexturesDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._arePrePassDirty = true;
    this._areImageProcessingDirty = true;
    this._normals = false;
    this._uvs = false;
    this._needNormals = false;
    this._needUVs = false;
    this._externalProperties = externalProperties;
    if (externalProperties) {
      for (var prop in externalProperties) {
        if (Object.prototype.hasOwnProperty.call(externalProperties, prop)) {
          this._setDefaultValue(prop);
        }
      }
    }
  }
  Object.defineProperty(MaterialDefines2.prototype, "isDirty", {
    get: function() {
      return this._isDirty;
    },
    enumerable: false,
    configurable: true
  });
  MaterialDefines2.prototype.markAsProcessed = function() {
    this._isDirty = false;
    this._areAttributesDirty = false;
    this._areTexturesDirty = false;
    this._areFresnelDirty = false;
    this._areLightsDirty = false;
    this._areLightsDisposed = false;
    this._areMiscDirty = false;
    this._arePrePassDirty = false;
    this._areImageProcessingDirty = false;
  };
  MaterialDefines2.prototype.markAsUnprocessed = function() {
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAllAsDirty = function() {
    this._areTexturesDirty = true;
    this._areAttributesDirty = true;
    this._areLightsDirty = true;
    this._areFresnelDirty = true;
    this._areMiscDirty = true;
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsImageProcessingDirty = function() {
    this._areImageProcessingDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsLightDirty = function(disposed) {
    if (disposed === void 0) {
      disposed = false;
    }
    this._areLightsDirty = true;
    this._areLightsDisposed = this._areLightsDisposed || disposed;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsAttributesDirty = function() {
    this._areAttributesDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsTexturesDirty = function() {
    this._areTexturesDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsFresnelDirty = function() {
    this._areFresnelDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsMiscDirty = function() {
    this._areMiscDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.markAsPrePassDirty = function() {
    this._arePrePassDirty = true;
    this._isDirty = true;
  };
  MaterialDefines2.prototype.rebuild = function() {
    this._keys = [];
    for (var _i = 0, _a2 = Object.keys(this); _i < _a2.length; _i++) {
      var key = _a2[_i];
      if (key[0] === "_") {
        continue;
      }
      this._keys.push(key);
    }
    if (this._externalProperties) {
      for (var name_1 in this._externalProperties) {
        if (this._keys.indexOf(name_1) === -1) {
          this._keys.push(name_1);
        }
      }
    }
  };
  MaterialDefines2.prototype.isEqual = function(other) {
    if (this._keys.length !== other._keys.length) {
      return false;
    }
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      if (this[prop] !== other[prop]) {
        return false;
      }
    }
    return true;
  };
  MaterialDefines2.prototype.cloneTo = function(other) {
    if (this._keys.length !== other._keys.length) {
      other._keys = this._keys.slice(0);
    }
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      other[prop] = this[prop];
    }
  };
  MaterialDefines2.prototype.reset = function() {
    var _this = this;
    this._keys.forEach(function(prop) {
      return _this._setDefaultValue(prop);
    });
  };
  MaterialDefines2.prototype._setDefaultValue = function(prop) {
    var _a2, _b2, _c2, _d, _e;
    var type = (_c2 = (_b2 = (_a2 = this._externalProperties) === null || _a2 === void 0 ? void 0 : _a2[prop]) === null || _b2 === void 0 ? void 0 : _b2.type) !== null && _c2 !== void 0 ? _c2 : typeof this[prop];
    var defValue = (_e = (_d = this._externalProperties) === null || _d === void 0 ? void 0 : _d[prop]) === null || _e === void 0 ? void 0 : _e.default;
    switch (type) {
      case "number":
        this[prop] = defValue !== null && defValue !== void 0 ? defValue : 0;
        break;
      case "string":
        this[prop] = defValue !== null && defValue !== void 0 ? defValue : "";
        break;
      default:
        this[prop] = defValue !== null && defValue !== void 0 ? defValue : false;
        break;
    }
  };
  MaterialDefines2.prototype.toString = function() {
    var result = "";
    for (var index = 0; index < this._keys.length; index++) {
      var prop = this._keys[index];
      var value = this[prop];
      var type = typeof value;
      switch (type) {
        case "number":
        case "string":
          result += "#define " + prop + " " + value + "\n";
          break;
        default:
          if (value) {
            result += "#define " + prop + "\n";
          }
          break;
      }
    }
    return result;
  };
  return MaterialDefines2;
}();
var ColorCurves = function() {
  function ColorCurves2() {
    this._dirty = true;
    this._tempColor = new Color4(0, 0, 0, 0);
    this._globalCurve = new Color4(0, 0, 0, 0);
    this._highlightsCurve = new Color4(0, 0, 0, 0);
    this._midtonesCurve = new Color4(0, 0, 0, 0);
    this._shadowsCurve = new Color4(0, 0, 0, 0);
    this._positiveCurve = new Color4(0, 0, 0, 0);
    this._negativeCurve = new Color4(0, 0, 0, 0);
    this._globalHue = 30;
    this._globalDensity = 0;
    this._globalSaturation = 0;
    this._globalExposure = 0;
    this._highlightsHue = 30;
    this._highlightsDensity = 0;
    this._highlightsSaturation = 0;
    this._highlightsExposure = 0;
    this._midtonesHue = 30;
    this._midtonesDensity = 0;
    this._midtonesSaturation = 0;
    this._midtonesExposure = 0;
    this._shadowsHue = 30;
    this._shadowsDensity = 0;
    this._shadowsSaturation = 0;
    this._shadowsExposure = 0;
  }
  Object.defineProperty(ColorCurves2.prototype, "globalHue", {
    get: function() {
      return this._globalHue;
    },
    set: function(value) {
      this._globalHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "globalDensity", {
    get: function() {
      return this._globalDensity;
    },
    set: function(value) {
      this._globalDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "globalSaturation", {
    get: function() {
      return this._globalSaturation;
    },
    set: function(value) {
      this._globalSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "globalExposure", {
    get: function() {
      return this._globalExposure;
    },
    set: function(value) {
      this._globalExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsHue", {
    get: function() {
      return this._highlightsHue;
    },
    set: function(value) {
      this._highlightsHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsDensity", {
    get: function() {
      return this._highlightsDensity;
    },
    set: function(value) {
      this._highlightsDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsSaturation", {
    get: function() {
      return this._highlightsSaturation;
    },
    set: function(value) {
      this._highlightsSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "highlightsExposure", {
    get: function() {
      return this._highlightsExposure;
    },
    set: function(value) {
      this._highlightsExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesHue", {
    get: function() {
      return this._midtonesHue;
    },
    set: function(value) {
      this._midtonesHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesDensity", {
    get: function() {
      return this._midtonesDensity;
    },
    set: function(value) {
      this._midtonesDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesSaturation", {
    get: function() {
      return this._midtonesSaturation;
    },
    set: function(value) {
      this._midtonesSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "midtonesExposure", {
    get: function() {
      return this._midtonesExposure;
    },
    set: function(value) {
      this._midtonesExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsHue", {
    get: function() {
      return this._shadowsHue;
    },
    set: function(value) {
      this._shadowsHue = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsDensity", {
    get: function() {
      return this._shadowsDensity;
    },
    set: function(value) {
      this._shadowsDensity = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsSaturation", {
    get: function() {
      return this._shadowsSaturation;
    },
    set: function(value) {
      this._shadowsSaturation = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ColorCurves2.prototype, "shadowsExposure", {
    get: function() {
      return this._shadowsExposure;
    },
    set: function(value) {
      this._shadowsExposure = value;
      this._dirty = true;
    },
    enumerable: false,
    configurable: true
  });
  ColorCurves2.prototype.getClassName = function() {
    return "ColorCurves";
  };
  ColorCurves2.Bind = function(colorCurves, effect, positiveUniform, neutralUniform, negativeUniform) {
    if (positiveUniform === void 0) {
      positiveUniform = "vCameraColorCurvePositive";
    }
    if (neutralUniform === void 0) {
      neutralUniform = "vCameraColorCurveNeutral";
    }
    if (negativeUniform === void 0) {
      negativeUniform = "vCameraColorCurveNegative";
    }
    if (colorCurves._dirty) {
      colorCurves._dirty = false;
      colorCurves._getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
      colorCurves._getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
      colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
      colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
      colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
    }
    if (effect) {
      effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
      effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
      effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
    }
  };
  ColorCurves2.PrepareUniforms = function(uniformsList) {
    uniformsList.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
  };
  ColorCurves2.prototype._getColorGradingDataToRef = function(hue, density, saturation, exposure, result) {
    if (hue == null) {
      return;
    }
    hue = ColorCurves2._Clamp(hue, 0, 360);
    density = ColorCurves2._Clamp(density, -100, 100);
    saturation = ColorCurves2._Clamp(saturation, -100, 100);
    exposure = ColorCurves2._Clamp(exposure, -100, 100);
    density = ColorCurves2._ApplyColorGradingSliderNonlinear(density);
    density *= 0.5;
    exposure = ColorCurves2._ApplyColorGradingSliderNonlinear(exposure);
    if (density < 0) {
      density *= -1;
      hue = (hue + 180) % 360;
    }
    ColorCurves2._FromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
    result.scaleToRef(2, result);
    result.a = 1 + 0.01 * saturation;
  };
  ColorCurves2._ApplyColorGradingSliderNonlinear = function(value) {
    value /= 100;
    var x = Math.abs(value);
    x = Math.pow(x, 2);
    if (value < 0) {
      x *= -1;
    }
    x *= 100;
    return x;
  };
  ColorCurves2._FromHSBToRef = function(hue, saturation, brightness, result) {
    var h = ColorCurves2._Clamp(hue, 0, 360);
    var s = ColorCurves2._Clamp(saturation / 100, 0, 1);
    var v = ColorCurves2._Clamp(brightness / 100, 0, 1);
    if (s === 0) {
      result.r = v;
      result.g = v;
      result.b = v;
    } else {
      h /= 60;
      var i = Math.floor(h);
      var f = h - i;
      var p = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          result.r = v;
          result.g = t;
          result.b = p;
          break;
        case 1:
          result.r = q;
          result.g = v;
          result.b = p;
          break;
        case 2:
          result.r = p;
          result.g = v;
          result.b = t;
          break;
        case 3:
          result.r = p;
          result.g = q;
          result.b = v;
          break;
        case 4:
          result.r = t;
          result.g = p;
          result.b = v;
          break;
        default:
          result.r = v;
          result.g = p;
          result.b = q;
          break;
      }
    }
    result.a = 1;
  };
  ColorCurves2._Clamp = function(value, min, max) {
    return Math.min(Math.max(value, min), max);
  };
  ColorCurves2.prototype.clone = function() {
    return SerializationHelper.Clone(function() {
      return new ColorCurves2();
    }, this);
  };
  ColorCurves2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  ColorCurves2.Parse = function(source) {
    return SerializationHelper.Parse(function() {
      return new ColorCurves2();
    }, source, null, null);
  };
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalHue", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalDensity", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalSaturation", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_globalExposure", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsHue", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsDensity", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsSaturation", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_highlightsExposure", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesHue", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesDensity", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesSaturation", void 0);
  __decorate([
    serialize()
  ], ColorCurves2.prototype, "_midtonesExposure", void 0);
  return ColorCurves2;
}();
SerializationHelper._ColorCurvesParser = ColorCurves.Parse;
var ImageProcessingConfigurationDefines = function(_super) {
  __extends(ImageProcessingConfigurationDefines2, _super);
  function ImageProcessingConfigurationDefines2() {
    var _this = _super.call(this) || this;
    _this.IMAGEPROCESSING = false;
    _this.VIGNETTE = false;
    _this.VIGNETTEBLENDMODEMULTIPLY = false;
    _this.VIGNETTEBLENDMODEOPAQUE = false;
    _this.TONEMAPPING = false;
    _this.TONEMAPPING_ACES = false;
    _this.CONTRAST = false;
    _this.COLORCURVES = false;
    _this.COLORGRADING = false;
    _this.COLORGRADING3D = false;
    _this.SAMPLER3DGREENDEPTH = false;
    _this.SAMPLER3DBGRMAP = false;
    _this.IMAGEPROCESSINGPOSTPROCESS = false;
    _this.EXPOSURE = false;
    _this.SKIPFINALCOLORCLAMP = false;
    _this.rebuild();
    return _this;
  }
  return ImageProcessingConfigurationDefines2;
}(MaterialDefines);
var ImageProcessingConfiguration = function() {
  function ImageProcessingConfiguration2() {
    this.colorCurves = new ColorCurves();
    this._colorCurvesEnabled = false;
    this._colorGradingEnabled = false;
    this._colorGradingWithGreenDepth = true;
    this._colorGradingBGR = true;
    this._exposure = 1;
    this._toneMappingEnabled = false;
    this._toneMappingType = ImageProcessingConfiguration2.TONEMAPPING_STANDARD;
    this._contrast = 1;
    this.vignetteStretch = 0;
    this.vignetteCentreX = 0;
    this.vignetteCentreY = 0;
    this.vignetteWeight = 1.5;
    this.vignetteColor = new Color4(0, 0, 0, 0);
    this.vignetteCameraFov = 0.5;
    this._vignetteBlendMode = ImageProcessingConfiguration2.VIGNETTEMODE_MULTIPLY;
    this._vignetteEnabled = false;
    this._skipFinalColorClamp = false;
    this._applyByPostProcess = false;
    this._isEnabled = true;
    this.onUpdateParameters = new Observable();
  }
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorCurvesEnabled", {
    get: function() {
      return this._colorCurvesEnabled;
    },
    set: function(value) {
      if (this._colorCurvesEnabled === value) {
        return;
      }
      this._colorCurvesEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingTexture", {
    get: function() {
      return this._colorGradingTexture;
    },
    set: function(value) {
      if (this._colorGradingTexture === value) {
        return;
      }
      this._colorGradingTexture = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingEnabled", {
    get: function() {
      return this._colorGradingEnabled;
    },
    set: function(value) {
      if (this._colorGradingEnabled === value) {
        return;
      }
      this._colorGradingEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingWithGreenDepth", {
    get: function() {
      return this._colorGradingWithGreenDepth;
    },
    set: function(value) {
      if (this._colorGradingWithGreenDepth === value) {
        return;
      }
      this._colorGradingWithGreenDepth = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "colorGradingBGR", {
    get: function() {
      return this._colorGradingBGR;
    },
    set: function(value) {
      if (this._colorGradingBGR === value) {
        return;
      }
      this._colorGradingBGR = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "exposure", {
    get: function() {
      return this._exposure;
    },
    set: function(value) {
      if (this._exposure === value) {
        return;
      }
      this._exposure = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "toneMappingEnabled", {
    get: function() {
      return this._toneMappingEnabled;
    },
    set: function(value) {
      if (this._toneMappingEnabled === value) {
        return;
      }
      this._toneMappingEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "toneMappingType", {
    get: function() {
      return this._toneMappingType;
    },
    set: function(value) {
      if (this._toneMappingType === value) {
        return;
      }
      this._toneMappingType = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "contrast", {
    get: function() {
      return this._contrast;
    },
    set: function(value) {
      if (this._contrast === value) {
        return;
      }
      this._contrast = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "vignetteBlendMode", {
    get: function() {
      return this._vignetteBlendMode;
    },
    set: function(value) {
      if (this._vignetteBlendMode === value) {
        return;
      }
      this._vignetteBlendMode = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "vignetteEnabled", {
    get: function() {
      return this._vignetteEnabled;
    },
    set: function(value) {
      if (this._vignetteEnabled === value) {
        return;
      }
      this._vignetteEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "skipFinalColorClamp", {
    get: function() {
      return this._skipFinalColorClamp;
    },
    set: function(value) {
      if (this._skipFinalColorClamp === value) {
        return;
      }
      this._skipFinalColorClamp = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "applyByPostProcess", {
    get: function() {
      return this._applyByPostProcess;
    },
    set: function(value) {
      if (this._applyByPostProcess === value) {
        return;
      }
      this._applyByPostProcess = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2.prototype, "isEnabled", {
    get: function() {
      return this._isEnabled;
    },
    set: function(value) {
      if (this._isEnabled === value) {
        return;
      }
      this._isEnabled = value;
      this._updateParameters();
    },
    enumerable: false,
    configurable: true
  });
  ImageProcessingConfiguration2.prototype._updateParameters = function() {
    this.onUpdateParameters.notifyObservers(this);
  };
  ImageProcessingConfiguration2.prototype.getClassName = function() {
    return "ImageProcessingConfiguration";
  };
  ImageProcessingConfiguration2.PrepareUniforms = function(uniforms, defines) {
    if (defines.EXPOSURE) {
      uniforms.push("exposureLinear");
    }
    if (defines.CONTRAST) {
      uniforms.push("contrast");
    }
    if (defines.COLORGRADING) {
      uniforms.push("colorTransformSettings");
    }
    if (defines.VIGNETTE) {
      uniforms.push("vInverseScreenSize");
      uniforms.push("vignetteSettings1");
      uniforms.push("vignetteSettings2");
    }
    if (defines.COLORCURVES) {
      ColorCurves.PrepareUniforms(uniforms);
    }
  };
  ImageProcessingConfiguration2.PrepareSamplers = function(samplersList, defines) {
    if (defines.COLORGRADING) {
      samplersList.push("txColorTransform");
    }
  };
  ImageProcessingConfiguration2.prototype.prepareDefines = function(defines, forPostProcess) {
    if (forPostProcess === void 0) {
      forPostProcess = false;
    }
    if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
      defines.VIGNETTE = false;
      defines.TONEMAPPING = false;
      defines.TONEMAPPING_ACES = false;
      defines.CONTRAST = false;
      defines.EXPOSURE = false;
      defines.COLORCURVES = false;
      defines.COLORGRADING = false;
      defines.COLORGRADING3D = false;
      defines.IMAGEPROCESSING = false;
      defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
      defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    defines.VIGNETTE = this.vignetteEnabled;
    defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === ImageProcessingConfiguration2._VIGNETTEMODE_MULTIPLY;
    defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
    defines.TONEMAPPING = this.toneMappingEnabled;
    switch (this._toneMappingType) {
      case ImageProcessingConfiguration2.TONEMAPPING_ACES:
        defines.TONEMAPPING_ACES = true;
        break;
      default:
        defines.TONEMAPPING_ACES = false;
        break;
    }
    defines.CONTRAST = this.contrast !== 1;
    defines.EXPOSURE = this.exposure !== 1;
    defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
    defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
    if (defines.COLORGRADING) {
      defines.COLORGRADING3D = this.colorGradingTexture.is3D;
    } else {
      defines.COLORGRADING3D = false;
    }
    defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
    defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
    defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
    defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
    defines.IMAGEPROCESSING = defines.VIGNETTE || defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING;
  };
  ImageProcessingConfiguration2.prototype.isReady = function() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  };
  ImageProcessingConfiguration2.prototype.bind = function(effect, overrideAspectRatio) {
    if (this._colorCurvesEnabled && this.colorCurves) {
      ColorCurves.Bind(this.colorCurves, effect);
    }
    if (this._vignetteEnabled) {
      var inverseWidth = 1 / effect.getEngine().getRenderWidth();
      var inverseHeight = 1 / effect.getEngine().getRenderHeight();
      effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
      var aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
      var vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
      var vignetteScaleX = vignetteScaleY * aspectRatio;
      var vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
      vignetteScaleX = Tools.Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
      vignetteScaleY = Tools.Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
      effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCentreX, -vignetteScaleY * this.vignetteCentreY);
      var vignettePower = -2 * this.vignetteWeight;
      effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
    }
    effect.setFloat("exposureLinear", this.exposure);
    effect.setFloat("contrast", this.contrast);
    if (this.colorGradingTexture) {
      effect.setTexture("txColorTransform", this.colorGradingTexture);
      var textureSize = this.colorGradingTexture.getSize().height;
      effect.setFloat4("colorTransformSettings", (textureSize - 1) / textureSize, 0.5 / textureSize, textureSize, this.colorGradingTexture.level);
    }
  };
  ImageProcessingConfiguration2.prototype.clone = function() {
    return SerializationHelper.Clone(function() {
      return new ImageProcessingConfiguration2();
    }, this);
  };
  ImageProcessingConfiguration2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  ImageProcessingConfiguration2.Parse = function(source) {
    return SerializationHelper.Parse(function() {
      return new ImageProcessingConfiguration2();
    }, source, null, null);
  };
  Object.defineProperty(ImageProcessingConfiguration2, "VIGNETTEMODE_MULTIPLY", {
    get: function() {
      return this._VIGNETTEMODE_MULTIPLY;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ImageProcessingConfiguration2, "VIGNETTEMODE_OPAQUE", {
    get: function() {
      return this._VIGNETTEMODE_OPAQUE;
    },
    enumerable: false,
    configurable: true
  });
  ImageProcessingConfiguration2.TONEMAPPING_STANDARD = 0;
  ImageProcessingConfiguration2.TONEMAPPING_ACES = 1;
  ImageProcessingConfiguration2._VIGNETTEMODE_MULTIPLY = 0;
  ImageProcessingConfiguration2._VIGNETTEMODE_OPAQUE = 1;
  __decorate([
    serializeAsColorCurves()
  ], ImageProcessingConfiguration2.prototype, "colorCurves", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorCurvesEnabled", void 0);
  __decorate([
    serializeAsTexture("colorGradingTexture")
  ], ImageProcessingConfiguration2.prototype, "_colorGradingTexture", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorGradingEnabled", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorGradingWithGreenDepth", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_colorGradingBGR", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_exposure", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_toneMappingEnabled", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_toneMappingType", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_contrast", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteStretch", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteCentreX", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteCentreY", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteWeight", void 0);
  __decorate([
    serializeAsColor4()
  ], ImageProcessingConfiguration2.prototype, "vignetteColor", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "vignetteCameraFov", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_vignetteBlendMode", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_vignetteEnabled", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_skipFinalColorClamp", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_applyByPostProcess", void 0);
  __decorate([
    serialize()
  ], ImageProcessingConfiguration2.prototype, "_isEnabled", void 0);
  return ImageProcessingConfiguration2;
}();
SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;
var ActionEvent = function() {
  function ActionEvent2(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {
    this.source = source;
    this.pointerX = pointerX;
    this.pointerY = pointerY;
    this.meshUnderPointer = meshUnderPointer;
    this.sourceEvent = sourceEvent;
    this.additionalData = additionalData;
  }
  ActionEvent2.CreateNew = function(source, evt, additionalData) {
    var scene = source.getScene();
    return new ActionEvent2(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer || source, evt, additionalData);
  };
  ActionEvent2.CreateNewFromSprite = function(source, scene, evt, additionalData) {
    return new ActionEvent2(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);
  };
  ActionEvent2.CreateNewFromScene = function(scene, evt) {
    return new ActionEvent2(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);
  };
  ActionEvent2.CreateNewFromPrimitive = function(prim, pointerPos, evt, additionalData) {
    return new ActionEvent2(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);
  };
  return ActionEvent2;
}();
var PostProcessManager = function() {
  function PostProcessManager2(scene) {
    this._vertexBuffers = {};
    this._scene = scene;
  }
  PostProcessManager2.prototype._prepareBuffers = function() {
    if (this._vertexBuffers[VertexBuffer.PositionKind]) {
      return;
    }
    var vertices = [];
    vertices.push(1, 1);
    vertices.push(-1, 1);
    vertices.push(-1, -1);
    vertices.push(1, -1);
    this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);
    this._buildIndexBuffer();
  };
  PostProcessManager2.prototype._buildIndexBuffer = function() {
    var indices = [];
    indices.push(0);
    indices.push(1);
    indices.push(2);
    indices.push(0);
    indices.push(2);
    indices.push(3);
    this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);
  };
  PostProcessManager2.prototype._rebuild = function() {
    var vb = this._vertexBuffers[VertexBuffer.PositionKind];
    if (!vb) {
      return;
    }
    vb._rebuild();
    this._buildIndexBuffer();
  };
  PostProcessManager2.prototype._prepareFrame = function(sourceTexture, postProcesses) {
    if (sourceTexture === void 0) {
      sourceTexture = null;
    }
    if (postProcesses === void 0) {
      postProcesses = null;
    }
    var camera = this._scene.activeCamera;
    if (!camera) {
      return false;
    }
    postProcesses = postProcesses || camera._postProcesses.filter(function(pp) {
      return pp != null;
    });
    if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return false;
    }
    postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== void 0);
    return true;
  };
  PostProcessManager2.prototype.directRender = function(postProcesses, targetTexture, forceFullscreenViewport, faceIndex, lodLevel, doNotBindFrambuffer) {
    var _a2;
    if (targetTexture === void 0) {
      targetTexture = null;
    }
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = false;
    }
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (lodLevel === void 0) {
      lodLevel = 0;
    }
    if (doNotBindFrambuffer === void 0) {
      doNotBindFrambuffer = false;
    }
    var engine = this._scene.getEngine();
    for (var index = 0; index < postProcesses.length; index++) {
      if (index < postProcesses.length - 1) {
        postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport, lodLevel);
        } else if (!doNotBindFrambuffer) {
          engine.restoreDefaultFramebuffer();
        }
        (_a2 = engine._debugInsertMarker) === null || _a2 === void 0 ? void 0 : _a2.call(engine, "post process ".concat(postProcesses[index].name, " output"));
      }
      var pp = postProcesses[index];
      var effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(0, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
  };
  PostProcessManager2.prototype._finalizeFrame = function(doNotPresent, targetTexture, faceIndex, postProcesses, forceFullscreenViewport) {
    var _a2;
    if (forceFullscreenViewport === void 0) {
      forceFullscreenViewport = false;
    }
    var camera = this._scene.activeCamera;
    if (!camera) {
      return;
    }
    postProcesses = postProcesses || camera._postProcesses.filter(function(pp2) {
      return pp2 != null;
    });
    if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
      return;
    }
    var engine = this._scene.getEngine();
    for (var index = 0, len = postProcesses.length; index < len; index++) {
      var pp = postProcesses[index];
      if (index < len - 1) {
        pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
      } else {
        if (targetTexture) {
          engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport);
          pp._outputTexture = targetTexture;
        } else {
          engine.restoreDefaultFramebuffer();
          pp._outputTexture = null;
        }
        (_a2 = engine._debugInsertMarker) === null || _a2 === void 0 ? void 0 : _a2.call(engine, "post process ".concat(postProcesses[index].name, " output"));
      }
      if (doNotPresent) {
        break;
      }
      var effect = pp.apply();
      if (effect) {
        pp.onBeforeRenderObservable.notifyObservers(effect);
        this._prepareBuffers();
        engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
        engine.drawElementsType(0, 0, 6);
        pp.onAfterRenderObservable.notifyObservers(effect);
      }
    }
    engine.setDepthBuffer(true);
    engine.setDepthWrite(true);
    engine.setAlphaMode(0);
  };
  PostProcessManager2.prototype.dispose = function() {
    var buffer = this._vertexBuffers[VertexBuffer.PositionKind];
    if (buffer) {
      buffer.dispose();
      this._vertexBuffers[VertexBuffer.PositionKind] = null;
    }
    if (this._indexBuffer) {
      this._scene.getEngine()._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
  };
  return PostProcessManager2;
}();
var RenderingGroup = function() {
  function RenderingGroup2(index, scene, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this.index = index;
    this._opaqueSubMeshes = new SmartArray(256);
    this._transparentSubMeshes = new SmartArray(256);
    this._alphaTestSubMeshes = new SmartArray(256);
    this._depthOnlySubMeshes = new SmartArray(256);
    this._particleSystems = new SmartArray(256);
    this._spriteManagers = new SmartArray(256);
    this._empty = true;
    this._edgesRenderers = new SmartArrayNoDuplicate(16);
    this._scene = scene;
    this.opaqueSortCompareFn = opaqueSortCompareFn;
    this.alphaTestSortCompareFn = alphaTestSortCompareFn;
    this.transparentSortCompareFn = transparentSortCompareFn;
  }
  Object.defineProperty(RenderingGroup2.prototype, "opaqueSortCompareFn", {
    set: function(value) {
      if (value) {
        this._opaqueSortCompareFn = value;
      } else {
        this._opaqueSortCompareFn = RenderingGroup2.PainterSortCompare;
      }
      this._renderOpaque = this._renderOpaqueSorted;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderingGroup2.prototype, "alphaTestSortCompareFn", {
    set: function(value) {
      if (value) {
        this._alphaTestSortCompareFn = value;
      } else {
        this._alphaTestSortCompareFn = RenderingGroup2.PainterSortCompare;
      }
      this._renderAlphaTest = this._renderAlphaTestSorted;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(RenderingGroup2.prototype, "transparentSortCompareFn", {
    set: function(value) {
      if (value) {
        this._transparentSortCompareFn = value;
      } else {
        this._transparentSortCompareFn = RenderingGroup2.defaultTransparentSortCompare;
      }
      this._renderTransparent = this._renderTransparentSorted;
    },
    enumerable: false,
    configurable: true
  });
  RenderingGroup2.prototype.render = function(customRenderFunction, renderSprites, renderParticles, activeMeshes) {
    if (customRenderFunction) {
      customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
      return;
    }
    var engine = this._scene.getEngine();
    if (this._depthOnlySubMeshes.length !== 0) {
      engine.setColorWrite(false);
      this._renderAlphaTest(this._depthOnlySubMeshes);
      engine.setColorWrite(true);
    }
    if (this._opaqueSubMeshes.length !== 0) {
      this._renderOpaque(this._opaqueSubMeshes);
    }
    if (this._alphaTestSubMeshes.length !== 0) {
      this._renderAlphaTest(this._alphaTestSubMeshes);
    }
    var stencilState = engine.getStencilBuffer();
    engine.setStencilBuffer(false);
    if (renderSprites) {
      this._renderSprites();
    }
    if (renderParticles) {
      this._renderParticles(activeMeshes);
    }
    if (this.onBeforeTransparentRendering) {
      this.onBeforeTransparentRendering();
    }
    if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {
      engine.setStencilBuffer(stencilState);
      if (this._scene.useOrderIndependentTransparency) {
        var excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
        if (excludedMeshes.length) {
          this._renderTransparent(excludedMeshes);
        }
      } else {
        this._renderTransparent(this._transparentSubMeshes);
      }
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(false);
    if (this._edgesRenderers.length) {
      for (var edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {
        this._edgesRenderers.data[edgesRendererIndex].render();
      }
      engine.setAlphaMode(0);
    }
    engine.setStencilBuffer(stencilState);
  };
  RenderingGroup2.prototype._renderOpaqueSorted = function(subMeshes) {
    return RenderingGroup2._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);
  };
  RenderingGroup2.prototype._renderAlphaTestSorted = function(subMeshes) {
    return RenderingGroup2._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);
  };
  RenderingGroup2.prototype._renderTransparentSorted = function(subMeshes) {
    return RenderingGroup2._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);
  };
  RenderingGroup2._RenderSorted = function(subMeshes, sortCompareFn, camera, transparent) {
    var subIndex = 0;
    var subMesh;
    var cameraPosition = camera ? camera.globalPosition : RenderingGroup2._ZeroVector;
    if (transparent) {
      for (; subIndex < subMeshes.length; subIndex++) {
        subMesh = subMeshes.data[subIndex];
        subMesh._alphaIndex = subMesh.getMesh().alphaIndex;
        subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
      }
    }
    var sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);
    if (sortCompareFn) {
      sortedArray.sort(sortCompareFn);
    }
    var scene = sortedArray[0].getMesh().getScene();
    for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {
      subMesh = sortedArray[subIndex];
      if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {
        continue;
      }
      if (transparent) {
        var material = subMesh.getMaterial();
        if (material && material.needDepthPrePass) {
          var engine = material.getScene().getEngine();
          engine.setColorWrite(false);
          engine.setAlphaMode(0);
          subMesh.render(false);
          engine.setColorWrite(true);
        }
      }
      subMesh.render(transparent);
    }
  };
  RenderingGroup2.defaultTransparentSortCompare = function(a, b) {
    if (a._alphaIndex > b._alphaIndex) {
      return 1;
    }
    if (a._alphaIndex < b._alphaIndex) {
      return -1;
    }
    return RenderingGroup2.backToFrontSortCompare(a, b);
  };
  RenderingGroup2.backToFrontSortCompare = function(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return 1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return -1;
    }
    return 0;
  };
  RenderingGroup2.frontToBackSortCompare = function(a, b) {
    if (a._distanceToCamera < b._distanceToCamera) {
      return -1;
    }
    if (a._distanceToCamera > b._distanceToCamera) {
      return 1;
    }
    return 0;
  };
  RenderingGroup2.PainterSortCompare = function(a, b) {
    var meshA = a.getMesh();
    var meshB = b.getMesh();
    if (meshA.material && meshB.material) {
      return meshA.material.uniqueId - meshB.material.uniqueId;
    }
    return meshA.uniqueId - meshB.uniqueId;
  };
  RenderingGroup2.prototype.prepare = function() {
    this._opaqueSubMeshes.reset();
    this._transparentSubMeshes.reset();
    this._alphaTestSubMeshes.reset();
    this._depthOnlySubMeshes.reset();
    this._particleSystems.reset();
    this._spriteManagers.reset();
    this._edgesRenderers.reset();
    this._empty = true;
  };
  RenderingGroup2.prototype.dispose = function() {
    this._opaqueSubMeshes.dispose();
    this._transparentSubMeshes.dispose();
    this._alphaTestSubMeshes.dispose();
    this._depthOnlySubMeshes.dispose();
    this._particleSystems.dispose();
    this._spriteManagers.dispose();
    this._edgesRenderers.dispose();
  };
  RenderingGroup2.prototype.dispatch = function(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    if (material === void 0) {
      material = subMesh.getMaterial();
    }
    if (material === null || material === void 0) {
      return;
    }
    if (material.needAlphaBlendingForMesh(mesh)) {
      this._transparentSubMeshes.push(subMesh);
    } else if (material.needAlphaTesting()) {
      if (material.needDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._alphaTestSubMeshes.push(subMesh);
    } else {
      if (material.needDepthPrePass) {
        this._depthOnlySubMeshes.push(subMesh);
      }
      this._opaqueSubMeshes.push(subMesh);
    }
    mesh._renderingGroup = this;
    if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {
      this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);
    }
    this._empty = false;
  };
  RenderingGroup2.prototype.dispatchSprites = function(spriteManager) {
    this._spriteManagers.push(spriteManager);
    this._empty = false;
  };
  RenderingGroup2.prototype.dispatchParticles = function(particleSystem) {
    this._particleSystems.push(particleSystem);
    this._empty = false;
  };
  RenderingGroup2.prototype._renderParticles = function(activeMeshes) {
    if (this._particleSystems.length === 0) {
      return;
    }
    var activeCamera = this._scene.activeCamera;
    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
    for (var particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {
      var particleSystem = this._particleSystems.data[particleIndex];
      if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {
        continue;
      }
      var emitter = particleSystem.emitter;
      if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {
        this._scene._activeParticles.addCount(particleSystem.render(), false);
      }
    }
    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
  };
  RenderingGroup2.prototype._renderSprites = function() {
    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {
      return;
    }
    var activeCamera = this._scene.activeCamera;
    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
    for (var id = 0; id < this._spriteManagers.length; id++) {
      var spriteManager = this._spriteManagers.data[id];
      if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {
        spriteManager.render();
      }
    }
    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
  };
  RenderingGroup2._ZeroVector = Vector3.Zero();
  return RenderingGroup2;
}();
var RenderingGroupInfo = function() {
  function RenderingGroupInfo2() {
  }
  return RenderingGroupInfo2;
}();
var RenderingManager = function() {
  function RenderingManager2(scene) {
    this._useSceneAutoClearSetup = false;
    this._renderingGroups = new Array();
    this._autoClearDepthStencil = {};
    this._customOpaqueSortCompareFn = {};
    this._customAlphaTestSortCompareFn = {};
    this._customTransparentSortCompareFn = {};
    this._renderingGroupInfo = new RenderingGroupInfo();
    this._scene = scene;
    for (var i = RenderingManager2.MIN_RENDERINGGROUPS; i < RenderingManager2.MAX_RENDERINGGROUPS; i++) {
      this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };
    }
  }
  RenderingManager2.prototype._clearDepthStencilBuffer = function(depth, stencil) {
    if (depth === void 0) {
      depth = true;
    }
    if (stencil === void 0) {
      stencil = true;
    }
    if (this._depthStencilBufferAlreadyCleaned) {
      return;
    }
    this._scene.getEngine().clear(null, false, depth, stencil);
    this._depthStencilBufferAlreadyCleaned = true;
  };
  RenderingManager2.prototype.render = function(customRenderFunction, activeMeshes, renderParticles, renderSprites) {
    var info = this._renderingGroupInfo;
    info.scene = this._scene;
    info.camera = this._scene.activeCamera;
    if (this._scene.spriteManagers && renderSprites) {
      for (var index = 0; index < this._scene.spriteManagers.length; index++) {
        var manager = this._scene.spriteManagers[index];
        this.dispatchSprites(manager);
      }
    }
    for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
      this._depthStencilBufferAlreadyCleaned = index === RenderingManager2.MIN_RENDERINGGROUPS;
      var renderingGroup = this._renderingGroups[index];
      if (!renderingGroup || renderingGroup._empty) {
        continue;
      }
      var renderingGroupMask = Math.pow(2, index);
      info.renderingGroupId = index;
      this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
      if (RenderingManager2.AUTOCLEAR) {
        var autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];
        if (autoClear && autoClear.autoClear) {
          this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);
        }
      }
      for (var _i = 0, _a2 = this._scene._beforeRenderingGroupDrawStage; _i < _a2.length; _i++) {
        var step = _a2[_i];
        step.action(index);
      }
      renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);
      for (var _b2 = 0, _c2 = this._scene._afterRenderingGroupDrawStage; _b2 < _c2.length; _b2++) {
        var step = _c2[_b2];
        step.action(index);
      }
      this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
    }
  };
  RenderingManager2.prototype.reset = function() {
    for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
      var renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.prepare();
      }
    }
  };
  RenderingManager2.prototype.dispose = function() {
    this.freeRenderingGroups();
    this._renderingGroups.length = 0;
    this._renderingGroupInfo = null;
  };
  RenderingManager2.prototype.freeRenderingGroups = function() {
    for (var index = RenderingManager2.MIN_RENDERINGGROUPS; index < RenderingManager2.MAX_RENDERINGGROUPS; index++) {
      var renderingGroup = this._renderingGroups[index];
      if (renderingGroup) {
        renderingGroup.dispose();
      }
    }
  };
  RenderingManager2.prototype._prepareRenderingGroup = function(renderingGroupId) {
    if (this._renderingGroups[renderingGroupId] === void 0) {
      this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);
    }
  };
  RenderingManager2.prototype.dispatchSprites = function(spriteManager) {
    var renderingGroupId = spriteManager.renderingGroupId || 0;
    this._prepareRenderingGroup(renderingGroupId);
    this._renderingGroups[renderingGroupId].dispatchSprites(spriteManager);
  };
  RenderingManager2.prototype.dispatchParticles = function(particleSystem) {
    var renderingGroupId = particleSystem.renderingGroupId || 0;
    this._prepareRenderingGroup(renderingGroupId);
    this._renderingGroups[renderingGroupId].dispatchParticles(particleSystem);
  };
  RenderingManager2.prototype.dispatch = function(subMesh, mesh, material) {
    if (mesh === void 0) {
      mesh = subMesh.getMesh();
    }
    var renderingGroupId = mesh.renderingGroupId || 0;
    this._prepareRenderingGroup(renderingGroupId);
    this._renderingGroups[renderingGroupId].dispatch(subMesh, mesh, material);
  };
  RenderingManager2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;
    this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;
    this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;
    if (this._renderingGroups[renderingGroupId]) {
      var group = this._renderingGroups[renderingGroupId];
      group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];
      group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];
      group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];
    }
  };
  RenderingManager2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil, depth, stencil) {
    if (depth === void 0) {
      depth = true;
    }
    if (stencil === void 0) {
      stencil = true;
    }
    this._autoClearDepthStencil[renderingGroupId] = {
      autoClear: autoClearDepthStencil,
      depth,
      stencil
    };
  };
  RenderingManager2.prototype.getAutoClearDepthStencilSetup = function(index) {
    return this._autoClearDepthStencil[index];
  };
  RenderingManager2.MAX_RENDERINGGROUPS = 4;
  RenderingManager2.MIN_RENDERINGGROUPS = 0;
  RenderingManager2.AUTOCLEAR = true;
  return RenderingManager2;
}();
var SceneComponentConstants = function() {
  function SceneComponentConstants2() {
  }
  SceneComponentConstants2.NAME_EFFECTLAYER = "EffectLayer";
  SceneComponentConstants2.NAME_LAYER = "Layer";
  SceneComponentConstants2.NAME_LENSFLARESYSTEM = "LensFlareSystem";
  SceneComponentConstants2.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
  SceneComponentConstants2.NAME_PARTICLESYSTEM = "ParticleSystem";
  SceneComponentConstants2.NAME_GAMEPAD = "Gamepad";
  SceneComponentConstants2.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
  SceneComponentConstants2.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
  SceneComponentConstants2.NAME_PREPASSRENDERER = "PrePassRenderer";
  SceneComponentConstants2.NAME_DEPTHRENDERER = "DepthRenderer";
  SceneComponentConstants2.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
  SceneComponentConstants2.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
  SceneComponentConstants2.NAME_SPRITE = "Sprite";
  SceneComponentConstants2.NAME_SUBSURFACE = "SubSurface";
  SceneComponentConstants2.NAME_OUTLINERENDERER = "Outline";
  SceneComponentConstants2.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
  SceneComponentConstants2.NAME_SHADOWGENERATOR = "ShadowGenerator";
  SceneComponentConstants2.NAME_OCTREE = "Octree";
  SceneComponentConstants2.NAME_PHYSICSENGINE = "PhysicsEngine";
  SceneComponentConstants2.NAME_AUDIO = "Audio";
  SceneComponentConstants2.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
  SceneComponentConstants2.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
  SceneComponentConstants2.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
  SceneComponentConstants2.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
  SceneComponentConstants2.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
  SceneComponentConstants2.STEP_BEFORECAMERADRAW_PREPASS = 0;
  SceneComponentConstants2.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
  SceneComponentConstants2.STEP_BEFORECAMERADRAW_LAYER = 2;
  SceneComponentConstants2.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
  SceneComponentConstants2.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
  SceneComponentConstants2.STEP_BEFORERENDERINGMESH_PREPASS = 0;
  SceneComponentConstants2.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
  SceneComponentConstants2.STEP_AFTERRENDERINGMESH_PREPASS = 0;
  SceneComponentConstants2.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
  SceneComponentConstants2.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
  SceneComponentConstants2.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
  SceneComponentConstants2.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
  SceneComponentConstants2.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1;
  SceneComponentConstants2.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
  SceneComponentConstants2.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
  SceneComponentConstants2.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_PREPASS = 0;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
  SceneComponentConstants2.STEP_AFTERCAMERADRAW_LAYER = 4;
  SceneComponentConstants2.STEP_AFTERRENDER_AUDIO = 0;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
  SceneComponentConstants2.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
  SceneComponentConstants2.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
  SceneComponentConstants2.STEP_BEFORECLEARSTAGE_PREPASS = 0;
  SceneComponentConstants2.STEP_BEFORERENDERTARGETCLEARSTAGE_PREPASS = 0;
  SceneComponentConstants2.STEP_POINTERMOVE_SPRITE = 0;
  SceneComponentConstants2.STEP_POINTERDOWN_SPRITE = 0;
  SceneComponentConstants2.STEP_POINTERUP_SPRITE = 0;
  return SceneComponentConstants2;
}();
var Stage = function(_super) {
  __extends(Stage2, _super);
  function Stage2(items) {
    return _super.apply(this, items) || this;
  }
  Stage2.Create = function() {
    return Object.create(Stage2.prototype);
  };
  Stage2.prototype.registerStep = function(index, component, action) {
    var i = 0;
    var maxIndex = Number.MAX_VALUE;
    for (; i < this.length; i++) {
      var step = this[i];
      maxIndex = step.index;
      if (index < maxIndex) {
        break;
      }
    }
    this.splice(i, 0, { index, component, action: action.bind(component) });
  };
  Stage2.prototype.clear = function() {
    this.length = 0;
  };
  return Stage2;
}(Array);
var PointerEventTypes = function() {
  function PointerEventTypes2() {
  }
  PointerEventTypes2.POINTERDOWN = 1;
  PointerEventTypes2.POINTERUP = 2;
  PointerEventTypes2.POINTERMOVE = 4;
  PointerEventTypes2.POINTERWHEEL = 8;
  PointerEventTypes2.POINTERPICK = 16;
  PointerEventTypes2.POINTERTAP = 32;
  PointerEventTypes2.POINTERDOUBLETAP = 64;
  return PointerEventTypes2;
}();
var PointerInfoBase = function() {
  function PointerInfoBase2(type, event) {
    this.type = type;
    this.event = event;
  }
  return PointerInfoBase2;
}();
var PointerInfoPre = function(_super) {
  __extends(PointerInfoPre2, _super);
  function PointerInfoPre2(type, event, localX, localY) {
    var _this = _super.call(this, type, event) || this;
    _this.ray = null;
    _this.skipOnPointerObservable = false;
    _this.localPosition = new Vector2(localX, localY);
    return _this;
  }
  return PointerInfoPre2;
}(PointerInfoBase);
var PointerInfo = function(_super) {
  __extends(PointerInfo2, _super);
  function PointerInfo2(type, event, pickInfo) {
    var _this = _super.call(this, type, event) || this;
    _this.pickInfo = pickInfo;
    return _this;
  }
  return PointerInfo2;
}(PointerInfoBase);
var AbstractActionManager = function() {
  function AbstractActionManager2() {
    this.hoverCursor = "";
    this.actions = new Array();
    this.isRecursive = false;
  }
  Object.defineProperty(AbstractActionManager2, "HasTriggers", {
    get: function() {
      for (var t in AbstractActionManager2.Triggers) {
        if (Object.prototype.hasOwnProperty.call(AbstractActionManager2.Triggers, t)) {
          return true;
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(AbstractActionManager2, "HasPickTriggers", {
    get: function() {
      for (var t in AbstractActionManager2.Triggers) {
        if (Object.prototype.hasOwnProperty.call(AbstractActionManager2.Triggers, t)) {
          var tAsInt = parseInt(t);
          if (tAsInt >= 1 && tAsInt <= 7) {
            return true;
          }
        }
      }
      return false;
    },
    enumerable: false,
    configurable: true
  });
  AbstractActionManager2.HasSpecificTrigger = function(trigger) {
    for (var t in AbstractActionManager2.Triggers) {
      if (Object.prototype.hasOwnProperty.call(AbstractActionManager2.Triggers, t)) {
        var tAsInt = parseInt(t);
        if (tAsInt === trigger) {
          return true;
        }
      }
    }
    return false;
  };
  AbstractActionManager2.Triggers = {};
  return AbstractActionManager2;
}();
var KeyboardEventTypes = function() {
  function KeyboardEventTypes2() {
  }
  KeyboardEventTypes2.KEYDOWN = 1;
  KeyboardEventTypes2.KEYUP = 2;
  return KeyboardEventTypes2;
}();
var KeyboardInfo = function() {
  function KeyboardInfo2(type, event) {
    this.type = type;
    this.event = event;
  }
  return KeyboardInfo2;
}();
var KeyboardInfoPre = function(_super) {
  __extends(KeyboardInfoPre2, _super);
  function KeyboardInfoPre2(type, event) {
    var _this = _super.call(this, type, event) || this;
    _this.type = type;
    _this.event = event;
    _this.skipOnKeyboardObservable = false;
    return _this;
  }
  Object.defineProperty(KeyboardInfoPre2.prototype, "skipOnPointerObservable", {
    get: function() {
      return this.skipOnKeyboardObservable;
    },
    set: function(value) {
      this.skipOnKeyboardObservable = value;
    },
    enumerable: false,
    configurable: true
  });
  return KeyboardInfoPre2;
}(KeyboardInfo);
var DeviceType;
(function(DeviceType2) {
  DeviceType2[DeviceType2["Generic"] = 0] = "Generic";
  DeviceType2[DeviceType2["Keyboard"] = 1] = "Keyboard";
  DeviceType2[DeviceType2["Mouse"] = 2] = "Mouse";
  DeviceType2[DeviceType2["Touch"] = 3] = "Touch";
  DeviceType2[DeviceType2["DualShock"] = 4] = "DualShock";
  DeviceType2[DeviceType2["Xbox"] = 5] = "Xbox";
  DeviceType2[DeviceType2["Switch"] = 6] = "Switch";
  DeviceType2[DeviceType2["DualSense"] = 7] = "DualSense";
})(DeviceType || (DeviceType = {}));
var PointerInput;
(function(PointerInput2) {
  PointerInput2[PointerInput2["Horizontal"] = 0] = "Horizontal";
  PointerInput2[PointerInput2["Vertical"] = 1] = "Vertical";
  PointerInput2[PointerInput2["LeftClick"] = 2] = "LeftClick";
  PointerInput2[PointerInput2["MiddleClick"] = 3] = "MiddleClick";
  PointerInput2[PointerInput2["RightClick"] = 4] = "RightClick";
  PointerInput2[PointerInput2["BrowserBack"] = 5] = "BrowserBack";
  PointerInput2[PointerInput2["BrowserForward"] = 6] = "BrowserForward";
  PointerInput2[PointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  PointerInput2[PointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  PointerInput2[PointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  PointerInput2[PointerInput2["Move"] = 12] = "Move";
})(PointerInput || (PointerInput = {}));
var NativePointerInput;
(function(NativePointerInput2) {
  NativePointerInput2[NativePointerInput2["Horizontal"] = 0] = "Horizontal";
  NativePointerInput2[NativePointerInput2["Vertical"] = 1] = "Vertical";
  NativePointerInput2[NativePointerInput2["LeftClick"] = 2] = "LeftClick";
  NativePointerInput2[NativePointerInput2["MiddleClick"] = 3] = "MiddleClick";
  NativePointerInput2[NativePointerInput2["RightClick"] = 4] = "RightClick";
  NativePointerInput2[NativePointerInput2["BrowserBack"] = 5] = "BrowserBack";
  NativePointerInput2[NativePointerInput2["BrowserForward"] = 6] = "BrowserForward";
  NativePointerInput2[NativePointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
  NativePointerInput2[NativePointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
  NativePointerInput2[NativePointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
  NativePointerInput2[NativePointerInput2["DeltaHorizontal"] = 10] = "DeltaHorizontal";
  NativePointerInput2[NativePointerInput2["DeltaVertical"] = 11] = "DeltaVertical";
})(NativePointerInput || (NativePointerInput = {}));
var DualShockInput;
(function(DualShockInput2) {
  DualShockInput2[DualShockInput2["Cross"] = 0] = "Cross";
  DualShockInput2[DualShockInput2["Circle"] = 1] = "Circle";
  DualShockInput2[DualShockInput2["Square"] = 2] = "Square";
  DualShockInput2[DualShockInput2["Triangle"] = 3] = "Triangle";
  DualShockInput2[DualShockInput2["L1"] = 4] = "L1";
  DualShockInput2[DualShockInput2["R1"] = 5] = "R1";
  DualShockInput2[DualShockInput2["L2"] = 6] = "L2";
  DualShockInput2[DualShockInput2["R2"] = 7] = "R2";
  DualShockInput2[DualShockInput2["Share"] = 8] = "Share";
  DualShockInput2[DualShockInput2["Options"] = 9] = "Options";
  DualShockInput2[DualShockInput2["L3"] = 10] = "L3";
  DualShockInput2[DualShockInput2["R3"] = 11] = "R3";
  DualShockInput2[DualShockInput2["DPadUp"] = 12] = "DPadUp";
  DualShockInput2[DualShockInput2["DPadDown"] = 13] = "DPadDown";
  DualShockInput2[DualShockInput2["DPadLeft"] = 14] = "DPadLeft";
  DualShockInput2[DualShockInput2["DPadRight"] = 15] = "DPadRight";
  DualShockInput2[DualShockInput2["Home"] = 16] = "Home";
  DualShockInput2[DualShockInput2["TouchPad"] = 17] = "TouchPad";
  DualShockInput2[DualShockInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualShockInput2[DualShockInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualShockInput2[DualShockInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualShockInput2[DualShockInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualShockInput || (DualShockInput = {}));
var DualSenseInput;
(function(DualSenseInput2) {
  DualSenseInput2[DualSenseInput2["Cross"] = 0] = "Cross";
  DualSenseInput2[DualSenseInput2["Circle"] = 1] = "Circle";
  DualSenseInput2[DualSenseInput2["Square"] = 2] = "Square";
  DualSenseInput2[DualSenseInput2["Triangle"] = 3] = "Triangle";
  DualSenseInput2[DualSenseInput2["L1"] = 4] = "L1";
  DualSenseInput2[DualSenseInput2["R1"] = 5] = "R1";
  DualSenseInput2[DualSenseInput2["L2"] = 6] = "L2";
  DualSenseInput2[DualSenseInput2["R2"] = 7] = "R2";
  DualSenseInput2[DualSenseInput2["Create"] = 8] = "Create";
  DualSenseInput2[DualSenseInput2["Options"] = 9] = "Options";
  DualSenseInput2[DualSenseInput2["L3"] = 10] = "L3";
  DualSenseInput2[DualSenseInput2["R3"] = 11] = "R3";
  DualSenseInput2[DualSenseInput2["DPadUp"] = 12] = "DPadUp";
  DualSenseInput2[DualSenseInput2["DPadDown"] = 13] = "DPadDown";
  DualSenseInput2[DualSenseInput2["DPadLeft"] = 14] = "DPadLeft";
  DualSenseInput2[DualSenseInput2["DPadRight"] = 15] = "DPadRight";
  DualSenseInput2[DualSenseInput2["Home"] = 16] = "Home";
  DualSenseInput2[DualSenseInput2["TouchPad"] = 17] = "TouchPad";
  DualSenseInput2[DualSenseInput2["LStickXAxis"] = 18] = "LStickXAxis";
  DualSenseInput2[DualSenseInput2["LStickYAxis"] = 19] = "LStickYAxis";
  DualSenseInput2[DualSenseInput2["RStickXAxis"] = 20] = "RStickXAxis";
  DualSenseInput2[DualSenseInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(DualSenseInput || (DualSenseInput = {}));
var XboxInput;
(function(XboxInput2) {
  XboxInput2[XboxInput2["A"] = 0] = "A";
  XboxInput2[XboxInput2["B"] = 1] = "B";
  XboxInput2[XboxInput2["X"] = 2] = "X";
  XboxInput2[XboxInput2["Y"] = 3] = "Y";
  XboxInput2[XboxInput2["LB"] = 4] = "LB";
  XboxInput2[XboxInput2["RB"] = 5] = "RB";
  XboxInput2[XboxInput2["LT"] = 6] = "LT";
  XboxInput2[XboxInput2["RT"] = 7] = "RT";
  XboxInput2[XboxInput2["Back"] = 8] = "Back";
  XboxInput2[XboxInput2["Start"] = 9] = "Start";
  XboxInput2[XboxInput2["LS"] = 10] = "LS";
  XboxInput2[XboxInput2["RS"] = 11] = "RS";
  XboxInput2[XboxInput2["DPadUp"] = 12] = "DPadUp";
  XboxInput2[XboxInput2["DPadDown"] = 13] = "DPadDown";
  XboxInput2[XboxInput2["DPadLeft"] = 14] = "DPadLeft";
  XboxInput2[XboxInput2["DPadRight"] = 15] = "DPadRight";
  XboxInput2[XboxInput2["Home"] = 16] = "Home";
  XboxInput2[XboxInput2["LStickXAxis"] = 17] = "LStickXAxis";
  XboxInput2[XboxInput2["LStickYAxis"] = 18] = "LStickYAxis";
  XboxInput2[XboxInput2["RStickXAxis"] = 19] = "RStickXAxis";
  XboxInput2[XboxInput2["RStickYAxis"] = 20] = "RStickYAxis";
})(XboxInput || (XboxInput = {}));
var SwitchInput;
(function(SwitchInput2) {
  SwitchInput2[SwitchInput2["B"] = 0] = "B";
  SwitchInput2[SwitchInput2["A"] = 1] = "A";
  SwitchInput2[SwitchInput2["Y"] = 2] = "Y";
  SwitchInput2[SwitchInput2["X"] = 3] = "X";
  SwitchInput2[SwitchInput2["L"] = 4] = "L";
  SwitchInput2[SwitchInput2["R"] = 5] = "R";
  SwitchInput2[SwitchInput2["ZL"] = 6] = "ZL";
  SwitchInput2[SwitchInput2["ZR"] = 7] = "ZR";
  SwitchInput2[SwitchInput2["Minus"] = 8] = "Minus";
  SwitchInput2[SwitchInput2["Plus"] = 9] = "Plus";
  SwitchInput2[SwitchInput2["LS"] = 10] = "LS";
  SwitchInput2[SwitchInput2["RS"] = 11] = "RS";
  SwitchInput2[SwitchInput2["DPadUp"] = 12] = "DPadUp";
  SwitchInput2[SwitchInput2["DPadDown"] = 13] = "DPadDown";
  SwitchInput2[SwitchInput2["DPadLeft"] = 14] = "DPadLeft";
  SwitchInput2[SwitchInput2["DPadRight"] = 15] = "DPadRight";
  SwitchInput2[SwitchInput2["Home"] = 16] = "Home";
  SwitchInput2[SwitchInput2["Capture"] = 17] = "Capture";
  SwitchInput2[SwitchInput2["LStickXAxis"] = 18] = "LStickXAxis";
  SwitchInput2[SwitchInput2["LStickYAxis"] = 19] = "LStickYAxis";
  SwitchInput2[SwitchInput2["RStickXAxis"] = 20] = "RStickXAxis";
  SwitchInput2[SwitchInput2["RStickYAxis"] = 21] = "RStickYAxis";
})(SwitchInput || (SwitchInput = {}));
var DeviceInputEventType;
(function(DeviceInputEventType2) {
  DeviceInputEventType2[DeviceInputEventType2["PointerMove"] = 0] = "PointerMove";
  DeviceInputEventType2[DeviceInputEventType2["PointerDown"] = 1] = "PointerDown";
  DeviceInputEventType2[DeviceInputEventType2["PointerUp"] = 2] = "PointerUp";
})(DeviceInputEventType || (DeviceInputEventType = {}));
var EventConstants = function() {
  function EventConstants2() {
  }
  EventConstants2.DOM_DELTA_PIXEL = 0;
  EventConstants2.DOM_DELTA_LINE = 1;
  EventConstants2.DOM_DELTA_PAGE = 2;
  return EventConstants2;
}();
var DeviceEventFactory = function() {
  function DeviceEventFactory2() {
  }
  DeviceEventFactory2.CreateDeviceEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    switch (deviceType) {
      case DeviceType.Keyboard:
        return this._CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo);
      case DeviceType.Mouse:
        if (inputIndex === PointerInput.MouseWheelX || inputIndex === PointerInput.MouseWheelY || inputIndex === PointerInput.MouseWheelZ) {
          return this._CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
        }
      case DeviceType.Touch:
        return this._CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
      default:
        throw "Unable to generate event for device ".concat(DeviceType[deviceType]);
    }
  };
  DeviceEventFactory2._CreatePointerEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    var evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    if (deviceType === DeviceType.Mouse) {
      evt.deviceType = DeviceType.Mouse;
      evt.pointerId = 1;
      evt.pointerType = "mouse";
    } else {
      evt.deviceType = DeviceType.Touch;
      evt.pointerId = deviceSlot;
      evt.pointerType = "touch";
    }
    if (inputIndex === PointerInput.Move) {
      evt.type = "pointermove";
    } else if (inputIndex >= PointerInput.LeftClick && inputIndex <= PointerInput.RightClick) {
      evt.type = currentState === 1 ? "pointerdown" : "pointerup";
      evt.button = inputIndex - 2;
    }
    return evt;
  };
  DeviceEventFactory2._CreateWheelEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    var evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
    evt.type = "wheel";
    evt.deltaMode = EventConstants.DOM_DELTA_PIXEL;
    evt.deltaX = 0;
    evt.deltaY = 0;
    evt.deltaZ = 0;
    switch (inputIndex) {
      case PointerInput.MouseWheelX:
        evt.deltaX = currentState;
        break;
      case PointerInput.MouseWheelY:
        evt.deltaY = currentState;
        break;
      case PointerInput.MouseWheelZ:
        evt.deltaZ = currentState;
        break;
    }
    return evt;
  };
  DeviceEventFactory2._CreateMouseEvent = function(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    var evt = this._CreateEvent(elementToAttachTo);
    var pointerX = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Horizontal);
    var pointerY = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Vertical);
    if (elementToAttachTo) {
      evt.movementX = 0;
      evt.movementY = 0;
      evt.offsetX = evt.movementX - elementToAttachTo.getBoundingClientRect().x;
      evt.offsetY = evt.movementY - elementToAttachTo.getBoundingClientRect().y;
    } else {
      evt.movementX = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaHorizontal);
      evt.movementY = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaVertical);
      evt.offsetX = 0;
      evt.offsetY = 0;
    }
    this._CheckNonCharacterKeys(evt, deviceInputSystem);
    evt.clientX = pointerX;
    evt.clientY = pointerY;
    evt.x = pointerX;
    evt.y = pointerY;
    evt.deviceType = deviceType;
    evt.deviceSlot = deviceSlot;
    evt.inputIndex = inputIndex;
    return evt;
  };
  DeviceEventFactory2._CreateKeyboardEvent = function(inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
    var evt = this._CreateEvent(elementToAttachTo);
    this._CheckNonCharacterKeys(evt, deviceInputSystem);
    evt.deviceType = DeviceType.Keyboard;
    evt.deviceSlot = 0;
    evt.inputIndex = inputIndex;
    evt.type = currentState === 1 ? "keydown" : "keyup";
    evt.key = String.fromCharCode(inputIndex);
    evt.keyCode = inputIndex;
    return evt;
  };
  DeviceEventFactory2._CheckNonCharacterKeys = function(evt, deviceInputSystem) {
    var isKeyboardActive = deviceInputSystem.isDeviceAvailable(DeviceType.Keyboard);
    var altKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 18) === 1;
    var ctrlKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 17) === 1;
    var metaKey = isKeyboardActive && (deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 91) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 92) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 93) === 1);
    var shiftKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 16) === 1;
    evt.altKey = altKey;
    evt.ctrlKey = ctrlKey;
    evt.metaKey = metaKey;
    evt.shiftKey = shiftKey;
  };
  DeviceEventFactory2._CreateEvent = function(elementToAttachTo) {
    var evt = {};
    evt.preventDefault = function() {
    };
    evt.target = elementToAttachTo;
    return evt;
  };
  return DeviceEventFactory2;
}();
var NativeDeviceInputSystem = function() {
  function NativeDeviceInputSystem2(onDeviceConnected, onDeviceDisconnected, onInputChanged) {
    var _this = this;
    this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(onDeviceConnected, onDeviceDisconnected, function(deviceType, deviceSlot, inputIndex, currentState) {
      var evt = DeviceEventFactory.CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, _this);
      onInputChanged(deviceType, deviceSlot, evt);
    }) : this._createDummyNativeInput();
  }
  NativeDeviceInputSystem2.prototype.pollInput = function(deviceType, deviceSlot, inputIndex) {
    return this._nativeInput.pollInput(deviceType, deviceSlot, inputIndex);
  };
  NativeDeviceInputSystem2.prototype.isDeviceAvailable = function(deviceType) {
    return deviceType === DeviceType.Mouse || deviceType === DeviceType.Touch;
  };
  NativeDeviceInputSystem2.prototype.dispose = function() {
    this._nativeInput.dispose();
  };
  NativeDeviceInputSystem2.prototype._createDummyNativeInput = function() {
    var nativeInput = {
      pollInput: function() {
        return 0;
      },
      isDeviceAvailable: function() {
        return false;
      },
      dispose: function() {
      }
    };
    return nativeInput;
  };
  return NativeDeviceInputSystem2;
}();
var MAX_KEYCODES = 255;
var MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;
var WebDeviceInputSystem = function() {
  function WebDeviceInputSystem2(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {
    var _this = this;
    this._inputs = [];
    this._keyboardActive = false;
    this._pointerActive = false;
    this._usingSafari = Tools.IsSafari();
    this._keyboardDownEvent = function(evt) {
    };
    this._keyboardUpEvent = function(evt) {
    };
    this._keyboardBlurEvent = function(evt) {
    };
    this._pointerMoveEvent = function(evt) {
    };
    this._pointerDownEvent = function(evt) {
    };
    this._pointerUpEvent = function(evt) {
    };
    this._pointerCancelEvent = function(evt) {
    };
    this._pointerWheelEvent = function(evt) {
    };
    this._pointerBlurEvent = function(evt) {
    };
    this._eventsAttached = false;
    this._mouseId = -1;
    this._isUsingFirefox = DomManagement.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1;
    this._maxTouchPoints = 0;
    this._pointerInputClearObserver = null;
    this._gamepadConnectedEvent = function(evt) {
    };
    this._gamepadDisconnectedEvent = function(evt) {
    };
    this._eventPrefix = Tools.GetPointerPrefix(engine);
    this._engine = engine;
    this._onDeviceConnected = onDeviceConnected;
    this._onDeviceDisconnected = onDeviceDisconnected;
    this._onInputChanged = onInputChanged;
    this._enableEvents();
    if (!this._engine._onEngineViewChanged) {
      this._engine._onEngineViewChanged = function() {
        _this._enableEvents();
      };
    }
  }
  WebDeviceInputSystem2.prototype.pollInput = function(deviceType, deviceSlot, inputIndex) {
    var device = this._inputs[deviceType][deviceSlot];
    if (!device) {
      throw "Unable to find device ".concat(DeviceType[deviceType]);
    }
    if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense && navigator.getGamepads) {
      this._updateDevice(deviceType, deviceSlot, inputIndex);
    }
    var currentValue = device[inputIndex];
    if (currentValue === void 0) {
      throw "Unable to find input ".concat(inputIndex, " for device ").concat(DeviceType[deviceType], " in slot ").concat(deviceSlot);
    }
    if (inputIndex === PointerInput.Move) {
      Tools.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.");
    }
    return currentValue;
  };
  WebDeviceInputSystem2.prototype.isDeviceAvailable = function(deviceType) {
    return this._inputs[deviceType] !== void 0;
  };
  WebDeviceInputSystem2.prototype.dispose = function() {
    this._onDeviceConnected = function() {
    };
    this._onDeviceDisconnected = function() {
    };
    this._onInputChanged = function() {
    };
    delete this._engine._onEngineViewChanged;
    if (this._elementToAttachTo) {
      this._disableEvents();
    }
  };
  WebDeviceInputSystem2.prototype._enableEvents = function() {
    var inputElement = this === null || this === void 0 ? void 0 : this._engine.getInputElement();
    if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {
      this._disableEvents();
      if (this._inputs) {
        for (var _i = 0, _a2 = this._inputs; _i < _a2.length; _i++) {
          var inputs = _a2[_i];
          if (inputs) {
            for (var deviceSlotKey in inputs) {
              var deviceSlot = +deviceSlotKey;
              var device = inputs[deviceSlot];
              if (device) {
                for (var inputIndex = 0; inputIndex < device.length; inputIndex++) {
                  device[inputIndex] = 0;
                }
              }
            }
          }
        }
      }
      this._elementToAttachTo = inputElement;
      this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;
      this._handleKeyActions();
      this._handlePointerActions();
      this._handleGamepadActions();
      this._eventsAttached = true;
      this._checkForConnectedDevices();
    }
  };
  WebDeviceInputSystem2.prototype._disableEvents = function() {
    if (this._elementToAttachTo) {
      this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent);
      this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent);
      this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent);
      this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent);
      this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
      this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);
      window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent);
      window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
    }
    if (this._pointerInputClearObserver) {
      this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);
    }
    this._eventsAttached = false;
  };
  WebDeviceInputSystem2.prototype._checkForConnectedDevices = function() {
    if (navigator.getGamepads) {
      var gamepads = navigator.getGamepads();
      for (var _i = 0, gamepads_1 = gamepads; _i < gamepads_1.length; _i++) {
        var gamepad = gamepads_1[_i];
        if (gamepad) {
          this._addGamePad(gamepad);
        }
      }
    }
    if (typeof matchMedia === "function" && matchMedia("(pointer:fine)").matches) {
      this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);
    }
  };
  WebDeviceInputSystem2.prototype._addGamePad = function(gamepad) {
    var deviceType = this._getGamepadDeviceType(gamepad.id);
    var deviceSlot = gamepad.index;
    this._gamepads = this._gamepads || new Array(gamepad.index + 1);
    this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);
    this._gamepads[deviceSlot] = deviceType;
  };
  WebDeviceInputSystem2.prototype._addPointerDevice = function(deviceType, deviceSlot, currentX, currentY) {
    if (!this._pointerActive) {
      this._pointerActive = true;
    }
    this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
    var pointer = this._inputs[deviceType][deviceSlot];
    pointer[0] = currentX;
    pointer[1] = currentY;
  };
  WebDeviceInputSystem2.prototype._registerDevice = function(deviceType, deviceSlot, numberOfInputs) {
    if (deviceSlot === void 0) {
      throw "Unable to register device ".concat(DeviceType[deviceType], " to undefined slot.");
    }
    if (!this._inputs[deviceType]) {
      this._inputs[deviceType] = {};
    }
    if (!this._inputs[deviceType][deviceSlot]) {
      var device = new Array(numberOfInputs);
      for (var i = 0; i < numberOfInputs; i++) {
        device[i] = 0;
      }
      this._inputs[deviceType][deviceSlot] = device;
      this._onDeviceConnected(deviceType, deviceSlot);
    }
  };
  WebDeviceInputSystem2.prototype._unregisterDevice = function(deviceType, deviceSlot) {
    if (this._inputs[deviceType][deviceSlot]) {
      delete this._inputs[deviceType][deviceSlot];
      this._onDeviceDisconnected(deviceType, deviceSlot);
    }
  };
  WebDeviceInputSystem2.prototype._handleKeyActions = function() {
    var _this = this;
    this._keyboardDownEvent = function(evt) {
      if (!_this._keyboardActive) {
        _this._keyboardActive = true;
        _this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      var kbKey = _this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 1;
        var deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        _this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardUpEvent = function(evt) {
      if (!_this._keyboardActive) {
        _this._keyboardActive = true;
        _this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
      }
      var kbKey = _this._inputs[DeviceType.Keyboard][0];
      if (kbKey) {
        kbKey[evt.keyCode] = 0;
        var deviceEvent = evt;
        deviceEvent.inputIndex = evt.keyCode;
        _this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
      }
    };
    this._keyboardBlurEvent = function() {
      if (_this._keyboardActive) {
        var kbKey = _this._inputs[DeviceType.Keyboard][0];
        for (var i = 0; i < kbKey.length; i++) {
          if (kbKey[i] !== 0) {
            kbKey[i] = 0;
            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, _this, _this._elementToAttachTo);
            _this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
          }
        }
      }
    };
    this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent);
    this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent);
    this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
  };
  WebDeviceInputSystem2.prototype._handlePointerActions = function() {
    var _this = this;
    this._maxTouchPoints = DomManagement.IsNavigatorAvailable() && navigator.maxTouchPoints || 2;
    if (!this._activeTouchIds) {
      this._activeTouchIds = new Array(this._maxTouchPoints);
    }
    for (var i = 0; i < this._maxTouchPoints; i++) {
      this._activeTouchIds[i] = -1;
    }
    this._pointerMoveEvent = function(evt) {
      var deviceType = _this._getPointerType(evt);
      var deviceSlot = deviceType === DeviceType.Mouse ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);
      if (!_this._inputs[deviceType]) {
        _this._inputs[deviceType] = {};
      }
      if (!_this._inputs[deviceType][deviceSlot]) {
        _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      }
      var pointer = _this._inputs[deviceType][deviceSlot];
      if (pointer) {
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        var deviceEvent = evt;
        deviceEvent.inputIndex = PointerInput.Move;
        _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (!_this._usingSafari && evt.button !== -1) {
          deviceEvent.inputIndex = evt.button + 2;
          pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1;
          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerDownEvent = function(evt) {
      var deviceType = _this._getPointerType(evt);
      var deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;
      if (deviceType === DeviceType.Touch) {
        var idx = _this._activeTouchIds.indexOf(-1);
        if (idx >= 0) {
          deviceSlot = idx;
          _this._activeTouchIds[idx] = evt.pointerId;
        } else {
          Tools.Warn("Max number of touches exceeded.  Ignoring touches in excess of ".concat(_this._maxTouchPoints));
          return;
        }
      }
      if (!_this._inputs[deviceType]) {
        _this._inputs[deviceType] = {};
      }
      if (!_this._inputs[deviceType][deviceSlot]) {
        _this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
      } else if (deviceType === DeviceType.Touch) {
        _this._onDeviceConnected(deviceType, deviceSlot);
      }
      var pointer = _this._inputs[deviceType][deviceSlot];
      if (pointer) {
        var previousHorizontal = pointer[PointerInput.Horizontal];
        var previousVertical = pointer[PointerInput.Vertical];
        if (deviceType === DeviceType.Mouse) {
          if (_this._mouseId === -1) {
            if (evt.pointerId === void 0) {
              _this._mouseId = _this._isUsingFirefox ? 0 : 1;
            } else {
              _this._mouseId = evt.pointerId;
            }
          }
          if (!document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {
            try {
              _this._elementToAttachTo.setPointerCapture(_this._mouseId);
            } catch (e) {
            }
          }
        } else {
          if (evt.pointerId && !document.pointerLockElement && _this._elementToAttachTo.hasPointerCapture) {
            try {
              _this._elementToAttachTo.setPointerCapture(evt.pointerId);
            } catch (e) {
            }
          }
        }
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[evt.button + 2] = 1;
        var deviceEvent = evt;
        deviceEvent.inputIndex = evt.button + 2;
        _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._pointerUpEvent = function(evt) {
      var _a2, _b2, _c2, _d, _e;
      var deviceType = _this._getPointerType(evt);
      var deviceSlot = deviceType === DeviceType.Mouse ? 0 : _this._activeTouchIds.indexOf(evt.pointerId);
      if (deviceType === DeviceType.Touch) {
        if (deviceSlot === -1) {
          return;
        } else {
          _this._activeTouchIds[deviceSlot] = -1;
        }
      }
      var pointer = (_a2 = _this._inputs[deviceType]) === null || _a2 === void 0 ? void 0 : _a2[deviceSlot];
      if (pointer && pointer[evt.button + 2] !== 0) {
        var previousHorizontal = pointer[PointerInput.Horizontal];
        var previousVertical = pointer[PointerInput.Vertical];
        pointer[PointerInput.Horizontal] = evt.clientX;
        pointer[PointerInput.Vertical] = evt.clientY;
        pointer[evt.button + 2] = 0;
        var deviceEvent = evt;
        if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = PointerInput.Move;
          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        deviceEvent.inputIndex = evt.button + 2;
        if (deviceType === DeviceType.Mouse && _this._mouseId >= 0 && ((_c2 = (_b2 = _this._elementToAttachTo).hasPointerCapture) === null || _c2 === void 0 ? void 0 : _c2.call(_b2, _this._mouseId))) {
          _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
        } else if (evt.pointerId && ((_e = (_d = _this._elementToAttachTo).hasPointerCapture) === null || _e === void 0 ? void 0 : _e.call(_d, evt.pointerId))) {
          _this._elementToAttachTo.releasePointerCapture(evt.pointerId);
        }
        _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        if (deviceType === DeviceType.Touch) {
          _this._onDeviceDisconnected(deviceType, deviceSlot);
        }
      }
    };
    this._pointerCancelEvent = function(evt) {
      var _a2, _b2, _c2, _d;
      if (evt.pointerType === "mouse") {
        var pointer = _this._inputs[DeviceType.Mouse][0];
        if (_this._mouseId >= 0 && ((_b2 = (_a2 = _this._elementToAttachTo).hasPointerCapture) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, _this._mouseId))) {
          _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
        }
        for (var inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, _this, _this._elementToAttachTo);
            _this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      } else {
        var deviceSlot = _this._activeTouchIds.indexOf(evt.pointerId);
        if ((_d = (_c2 = _this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c2, evt.pointerId)) {
          _this._elementToAttachTo.releasePointerCapture(evt.pointerId);
        }
        _this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;
        var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, _this, _this._elementToAttachTo);
        _this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
        _this._activeTouchIds[deviceSlot] = -1;
        _this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
      }
    };
    this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    var passiveSupported = false;
    var noop = function() {
    };
    try {
      var options = {
        passive: {
          get: function() {
            passiveSupported = true;
          }
        }
      };
      this._elementToAttachTo.addEventListener("test", noop, options);
      this._elementToAttachTo.removeEventListener("test", noop, options);
    } catch (e) {
    }
    this._pointerBlurEvent = function() {
      var _a2, _b2, _c2, _d, _e;
      if (_this.isDeviceAvailable(DeviceType.Mouse)) {
        var pointer = _this._inputs[DeviceType.Mouse][0];
        if (_this._mouseId >= 0 && ((_b2 = (_a2 = _this._elementToAttachTo).hasPointerCapture) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, _this._mouseId))) {
          _this._elementToAttachTo.releasePointerCapture(_this._mouseId);
        }
        for (var inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
          if (pointer[inputIndex] === 1) {
            pointer[inputIndex] = 0;
            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, _this, _this._elementToAttachTo);
            _this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
          }
        }
      }
      if (_this.isDeviceAvailable(DeviceType.Touch)) {
        var pointer = _this._inputs[DeviceType.Touch];
        for (var deviceSlot = 0; deviceSlot < _this._activeTouchIds.length; deviceSlot++) {
          var pointerId = _this._activeTouchIds[deviceSlot];
          if ((_d = (_c2 = _this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c2, pointerId)) {
            _this._elementToAttachTo.releasePointerCapture(pointerId);
          }
          if (pointerId !== -1 && ((_e = pointer[deviceSlot]) === null || _e === void 0 ? void 0 : _e[PointerInput.LeftClick]) === 1) {
            pointer[deviceSlot][PointerInput.LeftClick] = 0;
            var deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, _this, _this._elementToAttachTo);
            _this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
            _this._activeTouchIds[deviceSlot] = -1;
            _this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
          }
        }
      }
    };
    this._pointerWheelEvent = function(evt) {
      var deviceType = DeviceType.Mouse;
      var deviceSlot = 0;
      if (!_this._inputs[deviceType]) {
        _this._inputs[deviceType] = [];
      }
      if (!_this._inputs[deviceType][deviceSlot]) {
        _this._pointerActive = true;
        _this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
      }
      var pointer = _this._inputs[deviceType][deviceSlot];
      if (pointer) {
        pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;
        pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;
        pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;
        var deviceEvent = evt;
        if (pointer[PointerInput.MouseWheelX] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelX;
          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelY] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelY;
          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
        if (pointer[PointerInput.MouseWheelZ] !== 0) {
          deviceEvent.inputIndex = PointerInput.MouseWheelZ;
          _this._onInputChanged(deviceType, deviceSlot, deviceEvent);
        }
      }
    };
    this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent);
    this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
    this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent);
    this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);
    this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(function() {
      if (_this.isDeviceAvailable(DeviceType.Mouse)) {
        var pointer = _this._inputs[DeviceType.Mouse][0];
        pointer[PointerInput.MouseWheelX] = 0;
        pointer[PointerInput.MouseWheelY] = 0;
        pointer[PointerInput.MouseWheelZ] = 0;
      }
    });
  };
  WebDeviceInputSystem2.prototype._handleGamepadActions = function() {
    var _this = this;
    this._gamepadConnectedEvent = function(evt) {
      _this._addGamePad(evt.gamepad);
    };
    this._gamepadDisconnectedEvent = function(evt) {
      if (_this._gamepads) {
        var deviceType = _this._getGamepadDeviceType(evt.gamepad.id);
        var deviceSlot = evt.gamepad.index;
        _this._unregisterDevice(deviceType, deviceSlot);
        delete _this._gamepads[deviceSlot];
      }
    };
    window.addEventListener("gamepadconnected", this._gamepadConnectedEvent);
    window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  };
  WebDeviceInputSystem2.prototype._updateDevice = function(deviceType, deviceSlot, inputIndex) {
    var gp = navigator.getGamepads()[deviceSlot];
    if (gp && deviceType === this._gamepads[deviceSlot]) {
      var device = this._inputs[deviceType][deviceSlot];
      if (inputIndex >= gp.buttons.length) {
        device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();
      } else {
        device[inputIndex] = gp.buttons[inputIndex].value;
      }
    }
  };
  WebDeviceInputSystem2.prototype._getGamepadDeviceType = function(deviceName) {
    if (deviceName.indexOf("054c") !== -1) {
      return deviceName.indexOf("0ce6") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;
    } else if (deviceName.indexOf("Xbox One") !== -1 || deviceName.search("Xbox 360") !== -1 || deviceName.search("xinput") !== -1) {
      return DeviceType.Xbox;
    } else if (deviceName.indexOf("057e") !== -1) {
      return DeviceType.Switch;
    }
    return DeviceType.Generic;
  };
  WebDeviceInputSystem2.prototype._getPointerType = function(evt) {
    var deviceType = DeviceType.Mouse;
    if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
      deviceType = DeviceType.Touch;
    }
    return deviceType;
  };
  return WebDeviceInputSystem2;
}();
var DeviceSource = function() {
  function DeviceSource2(deviceInputSystem, deviceType, deviceSlot) {
    if (deviceSlot === void 0) {
      deviceSlot = 0;
    }
    this.deviceType = deviceType;
    this.deviceSlot = deviceSlot;
    this.onInputChangedObservable = new Observable();
    this._deviceInputSystem = deviceInputSystem;
  }
  DeviceSource2.prototype.getInput = function(inputIndex) {
    return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, inputIndex);
  };
  return DeviceSource2;
}();
var InternalDeviceSourceManager = function() {
  function InternalDeviceSourceManager2(engine) {
    var _this = this;
    this._registeredManagers = new Array();
    this._refCount = 0;
    this.registerManager = function(manager) {
      for (var deviceType = 0; deviceType < _this._devices.length; deviceType++) {
        var device = _this._devices[deviceType];
        for (var deviceSlotKey in device) {
          var deviceSlot = +deviceSlotKey;
          manager._addDevice(new DeviceSource(_this._deviceInputSystem, deviceType, deviceSlot));
        }
      }
      _this._registeredManagers.push(manager);
    };
    this.unregisterManager = function(manager) {
      var idx = _this._registeredManagers.indexOf(manager);
      if (idx > -1) {
        _this._registeredManagers.splice(idx, 1);
      }
    };
    var numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    var onDeviceConnected = function(deviceType, deviceSlot) {
      if (!_this._devices[deviceType]) {
        _this._devices[deviceType] = new Array();
      }
      if (!_this._devices[deviceType][deviceSlot]) {
        _this._devices[deviceType][deviceSlot] = deviceSlot;
      }
      for (var _i = 0, _a2 = _this._registeredManagers; _i < _a2.length; _i++) {
        var manager = _a2[_i];
        var deviceSource = new DeviceSource(_this._deviceInputSystem, deviceType, deviceSlot);
        manager._addDevice(deviceSource);
      }
    };
    var onDeviceDisconnected = function(deviceType, deviceSlot) {
      var _a2;
      if ((_a2 = _this._devices[deviceType]) === null || _a2 === void 0 ? void 0 : _a2[deviceSlot]) {
        delete _this._devices[deviceType][deviceSlot];
      }
      for (var _i = 0, _b2 = _this._registeredManagers; _i < _b2.length; _i++) {
        var manager = _b2[_i];
        manager._removeDevice(deviceType, deviceSlot);
      }
    };
    var onInputChanged = function(deviceType, deviceSlot, eventData) {
      if (eventData) {
        for (var _i = 0, _a2 = _this._registeredManagers; _i < _a2.length; _i++) {
          var manager = _a2[_i];
          manager._onInputChanged(deviceType, deviceSlot, eventData);
        }
      }
    };
    if (typeof _native !== "undefined") {
      this._deviceInputSystem = new NativeDeviceInputSystem(onDeviceConnected, onDeviceDisconnected, onInputChanged);
    } else {
      this._deviceInputSystem = new WebDeviceInputSystem(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged);
    }
  }
  InternalDeviceSourceManager2.prototype.dispose = function() {
    this._deviceInputSystem.dispose();
  };
  return InternalDeviceSourceManager2;
}();
var DeviceSourceManager = function() {
  function DeviceSourceManager2(engine) {
    var _this = this;
    var numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
    this._devices = new Array(numberOfDeviceTypes);
    this._firstDevice = new Array(numberOfDeviceTypes);
    this._engine = engine;
    if (!this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager = new InternalDeviceSourceManager(engine);
    }
    this._engine._deviceSourceManager._refCount++;
    this.onDeviceConnectedObservable = new Observable(function(observer) {
      for (var _i = 0, _a2 = _this._devices; _i < _a2.length; _i++) {
        var devices = _a2[_i];
        if (devices) {
          for (var _b2 = 0, devices_1 = devices; _b2 < devices_1.length; _b2++) {
            var device = devices_1[_b2];
            if (device) {
              _this.onDeviceConnectedObservable.notifyObserver(observer, device);
            }
          }
        }
      }
    });
    this.onDeviceDisconnectedObservable = new Observable();
    this._engine._deviceSourceManager.registerManager(this);
    this._onDisposeObserver = engine.onDisposeObservable.add(function() {
      _this.dispose();
    });
  }
  DeviceSourceManager2.prototype.getDeviceSource = function(deviceType, deviceSlot) {
    if (deviceSlot === void 0) {
      if (this._firstDevice[deviceType] === void 0) {
        return null;
      }
      deviceSlot = this._firstDevice[deviceType];
    }
    if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === void 0) {
      return null;
    }
    return this._devices[deviceType][deviceSlot];
  };
  DeviceSourceManager2.prototype.getDeviceSources = function(deviceType) {
    return this._devices[deviceType].filter(function(source) {
      return !!source;
    });
  };
  DeviceSourceManager2.prototype.dispose = function() {
    this.onDeviceConnectedObservable.clear();
    this.onDeviceDisconnectedObservable.clear();
    if (this._engine._deviceSourceManager) {
      this._engine._deviceSourceManager.unregisterManager(this);
      if (--this._engine._deviceSourceManager._refCount < 1) {
        this._engine._deviceSourceManager.dispose();
        delete this._engine._deviceSourceManager;
      }
    }
    this._engine.onDisposeObservable.remove(this._onDisposeObserver);
  };
  DeviceSourceManager2.prototype._addDevice = function(deviceSource) {
    if (!this._devices[deviceSource.deviceType]) {
      this._devices[deviceSource.deviceType] = new Array();
    }
    if (!this._devices[deviceSource.deviceType][deviceSource.deviceSlot]) {
      this._devices[deviceSource.deviceType][deviceSource.deviceSlot] = deviceSource;
      this._updateFirstDevices(deviceSource.deviceType);
    }
    this.onDeviceConnectedObservable.notifyObservers(deviceSource);
  };
  DeviceSourceManager2.prototype._removeDevice = function(deviceType, deviceSlot) {
    var _a2, _b2;
    var deviceSource = (_a2 = this._devices[deviceType]) === null || _a2 === void 0 ? void 0 : _a2[deviceSlot];
    this.onDeviceDisconnectedObservable.notifyObservers(deviceSource);
    if ((_b2 = this._devices[deviceType]) === null || _b2 === void 0 ? void 0 : _b2[deviceSlot]) {
      delete this._devices[deviceType][deviceSlot];
    }
    this._updateFirstDevices(deviceType);
  };
  DeviceSourceManager2.prototype._onInputChanged = function(deviceType, deviceSlot, eventData) {
    var _a2, _b2;
    (_b2 = (_a2 = this._devices[deviceType]) === null || _a2 === void 0 ? void 0 : _a2[deviceSlot]) === null || _b2 === void 0 ? void 0 : _b2.onInputChangedObservable.notifyObservers(eventData);
  };
  DeviceSourceManager2.prototype._updateFirstDevices = function(type) {
    switch (type) {
      case DeviceType.Keyboard:
      case DeviceType.Mouse:
        this._firstDevice[type] = 0;
        break;
      case DeviceType.Touch:
      case DeviceType.DualSense:
      case DeviceType.DualShock:
      case DeviceType.Xbox:
      case DeviceType.Switch:
      case DeviceType.Generic: {
        delete this._firstDevice[type];
        var devices = this._devices[type];
        if (devices) {
          for (var i = 0; i < devices.length; i++) {
            if (devices[i]) {
              this._firstDevice[type] = i;
              break;
            }
          }
        }
        break;
      }
    }
  };
  return DeviceSourceManager2;
}();
var _ClickInfo = function() {
  function _ClickInfo2() {
    this._singleClick = false;
    this._doubleClick = false;
    this._hasSwiped = false;
    this._ignore = false;
  }
  Object.defineProperty(_ClickInfo2.prototype, "singleClick", {
    get: function() {
      return this._singleClick;
    },
    set: function(b) {
      this._singleClick = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ClickInfo2.prototype, "doubleClick", {
    get: function() {
      return this._doubleClick;
    },
    set: function(b) {
      this._doubleClick = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ClickInfo2.prototype, "hasSwiped", {
    get: function() {
      return this._hasSwiped;
    },
    set: function(b) {
      this._hasSwiped = b;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(_ClickInfo2.prototype, "ignore", {
    get: function() {
      return this._ignore;
    },
    set: function(b) {
      this._ignore = b;
    },
    enumerable: false,
    configurable: true
  });
  return _ClickInfo2;
}();
var InputManager = function() {
  function InputManager2(scene) {
    this._alreadyAttached = false;
    this._meshPickProceed = false;
    this._currentPickResult = null;
    this._previousPickResult = null;
    this._totalPointersPressed = 0;
    this._doubleClickOccured = false;
    this._pointerX = 0;
    this._pointerY = 0;
    this._startingPointerPosition = new Vector2(0, 0);
    this._previousStartingPointerPosition = new Vector2(0, 0);
    this._startingPointerTime = 0;
    this._previousStartingPointerTime = 0;
    this._pointerCaptures = {};
    this._meshUnderPointerId = {};
    this._deviceSourceManager = null;
    this._scene = scene || EngineStore.LastCreatedScene;
    if (!this._scene) {
      return;
    }
  }
  Object.defineProperty(InputManager2.prototype, "meshUnderPointer", {
    get: function() {
      return this._pointerOverMesh;
    },
    enumerable: false,
    configurable: true
  });
  InputManager2.prototype.getMeshUnderPointerByPointerId = function(pointerId) {
    return this._meshUnderPointerId[pointerId] || null;
  };
  Object.defineProperty(InputManager2.prototype, "unTranslatedPointer", {
    get: function() {
      return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputManager2.prototype, "pointerX", {
    get: function() {
      return this._pointerX;
    },
    set: function(value) {
      this._pointerX = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(InputManager2.prototype, "pointerY", {
    get: function() {
      return this._pointerY;
    },
    set: function(value) {
      this._pointerY = value;
    },
    enumerable: false,
    configurable: true
  });
  InputManager2.prototype._updatePointerPosition = function(evt) {
    var canvasRect = this._scene.getEngine().getInputElementClientRect();
    if (!canvasRect) {
      return;
    }
    this._pointerX = evt.clientX - canvasRect.left;
    this._pointerY = evt.clientY - canvasRect.top;
    this._unTranslatedPointerX = this._pointerX;
    this._unTranslatedPointerY = this._pointerY;
  };
  InputManager2.prototype._processPointerMove = function(pickResult, evt) {
    var scene = this._scene;
    var engine = scene.getEngine();
    var canvas = engine.getInputElement();
    if (canvas) {
      canvas.tabIndex = engine.canvasTabIndex;
      if (!scene.doNotHandleCursors) {
        canvas.style.cursor = scene.defaultCursor;
      }
    }
    var isMeshPicked = pickResult && pickResult.hit && pickResult.pickedMesh ? true : false;
    if (isMeshPicked) {
      scene.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult);
      if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {
        var actionManager = this._pointerOverMesh._getActionManagerForTrigger();
        if (actionManager && actionManager.hasPointerTriggers) {
          canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;
        }
      }
    } else {
      scene.setPointerOverMesh(null, evt.pointerId, pickResult);
    }
    for (var _i = 0, _a2 = scene._pointerMoveStage; _i < _a2.length; _i++) {
      var step = _a2[_i];
      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);
    }
    if (pickResult) {
      var type = evt.type === "wheel" || evt.type === "mousewheel" || evt.type === "DOMMouseScroll" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;
      if (scene.onPointerMove) {
        scene.onPointerMove(evt, pickResult, type);
      }
      if (scene.onPointerObservable.hasObservers()) {
        var pi = new PointerInfo(type, evt, pickResult);
        this._setRayOnPointerInfo(pi);
        scene.onPointerObservable.notifyObservers(pi, type);
      }
    }
  };
  InputManager2.prototype._setRayOnPointerInfo = function(pointerInfo) {
    var scene = this._scene;
    if (pointerInfo.pickInfo && !pointerInfo.pickInfo._pickingUnavailable) {
      if (!pointerInfo.pickInfo.ray) {
        pointerInfo.pickInfo.ray = scene.createPickingRay(pointerInfo.event.offsetX, pointerInfo.event.offsetY, Matrix.Identity(), scene.activeCamera);
      }
    }
  };
  InputManager2.prototype._checkPrePointerObservable = function(pickResult, evt, type) {
    var scene = this._scene;
    var pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);
    if (pickResult) {
      pi.ray = pickResult.ray;
      if (pickResult.originMesh) {
        pi.nearInteractionPickingInfo = pickResult;
      }
    }
    scene.onPrePointerObservable.notifyObservers(pi, type);
    if (pi.skipOnPointerObservable) {
      return true;
    } else {
      return false;
    }
  };
  InputManager2.prototype.simulatePointerMove = function(pickResult, pointerEventInit) {
    var evt = new PointerEvent("pointermove", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {
      return;
    }
    this._processPointerMove(pickResult, evt);
  };
  InputManager2.prototype.simulatePointerDown = function(pickResult, pointerEventInit) {
    var evt = new PointerEvent("pointerdown", pointerEventInit);
    evt.inputIndex = evt.button + 2;
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {
      return;
    }
    this._processPointerDown(pickResult, evt);
  };
  InputManager2.prototype._processPointerDown = function(pickResult, evt) {
    var _this = this;
    var scene = this._scene;
    if (pickResult && pickResult.hit && pickResult.pickedMesh) {
      this._pickedDownMesh = pickResult.pickedMesh;
      var actionManager_1 = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager_1) {
        if (actionManager_1.hasPickTriggers) {
          actionManager_1.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
          switch (evt.button) {
            case 0:
              actionManager_1.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
            case 1:
              actionManager_1.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
            case 2:
              actionManager_1.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt));
              break;
          }
        }
        if (actionManager_1.hasSpecificTrigger(8)) {
          window.setTimeout(function() {
            var pickResult2 = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, function(mesh) {
              return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === _this._pickedDownMesh;
            }, false, scene.cameraToUseForPointers);
            if (pickResult2 && pickResult2.hit && pickResult2.pickedMesh && actionManager_1) {
              if (_this._totalPointersPressed !== 0 && Date.now() - _this._startingPointerTime > InputManager2.LongPressDelay && !_this._isPointerSwiping()) {
                _this._startingPointerTime = 0;
                actionManager_1.processTrigger(8, ActionEvent.CreateNew(pickResult2.pickedMesh, evt));
              }
            }
          }, InputManager2.LongPressDelay);
        }
      }
    } else {
      for (var _i = 0, _a2 = scene._pointerDownStage; _i < _a2.length; _i++) {
        var step = _a2[_i];
        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);
      }
    }
    if (pickResult) {
      var type = PointerEventTypes.POINTERDOWN;
      if (scene.onPointerDown) {
        scene.onPointerDown(evt, pickResult, type);
      }
      if (scene.onPointerObservable.hasObservers()) {
        var pi = new PointerInfo(type, evt, pickResult);
        this._setRayOnPointerInfo(pi);
        scene.onPointerObservable.notifyObservers(pi, type);
      }
    }
  };
  InputManager2.prototype._isPointerSwiping = function() {
    return Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager2.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager2.DragMovementThreshold;
  };
  InputManager2.prototype.simulatePointerUp = function(pickResult, pointerEventInit, doubleTap) {
    var evt = new PointerEvent("pointerup", pointerEventInit);
    evt.inputIndex = PointerInput.Move;
    var clickInfo = new _ClickInfo();
    if (doubleTap) {
      clickInfo.doubleClick = true;
    } else {
      clickInfo.singleClick = true;
    }
    if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {
      return;
    }
    this._processPointerUp(pickResult, evt, clickInfo);
  };
  InputManager2.prototype._processPointerUp = function(pickResult, evt, clickInfo) {
    var scene = this._scene;
    if (pickResult && pickResult.hit && pickResult.pickedMesh) {
      this._pickedUpMesh = pickResult.pickedMesh;
      if (this._pickedDownMesh === this._pickedUpMesh) {
        if (scene.onPointerPick) {
          scene.onPointerPick(evt, pickResult);
        }
        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.hasObservers()) {
          var type_1 = PointerEventTypes.POINTERPICK;
          var pi = new PointerInfo(type_1, evt, pickResult);
          this._setRayOnPointerInfo(pi);
          scene.onPointerObservable.notifyObservers(pi, type_1);
        }
      }
      var actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
      if (actionManager && !clickInfo.ignore) {
        actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        if (!clickInfo.hasSwiped && clickInfo.singleClick) {
          actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
        var doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);
        if (clickInfo.doubleClick && doubleClickActionManager) {
          doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
        }
      }
    } else {
      if (!clickInfo.ignore) {
        for (var _i = 0, _a2 = scene._pointerUpStage; _i < _a2.length; _i++) {
          var step = _a2[_i];
          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt);
        }
      }
    }
    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
      var pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);
      if (pickedDownActionManager) {
        pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));
      }
    }
    var type = 0;
    if (scene.onPointerObservable.hasObservers()) {
      if (!clickInfo.ignore && !clickInfo.hasSwiped) {
        if (clickInfo.singleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
          type = PointerEventTypes.POINTERTAP;
        } else if (clickInfo.doubleClick && scene.onPointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
          type = PointerEventTypes.POINTERDOUBLETAP;
        }
        if (type) {
          var pi = new PointerInfo(type, evt, pickResult);
          this._setRayOnPointerInfo(pi);
          scene.onPointerObservable.notifyObservers(pi, type);
        }
      }
      if (!clickInfo.ignore) {
        type = PointerEventTypes.POINTERUP;
        var pi = new PointerInfo(type, evt, pickResult);
        this._setRayOnPointerInfo(pi);
        scene.onPointerObservable.notifyObservers(pi, type);
      }
    }
    if (scene.onPointerUp && !clickInfo.ignore) {
      scene.onPointerUp(evt, pickResult, type);
    }
  };
  InputManager2.prototype.isPointerCaptured = function(pointerId) {
    if (pointerId === void 0) {
      pointerId = 0;
    }
    return this._pointerCaptures[pointerId];
  };
  InputManager2.prototype.attachControl = function(attachUp, attachDown, attachMove, elementToAttachTo) {
    var _this = this;
    if (attachUp === void 0) {
      attachUp = true;
    }
    if (attachDown === void 0) {
      attachDown = true;
    }
    if (attachMove === void 0) {
      attachMove = true;
    }
    if (elementToAttachTo === void 0) {
      elementToAttachTo = null;
    }
    var scene = this._scene;
    var engine = scene.getEngine();
    if (!elementToAttachTo) {
      elementToAttachTo = engine.getInputElement();
    }
    if (this._alreadyAttached) {
      this.detachControl();
    }
    if (elementToAttachTo) {
      this._alreadyAttachedTo = elementToAttachTo;
    }
    this._deviceSourceManager = new DeviceSourceManager(engine);
    this._initActionManager = function(act) {
      if (!_this._meshPickProceed) {
        var pickResult = scene.skipPointerUpPicking ? null : scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerUpPredicate, false, scene.cameraToUseForPointers);
        _this._currentPickResult = pickResult;
        if (pickResult) {
          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;
        }
        _this._meshPickProceed = true;
      }
      return act;
    };
    this._delayedSimpleClick = function(btn, clickInfo, cb) {
      if (Date.now() - _this._previousStartingPointerTime > InputManager2.DoubleClickDelay && !_this._doubleClickOccured || btn !== _this._previousButtonPressed) {
        _this._doubleClickOccured = false;
        clickInfo.singleClick = true;
        clickInfo.ignore = false;
        cb(clickInfo, _this._currentPickResult);
      }
    };
    this._initClickEvent = function(obs1, obs2, evt, cb) {
      var clickInfo = new _ClickInfo();
      _this._currentPickResult = null;
      var act = null;
      var checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
      if (!checkPicking && AbstractActionManager) {
        act = _this._initActionManager(act, clickInfo);
        if (act) {
          checkPicking = act.hasPickTriggers;
        }
      }
      var needToIgnoreNext = false;
      if (checkPicking) {
        var btn = evt.button;
        clickInfo.hasSwiped = _this._isPointerSwiping();
        if (!clickInfo.hasSwiped) {
          var checkSingleClickImmediately = !InputManager2.ExclusiveDoubleClickMode;
          if (!checkSingleClickImmediately) {
            checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
            if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {
              act = _this._initActionManager(act, clickInfo);
              if (act) {
                checkSingleClickImmediately = !act.hasSpecificTrigger(6);
              }
            }
          }
          if (checkSingleClickImmediately) {
            if (Date.now() - _this._previousStartingPointerTime > InputManager2.DoubleClickDelay || btn !== _this._previousButtonPressed) {
              clickInfo.singleClick = true;
              cb(clickInfo, _this._currentPickResult);
              needToIgnoreNext = true;
            }
          } else {
            _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
            _this._delayedSimpleClickTimeout = window.setTimeout(_this._delayedSimpleClick.bind(_this, btn, clickInfo, cb), InputManager2.DoubleClickDelay);
          }
          var checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
          if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {
            act = _this._initActionManager(act, clickInfo);
            if (act) {
              checkDoubleClick = act.hasSpecificTrigger(6);
            }
          }
          if (checkDoubleClick) {
            if (btn === _this._previousButtonPressed && Date.now() - _this._previousStartingPointerTime < InputManager2.DoubleClickDelay && !_this._doubleClickOccured) {
              if (!clickInfo.hasSwiped && !_this._isPointerSwiping()) {
                _this._previousStartingPointerTime = 0;
                _this._doubleClickOccured = true;
                clickInfo.doubleClick = true;
                clickInfo.ignore = false;
                if (InputManager2.ExclusiveDoubleClickMode && _this._previousDelayedSimpleClickTimeout) {
                  clearTimeout(_this._previousDelayedSimpleClickTimeout);
                }
                _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
                cb(clickInfo, _this._currentPickResult);
              } else {
                _this._doubleClickOccured = false;
                _this._previousStartingPointerTime = _this._startingPointerTime;
                _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;
                _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;
                _this._previousButtonPressed = btn;
                if (InputManager2.ExclusiveDoubleClickMode) {
                  if (_this._previousDelayedSimpleClickTimeout) {
                    clearTimeout(_this._previousDelayedSimpleClickTimeout);
                  }
                  _this._previousDelayedSimpleClickTimeout = _this._delayedSimpleClickTimeout;
                  cb(clickInfo, _this._previousPickResult);
                } else {
                  cb(clickInfo, _this._currentPickResult);
                }
              }
              needToIgnoreNext = true;
            } else {
              _this._doubleClickOccured = false;
              _this._previousStartingPointerTime = _this._startingPointerTime;
              _this._previousStartingPointerPosition.x = _this._startingPointerPosition.x;
              _this._previousStartingPointerPosition.y = _this._startingPointerPosition.y;
              _this._previousButtonPressed = btn;
            }
          }
        }
      }
      if (!needToIgnoreNext) {
        cb(clickInfo, _this._currentPickResult);
      }
    };
    this._onPointerMove = function(evt) {
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      _this._updatePointerPosition(evt);
      if (_this._checkPrePointerObservable(null, evt, evt.type === "wheel" || evt.type === "mousewheel" || evt.type === "DOMMouseScroll" ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      if (scene.skipPointerMovePicking) {
        _this._processPointerMove(new PickingInfo(), evt);
        return;
      }
      if (!scene.pointerMovePredicate) {
        scene.pointerMovePredicate = function(mesh) {
          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
        };
      }
      var pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerMovePredicate, false, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);
      _this._processPointerMove(pickResult, evt);
    };
    this._onPointerDown = function(evt) {
      _this._totalPointersPressed++;
      _this._pickedDownMesh = null;
      _this._meshPickProceed = false;
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      _this._updatePointerPosition(evt);
      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      _this._startingPointerPosition.x = _this._pointerX;
      _this._startingPointerPosition.y = _this._pointerY;
      _this._startingPointerTime = Date.now();
      if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {
        return;
      }
      if (!scene.cameraToUseForPointers && !scene.activeCamera) {
        return;
      }
      _this._pointerCaptures[evt.pointerId] = true;
      if (!scene.pointerDownPredicate) {
        scene.pointerDownPredicate = function(mesh) {
          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
        };
      }
      _this._pickedDownMesh = null;
      var pickResult;
      if (scene.skipPointerDownPicking) {
        pickResult = new PickingInfo();
      } else {
        pickResult = scene.pick(_this._unTranslatedPointerX, _this._unTranslatedPointerY, scene.pointerDownPredicate, false, scene.cameraToUseForPointers);
      }
      _this._processPointerDown(pickResult, evt);
    };
    this._onPointerUp = function(evt) {
      if (_this._totalPointersPressed === 0) {
        return;
      }
      _this._totalPointersPressed--;
      _this._pickedUpMesh = null;
      _this._meshPickProceed = false;
      if (evt.pointerId === void 0) {
        evt.pointerId = 0;
      }
      _this._updatePointerPosition(evt);
      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {
        evt.preventDefault();
        elementToAttachTo.focus();
      }
      _this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, function(clickInfo, pickResult) {
        if (scene.onPrePointerObservable.hasObservers()) {
          if (!clickInfo.ignore) {
            if (!clickInfo.hasSwiped) {
              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {
                  return;
                }
              }
              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
                if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {
                  return;
                }
              }
            }
            if (_this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {
              return;
            }
          }
        }
        if (!_this._pointerCaptures[evt.pointerId] && evt.buttons > 0) {
          return;
        }
        _this._pointerCaptures[evt.pointerId] = false;
        if (!scene.cameraToUseForPointers && !scene.activeCamera) {
          return;
        }
        if (!scene.pointerUpPredicate) {
          scene.pointerUpPredicate = function(mesh) {
            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
          };
        }
        if (!_this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || scene.onPointerObservable.hasObservers())) {
          _this._initActionManager(null, clickInfo);
        }
        if (!pickResult) {
          pickResult = _this._currentPickResult;
        }
        _this._processPointerUp(pickResult, evt, clickInfo);
        _this._previousPickResult = _this._currentPickResult;
      });
    };
    this._onKeyDown = function(evt) {
      var type = KeyboardEventTypes.KEYDOWN;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._onKeyUp = function(evt) {
      var type = KeyboardEventTypes.KEYUP;
      if (scene.onPreKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfoPre(type, evt);
        scene.onPreKeyboardObservable.notifyObservers(pi, type);
        if (pi.skipOnKeyboardObservable) {
          return;
        }
      }
      if (scene.onKeyboardObservable.hasObservers()) {
        var pi = new KeyboardInfo(type, evt);
        scene.onKeyboardObservable.notifyObservers(pi, type);
      }
      if (scene.actionManager) {
        scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));
      }
    };
    this._deviceSourceManager.onDeviceConnectedObservable.add(function(deviceSource) {
      if (deviceSource.deviceType === DeviceType.Mouse) {
        deviceSource.onInputChangedObservable.add(function(eventData) {
          if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick) {
            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
              _this._onPointerDown(eventData);
            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
              _this._onPointerUp(eventData);
            }
          } else if (attachMove) {
            if (eventData.inputIndex === PointerInput.Move) {
              _this._onPointerMove(eventData);
            } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {
              _this._onPointerMove(eventData);
            }
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Touch) {
        deviceSource.onInputChangedObservable.add(function(eventData) {
          if (eventData.inputIndex === PointerInput.LeftClick) {
            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
              _this._onPointerDown(eventData);
            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
              _this._onPointerUp(eventData);
            }
          }
          if (attachMove && eventData.inputIndex === PointerInput.Move) {
            _this._onPointerMove(eventData);
          }
        });
      } else if (deviceSource.deviceType === DeviceType.Keyboard) {
        deviceSource.onInputChangedObservable.add(function(eventData) {
          if (eventData.type === "keydown") {
            _this._onKeyDown(eventData);
          } else if (eventData.type === "keyup") {
            _this._onKeyUp(eventData);
          }
        });
      }
    });
    this._alreadyAttached = true;
  };
  InputManager2.prototype.detachControl = function() {
    if (this._alreadyAttached) {
      this._deviceSourceManager.dispose();
      this._deviceSourceManager = null;
      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {
        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;
      }
      this._alreadyAttached = false;
      this._alreadyAttachedTo = null;
    }
  };
  InputManager2.prototype.setPointerOverMesh = function(mesh, pointerId, pickResult) {
    if (pointerId === void 0) {
      pointerId = 0;
    }
    if (this._meshUnderPointerId[pointerId] === mesh) {
      return;
    }
    var underPointerMesh = this._meshUnderPointerId[pointerId];
    var actionManager;
    if (underPointerMesh) {
      actionManager = underPointerMesh._getActionManagerForTrigger(10);
      if (actionManager) {
        actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, void 0, { pointerId }));
      }
    }
    if (mesh) {
      this._meshUnderPointerId[pointerId] = mesh;
      this._pointerOverMesh = mesh;
      actionManager = mesh._getActionManagerForTrigger(9);
      if (actionManager) {
        actionManager.processTrigger(9, ActionEvent.CreateNew(mesh, void 0, { pointerId, pickResult }));
      }
    } else {
      delete this._meshUnderPointerId[pointerId];
      this._pointerOverMesh = null;
    }
  };
  InputManager2.prototype.getPointerOverMesh = function() {
    return this._pointerOverMesh;
  };
  InputManager2.prototype._invalidateMesh = function(mesh) {
    if (this._pointerOverMesh === mesh) {
      this._pointerOverMesh = null;
    }
    if (this._pickedDownMesh === mesh) {
      this._pickedDownMesh = null;
    }
    if (this._pickedUpMesh === mesh) {
      this._pickedUpMesh = null;
    }
    for (var pointerId in this._meshUnderPointerId) {
      if (this._meshUnderPointerId[pointerId] === mesh) {
        delete this._meshUnderPointerId[pointerId];
      }
    }
  };
  InputManager2.DragMovementThreshold = 10;
  InputManager2.LongPressDelay = 500;
  InputManager2.DoubleClickDelay = 300;
  InputManager2.ExclusiveDoubleClickMode = false;
  return InputManager2;
}();
var UniqueIdGenerator = function() {
  function UniqueIdGenerator2() {
  }
  Object.defineProperty(UniqueIdGenerator2, "UniqueId", {
    get: function() {
      var result = this._UniqueIdCounter;
      this._UniqueIdCounter++;
      return result;
    },
    enumerable: false,
    configurable: true
  });
  UniqueIdGenerator2._UniqueIdCounter = 1;
  return UniqueIdGenerator2;
}();
var LightConstants = function() {
  function LightConstants2() {
  }
  LightConstants2.CompareLightsPriority = function(a, b) {
    if (a.shadowEnabled !== b.shadowEnabled) {
      return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);
    }
    return b.renderPriority - a.renderPriority;
  };
  LightConstants2.FALLOFF_DEFAULT = 0;
  LightConstants2.FALLOFF_PHYSICAL = 1;
  LightConstants2.FALLOFF_GLTF = 2;
  LightConstants2.FALLOFF_STANDARD = 3;
  LightConstants2.LIGHTMAP_DEFAULT = 0;
  LightConstants2.LIGHTMAP_SPECULAR = 1;
  LightConstants2.LIGHTMAP_SHADOWSONLY = 2;
  LightConstants2.INTENSITYMODE_AUTOMATIC = 0;
  LightConstants2.INTENSITYMODE_LUMINOUSPOWER = 1;
  LightConstants2.INTENSITYMODE_LUMINOUSINTENSITY = 2;
  LightConstants2.INTENSITYMODE_ILLUMINANCE = 3;
  LightConstants2.INTENSITYMODE_LUMINANCE = 4;
  LightConstants2.LIGHTTYPEID_POINTLIGHT = 0;
  LightConstants2.LIGHTTYPEID_DIRECTIONALLIGHT = 1;
  LightConstants2.LIGHTTYPEID_SPOTLIGHT = 2;
  LightConstants2.LIGHTTYPEID_HEMISPHERICLIGHT = 3;
  return LightConstants2;
}();
var ComputePressureObserverWrapper = function() {
  function ComputePressureObserverWrapper2(callback, thresholds) {
    if (ComputePressureObserverWrapper2.IsAvailable) {
      this._observer = new window.ComputePressureObserver(callback, thresholds);
    }
  }
  Object.defineProperty(ComputePressureObserverWrapper2, "IsAvailable", {
    get: function() {
      return IsWindowObjectExist() && "ComputePressureObserver" in window;
    },
    enumerable: false,
    configurable: true
  });
  ComputePressureObserverWrapper2.prototype.observe = function() {
    var _a2, _b2;
    ((_a2 = this._observer) === null || _a2 === void 0 ? void 0 : _a2.observe) && ((_b2 = this._observer) === null || _b2 === void 0 ? void 0 : _b2.observe().catch(function() {
    }));
  };
  ComputePressureObserverWrapper2.prototype.unobserve = function() {
    var _a2, _b2;
    ((_a2 = this._observer) === null || _a2 === void 0 ? void 0 : _a2.unobserve) && ((_b2 = this._observer) === null || _b2 === void 0 ? void 0 : _b2.unobserve());
  };
  return ComputePressureObserverWrapper2;
}();
var Scene = function(_super) {
  __extends(Scene2, _super);
  function Scene2(engine, options) {
    var _this = _super.call(this) || this;
    _this._inputManager = new InputManager(_this);
    _this.cameraToUseForPointers = null;
    _this._isScene = true;
    _this._blockEntityCollection = false;
    _this.autoClear = true;
    _this.autoClearDepthAndStencil = true;
    _this.clearColor = new Color4(0.2, 0.2, 0.3, 1);
    _this.ambientColor = new Color3(0, 0, 0);
    _this.environmentIntensity = 1;
    _this._forceWireframe = false;
    _this._skipFrustumClipping = false;
    _this._forcePointsCloud = false;
    _this.animationsEnabled = true;
    _this._animationPropertiesOverride = null;
    _this.useConstantAnimationDeltaTime = false;
    _this.constantlyUpdateMeshUnderPointer = false;
    _this.hoverCursor = "pointer";
    _this.defaultCursor = "";
    _this.doNotHandleCursors = false;
    _this.preventDefaultOnPointerDown = true;
    _this.preventDefaultOnPointerUp = true;
    _this.metadata = null;
    _this.reservedDataStore = null;
    _this.disableOfflineSupportExceptionRules = new Array();
    _this.onDisposeObservable = new Observable();
    _this._onDisposeObserver = null;
    _this.onBeforeRenderObservable = new Observable();
    _this._onBeforeRenderObserver = null;
    _this.onAfterRenderObservable = new Observable();
    _this.onAfterRenderCameraObservable = new Observable();
    _this._onAfterRenderObserver = null;
    _this.onBeforeAnimationsObservable = new Observable();
    _this.onAfterAnimationsObservable = new Observable();
    _this.onBeforeDrawPhaseObservable = new Observable();
    _this.onAfterDrawPhaseObservable = new Observable();
    _this.onReadyObservable = new Observable();
    _this.onBeforeCameraRenderObservable = new Observable();
    _this._onBeforeCameraRenderObserver = null;
    _this.onAfterCameraRenderObservable = new Observable();
    _this._onAfterCameraRenderObserver = null;
    _this.onBeforeActiveMeshesEvaluationObservable = new Observable();
    _this.onAfterActiveMeshesEvaluationObservable = new Observable();
    _this.onBeforeParticlesRenderingObservable = new Observable();
    _this.onAfterParticlesRenderingObservable = new Observable();
    _this.onDataLoadedObservable = new Observable();
    _this.onNewCameraAddedObservable = new Observable();
    _this.onCameraRemovedObservable = new Observable();
    _this.onNewLightAddedObservable = new Observable();
    _this.onLightRemovedObservable = new Observable();
    _this.onNewGeometryAddedObservable = new Observable();
    _this.onGeometryRemovedObservable = new Observable();
    _this.onNewTransformNodeAddedObservable = new Observable();
    _this.onTransformNodeRemovedObservable = new Observable();
    _this.onNewMeshAddedObservable = new Observable();
    _this.onMeshRemovedObservable = new Observable();
    _this.onNewSkeletonAddedObservable = new Observable();
    _this.onSkeletonRemovedObservable = new Observable();
    _this.onNewMaterialAddedObservable = new Observable();
    _this.onNewMultiMaterialAddedObservable = new Observable();
    _this.onMaterialRemovedObservable = new Observable();
    _this.onMultiMaterialRemovedObservable = new Observable();
    _this.onNewTextureAddedObservable = new Observable();
    _this.onTextureRemovedObservable = new Observable();
    _this.onBeforeRenderTargetsRenderObservable = new Observable();
    _this.onAfterRenderTargetsRenderObservable = new Observable();
    _this.onBeforeStepObservable = new Observable();
    _this.onAfterStepObservable = new Observable();
    _this.onActiveCameraChanged = new Observable();
    _this.onBeforeRenderingGroupObservable = new Observable();
    _this.onAfterRenderingGroupObservable = new Observable();
    _this.onMeshImportedObservable = new Observable();
    _this.onAnimationFileImportedObservable = new Observable();
    _this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);
    _this.skipPointerMovePicking = false;
    _this.skipPointerDownPicking = false;
    _this.skipPointerUpPicking = false;
    _this.onPrePointerObservable = new Observable();
    _this.onPointerObservable = new Observable();
    _this.onPreKeyboardObservable = new Observable();
    _this.onKeyboardObservable = new Observable();
    _this._useRightHandedSystem = false;
    _this._timeAccumulator = 0;
    _this._currentStepId = 0;
    _this._currentInternalStep = 0;
    _this._fogEnabled = true;
    _this._fogMode = Scene2.FOGMODE_NONE;
    _this.fogColor = new Color3(0.2, 0.2, 0.3);
    _this.fogDensity = 0.1;
    _this.fogStart = 0;
    _this.fogEnd = 1e3;
    _this.needsPreviousWorldMatrices = false;
    _this._shadowsEnabled = true;
    _this._lightsEnabled = true;
    _this.activeCameras = new Array();
    _this._texturesEnabled = true;
    _this.physicsEnabled = true;
    _this.particlesEnabled = true;
    _this.spritesEnabled = true;
    _this._skeletonsEnabled = true;
    _this.lensFlaresEnabled = true;
    _this.collisionsEnabled = true;
    _this.gravity = new Vector3(0, -9.807, 0);
    _this.postProcessesEnabled = true;
    _this.renderTargetsEnabled = true;
    _this.dumpNextRenderTargets = false;
    _this.customRenderTargets = new Array();
    _this.importedMeshesFiles = new Array();
    _this.probesEnabled = true;
    _this._meshesForIntersections = new SmartArrayNoDuplicate(256);
    _this.proceduralTexturesEnabled = true;
    _this._totalVertices = new PerfCounter();
    _this._activeIndices = new PerfCounter();
    _this._activeParticles = new PerfCounter();
    _this._activeBones = new PerfCounter();
    _this._animationTime = 0;
    _this.animationTimeScale = 1;
    _this._renderId = 0;
    _this._frameId = 0;
    _this._executeWhenReadyTimeoutId = null;
    _this._intermediateRendering = false;
    _this._defaultFrameBufferCleared = false;
    _this._viewUpdateFlag = -1;
    _this._projectionUpdateFlag = -1;
    _this._toBeDisposed = new Array(256);
    _this._activeRequests = new Array();
    _this._pendingData = new Array();
    _this._isDisposed = false;
    _this.dispatchAllSubMeshesOfActiveMeshes = false;
    _this._activeMeshes = new SmartArray(256);
    _this._processedMaterials = new SmartArray(256);
    _this._renderTargets = new SmartArrayNoDuplicate(256);
    _this._materialsRenderTargets = new SmartArrayNoDuplicate(256);
    _this._activeParticleSystems = new SmartArray(256);
    _this._activeSkeletons = new SmartArrayNoDuplicate(32);
    _this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);
    _this._activeAnimatables = new Array();
    _this._transformMatrix = Matrix.Zero();
    _this.requireLightSorting = false;
    _this._components = [];
    _this._serializableComponents = [];
    _this._transientComponents = [];
    _this._beforeCameraUpdateStage = Stage.Create();
    _this._beforeClearStage = Stage.Create();
    _this._beforeRenderTargetClearStage = Stage.Create();
    _this._gatherRenderTargetsStage = Stage.Create();
    _this._gatherActiveCameraRenderTargetsStage = Stage.Create();
    _this._isReadyForMeshStage = Stage.Create();
    _this._beforeEvaluateActiveMeshStage = Stage.Create();
    _this._evaluateSubMeshStage = Stage.Create();
    _this._preActiveMeshStage = Stage.Create();
    _this._cameraDrawRenderTargetStage = Stage.Create();
    _this._beforeCameraDrawStage = Stage.Create();
    _this._beforeRenderTargetDrawStage = Stage.Create();
    _this._beforeRenderingGroupDrawStage = Stage.Create();
    _this._beforeRenderingMeshStage = Stage.Create();
    _this._afterRenderingMeshStage = Stage.Create();
    _this._afterRenderingGroupDrawStage = Stage.Create();
    _this._afterCameraDrawStage = Stage.Create();
    _this._afterRenderTargetDrawStage = Stage.Create();
    _this._afterRenderStage = Stage.Create();
    _this._pointerMoveStage = Stage.Create();
    _this._pointerDownStage = Stage.Create();
    _this._pointerUpStage = Stage.Create();
    _this._geometriesByUniqueId = null;
    _this._defaultMeshCandidates = {
      data: [],
      length: 0
    };
    _this._defaultSubMeshCandidates = {
      data: [],
      length: 0
    };
    _this._preventFreeActiveMeshesAndRenderingGroups = false;
    _this._activeMeshesFrozen = false;
    _this._activeMeshesFrozenButKeepClipping = false;
    _this._skipEvaluateActiveMeshesCompletely = false;
    _this._allowPostProcessClearColor = true;
    _this.getDeterministicFrameTime = function() {
      return _this._engine.getTimeStep();
    };
    _this._blockMaterialDirtyMechanism = false;
    _this._perfCollector = null;
    _this.onComputePressureChanged = new Observable();
    var fullOptions = __assign({ useGeometryUniqueIdsMap: true, useMaterialMeshMap: true, useClonedMeshMap: true, virtual: false }, options);
    _this._engine = engine || EngineStore.LastCreatedEngine;
    if (!fullOptions.virtual) {
      EngineStore._LastCreatedScene = _this;
      _this._engine.scenes.push(_this);
    } else {
      _this._engine._virtualScenes.push(_this);
    }
    _this._uid = null;
    _this._renderingManager = new RenderingManager(_this);
    if (PostProcessManager) {
      _this.postProcessManager = new PostProcessManager(_this);
    }
    if (IsWindowObjectExist()) {
      _this.attachControl();
    }
    _this._createUbo();
    if (ImageProcessingConfiguration) {
      _this._imageProcessingConfiguration = new ImageProcessingConfiguration();
    }
    _this.setDefaultCandidateProviders();
    if (fullOptions.useGeometryUniqueIdsMap) {
      _this._geometriesByUniqueId = {};
    }
    _this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;
    _this.useClonedMeshMap = fullOptions.useClonedMeshMap;
    if (!options || !options.virtual) {
      _this._engine.onNewSceneAddedObservable.notifyObservers(_this);
    }
    if (ComputePressureObserverWrapper.IsAvailable) {
      _this._computePressureObserver = new ComputePressureObserverWrapper(function(update2) {
        _this.onComputePressureChanged.notifyObservers(update2);
      }, {
        cpuUtilizationThresholds: [0.25, 0.5, 0.75, 0.9],
        cpuSpeedThresholds: [0.5]
      });
      _this._computePressureObserver.observe();
    }
    return _this;
  }
  Scene2.DefaultMaterialFactory = function(scene) {
    throw _WarnImport("StandardMaterial");
  };
  Scene2.CollisionCoordinatorFactory = function() {
    throw _WarnImport("DefaultCollisionCoordinator");
  };
  Object.defineProperty(Scene2.prototype, "environmentTexture", {
    get: function() {
      return this._environmentTexture;
    },
    set: function(value) {
      if (this._environmentTexture === value) {
        return;
      }
      this._environmentTexture = value;
      this.markAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "forceWireframe", {
    get: function() {
      return this._forceWireframe;
    },
    set: function(value) {
      if (this._forceWireframe === value) {
        return;
      }
      this._forceWireframe = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "skipFrustumClipping", {
    get: function() {
      return this._skipFrustumClipping;
    },
    set: function(value) {
      if (this._skipFrustumClipping === value) {
        return;
      }
      this._skipFrustumClipping = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "forcePointsCloud", {
    get: function() {
      return this._forcePointsCloud;
    },
    set: function(value) {
      if (this._forcePointsCloud === value) {
        return;
      }
      this._forcePointsCloud = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "animationPropertiesOverride", {
    get: function() {
      return this._animationPropertiesOverride;
    },
    set: function(value) {
      this._animationPropertiesOverride = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "beforeRender", {
    set: function(callback) {
      if (this._onBeforeRenderObserver) {
        this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
      }
      if (callback) {
        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "afterRender", {
    set: function(callback) {
      if (this._onAfterRenderObserver) {
        this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
      }
      if (callback) {
        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "beforeCameraRender", {
    set: function(callback) {
      if (this._onBeforeCameraRenderObserver) {
        this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
      }
      this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "afterCameraRender", {
    set: function(callback) {
      if (this._onAfterCameraRenderObserver) {
        this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
      }
      this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "unTranslatedPointer", {
    get: function() {
      return this._inputManager.unTranslatedPointer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "DragMovementThreshold", {
    get: function() {
      return InputManager.DragMovementThreshold;
    },
    set: function(value) {
      InputManager.DragMovementThreshold = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "LongPressDelay", {
    get: function() {
      return InputManager.LongPressDelay;
    },
    set: function(value) {
      InputManager.LongPressDelay = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "DoubleClickDelay", {
    get: function() {
      return InputManager.DoubleClickDelay;
    },
    set: function(value) {
      InputManager.DoubleClickDelay = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2, "ExclusiveDoubleClickMode", {
    get: function() {
      return InputManager.ExclusiveDoubleClickMode;
    },
    set: function(value) {
      InputManager.ExclusiveDoubleClickMode = value;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.bindEyePosition = function(effect, variableName, isVector3) {
    var _a2;
    if (variableName === void 0) {
      variableName = "vEyePosition";
    }
    if (isVector3 === void 0) {
      isVector3 = false;
    }
    var eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (_a2 = this.activeCamera.globalPosition) !== null && _a2 !== void 0 ? _a2 : this.activeCamera.devicePosition;
    var invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
    TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);
    if (effect) {
      if (isVector3) {
        effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);
      } else {
        effect.setVector4(variableName, TmpVectors.Vector4[0]);
      }
    }
    return TmpVectors.Vector4[0];
  };
  Scene2.prototype.finalizeSceneUbo = function() {
    var ubo = this.getSceneUniformBuffer();
    var eyePosition = this.bindEyePosition(null);
    ubo.updateFloat4("vEyePosition", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);
    ubo.update();
    return ubo;
  };
  Object.defineProperty(Scene2.prototype, "useRightHandedSystem", {
    get: function() {
      return this._useRightHandedSystem;
    },
    set: function(value) {
      if (this._useRightHandedSystem === value) {
        return;
      }
      this._useRightHandedSystem = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.setStepId = function(newStepId) {
    this._currentStepId = newStepId;
  };
  Scene2.prototype.getStepId = function() {
    return this._currentStepId;
  };
  Scene2.prototype.getInternalStep = function() {
    return this._currentInternalStep;
  };
  Object.defineProperty(Scene2.prototype, "fogEnabled", {
    get: function() {
      return this._fogEnabled;
    },
    set: function(value) {
      if (this._fogEnabled === value) {
        return;
      }
      this._fogEnabled = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "fogMode", {
    get: function() {
      return this._fogMode;
    },
    set: function(value) {
      if (this._fogMode === value) {
        return;
      }
      this._fogMode = value;
      this.markAllMaterialsAsDirty(16);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "prePass", {
    get: function() {
      return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "shadowsEnabled", {
    get: function() {
      return this._shadowsEnabled;
    },
    set: function(value) {
      if (this._shadowsEnabled === value) {
        return;
      }
      this._shadowsEnabled = value;
      this.markAllMaterialsAsDirty(2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "lightsEnabled", {
    get: function() {
      return this._lightsEnabled;
    },
    set: function(value) {
      if (this._lightsEnabled === value) {
        return;
      }
      this._lightsEnabled = value;
      this.markAllMaterialsAsDirty(2);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "activeCamera", {
    get: function() {
      return this._activeCamera;
    },
    set: function(value) {
      if (value === this._activeCamera) {
        return;
      }
      this._activeCamera = value;
      this.onActiveCameraChanged.notifyObservers(this);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "defaultMaterial", {
    get: function() {
      if (!this._defaultMaterial) {
        this._defaultMaterial = Scene2.DefaultMaterialFactory(this);
      }
      return this._defaultMaterial;
    },
    set: function(value) {
      this._defaultMaterial = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "texturesEnabled", {
    get: function() {
      return this._texturesEnabled;
    },
    set: function(value) {
      if (this._texturesEnabled === value) {
        return;
      }
      this._texturesEnabled = value;
      this.markAllMaterialsAsDirty(1);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "skeletonsEnabled", {
    get: function() {
      return this._skeletonsEnabled;
    },
    set: function(value) {
      if (this._skeletonsEnabled === value) {
        return;
      }
      this._skeletonsEnabled = value;
      this.markAllMaterialsAsDirty(8);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "collisionCoordinator", {
    get: function() {
      if (!this._collisionCoordinator) {
        this._collisionCoordinator = Scene2.CollisionCoordinatorFactory();
        this._collisionCoordinator.init(this);
      }
      return this._collisionCoordinator;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "frustumPlanes", {
    get: function() {
      return this._frustumPlanes;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype._registerTransientComponents = function() {
    if (this._transientComponents.length > 0) {
      for (var _i = 0, _a2 = this._transientComponents; _i < _a2.length; _i++) {
        var component = _a2[_i];
        component.register();
      }
      this._transientComponents = [];
    }
  };
  Scene2.prototype._addComponent = function(component) {
    this._components.push(component);
    this._transientComponents.push(component);
    var serializableComponent = component;
    if (serializableComponent.addFromContainer && serializableComponent.serialize) {
      this._serializableComponents.push(serializableComponent);
    }
  };
  Scene2.prototype._getComponent = function(name2) {
    for (var _i = 0, _a2 = this._components; _i < _a2.length; _i++) {
      var component = _a2[_i];
      if (component.name === name2) {
        return component;
      }
    }
    return null;
  };
  Scene2.prototype.getClassName = function() {
    return "Scene";
  };
  Scene2.prototype._getDefaultMeshCandidates = function() {
    this._defaultMeshCandidates.data = this.meshes;
    this._defaultMeshCandidates.length = this.meshes.length;
    return this._defaultMeshCandidates;
  };
  Scene2.prototype._getDefaultSubMeshCandidates = function(mesh) {
    this._defaultSubMeshCandidates.data = mesh.subMeshes;
    this._defaultSubMeshCandidates.length = mesh.subMeshes.length;
    return this._defaultSubMeshCandidates;
  };
  Scene2.prototype.setDefaultCandidateProviders = function() {
    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);
    this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
    this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
    this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
  };
  Object.defineProperty(Scene2.prototype, "meshUnderPointer", {
    get: function() {
      return this._inputManager.meshUnderPointer;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "pointerX", {
    get: function() {
      return this._inputManager.pointerX;
    },
    set: function(value) {
      this._inputManager.pointerX = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Scene2.prototype, "pointerY", {
    get: function() {
      return this._inputManager.pointerY;
    },
    set: function(value) {
      this._inputManager.pointerY = value;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getCachedMaterial = function() {
    return this._cachedMaterial;
  };
  Scene2.prototype.getCachedEffect = function() {
    return this._cachedEffect;
  };
  Scene2.prototype.getCachedVisibility = function() {
    return this._cachedVisibility;
  };
  Scene2.prototype.isCachedMaterialInvalid = function(material, effect, visibility) {
    if (visibility === void 0) {
      visibility = 1;
    }
    return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;
  };
  Scene2.prototype.getEngine = function() {
    return this._engine;
  };
  Scene2.prototype.getTotalVertices = function() {
    return this._totalVertices.current;
  };
  Object.defineProperty(Scene2.prototype, "totalVerticesPerfCounter", {
    get: function() {
      return this._totalVertices;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveIndices = function() {
    return this._activeIndices.current;
  };
  Object.defineProperty(Scene2.prototype, "totalActiveIndicesPerfCounter", {
    get: function() {
      return this._activeIndices;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveParticles = function() {
    return this._activeParticles.current;
  };
  Object.defineProperty(Scene2.prototype, "activeParticlesPerfCounter", {
    get: function() {
      return this._activeParticles;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveBones = function() {
    return this._activeBones.current;
  };
  Object.defineProperty(Scene2.prototype, "activeBonesPerfCounter", {
    get: function() {
      return this._activeBones;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.getActiveMeshes = function() {
    return this._activeMeshes;
  };
  Scene2.prototype.getAnimationRatio = function() {
    return this._animationRatio !== void 0 ? this._animationRatio : 1;
  };
  Scene2.prototype.getRenderId = function() {
    return this._renderId;
  };
  Scene2.prototype.getFrameId = function() {
    return this._frameId;
  };
  Scene2.prototype.incrementRenderId = function() {
    this._renderId++;
  };
  Scene2.prototype._createUbo = function() {
    this.setSceneUniformBuffer(this.createSceneUniformBuffer());
  };
  Scene2.prototype.simulatePointerMove = function(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerMove(pickResult, pointerEventInit);
    return this;
  };
  Scene2.prototype.simulatePointerDown = function(pickResult, pointerEventInit) {
    this._inputManager.simulatePointerDown(pickResult, pointerEventInit);
    return this;
  };
  Scene2.prototype.simulatePointerUp = function(pickResult, pointerEventInit, doubleTap) {
    this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);
    return this;
  };
  Scene2.prototype.isPointerCaptured = function(pointerId) {
    if (pointerId === void 0) {
      pointerId = 0;
    }
    return this._inputManager.isPointerCaptured(pointerId);
  };
  Scene2.prototype.attachControl = function(attachUp, attachDown, attachMove) {
    if (attachUp === void 0) {
      attachUp = true;
    }
    if (attachDown === void 0) {
      attachDown = true;
    }
    if (attachMove === void 0) {
      attachMove = true;
    }
    this._inputManager.attachControl(attachUp, attachDown, attachMove);
  };
  Scene2.prototype.detachControl = function() {
    this._inputManager.detachControl();
  };
  Scene2.prototype.isReady = function(checkRenderTargets) {
    if (checkRenderTargets === void 0) {
      checkRenderTargets = true;
    }
    if (this._isDisposed) {
      return false;
    }
    var index;
    var engine = this.getEngine();
    var isReady = true;
    if (this._pendingData.length > 0) {
      isReady = false;
    }
    if (checkRenderTargets) {
      this._processedMaterials.reset();
      this._materialsRenderTargets.reset();
    }
    for (index = 0; index < this.meshes.length; index++) {
      var mesh = this.meshes[index];
      if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
        continue;
      }
      if (!mesh.isReady(true)) {
        isReady = false;
        continue;
      }
      var hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === "InstancedMesh" || mesh.getClassName() === "InstancedLinesMesh" || engine.getCaps().instancedArrays && mesh.instances.length > 0;
      for (var _i = 0, _a2 = this._isReadyForMeshStage; _i < _a2.length; _i++) {
        var step = _a2[_i];
        if (!step.action(mesh, hardwareInstancedRendering)) {
          isReady = false;
        }
      }
      if (!checkRenderTargets) {
        continue;
      }
      var mat = mesh.material || this.defaultMaterial;
      if (mat) {
        if (mat._storeEffectOnSubMeshes) {
          for (var _b2 = 0, _c2 = mesh.subMeshes; _b2 < _c2.length; _b2++) {
            var subMesh = _c2[_b2];
            var material = subMesh.getMaterial();
            if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
              if (this._processedMaterials.indexOf(material) === -1) {
                this._processedMaterials.push(material);
                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
              }
            }
          }
        } else {
          if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {
            if (this._processedMaterials.indexOf(mat) === -1) {
              this._processedMaterials.push(mat);
              this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());
            }
          }
        }
      }
    }
    if (!isReady) {
      return false;
    }
    if (!engine.areAllEffectsReady()) {
      return false;
    }
    if (checkRenderTargets) {
      for (index = 0; index < this._materialsRenderTargets.length; ++index) {
        var rtt = this._materialsRenderTargets.data[index];
        if (!rtt.isReadyForRendering()) {
          return false;
        }
      }
    }
    for (index = 0; index < this.geometries.length; index++) {
      var geometry = this.geometries[index];
      if (geometry.delayLoadState === 2) {
        return false;
      }
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (var _d = 0, _e = this.activeCameras; _d < _e.length; _d++) {
        var camera = _e[_d];
        if (!camera.isReady(true)) {
          return false;
        }
      }
    } else if (this.activeCamera) {
      if (!this.activeCamera.isReady(true)) {
        return false;
      }
    }
    for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {
      var particleSystem = _g[_f];
      if (!particleSystem.isReady()) {
        return false;
      }
    }
    return true;
  };
  Scene2.prototype.resetCachedMaterial = function() {
    this._cachedMaterial = null;
    this._cachedEffect = null;
    this._cachedVisibility = null;
  };
  Scene2.prototype.registerBeforeRender = function(func) {
    this.onBeforeRenderObservable.add(func);
  };
  Scene2.prototype.unregisterBeforeRender = function(func) {
    this.onBeforeRenderObservable.removeCallback(func);
  };
  Scene2.prototype.registerAfterRender = function(func) {
    this.onAfterRenderObservable.add(func);
  };
  Scene2.prototype.unregisterAfterRender = function(func) {
    this.onAfterRenderObservable.removeCallback(func);
  };
  Scene2.prototype._executeOnceBeforeRender = function(func) {
    var _this = this;
    var execFunc = function() {
      func();
      setTimeout(function() {
        _this.unregisterBeforeRender(execFunc);
      });
    };
    this.registerBeforeRender(execFunc);
  };
  Scene2.prototype.executeOnceBeforeRender = function(func, timeout) {
    var _this = this;
    if (timeout !== void 0) {
      setTimeout(function() {
        _this._executeOnceBeforeRender(func);
      }, timeout);
    } else {
      this._executeOnceBeforeRender(func);
    }
  };
  Scene2.prototype._addPendingData = function(data) {
    this._pendingData.push(data);
  };
  Scene2.prototype._removePendingData = function(data) {
    var wasLoading = this.isLoading;
    var index = this._pendingData.indexOf(data);
    if (index !== -1) {
      this._pendingData.splice(index, 1);
    }
    if (wasLoading && !this.isLoading) {
      this.onDataLoadedObservable.notifyObservers(this);
    }
  };
  Scene2.prototype.getWaitingItemsCount = function() {
    return this._pendingData.length;
  };
  Object.defineProperty(Scene2.prototype, "isLoading", {
    get: function() {
      return this._pendingData.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.executeWhenReady = function(func, checkRenderTargets) {
    if (checkRenderTargets === void 0) {
      checkRenderTargets = false;
    }
    this.onReadyObservable.add(func);
    if (this._executeWhenReadyTimeoutId !== null) {
      return;
    }
    this._checkIsReady(checkRenderTargets);
  };
  Scene2.prototype.whenReadyAsync = function(checkRenderTargets) {
    var _this = this;
    if (checkRenderTargets === void 0) {
      checkRenderTargets = false;
    }
    return new Promise(function(resolve) {
      _this.executeWhenReady(function() {
        resolve();
      }, checkRenderTargets);
    });
  };
  Scene2.prototype._checkIsReady = function(checkRenderTargets) {
    var _this = this;
    if (checkRenderTargets === void 0) {
      checkRenderTargets = false;
    }
    this._registerTransientComponents();
    if (this.isReady(checkRenderTargets)) {
      this.onReadyObservable.notifyObservers(this);
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    if (this._isDisposed) {
      this.onReadyObservable.clear();
      this._executeWhenReadyTimeoutId = null;
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(function() {
      _this._checkIsReady(checkRenderTargets);
    }, 100);
  };
  Object.defineProperty(Scene2.prototype, "animatables", {
    get: function() {
      return this._activeAnimatables;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.resetLastAnimationTimeFrame = function() {
    this._animationTimeLast = PrecisionDate.Now;
  };
  Scene2.prototype.getViewMatrix = function() {
    return this._viewMatrix;
  };
  Scene2.prototype.getProjectionMatrix = function() {
    return this._projectionMatrix;
  };
  Scene2.prototype.getTransformMatrix = function() {
    return this._transformMatrix;
  };
  Scene2.prototype.setTransformMatrix = function(viewL, projectionL, viewR, projectionR) {
    if (!viewR && !projectionR && this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
      this._multiviewSceneUbo = null;
    }
    if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {
      return;
    }
    this._viewUpdateFlag = viewL.updateFlag;
    this._projectionUpdateFlag = projectionL.updateFlag;
    this._viewMatrix = viewL;
    this._projectionMatrix = projectionL;
    this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    if (!this._frustumPlanes) {
      this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
    } else {
      Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
    }
    if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {
      this._updateMultiviewUbo(viewR, projectionR);
    } else if (this._sceneUbo.useUbo) {
      this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix);
      this._sceneUbo.updateMatrix("view", this._viewMatrix);
      this._sceneUbo.updateMatrix("projection", this._projectionMatrix);
    }
  };
  Scene2.prototype.getSceneUniformBuffer = function() {
    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
  };
  Scene2.prototype.createSceneUniformBuffer = function(name2) {
    var sceneUbo = new UniformBuffer(this._engine, void 0, false, name2 !== null && name2 !== void 0 ? name2 : "scene");
    sceneUbo.addUniform("viewProjection", 16);
    sceneUbo.addUniform("view", 16);
    sceneUbo.addUniform("projection", 16);
    sceneUbo.addUniform("vEyePosition", 4);
    return sceneUbo;
  };
  Scene2.prototype.setSceneUniformBuffer = function(ubo) {
    this._sceneUbo = ubo;
    this._viewUpdateFlag = -1;
    this._projectionUpdateFlag = -1;
  };
  Scene2.prototype.getUniqueId = function() {
    return UniqueIdGenerator.UniqueId;
  };
  Scene2.prototype.addMesh = function(newMesh, recursive) {
    var _this = this;
    if (recursive === void 0) {
      recursive = false;
    }
    if (this._blockEntityCollection) {
      return;
    }
    this.meshes.push(newMesh);
    newMesh._resyncLightSources();
    if (!newMesh.parent) {
      newMesh._addToSceneRootNodes();
    }
    this.onNewMeshAddedObservable.notifyObservers(newMesh);
    if (recursive) {
      newMesh.getChildMeshes().forEach(function(m) {
        _this.addMesh(m);
      });
    }
  };
  Scene2.prototype.removeMesh = function(toRemove, recursive) {
    var _this = this;
    if (recursive === void 0) {
      recursive = false;
    }
    var index = this.meshes.indexOf(toRemove);
    if (index !== -1) {
      this.meshes[index] = this.meshes[this.meshes.length - 1];
      this.meshes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this._inputManager._invalidateMesh(toRemove);
    this.onMeshRemovedObservable.notifyObservers(toRemove);
    if (recursive) {
      toRemove.getChildMeshes().forEach(function(m) {
        _this.removeMesh(m);
      });
    }
    return index;
  };
  Scene2.prototype.addTransformNode = function(newTransformNode) {
    if (this._blockEntityCollection) {
      return;
    }
    if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {
      return;
    }
    newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;
    this.transformNodes.push(newTransformNode);
    if (!newTransformNode.parent) {
      newTransformNode._addToSceneRootNodes();
    }
    this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);
  };
  Scene2.prototype.removeTransformNode = function(toRemove) {
    var index = toRemove._indexInSceneTransformNodesArray;
    if (index !== -1) {
      if (index !== this.transformNodes.length - 1) {
        var lastNode = this.transformNodes[this.transformNodes.length - 1];
        this.transformNodes[index] = lastNode;
        lastNode._indexInSceneTransformNodesArray = index;
      }
      toRemove._indexInSceneTransformNodesArray = -1;
      this.transformNodes.pop();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onTransformNodeRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeSkeleton = function(toRemove) {
    var index = this.skeletons.indexOf(toRemove);
    if (index !== -1) {
      this.skeletons.splice(index, 1);
      this.onSkeletonRemovedObservable.notifyObservers(toRemove);
      this._executeActiveContainerCleanup(this._activeSkeletons);
    }
    return index;
  };
  Scene2.prototype.removeMorphTargetManager = function(toRemove) {
    var index = this.morphTargetManagers.indexOf(toRemove);
    if (index !== -1) {
      this.morphTargetManagers.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeLight = function(toRemove) {
    var index = this.lights.indexOf(toRemove);
    if (index !== -1) {
      for (var _i = 0, _a2 = this.meshes; _i < _a2.length; _i++) {
        var mesh = _a2[_i];
        mesh._removeLightSource(toRemove, false);
      }
      this.lights.splice(index, 1);
      this.sortLightsByPriority();
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    this.onLightRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeCamera = function(toRemove) {
    var index = this.cameras.indexOf(toRemove);
    if (index !== -1) {
      this.cameras.splice(index, 1);
      if (!toRemove.parent) {
        toRemove._removeFromSceneRootNodes();
      }
    }
    if (this.activeCameras) {
      var index2 = this.activeCameras.indexOf(toRemove);
      if (index2 !== -1) {
        this.activeCameras.splice(index2, 1);
      }
    }
    if (this.activeCamera === toRemove) {
      if (this.cameras.length > 0) {
        this.activeCamera = this.cameras[0];
      } else {
        this.activeCamera = null;
      }
    }
    this.onCameraRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeParticleSystem = function(toRemove) {
    var index = this.particleSystems.indexOf(toRemove);
    if (index !== -1) {
      this.particleSystems.splice(index, 1);
      this._executeActiveContainerCleanup(this._activeParticleSystems);
    }
    return index;
  };
  Scene2.prototype.removeAnimation = function(toRemove) {
    var index = this.animations.indexOf(toRemove);
    if (index !== -1) {
      this.animations.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.stopAnimation = function(target2, animationName, targetMask) {
  };
  Scene2.prototype.removeAnimationGroup = function(toRemove) {
    var index = this.animationGroups.indexOf(toRemove);
    if (index !== -1) {
      this.animationGroups.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeMultiMaterial = function(toRemove) {
    var index = this.multiMaterials.indexOf(toRemove);
    if (index !== -1) {
      this.multiMaterials.splice(index, 1);
    }
    this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeMaterial = function(toRemove) {
    var index = toRemove._indexInSceneMaterialArray;
    if (index !== -1 && index < this.materials.length) {
      if (index !== this.materials.length - 1) {
        var lastMaterial = this.materials[this.materials.length - 1];
        this.materials[index] = lastMaterial;
        lastMaterial._indexInSceneMaterialArray = index;
      }
      toRemove._indexInSceneMaterialArray = -1;
      this.materials.pop();
    }
    this.onMaterialRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.removeActionManager = function(toRemove) {
    var index = this.actionManagers.indexOf(toRemove);
    if (index !== -1) {
      this.actionManagers.splice(index, 1);
    }
    return index;
  };
  Scene2.prototype.removeTexture = function(toRemove) {
    var index = this.textures.indexOf(toRemove);
    if (index !== -1) {
      this.textures.splice(index, 1);
    }
    this.onTextureRemovedObservable.notifyObservers(toRemove);
    return index;
  };
  Scene2.prototype.addLight = function(newLight) {
    if (this._blockEntityCollection) {
      return;
    }
    this.lights.push(newLight);
    this.sortLightsByPriority();
    if (!newLight.parent) {
      newLight._addToSceneRootNodes();
    }
    for (var _i = 0, _a2 = this.meshes; _i < _a2.length; _i++) {
      var mesh = _a2[_i];
      if (mesh.lightSources.indexOf(newLight) === -1) {
        mesh.lightSources.push(newLight);
        mesh._resyncLightSources();
      }
    }
    this.onNewLightAddedObservable.notifyObservers(newLight);
  };
  Scene2.prototype.sortLightsByPriority = function() {
    if (this.requireLightSorting) {
      this.lights.sort(LightConstants.CompareLightsPriority);
    }
  };
  Scene2.prototype.addCamera = function(newCamera) {
    if (this._blockEntityCollection) {
      return;
    }
    this.cameras.push(newCamera);
    this.onNewCameraAddedObservable.notifyObservers(newCamera);
    if (!newCamera.parent) {
      newCamera._addToSceneRootNodes();
    }
  };
  Scene2.prototype.addSkeleton = function(newSkeleton) {
    if (this._blockEntityCollection) {
      return;
    }
    this.skeletons.push(newSkeleton);
    this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);
  };
  Scene2.prototype.addParticleSystem = function(newParticleSystem) {
    if (this._blockEntityCollection) {
      return;
    }
    this.particleSystems.push(newParticleSystem);
  };
  Scene2.prototype.addAnimation = function(newAnimation) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animations.push(newAnimation);
  };
  Scene2.prototype.addAnimationGroup = function(newAnimationGroup) {
    if (this._blockEntityCollection) {
      return;
    }
    this.animationGroups.push(newAnimationGroup);
  };
  Scene2.prototype.addMultiMaterial = function(newMultiMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    this.multiMaterials.push(newMultiMaterial);
    this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);
  };
  Scene2.prototype.addMaterial = function(newMaterial) {
    if (this._blockEntityCollection) {
      return;
    }
    if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {
      return;
    }
    newMaterial._indexInSceneMaterialArray = this.materials.length;
    this.materials.push(newMaterial);
    this.onNewMaterialAddedObservable.notifyObservers(newMaterial);
  };
  Scene2.prototype.addMorphTargetManager = function(newMorphTargetManager) {
    if (this._blockEntityCollection) {
      return;
    }
    this.morphTargetManagers.push(newMorphTargetManager);
  };
  Scene2.prototype.addGeometry = function(newGeometry) {
    if (this._blockEntityCollection) {
      return;
    }
    if (this._geometriesByUniqueId) {
      this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;
    }
    this.geometries.push(newGeometry);
  };
  Scene2.prototype.addActionManager = function(newActionManager) {
    this.actionManagers.push(newActionManager);
  };
  Scene2.prototype.addTexture = function(newTexture) {
    if (this._blockEntityCollection) {
      return;
    }
    this.textures.push(newTexture);
    this.onNewTextureAddedObservable.notifyObservers(newTexture);
  };
  Scene2.prototype.switchActiveCamera = function(newCamera, attachControl) {
    if (attachControl === void 0) {
      attachControl = true;
    }
    var canvas = this._engine.getInputElement();
    if (!canvas) {
      return;
    }
    if (this.activeCamera) {
      this.activeCamera.detachControl();
    }
    this.activeCamera = newCamera;
    if (attachControl) {
      newCamera.attachControl();
    }
  };
  Scene2.prototype.setActiveCameraById = function(id) {
    var camera = this.getCameraById(id);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  };
  Scene2.prototype.setActiveCameraByName = function(name2) {
    var camera = this.getCameraByName(name2);
    if (camera) {
      this.activeCamera = camera;
      return camera;
    }
    return null;
  };
  Scene2.prototype.getAnimationGroupByName = function(name2) {
    for (var index = 0; index < this.animationGroups.length; index++) {
      if (this.animationGroups[index].name === name2) {
        return this.animationGroups[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMaterialByUniqueID = function(uniqueId) {
    for (var index = 0; index < this.materials.length; index++) {
      if (this.materials[index].uniqueId === uniqueId) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMaterialById = function(id) {
    for (var index = 0; index < this.materials.length; index++) {
      if (this.materials[index].id === id) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastMaterialById = function(id, allowMultiMaterials) {
    if (allowMultiMaterials === void 0) {
      allowMultiMaterials = false;
    }
    for (var index = this.materials.length - 1; index >= 0; index--) {
      if (this.materials[index].id === id) {
        return this.materials[index];
      }
    }
    if (allowMultiMaterials) {
      for (var index = this.multiMaterials.length - 1; index >= 0; index--) {
        if (this.multiMaterials[index].id === id) {
          return this.multiMaterials[index];
        }
      }
    }
    return null;
  };
  Scene2.prototype.getMaterialByName = function(name2) {
    for (var index = 0; index < this.materials.length; index++) {
      if (this.materials[index].name === name2) {
        return this.materials[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTextureByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.textures.length; index++) {
      if (this.textures[index].uniqueId === uniqueId) {
        return this.textures[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTextureByName = function(name2) {
    for (var index = 0; index < this.textures.length; index++) {
      if (this.textures[index].name === name2) {
        return this.textures[index];
      }
    }
    return null;
  };
  Scene2.prototype.getCameraById = function(id) {
    for (var index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    return null;
  };
  Scene2.prototype.getCameraByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].uniqueId === uniqueId) {
        return this.cameras[index];
      }
    }
    return null;
  };
  Scene2.prototype.getCameraByName = function(name2) {
    for (var index = 0; index < this.cameras.length; index++) {
      if (this.cameras[index].name === name2) {
        return this.cameras[index];
      }
    }
    return null;
  };
  Scene2.prototype.getBoneById = function(id) {
    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      var skeleton = this.skeletons[skeletonIndex];
      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].id === id) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  };
  Scene2.prototype.getBoneByName = function(name2) {
    for (var skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
      var skeleton = this.skeletons[skeletonIndex];
      for (var boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
        if (skeleton.bones[boneIndex].name === name2) {
          return skeleton.bones[boneIndex];
        }
      }
    }
    return null;
  };
  Scene2.prototype.getLightByName = function(name2) {
    for (var index = 0; index < this.lights.length; index++) {
      if (this.lights[index].name === name2) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLightById = function(id) {
    for (var index = 0; index < this.lights.length; index++) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLightByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.lights.length; index++) {
      if (this.lights[index].uniqueId === uniqueId) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getParticleSystemById = function(id) {
    for (var index = 0; index < this.particleSystems.length; index++) {
      if (this.particleSystems[index].id === id) {
        return this.particleSystems[index];
      }
    }
    return null;
  };
  Scene2.prototype.getGeometryById = function(id) {
    for (var index = 0; index < this.geometries.length; index++) {
      if (this.geometries[index].id === id) {
        return this.geometries[index];
      }
    }
    return null;
  };
  Scene2.prototype._getGeometryByUniqueId = function(uniqueId) {
    if (this._geometriesByUniqueId) {
      var index = this._geometriesByUniqueId[uniqueId];
      if (index !== void 0) {
        return this.geometries[index];
      }
    } else {
      for (var index = 0; index < this.geometries.length; index++) {
        if (this.geometries[index].uniqueId === uniqueId) {
          return this.geometries[index];
        }
      }
    }
    return null;
  };
  Scene2.prototype.pushGeometry = function(geometry, force) {
    if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {
      return false;
    }
    this.addGeometry(geometry);
    this.onNewGeometryAddedObservable.notifyObservers(geometry);
    return true;
  };
  Scene2.prototype.removeGeometry = function(geometry) {
    var index;
    if (this._geometriesByUniqueId) {
      index = this._geometriesByUniqueId[geometry.uniqueId];
      if (index === void 0) {
        return false;
      }
    } else {
      index = this.geometries.indexOf(geometry);
      if (index < 0) {
        return false;
      }
    }
    if (index !== this.geometries.length - 1) {
      var lastGeometry = this.geometries[this.geometries.length - 1];
      if (lastGeometry) {
        this.geometries[index] = lastGeometry;
        if (this._geometriesByUniqueId) {
          this._geometriesByUniqueId[lastGeometry.uniqueId] = index;
          this._geometriesByUniqueId[geometry.uniqueId] = void 0;
        }
      }
    }
    this.geometries.pop();
    this.onGeometryRemovedObservable.notifyObservers(geometry);
    return true;
  };
  Scene2.prototype.getGeometries = function() {
    return this.geometries;
  };
  Scene2.prototype.getMeshById = function(id) {
    for (var index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMeshesById = function(id) {
    return this.meshes.filter(function(m) {
      return m.id === id;
    });
  };
  Scene2.prototype.getTransformNodeById = function(id) {
    for (var index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTransformNodeByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].uniqueId === uniqueId) {
        return this.transformNodes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTransformNodesById = function(id) {
    return this.transformNodes.filter(function(m) {
      return m.id === id;
    });
  };
  Scene2.prototype.getMeshByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].uniqueId === uniqueId) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastMeshById = function(id) {
    for (var index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastEntryById = function(id) {
    var index;
    for (index = this.meshes.length - 1; index >= 0; index--) {
      if (this.meshes[index].id === id) {
        return this.meshes[index];
      }
    }
    for (index = this.transformNodes.length - 1; index >= 0; index--) {
      if (this.transformNodes[index].id === id) {
        return this.transformNodes[index];
      }
    }
    for (index = this.cameras.length - 1; index >= 0; index--) {
      if (this.cameras[index].id === id) {
        return this.cameras[index];
      }
    }
    for (index = this.lights.length - 1; index >= 0; index--) {
      if (this.lights[index].id === id) {
        return this.lights[index];
      }
    }
    return null;
  };
  Scene2.prototype.getNodeById = function(id) {
    var mesh = this.getMeshById(id);
    if (mesh) {
      return mesh;
    }
    var transformNode = this.getTransformNodeById(id);
    if (transformNode) {
      return transformNode;
    }
    var light = this.getLightById(id);
    if (light) {
      return light;
    }
    var camera = this.getCameraById(id);
    if (camera) {
      return camera;
    }
    var bone = this.getBoneById(id);
    if (bone) {
      return bone;
    }
    return null;
  };
  Scene2.prototype.getNodeByName = function(name2) {
    var mesh = this.getMeshByName(name2);
    if (mesh) {
      return mesh;
    }
    var transformNode = this.getTransformNodeByName(name2);
    if (transformNode) {
      return transformNode;
    }
    var light = this.getLightByName(name2);
    if (light) {
      return light;
    }
    var camera = this.getCameraByName(name2);
    if (camera) {
      return camera;
    }
    var bone = this.getBoneByName(name2);
    if (bone) {
      return bone;
    }
    return null;
  };
  Scene2.prototype.getMeshByName = function(name2) {
    for (var index = 0; index < this.meshes.length; index++) {
      if (this.meshes[index].name === name2) {
        return this.meshes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getTransformNodeByName = function(name2) {
    for (var index = 0; index < this.transformNodes.length; index++) {
      if (this.transformNodes[index].name === name2) {
        return this.transformNodes[index];
      }
    }
    return null;
  };
  Scene2.prototype.getLastSkeletonById = function(id) {
    for (var index = this.skeletons.length - 1; index >= 0; index--) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getSkeletonByUniqueId = function(uniqueId) {
    for (var index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].uniqueId === uniqueId) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getSkeletonById = function(id) {
    for (var index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].id === id) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getSkeletonByName = function(name2) {
    for (var index = 0; index < this.skeletons.length; index++) {
      if (this.skeletons[index].name === name2) {
        return this.skeletons[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMorphTargetManagerById = function(id) {
    for (var index = 0; index < this.morphTargetManagers.length; index++) {
      if (this.morphTargetManagers[index].uniqueId === id) {
        return this.morphTargetManagers[index];
      }
    }
    return null;
  };
  Scene2.prototype.getMorphTargetById = function(id) {
    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      var morphTargetManager = this.morphTargetManagers[managerIndex];
      for (var index = 0; index < morphTargetManager.numTargets; ++index) {
        var target2 = morphTargetManager.getTarget(index);
        if (target2.id === id) {
          return target2;
        }
      }
    }
    return null;
  };
  Scene2.prototype.getMorphTargetByName = function(name2) {
    for (var managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
      var morphTargetManager = this.morphTargetManagers[managerIndex];
      for (var index = 0; index < morphTargetManager.numTargets; ++index) {
        var target2 = morphTargetManager.getTarget(index);
        if (target2.name === name2) {
          return target2;
        }
      }
    }
    return null;
  };
  Scene2.prototype.getPostProcessByName = function(name2) {
    for (var postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {
      var postProcess = this.postProcesses[postProcessIndex];
      if (postProcess.name === name2) {
        return postProcess;
      }
    }
    return null;
  };
  Scene2.prototype.isActiveMesh = function(mesh) {
    return this._activeMeshes.indexOf(mesh) !== -1;
  };
  Object.defineProperty(Scene2.prototype, "uid", {
    get: function() {
      if (!this._uid) {
        this._uid = Tools.RandomId();
      }
      return this._uid;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.addExternalData = function(key, data) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.add(key, data);
  };
  Scene2.prototype.getExternalData = function(key) {
    if (!this._externalData) {
      return null;
    }
    return this._externalData.get(key);
  };
  Scene2.prototype.getOrAddExternalDataWithFactory = function(key, factory) {
    if (!this._externalData) {
      this._externalData = new StringDictionary();
    }
    return this._externalData.getOrAddWithFactory(key, factory);
  };
  Scene2.prototype.removeExternalData = function(key) {
    return this._externalData.remove(key);
  };
  Scene2.prototype._evaluateSubMesh = function(subMesh, mesh, initialMesh) {
    if (initialMesh.hasInstances || initialMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.subMeshes.length === 1 || subMesh.isInFrustum(this._frustumPlanes)) {
      for (var _i = 0, _a2 = this._evaluateSubMeshStage; _i < _a2.length; _i++) {
        var step = _a2[_i];
        step.action(mesh, subMesh);
      }
      var material = subMesh.getMaterial();
      if (material !== null && material !== void 0) {
        if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
          if (this._processedMaterials.indexOf(material) === -1) {
            this._processedMaterials.push(material);
            this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
          }
        }
        this._renderingManager.dispatch(subMesh, mesh, material);
      }
    }
  };
  Scene2.prototype.freeProcessedMaterials = function() {
    this._processedMaterials.dispose();
  };
  Object.defineProperty(Scene2.prototype, "blockfreeActiveMeshesAndRenderingGroups", {
    get: function() {
      return this._preventFreeActiveMeshesAndRenderingGroups;
    },
    set: function(value) {
      if (this._preventFreeActiveMeshesAndRenderingGroups === value) {
        return;
      }
      if (value) {
        this.freeActiveMeshes();
        this.freeRenderingGroups();
      }
      this._preventFreeActiveMeshesAndRenderingGroups = value;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.freeActiveMeshes = function() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    this._activeMeshes.dispose();
    if (this.activeCamera && this.activeCamera._activeMeshes) {
      this.activeCamera._activeMeshes.dispose();
    }
    if (this.activeCameras) {
      for (var i = 0; i < this.activeCameras.length; i++) {
        var activeCamera = this.activeCameras[i];
        if (activeCamera && activeCamera._activeMeshes) {
          activeCamera._activeMeshes.dispose();
        }
      }
    }
  };
  Scene2.prototype.freeRenderingGroups = function() {
    if (this.blockfreeActiveMeshesAndRenderingGroups) {
      return;
    }
    if (this._renderingManager) {
      this._renderingManager.freeRenderingGroups();
    }
    if (this.textures) {
      for (var i = 0; i < this.textures.length; i++) {
        var texture = this.textures[i];
        if (texture && texture.renderList) {
          texture.freeRenderingGroups();
        }
      }
    }
  };
  Scene2.prototype._isInIntermediateRendering = function() {
    return this._intermediateRendering;
  };
  Scene2.prototype.freezeActiveMeshes = function(skipEvaluateActiveMeshes, onSuccess, onError, freezeMeshes, keepFrustumCulling) {
    var _this = this;
    if (skipEvaluateActiveMeshes === void 0) {
      skipEvaluateActiveMeshes = false;
    }
    if (freezeMeshes === void 0) {
      freezeMeshes = true;
    }
    if (keepFrustumCulling === void 0) {
      keepFrustumCulling = false;
    }
    this.executeWhenReady(function() {
      if (!_this.activeCamera) {
        onError && onError("No active camera found");
        return;
      }
      if (!_this._frustumPlanes) {
        _this.updateTransformMatrix();
      }
      _this._evaluateActiveMeshes();
      _this._activeMeshesFrozen = true;
      _this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;
      _this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
      if (freezeMeshes) {
        for (var index = 0; index < _this._activeMeshes.length; index++) {
          _this._activeMeshes.data[index]._freeze();
        }
      }
      onSuccess && onSuccess();
    });
    return this;
  };
  Scene2.prototype.unfreezeActiveMeshes = function() {
    for (var index = 0; index < this.meshes.length; index++) {
      var mesh = this.meshes[index];
      if (mesh._internalAbstractMeshDataInfo) {
        mesh._internalAbstractMeshDataInfo._isActive = false;
      }
    }
    for (var index = 0; index < this._activeMeshes.length; index++) {
      this._activeMeshes.data[index]._unFreeze();
    }
    this._activeMeshesFrozen = false;
    return this;
  };
  Scene2.prototype._executeActiveContainerCleanup = function(container) {
    var isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
    if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {
      return;
    }
    this.onBeforeRenderObservable.addOnce(function() {
      return container.dispose();
    });
  };
  Scene2.prototype._evaluateActiveMeshes = function() {
    var _a2;
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      if (this._activeMeshes.length > 0) {
        (_a2 = this.activeCamera) === null || _a2 === void 0 ? void 0 : _a2._activeMeshes.reset();
        this._activeMeshes.reset();
        this._renderingManager.reset();
        this._processedMaterials.reset();
        this._activeParticleSystems.reset();
        this._activeSkeletons.reset();
        this._softwareSkinnedMeshes.reset();
      }
      return;
    }
    if (this._activeMeshesFrozen && this._activeMeshes.length) {
      if (!this._skipEvaluateActiveMeshesCompletely) {
        var len_1 = this._activeMeshes.length;
        for (var i = 0; i < len_1; i++) {
          var mesh = this._activeMeshes.data[i];
          mesh.computeWorldMatrix();
        }
      }
      if (this._activeParticleSystems) {
        var psLength = this._activeParticleSystems.length;
        for (var i = 0; i < psLength; i++) {
          this._activeParticleSystems.data[i].animate();
        }
      }
      return;
    }
    if (!this.activeCamera) {
      return;
    }
    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);
    this.activeCamera._activeMeshes.reset();
    this._activeMeshes.reset();
    this._renderingManager.reset();
    this._processedMaterials.reset();
    this._activeParticleSystems.reset();
    this._activeSkeletons.reset();
    this._softwareSkinnedMeshes.reset();
    this._materialsRenderTargets.reset();
    for (var _i = 0, _b2 = this._beforeEvaluateActiveMeshStage; _i < _b2.length; _i++) {
      var step = _b2[_i];
      step.action();
    }
    var meshes = this.getActiveMeshCandidates();
    var len = meshes.length;
    for (var i = 0; i < len; i++) {
      var mesh = meshes.data[i];
      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;
      if (mesh.isBlocked) {
        continue;
      }
      this._totalVertices.addCount(mesh.getTotalVertices(), false);
      if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {
        continue;
      }
      mesh.computeWorldMatrix();
      if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
        this._meshesForIntersections.pushNoDuplicate(mesh);
      }
      var meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);
      mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;
      mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
      if (meshToRender === void 0 || meshToRender === null) {
        continue;
      }
      if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {
        meshToRender.computeWorldMatrix();
      }
      mesh._preActivate();
      if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {
        this._activeMeshes.push(mesh);
        this.activeCamera._activeMeshes.push(mesh);
        if (meshToRender !== mesh) {
          meshToRender._activate(this._renderId, false);
        }
        for (var _c2 = 0, _d = this._preActiveMeshStage; _c2 < _d.length; _c2++) {
          var step = _d[_c2];
          step.action(mesh);
        }
        if (mesh._activate(this._renderId, false)) {
          if (!mesh.isAnInstance) {
            meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;
          } else {
            if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
              meshToRender = mesh;
            }
          }
          meshToRender._internalAbstractMeshDataInfo._isActive = true;
          this._activeMesh(mesh, meshToRender);
        }
        mesh._postActivate();
      }
    }
    this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);
    if (this.particlesEnabled) {
      this.onBeforeParticlesRenderingObservable.notifyObservers(this);
      for (var particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
        var particleSystem = this.particleSystems[particleIndex];
        if (!particleSystem.isStarted() || !particleSystem.emitter) {
          continue;
        }
        var emitter = particleSystem.emitter;
        if (!emitter.position || emitter.isEnabled()) {
          this._activeParticleSystems.push(particleSystem);
          particleSystem.animate();
          this._renderingManager.dispatchParticles(particleSystem);
        }
      }
      this.onAfterParticlesRenderingObservable.notifyObservers(this);
    }
  };
  Scene2.prototype._activeMesh = function(sourceMesh, mesh) {
    if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== void 0) {
      if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {
        mesh.skeleton.prepare();
        this._activeBones.addCount(mesh.skeleton.bones.length, false);
      }
      if (!mesh.computeBonesUsingShaders) {
        this._softwareSkinnedMeshes.pushNoDuplicate(mesh);
      }
    }
    if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {
      var subMeshes = this.getActiveSubMeshCandidates(mesh);
      var len = subMeshes.length;
      for (var i = 0; i < len; i++) {
        var subMesh = subMeshes.data[i];
        this._evaluateSubMesh(subMesh, mesh, sourceMesh);
      }
    }
  };
  Scene2.prototype.updateTransformMatrix = function(force) {
    if (!this.activeCamera) {
      return;
    }
    if (this.activeCamera._renderingMultiview) {
      var leftCamera = this.activeCamera._rigCameras[0];
      var rightCamera = this.activeCamera._rigCameras[1];
      this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));
    } else {
      this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));
    }
  };
  Scene2.prototype._bindFrameBuffer = function(camera, clear) {
    if (clear === void 0) {
      clear = true;
    }
    if (camera && camera._multiviewTexture) {
      camera._multiviewTexture._bindFrameBuffer();
    } else if (camera && camera.outputRenderTarget) {
      camera.outputRenderTarget._bindFrameBuffer();
    } else {
      if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {
        this._engine.restoreDefaultFramebuffer();
      }
    }
    if (clear) {
      this._clearFrameBuffer(camera);
    }
  };
  Scene2.prototype._clearFrameBuffer = function(camera) {
    if (camera && camera._multiviewTexture)
      ;
    else if (camera && camera.outputRenderTarget) {
      var rtt = camera.outputRenderTarget;
      if (rtt.onClearObservable.hasObservers()) {
        rtt.onClearObservable.notifyObservers(this._engine);
      } else if (!rtt.skipInitialClear) {
        this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);
        rtt._cleared = true;
      }
    } else {
      if (!this._defaultFrameBufferCleared) {
        this._defaultFrameBufferCleared = true;
        this._clear();
      } else {
        this._engine.clear(null, false, true, true);
      }
    }
  };
  Scene2.prototype._renderForCamera = function(camera, rigParent, bindFrameBuffer) {
    var _a2, _b2, _c2;
    if (bindFrameBuffer === void 0) {
      bindFrameBuffer = true;
    }
    if (camera && camera._skipRendering) {
      return;
    }
    var engine = this._engine;
    this._activeCamera = camera;
    if (!this.activeCamera) {
      throw new Error("Active camera not set");
    }
    engine.setViewport(this.activeCamera.viewport);
    this.resetCachedMaterial();
    this._renderId++;
    if (!this.prePass && bindFrameBuffer) {
      var skipInitialClear = true;
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        skipInitialClear = camera.outputRenderTarget.skipInitialClear;
        if (this.autoClear) {
          camera.outputRenderTarget.skipInitialClear = false;
        }
      }
      this._bindFrameBuffer(this._activeCamera);
      if (camera._renderingMultiview && camera.outputRenderTarget) {
        camera.outputRenderTarget.skipInitialClear = skipInitialClear;
      }
    }
    this.updateTransformMatrix();
    this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);
    this._evaluateActiveMeshes();
    for (var softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {
      var mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];
      mesh.applySkeleton(mesh.skeleton);
    }
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);
    if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);
    }
    if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {
      this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);
    }
    if (this.environmentTexture && this.environmentTexture.isRenderTarget) {
      this._renderTargets.pushNoDuplicate(this.environmentTexture);
    }
    for (var _i = 0, _d = this._gatherActiveCameraRenderTargetsStage; _i < _d.length; _i++) {
      var step = _d[_i];
      step.action(this._renderTargets);
    }
    var needRebind = false;
    if (this.renderTargetsEnabled) {
      this._intermediateRendering = true;
      if (this._renderTargets.length > 0) {
        Tools.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
        for (var renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {
          var renderTarget = this._renderTargets.data[renderIndex];
          if (renderTarget._shouldRender()) {
            this._renderId++;
            var hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;
            renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);
            needRebind = true;
          }
        }
        Tools.EndPerformanceCounter("Render targets", this._renderTargets.length > 0);
        this._renderId++;
      }
      for (var _e = 0, _f = this._cameraDrawRenderTargetStage; _e < _f.length; _e++) {
        var step = _f[_e];
        needRebind = step.action(this.activeCamera) || needRebind;
      }
      this._intermediateRendering = false;
    }
    this._engine.currentRenderPassId = (_c2 = (_b2 = (_a2 = camera.outputRenderTarget) === null || _a2 === void 0 ? void 0 : _a2.renderPassId) !== null && _b2 !== void 0 ? _b2 : camera.renderPassId) !== null && _c2 !== void 0 ? _c2 : 0;
    if (needRebind && !this.prePass) {
      this._bindFrameBuffer(this._activeCamera, false);
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {
      this.postProcessManager._prepareFrame();
    }
    for (var _g = 0, _h = this._beforeCameraDrawStage; _g < _h.length; _g++) {
      var step = _h[_g];
      step.action(this.activeCamera);
    }
    this.onBeforeDrawPhaseObservable.notifyObservers(this);
    if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {
      this.finalizeSceneUbo();
    }
    this._renderingManager.render(null, null, true, true);
    this.onAfterDrawPhaseObservable.notifyObservers(this);
    for (var _j = 0, _k = this._afterCameraDrawStage; _j < _k.length; _j++) {
      var step = _k[_j];
      step.action(this.activeCamera);
    }
    if (this.postProcessManager && !camera._multiviewTexture) {
      var texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : void 0;
      this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);
    }
    this._renderTargets.reset();
    this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
  };
  Scene2.prototype._processSubCameras = function(camera, bindFrameBuffer) {
    if (bindFrameBuffer === void 0) {
      bindFrameBuffer = true;
    }
    if (camera.cameraRigMode === 0 || camera._renderingMultiview) {
      if (camera._renderingMultiview && !this._multiviewSceneUbo) {
        this._createMultiviewUbo();
      }
      this._renderForCamera(camera, void 0, bindFrameBuffer);
      this.onAfterRenderCameraObservable.notifyObservers(camera);
      return;
    }
    if (camera._useMultiviewToSingleView) {
      this._renderMultiviewToSingleView(camera);
    } else {
      this.onBeforeCameraRenderObservable.notifyObservers(camera);
      for (var index = 0; index < camera._rigCameras.length; index++) {
        this._renderForCamera(camera._rigCameras[index], camera);
      }
    }
    this._activeCamera = camera;
    this.updateTransformMatrix();
    this.onAfterRenderCameraObservable.notifyObservers(camera);
  };
  Scene2.prototype._checkIntersections = function() {
    for (var index = 0; index < this._meshesForIntersections.length; index++) {
      var sourceMesh = this._meshesForIntersections.data[index];
      if (!sourceMesh.actionManager) {
        continue;
      }
      var _loop_1 = function(actionIndex2) {
        var action = sourceMesh.actionManager.actions[actionIndex2];
        if (action.trigger === 12 || action.trigger === 13) {
          var parameters = action.getTriggerParameter();
          var otherMesh_1 = parameters.mesh ? parameters.mesh : parameters;
          var areIntersecting = otherMesh_1.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);
          var currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh_1);
          if (areIntersecting && currentIntersectionInProgress === -1) {
            if (action.trigger === 12) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh_1));
              sourceMesh._intersectionsInProgress.push(otherMesh_1);
            } else if (action.trigger === 13) {
              sourceMesh._intersectionsInProgress.push(otherMesh_1);
            }
          } else if (!areIntersecting && currentIntersectionInProgress > -1) {
            if (action.trigger === 13) {
              action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh_1));
            }
            if (!sourceMesh.actionManager.hasSpecificTrigger(13, function(parameter) {
              var parameterMesh = parameter.mesh ? parameter.mesh : parameter;
              return otherMesh_1 === parameterMesh;
            }) || action.trigger === 13) {
              sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);
            }
          }
        }
      };
      for (var actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {
        _loop_1(actionIndex);
      }
    }
  };
  Scene2.prototype._advancePhysicsEngineStep = function(step) {
  };
  Scene2.prototype._animate = function() {
  };
  Scene2.prototype.animate = function() {
    if (this._engine.isDeterministicLockStep()) {
      var deltaTime = Math.max(Scene2.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene2.MaxDeltaTime)) + this._timeAccumulator;
      var defaultFrameTime = this._engine.getTimeStep();
      var defaultFPS = 1e3 / defaultFrameTime / 1e3;
      var stepsTaken = 0;
      var maxSubSteps = this._engine.getLockstepMaxSteps();
      var internalSteps = Math.floor(deltaTime / defaultFrameTime);
      internalSteps = Math.min(internalSteps, maxSubSteps);
      while (deltaTime > 0 && stepsTaken < internalSteps) {
        this.onBeforeStepObservable.notifyObservers(this);
        this._animationRatio = defaultFrameTime * defaultFPS;
        this._animate();
        this.onAfterAnimationsObservable.notifyObservers(this);
        if (this.physicsEnabled) {
          this._advancePhysicsEngineStep(defaultFrameTime);
        }
        this.onAfterStepObservable.notifyObservers(this);
        this._currentStepId++;
        stepsTaken++;
        deltaTime -= defaultFrameTime;
      }
      this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;
    } else {
      var deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene2.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene2.MaxDeltaTime));
      this._animationRatio = deltaTime * (60 / 1e3);
      this._animate();
      this.onAfterAnimationsObservable.notifyObservers(this);
      if (this.physicsEnabled) {
        this._advancePhysicsEngineStep(deltaTime);
      }
    }
  };
  Scene2.prototype._clear = function() {
    if (this.autoClearDepthAndStencil || this.autoClear) {
      this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
    }
  };
  Scene2.prototype._checkCameraRenderTarget = function(camera) {
    var _a2;
    if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {
      camera.outputRenderTarget._cleared = false;
    }
    if ((_a2 = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a2 === void 0 ? void 0 : _a2.length) {
      for (var i = 0; i < camera.rigCameras.length; ++i) {
        var rtt = camera.rigCameras[i].outputRenderTarget;
        if (rtt) {
          rtt._cleared = false;
        }
      }
    }
  };
  Scene2.prototype.resetDrawCache = function(passId) {
    if (!this.meshes) {
      return;
    }
    for (var _i = 0, _a2 = this.meshes; _i < _a2.length; _i++) {
      var mesh = _a2[_i];
      mesh.resetDrawCache(passId);
    }
  };
  Scene2.prototype.render = function(updateCameras, ignoreAnimations) {
    var _a2, _b2, _c2;
    if (updateCameras === void 0) {
      updateCameras = true;
    }
    if (ignoreAnimations === void 0) {
      ignoreAnimations = false;
    }
    if (this.isDisposed) {
      return;
    }
    if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {
      this._checkIsReady();
    }
    this._frameId++;
    this._defaultFrameBufferCleared = false;
    this._checkCameraRenderTarget(this.activeCamera);
    if ((_a2 = this.activeCameras) === null || _a2 === void 0 ? void 0 : _a2.length) {
      this.activeCameras.forEach(this._checkCameraRenderTarget);
    }
    this._registerTransientComponents();
    this._activeParticles.fetchNewFrame();
    this._totalVertices.fetchNewFrame();
    this._activeIndices.fetchNewFrame();
    this._activeBones.fetchNewFrame();
    this._meshesForIntersections.reset();
    this.resetCachedMaterial();
    this.onBeforeAnimationsObservable.notifyObservers(this);
    if (this.actionManager) {
      this.actionManager.processTrigger(11);
    }
    if (!ignoreAnimations) {
      this.animate();
    }
    for (var _i = 0, _d = this._beforeCameraUpdateStage; _i < _d.length; _i++) {
      var step = _d[_i];
      step.action();
    }
    if (updateCameras) {
      if (this.activeCameras && this.activeCameras.length > 0) {
        for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
          var camera = this.activeCameras[cameraIndex];
          camera.update();
          if (camera.cameraRigMode !== 0) {
            for (var index = 0; index < camera._rigCameras.length; index++) {
              camera._rigCameras[index].update();
            }
          }
        }
      } else if (this.activeCamera) {
        this.activeCamera.update();
        if (this.activeCamera.cameraRigMode !== 0) {
          for (var index = 0; index < this.activeCamera._rigCameras.length; index++) {
            this.activeCamera._rigCameras[index].update();
          }
        }
      }
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    var engine = this.getEngine();
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    var currentActiveCamera = ((_b2 = this.activeCameras) === null || _b2 === void 0 ? void 0 : _b2.length) ? this.activeCameras[0] : this.activeCamera;
    if (this.renderTargetsEnabled) {
      Tools.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
      this._intermediateRendering = true;
      for (var customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {
        var renderTarget = this.customRenderTargets[customIndex];
        if (renderTarget._shouldRender()) {
          this._renderId++;
          this.activeCamera = renderTarget.activeCamera || this.activeCamera;
          if (!this.activeCamera) {
            throw new Error("Active camera not set");
          }
          engine.setViewport(this.activeCamera.viewport);
          this.updateTransformMatrix();
          renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);
        }
      }
      Tools.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
      this._intermediateRendering = false;
      this._renderId++;
    }
    this._engine.currentRenderPassId = (_c2 = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c2 !== void 0 ? _c2 : 0;
    this.activeCamera = currentActiveCamera;
    if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {
      this._bindFrameBuffer(this._activeCamera, false);
    }
    this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    for (var _e = 0, _f = this._beforeClearStage; _e < _f.length; _e++) {
      var step = _f[_e];
      step.action();
    }
    this._clearFrameBuffer(this.activeCamera);
    for (var _g = 0, _h = this._gatherRenderTargetsStage; _g < _h.length; _g++) {
      var step = _h[_g];
      step.action(this._renderTargets);
    }
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (var cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
        this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);
      }
    } else {
      if (!this.activeCamera) {
        throw new Error("No camera defined");
      }
      this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
    }
    this._checkIntersections();
    for (var _j = 0, _k = this._afterRenderStage; _j < _k.length; _j++) {
      var step = _k[_j];
      step.action();
    }
    if (this.afterRender) {
      this.afterRender();
    }
    this.onAfterRenderObservable.notifyObservers(this);
    if (this._toBeDisposed.length) {
      for (var index = 0; index < this._toBeDisposed.length; index++) {
        var data = this._toBeDisposed[index];
        if (data) {
          data.dispose();
        }
      }
      this._toBeDisposed = [];
    }
    if (this.dumpNextRenderTargets) {
      this.dumpNextRenderTargets = false;
    }
    this._activeBones.addCount(0, true);
    this._activeIndices.addCount(0, true);
    this._activeParticles.addCount(0, true);
    this._engine.restoreDefaultFramebuffer();
  };
  Scene2.prototype.freezeMaterials = function() {
    for (var i = 0; i < this.materials.length; i++) {
      this.materials[i].freeze();
    }
  };
  Scene2.prototype.unfreezeMaterials = function() {
    for (var i = 0; i < this.materials.length; i++) {
      this.materials[i].unfreeze();
    }
  };
  Scene2.prototype.dispose = function() {
    var _a2;
    if (this.isDisposed) {
      return;
    }
    this.beforeRender = null;
    this.afterRender = null;
    this.metadata = null;
    this.skeletons = [];
    this.morphTargetManagers = [];
    this._transientComponents = [];
    this._isReadyForMeshStage.clear();
    this._beforeEvaluateActiveMeshStage.clear();
    this._evaluateSubMeshStage.clear();
    this._preActiveMeshStage.clear();
    this._cameraDrawRenderTargetStage.clear();
    this._beforeCameraDrawStage.clear();
    this._beforeRenderTargetDrawStage.clear();
    this._beforeRenderingGroupDrawStage.clear();
    this._beforeRenderingMeshStage.clear();
    this._afterRenderingMeshStage.clear();
    this._afterRenderingGroupDrawStage.clear();
    this._afterCameraDrawStage.clear();
    this._afterRenderTargetDrawStage.clear();
    this._afterRenderStage.clear();
    this._beforeCameraUpdateStage.clear();
    this._beforeClearStage.clear();
    this._gatherRenderTargetsStage.clear();
    this._gatherActiveCameraRenderTargetsStage.clear();
    this._pointerMoveStage.clear();
    this._pointerDownStage.clear();
    this._pointerUpStage.clear();
    this.importedMeshesFiles = new Array();
    if (this.stopAllAnimations) {
      this.stopAllAnimations();
    }
    this.resetCachedMaterial();
    if (this.activeCamera) {
      this.activeCamera._activeMeshes.dispose();
      this.activeCamera = null;
    }
    this._activeMeshes.dispose();
    this._renderingManager.dispose();
    this._processedMaterials.dispose();
    this._activeParticleSystems.dispose();
    this._activeSkeletons.dispose();
    this._softwareSkinnedMeshes.dispose();
    this._renderTargets.dispose();
    this._materialsRenderTargets.dispose();
    this._registeredForLateAnimationBindings.dispose();
    this._meshesForIntersections.dispose();
    this._toBeDisposed = [];
    var activeRequests = this._activeRequests.slice();
    for (var _i = 0, activeRequests_1 = activeRequests; _i < activeRequests_1.length; _i++) {
      var request = activeRequests_1[_i];
      request.abort();
    }
    this._activeRequests = [];
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onBeforeRenderObservable.clear();
    this.onAfterRenderObservable.clear();
    this.onBeforeRenderTargetsRenderObservable.clear();
    this.onAfterRenderTargetsRenderObservable.clear();
    this.onAfterStepObservable.clear();
    this.onBeforeStepObservable.clear();
    this.onBeforeActiveMeshesEvaluationObservable.clear();
    this.onAfterActiveMeshesEvaluationObservable.clear();
    this.onBeforeParticlesRenderingObservable.clear();
    this.onAfterParticlesRenderingObservable.clear();
    this.onBeforeDrawPhaseObservable.clear();
    this.onAfterDrawPhaseObservable.clear();
    this.onBeforeAnimationsObservable.clear();
    this.onAfterAnimationsObservable.clear();
    this.onDataLoadedObservable.clear();
    this.onBeforeRenderingGroupObservable.clear();
    this.onAfterRenderingGroupObservable.clear();
    this.onMeshImportedObservable.clear();
    this.onBeforeCameraRenderObservable.clear();
    this.onAfterCameraRenderObservable.clear();
    this.onReadyObservable.clear();
    this.onNewCameraAddedObservable.clear();
    this.onCameraRemovedObservable.clear();
    this.onNewLightAddedObservable.clear();
    this.onLightRemovedObservable.clear();
    this.onNewGeometryAddedObservable.clear();
    this.onGeometryRemovedObservable.clear();
    this.onNewTransformNodeAddedObservable.clear();
    this.onTransformNodeRemovedObservable.clear();
    this.onNewMeshAddedObservable.clear();
    this.onMeshRemovedObservable.clear();
    this.onNewSkeletonAddedObservable.clear();
    this.onSkeletonRemovedObservable.clear();
    this.onNewMaterialAddedObservable.clear();
    this.onNewMultiMaterialAddedObservable.clear();
    this.onMaterialRemovedObservable.clear();
    this.onMultiMaterialRemovedObservable.clear();
    this.onNewTextureAddedObservable.clear();
    this.onTextureRemovedObservable.clear();
    this.onPrePointerObservable.clear();
    this.onPointerObservable.clear();
    this.onPreKeyboardObservable.clear();
    this.onKeyboardObservable.clear();
    this.onActiveCameraChanged.clear();
    this.onComputePressureChanged.clear();
    (_a2 = this._computePressureObserver) === null || _a2 === void 0 ? void 0 : _a2.unobserve();
    this._computePressureObserver = void 0;
    this.detachControl();
    var canvas = this._engine.getInputElement();
    if (canvas) {
      for (var index_1 = 0; index_1 < this.cameras.length; index_1++) {
        this.cameras[index_1].detachControl();
      }
    }
    this._disposeList(this.animationGroups);
    this._disposeList(this.lights);
    this._disposeList(this.meshes, function(item) {
      return item.dispose(true);
    });
    this._disposeList(this.transformNodes, function(item) {
      return item.dispose(true);
    });
    this._disposeList(this.cameras);
    if (this._defaultMaterial) {
      this._defaultMaterial.dispose();
    }
    this._disposeList(this.multiMaterials);
    this._disposeList(this.materials);
    this._disposeList(this.particleSystems);
    this._disposeList(this.postProcesses);
    this._disposeList(this.textures);
    this._disposeList(this.morphTargetManagers);
    this._sceneUbo.dispose();
    if (this._multiviewSceneUbo) {
      this._multiviewSceneUbo.dispose();
    }
    this.postProcessManager.dispose();
    this._disposeList(this._components);
    var index = this._engine.scenes.indexOf(this);
    if (index > -1) {
      this._engine.scenes.splice(index, 1);
    }
    if (EngineStore._LastCreatedScene === this) {
      if (this._engine.scenes.length > 0) {
        EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];
      } else {
        EngineStore._LastCreatedScene = null;
      }
    }
    index = this._engine._virtualScenes.indexOf(this);
    if (index > -1) {
      this._engine._virtualScenes.splice(index, 1);
    }
    this._engine.wipeCaches(true);
    this._isDisposed = true;
  };
  Scene2.prototype._disposeList = function(items, callback) {
    var itemsCopy = items.slice(0);
    callback = callback !== null && callback !== void 0 ? callback : function(item2) {
      return item2.dispose();
    };
    for (var _i = 0, itemsCopy_1 = itemsCopy; _i < itemsCopy_1.length; _i++) {
      var item = itemsCopy_1[_i];
      callback(item);
    }
    items.length = 0;
  };
  Object.defineProperty(Scene2.prototype, "isDisposed", {
    get: function() {
      return this._isDisposed;
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.clearCachedVertexData = function() {
    for (var meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
      var mesh = this.meshes[meshIndex];
      var geometry = mesh.geometry;
      if (geometry) {
        geometry.clearCachedData();
      }
    }
  };
  Scene2.prototype.cleanCachedTextureBuffer = function() {
    for (var _i = 0, _a2 = this.textures; _i < _a2.length; _i++) {
      var baseTexture = _a2[_i];
      var buffer = baseTexture._buffer;
      if (buffer) {
        baseTexture._buffer = null;
      }
    }
  };
  Scene2.prototype.getWorldExtends = function(filterPredicate) {
    var min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    var max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    filterPredicate = filterPredicate || function() {
      return true;
    };
    this.meshes.filter(filterPredicate).forEach(function(mesh) {
      mesh.computeWorldMatrix(true);
      if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {
        return;
      }
      var boundingInfo = mesh.getBoundingInfo();
      var minBox = boundingInfo.boundingBox.minimumWorld;
      var maxBox = boundingInfo.boundingBox.maximumWorld;
      Vector3.CheckExtends(minBox, min, max);
      Vector3.CheckExtends(maxBox, min, max);
    });
    return {
      min,
      max
    };
  };
  Scene2.prototype.createPickingRay = function(x, y, world, camera, cameraViewSpace) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.createPickingRayToRef = function(x, y, world, result, camera, cameraViewSpace, enableDistantPicking) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.createPickingRayInCameraSpace = function(x, y, camera) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.createPickingRayInCameraSpaceToRef = function(x, y, result, camera) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.pick = function(x, y, predicate, fastCheck, camera, trianglePredicate) {
    var pi = new PickingInfo();
    pi._pickingUnavailable = true;
    return pi;
  };
  Scene2.prototype.pickWithBoundingInfo = function(x, y, predicate, fastCheck, camera) {
    var pi = new PickingInfo();
    pi._pickingUnavailable = true;
    return pi;
  };
  Scene2.prototype.pickWithRay = function(ray, predicate, fastCheck, trianglePredicate) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.multiPick = function(x, y, predicate, camera, trianglePredicate) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.multiPickWithRay = function(ray, predicate, trianglePredicate) {
    throw _WarnImport("Ray");
  };
  Scene2.prototype.setPointerOverMesh = function(mesh, pointerId, pickResult) {
    this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);
  };
  Scene2.prototype.getPointerOverMesh = function() {
    return this._inputManager.getPointerOverMesh();
  };
  Scene2.prototype._rebuildGeometries = function() {
    for (var _i = 0, _a2 = this.geometries; _i < _a2.length; _i++) {
      var geometry = _a2[_i];
      geometry._rebuild();
    }
    for (var _b2 = 0, _c2 = this.meshes; _b2 < _c2.length; _b2++) {
      var mesh = _c2[_b2];
      mesh._rebuild();
    }
    if (this.postProcessManager) {
      this.postProcessManager._rebuild();
    }
    for (var _d = 0, _e = this._components; _d < _e.length; _d++) {
      var component = _e[_d];
      component.rebuild();
    }
    for (var _f = 0, _g = this.particleSystems; _f < _g.length; _f++) {
      var system = _g[_f];
      system.rebuild();
    }
    if (this.spriteManagers) {
      for (var _h = 0, _j = this.spriteManagers; _h < _j.length; _h++) {
        var spriteMgr = _j[_h];
        spriteMgr.rebuild();
      }
    }
  };
  Scene2.prototype._rebuildTextures = function() {
    for (var _i = 0, _a2 = this.textures; _i < _a2.length; _i++) {
      var texture = _a2[_i];
      texture._rebuild();
    }
    this.markAllMaterialsAsDirty(1);
  };
  Scene2.prototype._getByTags = function(list, tagsQuery, forEach) {
    if (tagsQuery === void 0) {
      return list;
    }
    var listByTags = [];
    forEach = forEach || function(item2) {
      return;
    };
    for (var i in list) {
      var item = list[i];
      if (Tags && Tags.MatchesQuery(item, tagsQuery)) {
        listByTags.push(item);
        forEach(item);
      }
    }
    return listByTags;
  };
  Scene2.prototype.getMeshesByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.meshes, tagsQuery, forEach);
  };
  Scene2.prototype.getCamerasByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.cameras, tagsQuery, forEach);
  };
  Scene2.prototype.getLightsByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.lights, tagsQuery, forEach);
  };
  Scene2.prototype.getMaterialByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));
  };
  Scene2.prototype.getTransformNodesByTags = function(tagsQuery, forEach) {
    return this._getByTags(this.transformNodes, tagsQuery, forEach);
  };
  Scene2.prototype.setRenderingOrder = function(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn) {
    if (opaqueSortCompareFn === void 0) {
      opaqueSortCompareFn = null;
    }
    if (alphaTestSortCompareFn === void 0) {
      alphaTestSortCompareFn = null;
    }
    if (transparentSortCompareFn === void 0) {
      transparentSortCompareFn = null;
    }
    this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
  };
  Scene2.prototype.setRenderingAutoClearDepthStencil = function(renderingGroupId, autoClearDepthStencil, depth, stencil) {
    if (depth === void 0) {
      depth = true;
    }
    if (stencil === void 0) {
      stencil = true;
    }
    this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
  };
  Scene2.prototype.getAutoClearDepthStencilSetup = function(index) {
    return this._renderingManager.getAutoClearDepthStencilSetup(index);
  };
  Object.defineProperty(Scene2.prototype, "blockMaterialDirtyMechanism", {
    get: function() {
      return this._blockMaterialDirtyMechanism;
    },
    set: function(value) {
      if (this._blockMaterialDirtyMechanism === value) {
        return;
      }
      this._blockMaterialDirtyMechanism = value;
      if (!value) {
        this.markAllMaterialsAsDirty(63);
      }
    },
    enumerable: false,
    configurable: true
  });
  Scene2.prototype.markAllMaterialsAsDirty = function(flag, predicate) {
    if (this._blockMaterialDirtyMechanism) {
      return;
    }
    for (var _i = 0, _a2 = this.materials; _i < _a2.length; _i++) {
      var material = _a2[_i];
      if (predicate && !predicate(material)) {
        continue;
      }
      material.markAsDirty(flag);
    }
  };
  Scene2.prototype._loadFile = function(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    var _this = this;
    var request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  Scene2.prototype._loadFileAsync = function(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._loadFile(fileOrUrl, function(data) {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, function(request, exception) {
        reject(exception);
      }, onOpened);
    });
  };
  Scene2.prototype._requestFile = function(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
    var _this = this;
    var request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  Scene2.prototype._requestFileAsync = function(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._requestFile(url, function(data) {
        resolve(data);
      }, onProgress, useOfflineSupport, useArrayBuffer, function(error) {
        reject(error);
      }, onOpened);
    });
  };
  Scene2.prototype._readFile = function(file, onSuccess, onProgress, useArrayBuffer, onError) {
    var _this = this;
    var request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
    this._activeRequests.push(request);
    request.onCompleteObservable.add(function(request2) {
      _this._activeRequests.splice(_this._activeRequests.indexOf(request2), 1);
    });
    return request;
  };
  Scene2.prototype._readFileAsync = function(file, onProgress, useArrayBuffer) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this._readFile(file, function(data) {
        resolve(data);
      }, onProgress, useArrayBuffer, function(error) {
        reject(error);
      });
    });
  };
  Scene2.prototype.getPerfCollector = function() {
    throw _WarnImport("performanceViewerSceneExtension");
  };
  Scene2.FOGMODE_NONE = 0;
  Scene2.FOGMODE_EXP = 1;
  Scene2.FOGMODE_EXP2 = 2;
  Scene2.FOGMODE_LINEAR = 3;
  Scene2.MinDeltaTime = 1;
  Scene2.MaxDeltaTime = 1e3;
  return Scene2;
}(AbstractScene);
Scene.prototype.setActiveCameraByID = function(id) {
  return this.setActiveCameraById(id);
};
Scene.prototype.getLastMaterialByID = function(id) {
  return this.getLastMaterialById(id);
};
Scene.prototype.getMaterialByID = function(id) {
  return this.getMaterialById(id);
};
Scene.prototype.getTextureByUniqueID = function(uniqueId) {
  return this.getTextureByUniqueId(uniqueId);
};
Scene.prototype.getCameraByID = function(id) {
  return this.getCameraById(id);
};
Scene.prototype.getCameraByUniqueID = function(uniqueId) {
  return this.getCameraByUniqueId(uniqueId);
};
Scene.prototype.getBoneByID = function(id) {
  return this.getBoneById(id);
};
Scene.prototype.getLightByID = function(id) {
  return this.getLightById(id);
};
Scene.prototype.getLightByUniqueID = function(uniqueId) {
  return this.getLightByUniqueId(uniqueId);
};
Scene.prototype.getParticleSystemByID = function(id) {
  return this.getParticleSystemById(id);
};
Scene.prototype.getGeometryByID = function(id) {
  return this.getGeometryById(id);
};
Scene.prototype.getMeshByID = function(id) {
  return this.getMeshById(id);
};
Scene.prototype.getMeshesByID = function(id) {
  return this.getMeshesById(id);
};
Scene.prototype.getTransformNodeByID = function(id) {
  return this.getTransformNodeById(id);
};
Scene.prototype.getTransformNodeByUniqueID = function(uniqueId) {
  return this.getTransformNodeByUniqueId(uniqueId);
};
Scene.prototype.getTransformNodesByID = function(id) {
  return this.getTransformNodesById(id);
};
Scene.prototype.getMeshByUniqueID = function(uniqueId) {
  return this.getMeshByUniqueId(uniqueId);
};
Scene.prototype.getLastMeshByID = function(id) {
  return this.getLastMeshById(id);
};
Scene.prototype.getLastEntryByID = function(id) {
  return this.getLastEntryById(id);
};
Scene.prototype.getNodeByID = function(id) {
  return this.getNodeById(id);
};
Scene.prototype.getLastSkeletonByID = function(id) {
  return this.getLastSkeletonById(id);
};
var Light = function(_super) {
  __extends(Light2, _super);
  function Light2(name2, scene) {
    var _this = _super.call(this, name2, scene) || this;
    _this.diffuse = new Color3(1, 1, 1);
    _this.specular = new Color3(1, 1, 1);
    _this.falloffType = Light2.FALLOFF_DEFAULT;
    _this.intensity = 1;
    _this._range = Number.MAX_VALUE;
    _this._inverseSquaredRange = 0;
    _this._photometricScale = 1;
    _this._intensityMode = Light2.INTENSITYMODE_AUTOMATIC;
    _this._radius = 1e-5;
    _this.renderPriority = 0;
    _this._shadowEnabled = true;
    _this._excludeWithLayerMask = 0;
    _this._includeOnlyWithLayerMask = 0;
    _this._lightmapMode = 0;
    _this._excludedMeshesIds = new Array();
    _this._includedOnlyMeshesIds = new Array();
    _this._isLight = true;
    _this.getScene().addLight(_this);
    _this._uniformBuffer = new UniformBuffer(_this.getScene().getEngine(), void 0, void 0, name2);
    _this._buildUniformLayout();
    _this.includedOnlyMeshes = new Array();
    _this.excludedMeshes = new Array();
    _this._resyncMeshes();
    return _this;
  }
  Object.defineProperty(Light2.prototype, "range", {
    get: function() {
      return this._range;
    },
    set: function(value) {
      this._range = value;
      this._inverseSquaredRange = 1 / (this.range * this.range);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "intensityMode", {
    get: function() {
      return this._intensityMode;
    },
    set: function(value) {
      this._intensityMode = value;
      this._computePhotometricScale();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "radius", {
    get: function() {
      return this._radius;
    },
    set: function(value) {
      this._radius = value;
      this._computePhotometricScale();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "shadowEnabled", {
    get: function() {
      return this._shadowEnabled;
    },
    set: function(value) {
      if (this._shadowEnabled === value) {
        return;
      }
      this._shadowEnabled = value;
      this._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "includedOnlyMeshes", {
    get: function() {
      return this._includedOnlyMeshes;
    },
    set: function(value) {
      this._includedOnlyMeshes = value;
      this._hookArrayForIncludedOnly(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "excludedMeshes", {
    get: function() {
      return this._excludedMeshes;
    },
    set: function(value) {
      this._excludedMeshes = value;
      this._hookArrayForExcluded(value);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "excludeWithLayerMask", {
    get: function() {
      return this._excludeWithLayerMask;
    },
    set: function(value) {
      this._excludeWithLayerMask = value;
      this._resyncMeshes();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "includeOnlyWithLayerMask", {
    get: function() {
      return this._includeOnlyWithLayerMask;
    },
    set: function(value) {
      this._includeOnlyWithLayerMask = value;
      this._resyncMeshes();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Light2.prototype, "lightmapMode", {
    get: function() {
      return this._lightmapMode;
    },
    set: function(value) {
      if (this._lightmapMode === value) {
        return;
      }
      this._lightmapMode = value;
      this._markMeshesAsLightDirty();
    },
    enumerable: false,
    configurable: true
  });
  Light2.prototype.transferTexturesToEffect = function(effect, lightIndex) {
    return this;
  };
  Light2.prototype._bindLight = function(lightIndex, scene, effect, useSpecular, receiveShadows) {
    if (receiveShadows === void 0) {
      receiveShadows = true;
    }
    var iAsString = lightIndex.toString();
    var needUpdate = false;
    this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
    if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
      this._renderId = scene.getRenderId();
      this._lastUseSpecular = useSpecular;
      var scaledIntensity = this.getScaledIntensity();
      this.transferToEffect(effect, iAsString);
      this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
      this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
      if (useSpecular) {
        this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
        this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
      }
      needUpdate = true;
    }
    this.transferTexturesToEffect(effect, iAsString);
    if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
      var shadowGenerator = this.getShadowGenerator();
      if (shadowGenerator) {
        shadowGenerator.bindShadowLight(iAsString, effect);
        needUpdate = true;
      }
    }
    if (needUpdate) {
      this._uniformBuffer.update();
    } else {
      this._uniformBuffer.bindUniformBuffer();
    }
  };
  Light2.prototype.getClassName = function() {
    return "Light";
  };
  Light2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()];
    if (this.animations) {
      for (var i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    return ret;
  };
  Light2.prototype._syncParentEnabledState = function() {
    _super.prototype._syncParentEnabledState.call(this);
    if (!this.isDisposed()) {
      this._resyncMeshes();
    }
  };
  Light2.prototype.setEnabled = function(value) {
    _super.prototype.setEnabled.call(this, value);
    this._resyncMeshes();
  };
  Light2.prototype.getShadowGenerator = function() {
    return this._shadowGenerator;
  };
  Light2.prototype.getAbsolutePosition = function() {
    return Vector3.Zero();
  };
  Light2.prototype.canAffectMesh = function(mesh) {
    if (!mesh) {
      return true;
    }
    if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
      return false;
    }
    if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
      return false;
    }
    if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
      return false;
    }
    if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
      return false;
    }
    return true;
  };
  Light2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    if (this._shadowGenerator) {
      this._shadowGenerator.dispose();
      this._shadowGenerator = null;
    }
    this.getScene().stopAnimation(this);
    if (this._parentContainer) {
      var index = this._parentContainer.lights.indexOf(this);
      if (index > -1) {
        this._parentContainer.lights.splice(index, 1);
      }
      this._parentContainer = null;
    }
    for (var _i = 0, _a2 = this.getScene().meshes; _i < _a2.length; _i++) {
      var mesh = _a2[_i];
      mesh._removeLightSource(this, true);
    }
    this._uniformBuffer.dispose();
    this.getScene().removeLight(this);
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  Light2.prototype.getTypeID = function() {
    return 0;
  };
  Light2.prototype.getScaledIntensity = function() {
    return this._photometricScale * this.intensity;
  };
  Light2.prototype.clone = function(name2, newParent) {
    if (newParent === void 0) {
      newParent = null;
    }
    var constructor = Light2.GetConstructorFromName(this.getTypeID(), name2, this.getScene());
    if (!constructor) {
      return null;
    }
    var clonedLight = SerializationHelper.Clone(constructor, this);
    if (name2) {
      clonedLight.name = name2;
    }
    if (newParent) {
      clonedLight.parent = newParent;
    }
    clonedLight.setEnabled(this.isEnabled());
    this.onClonedObservable.notifyObservers(clonedLight);
    return clonedLight;
  };
  Light2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getTypeID();
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    if (this.excludedMeshes.length > 0) {
      serializationObject.excludedMeshesIds = [];
      this.excludedMeshes.forEach(function(mesh) {
        serializationObject.excludedMeshesIds.push(mesh.id);
      });
    }
    if (this.includedOnlyMeshes.length > 0) {
      serializationObject.includedOnlyMeshesIds = [];
      this.includedOnlyMeshes.forEach(function(mesh) {
        serializationObject.includedOnlyMeshesIds.push(mesh.id);
      });
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.isEnabled = this.isEnabled();
    return serializationObject;
  };
  Light2.GetConstructorFromName = function(type, name2, scene) {
    var constructorFunc = Node.Construct("Light_Type_" + type, name2, scene);
    if (constructorFunc) {
      return constructorFunc;
    }
    return null;
  };
  Light2.Parse = function(parsedLight, scene) {
    var constructor = Light2.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
    if (!constructor) {
      return null;
    }
    var light = SerializationHelper.Parse(constructor, parsedLight, scene);
    if (parsedLight.excludedMeshesIds) {
      light._excludedMeshesIds = parsedLight.excludedMeshesIds;
    }
    if (parsedLight.includedOnlyMeshesIds) {
      light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
    }
    if (parsedLight.parentId !== void 0) {
      light._waitingParentId = parsedLight.parentId;
    }
    if (parsedLight.falloffType !== void 0) {
      light.falloffType = parsedLight.falloffType;
    }
    if (parsedLight.lightmapMode !== void 0) {
      light.lightmapMode = parsedLight.lightmapMode;
    }
    if (parsedLight.animations) {
      for (var animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
        var parsedAnimation = parsedLight.animations[animationIndex];
        var internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          light.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(light, parsedLight, scene);
    }
    if (parsedLight.autoAnimate) {
      scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
    }
    if (parsedLight.isEnabled !== void 0) {
      light.setEnabled(parsedLight.isEnabled);
    }
    return light;
  };
  Light2.prototype._hookArrayForExcluded = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        items[_i2] = arguments[_i2];
      }
      var result = oldPush.apply(array, items);
      for (var _a2 = 0, items_1 = items; _a2 < items_1.length; _a2++) {
        var item2 = items_1[_a2];
        item2._resyncLightSource(_this);
      }
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      for (var _i2 = 0, deleted_1 = deleted; _i2 < deleted_1.length; _i2++) {
        var item2 = deleted_1[_i2];
        item2._resyncLightSource(_this);
      }
      return deleted;
    };
    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
      var item = array_1[_i];
      item._resyncLightSource(this);
    }
  };
  Light2.prototype._hookArrayForIncludedOnly = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var result = oldPush.apply(array, items);
      _this._resyncMeshes();
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      _this._resyncMeshes();
      return deleted;
    };
    this._resyncMeshes();
  };
  Light2.prototype._resyncMeshes = function() {
    for (var _i = 0, _a2 = this.getScene().meshes; _i < _a2.length; _i++) {
      var mesh = _a2[_i];
      mesh._resyncLightSource(this);
    }
  };
  Light2.prototype._markMeshesAsLightDirty = function() {
    for (var _i = 0, _a2 = this.getScene().meshes; _i < _a2.length; _i++) {
      var mesh = _a2[_i];
      if (mesh.lightSources.indexOf(this) !== -1) {
        mesh._markSubMeshesAsLightDirty();
      }
    }
  };
  Light2.prototype._computePhotometricScale = function() {
    this._photometricScale = this._getPhotometricScale();
    this.getScene().resetCachedMaterial();
  };
  Light2.prototype._getPhotometricScale = function() {
    var photometricScale = 0;
    var lightTypeID = this.getTypeID();
    var photometricMode = this.intensityMode;
    if (photometricMode === Light2.INTENSITYMODE_AUTOMATIC) {
      if (lightTypeID === Light2.LIGHTTYPEID_DIRECTIONALLIGHT) {
        photometricMode = Light2.INTENSITYMODE_ILLUMINANCE;
      } else {
        photometricMode = Light2.INTENSITYMODE_LUMINOUSINTENSITY;
      }
    }
    switch (lightTypeID) {
      case Light2.LIGHTTYPEID_POINTLIGHT:
      case Light2.LIGHTTYPEID_SPOTLIGHT:
        switch (photometricMode) {
          case Light2.INTENSITYMODE_LUMINOUSPOWER:
            photometricScale = 1 / (4 * Math.PI);
            break;
          case Light2.INTENSITYMODE_LUMINOUSINTENSITY:
            photometricScale = 1;
            break;
          case Light2.INTENSITYMODE_LUMINANCE:
            photometricScale = this.radius * this.radius;
            break;
        }
        break;
      case Light2.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (photometricMode) {
          case Light2.INTENSITYMODE_ILLUMINANCE:
            photometricScale = 1;
            break;
          case Light2.INTENSITYMODE_LUMINANCE: {
            var apexAngleRadians = this.radius;
            apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
            var solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
            photometricScale = solidAngle;
            break;
          }
        }
        break;
      case Light2.LIGHTTYPEID_HEMISPHERICLIGHT:
        photometricScale = 1;
        break;
    }
    return photometricScale;
  };
  Light2.prototype._reorderLightsInScene = function() {
    var scene = this.getScene();
    if (this._renderPriority != 0) {
      scene.requireLightSorting = true;
    }
    this.getScene().sortLightsByPriority();
  };
  Light2.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
  Light2.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
  Light2.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
  Light2.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
  Light2.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
  Light2.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
  Light2.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
  Light2.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
  Light2.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
  Light2.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
  Light2.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
  Light2.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
  Light2.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
  Light2.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
  Light2.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
  Light2.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
  __decorate([
    serializeAsColor3()
  ], Light2.prototype, "diffuse", void 0);
  __decorate([
    serializeAsColor3()
  ], Light2.prototype, "specular", void 0);
  __decorate([
    serialize()
  ], Light2.prototype, "falloffType", void 0);
  __decorate([
    serialize()
  ], Light2.prototype, "intensity", void 0);
  __decorate([
    serialize()
  ], Light2.prototype, "range", null);
  __decorate([
    serialize()
  ], Light2.prototype, "intensityMode", null);
  __decorate([
    serialize()
  ], Light2.prototype, "radius", null);
  __decorate([
    serialize()
  ], Light2.prototype, "_renderPriority", void 0);
  __decorate([
    expandToProperty("_reorderLightsInScene")
  ], Light2.prototype, "renderPriority", void 0);
  __decorate([
    serialize("shadowEnabled")
  ], Light2.prototype, "_shadowEnabled", void 0);
  __decorate([
    serialize("excludeWithLayerMask")
  ], Light2.prototype, "_excludeWithLayerMask", void 0);
  __decorate([
    serialize("includeOnlyWithLayerMask")
  ], Light2.prototype, "_includeOnlyWithLayerMask", void 0);
  __decorate([
    serialize("lightmapMode")
  ], Light2.prototype, "_lightmapMode", void 0);
  return Light2;
}(Node);
var ThinMaterialHelper = function() {
  function ThinMaterialHelper2() {
  }
  ThinMaterialHelper2.BindClipPlane = function(effect, holder) {
    if (holder.clipPlane) {
      var clipPlane = holder.clipPlane;
      effect.setFloat4("vClipPlane", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane2) {
      var clipPlane = holder.clipPlane2;
      effect.setFloat4("vClipPlane2", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane3) {
      var clipPlane = holder.clipPlane3;
      effect.setFloat4("vClipPlane3", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane4) {
      var clipPlane = holder.clipPlane4;
      effect.setFloat4("vClipPlane4", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane5) {
      var clipPlane = holder.clipPlane5;
      effect.setFloat4("vClipPlane5", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
    if (holder.clipPlane6) {
      var clipPlane = holder.clipPlane6;
      effect.setFloat4("vClipPlane6", clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
    }
  };
  return ThinMaterialHelper2;
}();
var MaterialHelper = function() {
  function MaterialHelper2() {
  }
  MaterialHelper2.BindSceneUniformBuffer = function(effect, sceneUbo) {
    sceneUbo.bindToEffect(effect, "Scene");
  };
  MaterialHelper2.PrepareDefinesForMergedUV = function(texture, defines, key) {
    defines._needUVs = true;
    defines[key] = true;
    if (texture.getTextureMatrix().isIdentityAs3x2()) {
      defines[key + "DIRECTUV"] = texture.coordinatesIndex + 1;
      defines["MAINUV" + (texture.coordinatesIndex + 1)] = true;
    } else {
      defines[key + "DIRECTUV"] = 0;
    }
  };
  MaterialHelper2.BindTextureMatrix = function(texture, uniformBuffer, key) {
    var matrix = texture.getTextureMatrix();
    uniformBuffer.updateMatrix(key + "Matrix", matrix);
  };
  MaterialHelper2.GetFogState = function(mesh, scene) {
    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;
  };
  MaterialHelper2.PrepareDefinesForMisc = function(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {
    if (defines._areMiscDirty) {
      defines["LOGARITHMICDEPTH"] = useLogarithmicDepth;
      defines["POINTSIZE"] = pointsCloud;
      defines["FOG"] = fogEnabled && this.GetFogState(mesh, scene);
      defines["NONUNIFORMSCALING"] = mesh.nonUniformScaling;
      defines["ALPHATEST"] = alphaTest;
    }
  };
  MaterialHelper2.PrepareDefinesForFrameBoundValues = function(scene, engine, defines, useInstances, useClipPlane, useThinInstances) {
    if (useClipPlane === void 0) {
      useClipPlane = null;
    }
    if (useThinInstances === void 0) {
      useThinInstances = false;
    }
    var changed = false;
    var useClipPlane1 = false;
    var useClipPlane2 = false;
    var useClipPlane3 = false;
    var useClipPlane4 = false;
    var useClipPlane5 = false;
    var useClipPlane6 = false;
    useClipPlane1 = useClipPlane == null ? scene.clipPlane !== void 0 && scene.clipPlane !== null : useClipPlane;
    useClipPlane2 = useClipPlane == null ? scene.clipPlane2 !== void 0 && scene.clipPlane2 !== null : useClipPlane;
    useClipPlane3 = useClipPlane == null ? scene.clipPlane3 !== void 0 && scene.clipPlane3 !== null : useClipPlane;
    useClipPlane4 = useClipPlane == null ? scene.clipPlane4 !== void 0 && scene.clipPlane4 !== null : useClipPlane;
    useClipPlane5 = useClipPlane == null ? scene.clipPlane5 !== void 0 && scene.clipPlane5 !== null : useClipPlane;
    useClipPlane6 = useClipPlane == null ? scene.clipPlane6 !== void 0 && scene.clipPlane6 !== null : useClipPlane;
    if (defines["CLIPPLANE"] !== useClipPlane1) {
      defines["CLIPPLANE"] = useClipPlane1;
      changed = true;
    }
    if (defines["CLIPPLANE2"] !== useClipPlane2) {
      defines["CLIPPLANE2"] = useClipPlane2;
      changed = true;
    }
    if (defines["CLIPPLANE3"] !== useClipPlane3) {
      defines["CLIPPLANE3"] = useClipPlane3;
      changed = true;
    }
    if (defines["CLIPPLANE4"] !== useClipPlane4) {
      defines["CLIPPLANE4"] = useClipPlane4;
      changed = true;
    }
    if (defines["CLIPPLANE5"] !== useClipPlane5) {
      defines["CLIPPLANE5"] = useClipPlane5;
      changed = true;
    }
    if (defines["CLIPPLANE6"] !== useClipPlane6) {
      defines["CLIPPLANE6"] = useClipPlane6;
      changed = true;
    }
    if (defines["DEPTHPREPASS"] !== !engine.getColorWrite()) {
      defines["DEPTHPREPASS"] = !defines["DEPTHPREPASS"];
      changed = true;
    }
    if (defines["INSTANCES"] !== useInstances) {
      defines["INSTANCES"] = useInstances;
      changed = true;
    }
    if (defines["INSTANCESCOLOR"] && !defines["INSTANCES"]) {
      defines["INSTANCESCOLOR"] = false;
      changed = true;
    }
    if (defines["THIN_INSTANCES"] !== useThinInstances) {
      defines["THIN_INSTANCES"] = useThinInstances;
      changed = true;
    }
    if (changed) {
      defines.markAsUnprocessed();
    }
  };
  MaterialHelper2.PrepareDefinesForBones = function(mesh, defines) {
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      defines["NUM_BONE_INFLUENCERS"] = mesh.numBoneInfluencers;
      var materialSupportsBoneTexture = defines["BONETEXTURE"] !== void 0;
      if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {
        defines["BONETEXTURE"] = true;
      } else {
        defines["BonesPerMesh"] = mesh.skeleton.bones.length + 1;
        defines["BONETEXTURE"] = materialSupportsBoneTexture ? false : void 0;
        var prePassRenderer = mesh.getScene().prePassRenderer;
        if (prePassRenderer && prePassRenderer.enabled) {
          var nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;
          defines["BONES_VELOCITY_ENABLED"] = nonExcluded;
        }
      }
    } else {
      defines["NUM_BONE_INFLUENCERS"] = 0;
      defines["BonesPerMesh"] = 0;
    }
  };
  MaterialHelper2.PrepareDefinesForMorphTargets = function(mesh, defines) {
    var manager = mesh.morphTargetManager;
    if (manager) {
      defines["MORPHTARGETS_UV"] = manager.supportsUVs && defines["UV1"];
      defines["MORPHTARGETS_TANGENT"] = manager.supportsTangents && defines["TANGENT"];
      defines["MORPHTARGETS_NORMAL"] = manager.supportsNormals && defines["NORMAL"];
      defines["MORPHTARGETS"] = manager.numInfluencers > 0;
      defines["NUM_MORPH_INFLUENCERS"] = manager.numInfluencers;
      defines["MORPHTARGETS_TEXTURE"] = manager.isUsingTextureForTargets;
    } else {
      defines["MORPHTARGETS_UV"] = false;
      defines["MORPHTARGETS_TANGENT"] = false;
      defines["MORPHTARGETS_NORMAL"] = false;
      defines["MORPHTARGETS"] = false;
      defines["NUM_MORPH_INFLUENCERS"] = 0;
    }
  };
  MaterialHelper2.PrepareDefinesForBakedVertexAnimation = function(mesh, defines) {
    var manager = mesh.bakedVertexAnimationManager;
    defines["BAKED_VERTEX_ANIMATION_TEXTURE"] = manager && manager.isEnabled ? true : false;
  };
  MaterialHelper2.PrepareDefinesForAttributes = function(mesh, defines, useVertexColor, useBones, useMorphTargets, useVertexAlpha, useBakedVertexAnimation) {
    if (useMorphTargets === void 0) {
      useMorphTargets = false;
    }
    if (useVertexAlpha === void 0) {
      useVertexAlpha = true;
    }
    if (useBakedVertexAnimation === void 0) {
      useBakedVertexAnimation = true;
    }
    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {
      return false;
    }
    defines._normals = defines._needNormals;
    defines._uvs = defines._needUVs;
    defines["NORMAL"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
    if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
      defines["TANGENT"] = true;
    }
    for (var i = 1; i <= 6; ++i) {
      defines["UV" + i] = defines._needUVs ? mesh.isVerticesDataPresent("uv".concat(i === 1 ? "" : i)) : false;
    }
    if (useVertexColor) {
      var hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
      defines["VERTEXCOLOR"] = hasVertexColors;
      defines["VERTEXALPHA"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;
    }
    if (mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {
      defines["INSTANCESCOLOR"] = true;
    }
    if (useBones) {
      this.PrepareDefinesForBones(mesh, defines);
    }
    if (useMorphTargets) {
      this.PrepareDefinesForMorphTargets(mesh, defines);
    }
    if (useBakedVertexAnimation) {
      this.PrepareDefinesForBakedVertexAnimation(mesh, defines);
    }
    return true;
  };
  MaterialHelper2.PrepareDefinesForMultiview = function(scene, defines) {
    if (scene.activeCamera) {
      var previousMultiview = defines.MULTIVIEW;
      defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;
      if (defines.MULTIVIEW != previousMultiview) {
        defines.markAsUnprocessed();
      }
    }
  };
  MaterialHelper2.PrepareDefinesForOIT = function(scene, defines, needAlphaBlending) {
    var previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;
    var previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;
    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;
    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {
      defines.markAsUnprocessed();
    }
  };
  MaterialHelper2.PrepareDefinesForPrePass = function(scene, defines, canRenderToMRT) {
    var previousPrePass = defines.PREPASS;
    if (!defines._arePrePassDirty) {
      return;
    }
    var texturesList = [
      {
        type: 1,
        define: "PREPASS_POSITION",
        index: "PREPASS_POSITION_INDEX"
      },
      {
        type: 2,
        define: "PREPASS_VELOCITY",
        index: "PREPASS_VELOCITY_INDEX"
      },
      {
        type: 3,
        define: "PREPASS_REFLECTIVITY",
        index: "PREPASS_REFLECTIVITY_INDEX"
      },
      {
        type: 0,
        define: "PREPASS_IRRADIANCE",
        index: "PREPASS_IRRADIANCE_INDEX"
      },
      {
        type: 7,
        define: "PREPASS_ALBEDO_SQRT",
        index: "PREPASS_ALBEDO_SQRT_INDEX"
      },
      {
        type: 5,
        define: "PREPASS_DEPTH",
        index: "PREPASS_DEPTH_INDEX"
      },
      {
        type: 6,
        define: "PREPASS_NORMAL",
        index: "PREPASS_NORMAL_INDEX"
      }
    ];
    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {
      defines.PREPASS = true;
      defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;
      for (var i = 0; i < texturesList.length; i++) {
        var index = scene.prePassRenderer.getIndex(texturesList[i].type);
        if (index !== -1) {
          defines[texturesList[i].define] = true;
          defines[texturesList[i].index] = index;
        } else {
          defines[texturesList[i].define] = false;
        }
      }
    } else {
      defines.PREPASS = false;
      for (var i = 0; i < texturesList.length; i++) {
        defines[texturesList[i].define] = false;
      }
    }
    if (defines.PREPASS != previousPrePass) {
      defines.markAsUnprocessed();
      defines.markAsImageProcessingDirty();
    }
  };
  MaterialHelper2.PrepareDefinesForLight = function(scene, mesh, light, lightIndex, defines, specularSupported, state) {
    state.needNormals = true;
    if (defines["LIGHT" + lightIndex] === void 0) {
      state.needRebuild = true;
    }
    defines["LIGHT" + lightIndex] = true;
    defines["SPOTLIGHT" + lightIndex] = false;
    defines["HEMILIGHT" + lightIndex] = false;
    defines["POINTLIGHT" + lightIndex] = false;
    defines["DIRLIGHT" + lightIndex] = false;
    light.prepareLightSpecificDefines(defines, lightIndex);
    defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = false;
    defines["LIGHT_FALLOFF_GLTF" + lightIndex] = false;
    defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = false;
    switch (light.falloffType) {
      case Light.FALLOFF_GLTF:
        defines["LIGHT_FALLOFF_GLTF" + lightIndex] = true;
        break;
      case Light.FALLOFF_PHYSICAL:
        defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = true;
        break;
      case Light.FALLOFF_STANDARD:
        defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = true;
        break;
    }
    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {
      state.specularEnabled = true;
    }
    defines["SHADOW" + lightIndex] = false;
    defines["SHADOWCSM" + lightIndex] = false;
    defines["SHADOWCSMDEBUG" + lightIndex] = false;
    defines["SHADOWCSMNUM_CASCADES" + lightIndex] = false;
    defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = false;
    defines["SHADOWCSMNOBLEND" + lightIndex] = false;
    defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = false;
    defines["SHADOWPCF" + lightIndex] = false;
    defines["SHADOWPCSS" + lightIndex] = false;
    defines["SHADOWPOISSON" + lightIndex] = false;
    defines["SHADOWESM" + lightIndex] = false;
    defines["SHADOWCLOSEESM" + lightIndex] = false;
    defines["SHADOWCUBE" + lightIndex] = false;
    defines["SHADOWLOWQUALITY" + lightIndex] = false;
    defines["SHADOWMEDIUMQUALITY" + lightIndex] = false;
    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {
      var shadowGenerator = light.getShadowGenerator();
      if (shadowGenerator) {
        var shadowMap = shadowGenerator.getShadowMap();
        if (shadowMap) {
          if (shadowMap.renderList && shadowMap.renderList.length > 0) {
            state.shadowEnabled = true;
            shadowGenerator.prepareDefines(defines, lightIndex);
          }
        }
      }
    }
    if (light.lightmapMode != Light.LIGHTMAP_DEFAULT) {
      state.lightmapMode = true;
      defines["LIGHTMAPEXCLUDED" + lightIndex] = true;
      defines["LIGHTMAPNOSPECULAR" + lightIndex] = light.lightmapMode == Light.LIGHTMAP_SHADOWSONLY;
    } else {
      defines["LIGHTMAPEXCLUDED" + lightIndex] = false;
      defines["LIGHTMAPNOSPECULAR" + lightIndex] = false;
    }
  };
  MaterialHelper2.PrepareDefinesForLights = function(scene, mesh, defines, specularSupported, maxSimultaneousLights, disableLighting) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    if (disableLighting === void 0) {
      disableLighting = false;
    }
    if (!defines._areLightsDirty) {
      return defines._needNormals;
    }
    var lightIndex = 0;
    var state = {
      needNormals: false,
      needRebuild: false,
      lightmapMode: false,
      shadowEnabled: false,
      specularEnabled: false
    };
    if (scene.lightsEnabled && !disableLighting) {
      for (var _i = 0, _a2 = mesh.lightSources; _i < _a2.length; _i++) {
        var light = _a2[_i];
        this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);
        lightIndex++;
        if (lightIndex === maxSimultaneousLights) {
          break;
        }
      }
    }
    defines["SPECULARTERM"] = state.specularEnabled;
    defines["SHADOWS"] = state.shadowEnabled;
    for (var index = lightIndex; index < maxSimultaneousLights; index++) {
      if (defines["LIGHT" + index] !== void 0) {
        defines["LIGHT" + index] = false;
        defines["HEMILIGHT" + index] = false;
        defines["POINTLIGHT" + index] = false;
        defines["DIRLIGHT" + index] = false;
        defines["SPOTLIGHT" + index] = false;
        defines["SHADOW" + index] = false;
        defines["SHADOWCSM" + index] = false;
        defines["SHADOWCSMDEBUG" + index] = false;
        defines["SHADOWCSMNUM_CASCADES" + index] = false;
        defines["SHADOWCSMUSESHADOWMAXZ" + index] = false;
        defines["SHADOWCSMNOBLEND" + index] = false;
        defines["SHADOWCSM_RIGHTHANDED" + index] = false;
        defines["SHADOWPCF" + index] = false;
        defines["SHADOWPCSS" + index] = false;
        defines["SHADOWPOISSON" + index] = false;
        defines["SHADOWESM" + index] = false;
        defines["SHADOWCLOSEESM" + index] = false;
        defines["SHADOWCUBE" + index] = false;
        defines["SHADOWLOWQUALITY" + index] = false;
        defines["SHADOWMEDIUMQUALITY" + index] = false;
      }
    }
    var caps = scene.getEngine().getCaps();
    if (defines["SHADOWFLOAT"] === void 0) {
      state.needRebuild = true;
    }
    defines["SHADOWFLOAT"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);
    defines["LIGHTMAPEXCLUDED"] = state.lightmapMode;
    if (state.needRebuild) {
      defines.rebuild();
    }
    return state.needNormals;
  };
  MaterialHelper2.PrepareUniformsAndSamplersForLight = function(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList, updateOnlyBuffersList) {
    if (uniformBuffersList === void 0) {
      uniformBuffersList = null;
    }
    if (updateOnlyBuffersList === void 0) {
      updateOnlyBuffersList = false;
    }
    if (uniformBuffersList) {
      uniformBuffersList.push("Light" + lightIndex);
    }
    if (updateOnlyBuffersList) {
      return;
    }
    uniformsList.push("vLightData" + lightIndex, "vLightDiffuse" + lightIndex, "vLightSpecular" + lightIndex, "vLightDirection" + lightIndex, "vLightFalloff" + lightIndex, "vLightGround" + lightIndex, "lightMatrix" + lightIndex, "shadowsInfo" + lightIndex, "depthValues" + lightIndex);
    samplersList.push("shadowSampler" + lightIndex);
    samplersList.push("depthSampler" + lightIndex);
    uniformsList.push("viewFrustumZ" + lightIndex, "cascadeBlendFactor" + lightIndex, "lightSizeUVCorrection" + lightIndex, "depthCorrection" + lightIndex, "penumbraDarkness" + lightIndex, "frustumLengths" + lightIndex);
    if (projectedLightTexture) {
      samplersList.push("projectionLightSampler" + lightIndex);
      uniformsList.push("textureProjectionMatrix" + lightIndex);
    }
  };
  MaterialHelper2.PrepareUniformsAndSamplersList = function(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    var uniformsList;
    var uniformBuffersList = null;
    if (uniformsListOrOptions.uniformsNames) {
      var options = uniformsListOrOptions;
      uniformsList = options.uniformsNames;
      uniformBuffersList = options.uniformBuffersNames;
      samplersList = options.samplers;
      defines = options.defines;
      maxSimultaneousLights = options.maxSimultaneousLights || 0;
    } else {
      uniformsList = uniformsListOrOptions;
      if (!samplersList) {
        samplersList = [];
      }
    }
    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffersList);
    }
    if (defines["NUM_MORPH_INFLUENCERS"]) {
      uniformsList.push("morphTargetInfluences");
    }
    if (defines["BAKED_VERTEX_ANIMATION_TEXTURE"]) {
      uniformsList.push("bakedVertexAnimationSettings");
      uniformsList.push("bakedVertexAnimationTextureSizeInverted");
      uniformsList.push("bakedVertexAnimationTime");
      samplersList.push("bakedVertexAnimationTexture");
    }
  };
  MaterialHelper2.HandleFallbacksForShadows = function(defines, fallbacks, maxSimultaneousLights, rank) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    if (rank === void 0) {
      rank = 0;
    }
    var lightFallbackRank = 0;
    for (var lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
      if (!defines["LIGHT" + lightIndex]) {
        break;
      }
      if (lightIndex > 0) {
        lightFallbackRank = rank + lightIndex;
        fallbacks.addFallback(lightFallbackRank, "LIGHT" + lightIndex);
      }
      if (!defines["SHADOWS"]) {
        if (defines["SHADOW" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOW" + lightIndex);
        }
        if (defines["SHADOWPCF" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPCF" + lightIndex);
        }
        if (defines["SHADOWPCSS" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPCSS" + lightIndex);
        }
        if (defines["SHADOWPOISSON" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWPOISSON" + lightIndex);
        }
        if (defines["SHADOWESM" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWESM" + lightIndex);
        }
        if (defines["SHADOWCLOSEESM" + lightIndex]) {
          fallbacks.addFallback(rank, "SHADOWCLOSEESM" + lightIndex);
        }
      }
    }
    return lightFallbackRank++;
  };
  MaterialHelper2.PrepareAttributesForMorphTargetsInfluencers = function(attribs, mesh, influencers) {
    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;
    this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);
  };
  MaterialHelper2.PrepareAttributesForMorphTargets = function(attribs, mesh, defines) {
    var influencers = defines["NUM_MORPH_INFLUENCERS"];
    if (influencers > 0 && EngineStore.LastCreatedEngine) {
      var maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;
      var manager = mesh.morphTargetManager;
      if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {
        return;
      }
      var normal = manager && manager.supportsNormals && defines["NORMAL"];
      var tangent = manager && manager.supportsTangents && defines["TANGENT"];
      var uv = manager && manager.supportsUVs && defines["UV1"];
      for (var index = 0; index < influencers; index++) {
        attribs.push(VertexBuffer.PositionKind + index);
        if (normal) {
          attribs.push(VertexBuffer.NormalKind + index);
        }
        if (tangent) {
          attribs.push(VertexBuffer.TangentKind + index);
        }
        if (uv) {
          attribs.push(VertexBuffer.UVKind + "_" + index);
        }
        if (attribs.length > maxAttributesCount) {
          Logger.Error("Cannot add more vertex attributes for mesh " + mesh.name);
        }
      }
    }
  };
  MaterialHelper2.PrepareAttributesForBakedVertexAnimation = function(attribs, mesh, defines) {
    var enabled = defines["BAKED_VERTEX_ANIMATION_TEXTURE"] && defines["INSTANCES"];
    if (enabled) {
      attribs.push("bakedVertexAnimationSettingsInstanced");
    }
  };
  MaterialHelper2.PrepareAttributesForBones = function(attribs, mesh, defines, fallbacks) {
    if (defines["NUM_BONE_INFLUENCERS"] > 0) {
      fallbacks.addCPUSkinningFallback(0, mesh);
      attribs.push(VertexBuffer.MatricesIndicesKind);
      attribs.push(VertexBuffer.MatricesWeightsKind);
      if (defines["NUM_BONE_INFLUENCERS"] > 4) {
        attribs.push(VertexBuffer.MatricesIndicesExtraKind);
        attribs.push(VertexBuffer.MatricesWeightsExtraKind);
      }
    }
  };
  MaterialHelper2.PrepareAttributesForInstances = function(attribs, defines) {
    if (defines["INSTANCES"] || defines["THIN_INSTANCES"]) {
      this.PushAttributesForInstances(attribs, !!defines["PREPASS_VELOCITY"]);
    }
    if (defines.INSTANCESCOLOR) {
      attribs.push(VertexBuffer.ColorInstanceKind);
    }
  };
  MaterialHelper2.PushAttributesForInstances = function(attribs, needsPreviousMatrices) {
    if (needsPreviousMatrices === void 0) {
      needsPreviousMatrices = false;
    }
    attribs.push("world0");
    attribs.push("world1");
    attribs.push("world2");
    attribs.push("world3");
    if (needsPreviousMatrices) {
      attribs.push("previousWorld0");
      attribs.push("previousWorld1");
      attribs.push("previousWorld2");
      attribs.push("previousWorld3");
    }
  };
  MaterialHelper2.BindLightProperties = function(light, effect, lightIndex) {
    light.transferToEffect(effect, lightIndex + "");
  };
  MaterialHelper2.BindLight = function(light, lightIndex, scene, effect, useSpecular, receiveShadows) {
    if (receiveShadows === void 0) {
      receiveShadows = true;
    }
    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);
  };
  MaterialHelper2.BindLights = function(scene, mesh, effect, defines, maxSimultaneousLights) {
    if (maxSimultaneousLights === void 0) {
      maxSimultaneousLights = 4;
    }
    var len = Math.min(mesh.lightSources.length, maxSimultaneousLights);
    for (var i = 0; i < len; i++) {
      var light = mesh.lightSources[i];
      this.BindLight(light, i, scene, effect, typeof defines === "boolean" ? defines : defines["SPECULARTERM"], mesh.receiveShadows);
    }
  };
  MaterialHelper2.BindFogParameters = function(scene, mesh, effect, linearSpace) {
    if (linearSpace === void 0) {
      linearSpace = false;
    }
    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
      effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
      if (linearSpace) {
        scene.fogColor.toLinearSpaceToRef(this._TempFogColor);
        effect.setColor3("vFogColor", this._TempFogColor);
      } else {
        effect.setColor3("vFogColor", scene.fogColor);
      }
    }
  };
  MaterialHelper2.BindBonesParameters = function(mesh, effect, prePassConfiguration) {
    if (!effect || !mesh) {
      return;
    }
    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {
      mesh.computeBonesUsingShaders = false;
    }
    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
      var skeleton = mesh.skeleton;
      if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex("boneTextureWidth") > -1) {
        var boneTexture = skeleton.getTransformMatrixTexture(mesh);
        effect.setTexture("boneSampler", boneTexture);
        effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
      } else {
        var matrices = skeleton.getTransformMatrices(mesh);
        if (matrices) {
          effect.setMatrices("mBones", matrices);
          if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {
            if (!prePassConfiguration.previousBones[mesh.uniqueId]) {
              prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();
            }
            effect.setMatrices("mPreviousBones", prePassConfiguration.previousBones[mesh.uniqueId]);
            MaterialHelper2._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);
          }
        }
      }
    }
  };
  MaterialHelper2._CopyBonesTransformationMatrices = function(source, target2) {
    target2.set(source);
    return target2;
  };
  MaterialHelper2.BindMorphTargetParameters = function(abstractMesh, effect) {
    var manager = abstractMesh.morphTargetManager;
    if (!abstractMesh || !manager) {
      return;
    }
    effect.setFloatArray("morphTargetInfluences", manager.influences);
  };
  MaterialHelper2.BindLogDepth = function(defines, effect, scene) {
    if (!defines || defines["LOGARITHMICDEPTH"]) {
      var camera = scene.activeCamera;
      if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
        Logger.Error("Logarithmic depth is not compatible with orthographic cameras!", 20);
      }
      effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(camera.maxZ + 1) / Math.LN2));
    }
  };
  MaterialHelper2.BindClipPlane = function(effect, scene) {
    ThinMaterialHelper.BindClipPlane(effect, scene);
  };
  MaterialHelper2._TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };
  MaterialHelper2._TempFogColor = Color3.Black();
  return MaterialHelper2;
}();
var MaterialStencilState = function() {
  function MaterialStencilState2() {
    this.reset();
  }
  MaterialStencilState2.prototype.reset = function() {
    this.enabled = false;
    this.mask = 255;
    this.func = 519;
    this.funcRef = 1;
    this.funcMask = 255;
    this.opStencilFail = 7680;
    this.opDepthFail = 7680;
    this.opStencilDepthPass = 7681;
  };
  Object.defineProperty(MaterialStencilState2.prototype, "func", {
    get: function() {
      return this._func;
    },
    set: function(value) {
      this._func = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "funcRef", {
    get: function() {
      return this._funcRef;
    },
    set: function(value) {
      this._funcRef = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "funcMask", {
    get: function() {
      return this._funcMask;
    },
    set: function(value) {
      this._funcMask = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "opStencilFail", {
    get: function() {
      return this._opStencilFail;
    },
    set: function(value) {
      this._opStencilFail = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "opDepthFail", {
    get: function() {
      return this._opDepthFail;
    },
    set: function(value) {
      this._opDepthFail = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "opStencilDepthPass", {
    get: function() {
      return this._opStencilDepthPass;
    },
    set: function(value) {
      this._opStencilDepthPass = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "mask", {
    get: function() {
      return this._mask;
    },
    set: function(value) {
      this._mask = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(MaterialStencilState2.prototype, "enabled", {
    get: function() {
      return this._enabled;
    },
    set: function(value) {
      this._enabled = value;
    },
    enumerable: false,
    configurable: true
  });
  MaterialStencilState2.prototype.getClassName = function() {
    return "MaterialStencilState";
  };
  MaterialStencilState2.prototype.copyTo = function(stencilState) {
    SerializationHelper.Clone(function() {
      return stencilState;
    }, this);
  };
  MaterialStencilState2.prototype.serialize = function() {
    return SerializationHelper.Serialize(this);
  };
  MaterialStencilState2.prototype.parse = function(source, scene, rootUrl) {
    var _this = this;
    SerializationHelper.Parse(function() {
      return _this;
    }, source, scene, rootUrl);
  };
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "func", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "funcRef", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "funcMask", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "opStencilFail", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "opDepthFail", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "opStencilDepthPass", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "mask", null);
  __decorate([
    serialize()
  ], MaterialStencilState2.prototype, "enabled", null);
  return MaterialStencilState2;
}();
var MaterialPluginEvent;
(function(MaterialPluginEvent2) {
  MaterialPluginEvent2[MaterialPluginEvent2["Created"] = 1] = "Created";
  MaterialPluginEvent2[MaterialPluginEvent2["Disposed"] = 2] = "Disposed";
  MaterialPluginEvent2[MaterialPluginEvent2["GetDefineNames"] = 4] = "GetDefineNames";
  MaterialPluginEvent2[MaterialPluginEvent2["PrepareUniformBuffer"] = 8] = "PrepareUniformBuffer";
  MaterialPluginEvent2[MaterialPluginEvent2["IsReadyForSubMesh"] = 16] = "IsReadyForSubMesh";
  MaterialPluginEvent2[MaterialPluginEvent2["PrepareDefines"] = 32] = "PrepareDefines";
  MaterialPluginEvent2[MaterialPluginEvent2["BindForSubMesh"] = 64] = "BindForSubMesh";
  MaterialPluginEvent2[MaterialPluginEvent2["PrepareEffect"] = 128] = "PrepareEffect";
  MaterialPluginEvent2[MaterialPluginEvent2["GetAnimatables"] = 256] = "GetAnimatables";
  MaterialPluginEvent2[MaterialPluginEvent2["GetActiveTextures"] = 512] = "GetActiveTextures";
  MaterialPluginEvent2[MaterialPluginEvent2["HasTexture"] = 1024] = "HasTexture";
  MaterialPluginEvent2[MaterialPluginEvent2["FillRenderTargetTextures"] = 2048] = "FillRenderTargetTextures";
  MaterialPluginEvent2[MaterialPluginEvent2["HasRenderTargetTextures"] = 4096] = "HasRenderTargetTextures";
  MaterialPluginEvent2[MaterialPluginEvent2["HardBindForSubMesh"] = 8192] = "HardBindForSubMesh";
})(MaterialPluginEvent || (MaterialPluginEvent = {}));
var Material = function() {
  function Material2(name2, scene, doNotAdd) {
    this.shadowDepthWrapper = null;
    this.allowShaderHotSwapping = true;
    this.metadata = null;
    this.reservedDataStore = null;
    this.checkReadyOnEveryCall = false;
    this.checkReadyOnlyOnce = false;
    this.state = "";
    this._alpha = 1;
    this._backFaceCulling = true;
    this._cullBackFaces = true;
    this.onCompiled = null;
    this.onError = null;
    this.getRenderTargetTextures = null;
    this.doNotSerialize = false;
    this._storeEffectOnSubMeshes = false;
    this.animations = null;
    this.onDisposeObservable = new Observable();
    this._onDisposeObserver = null;
    this._onUnBindObservable = null;
    this._onBindObserver = null;
    this._alphaMode = 2;
    this._needDepthPrePass = false;
    this.disableDepthWrite = false;
    this.disableColorWrite = false;
    this.forceDepthWrite = false;
    this.depthFunction = 0;
    this.separateCullingPass = false;
    this._fogEnabled = true;
    this.pointSize = 1;
    this.zOffset = 0;
    this.zOffsetUnits = 0;
    this.stencil = new MaterialStencilState();
    this._useUBO = false;
    this._fillMode = Material2.TriangleFillMode;
    this._cachedDepthWriteState = false;
    this._cachedColorWriteState = false;
    this._cachedDepthFunctionState = 0;
    this._indexInSceneMaterialArray = -1;
    this.meshMap = null;
    this._parentContainer = null;
    this._uniformBufferLayoutBuilt = false;
    this._eventInfo = {};
    this._callbackPluginEventGeneric = function() {
      return void 0;
    };
    this._callbackPluginEventIsReadyForSubMesh = function() {
      return void 0;
    };
    this._callbackPluginEventPrepareDefines = function() {
      return void 0;
    };
    this._callbackPluginEventHardBindForSubMesh = function() {
      return void 0;
    };
    this._callbackPluginEventBindForSubMesh = function() {
      return void 0;
    };
    this._callbackPluginEventHasRenderTargetTextures = function() {
      return void 0;
    };
    this._callbackPluginEventFillRenderTargetTextures = function() {
      return void 0;
    };
    this._forceAlphaTest = false;
    this._transparencyMode = null;
    this.name = name2;
    var setScene = scene || EngineStore.LastCreatedScene;
    if (!setScene) {
      return;
    }
    this._scene = setScene;
    this._dirtyCallbacks = {};
    this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this);
    this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this);
    this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this);
    this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this);
    this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this);
    this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this);
    this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this);
    this.id = name2 || Tools.RandomId();
    this.uniqueId = this._scene.getUniqueId();
    this._materialContext = this._scene.getEngine().createMaterialContext();
    this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);
    this._drawWrapper.materialContext = this._materialContext;
    if (this._scene.useRightHandedSystem) {
      this.sideOrientation = Material2.ClockWiseSideOrientation;
    } else {
      this.sideOrientation = Material2.CounterClockWiseSideOrientation;
    }
    this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), void 0, void 0, name2);
    this._useUBO = this.getScene().getEngine().supportsUniformBuffers;
    if (!doNotAdd) {
      this._scene.addMaterial(this);
    }
    if (this._scene.useMaterialMeshMap) {
      this.meshMap = {};
    }
    Material2.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);
  }
  Object.defineProperty(Material2.prototype, "canRenderToMRT", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "alpha", {
    get: function() {
      return this._alpha;
    },
    set: function(value) {
      if (this._alpha === value) {
        return;
      }
      var oldValue = this._alpha;
      this._alpha = value;
      if (oldValue === 1 || value === 1) {
        this.markAsDirty(Material2.MiscDirtyFlag);
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "backFaceCulling", {
    get: function() {
      return this._backFaceCulling;
    },
    set: function(value) {
      if (this._backFaceCulling === value) {
        return;
      }
      this._backFaceCulling = value;
      this.markAsDirty(Material2.TextureDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "cullBackFaces", {
    get: function() {
      return this._cullBackFaces;
    },
    set: function(value) {
      if (this._cullBackFaces === value) {
        return;
      }
      this._cullBackFaces = value;
      this.markAsDirty(Material2.TextureDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "hasRenderTargetTextures", {
    get: function() {
      this._eventInfo.hasRenderTargetTextures = false;
      this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
      return this._eventInfo.hasRenderTargetTextures;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onBindObservable", {
    get: function() {
      if (!this._onBindObservable) {
        this._onBindObservable = new Observable();
      }
      return this._onBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onBind", {
    set: function(callback) {
      if (this._onBindObserver) {
        this.onBindObservable.remove(this._onBindObserver);
      }
      this._onBindObserver = this.onBindObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onUnBindObservable", {
    get: function() {
      if (!this._onUnBindObservable) {
        this._onUnBindObservable = new Observable();
      }
      return this._onUnBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "onEffectCreatedObservable", {
    get: function() {
      if (!this._onEffectCreatedObservable) {
        this._onEffectCreatedObservable = new Observable();
      }
      return this._onEffectCreatedObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "alphaMode", {
    get: function() {
      return this._alphaMode;
    },
    set: function(value) {
      if (this._alphaMode === value) {
        return;
      }
      this._alphaMode = value;
      this.markAsDirty(Material2.TextureDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "needDepthPrePass", {
    get: function() {
      return this._needDepthPrePass;
    },
    set: function(value) {
      if (this._needDepthPrePass === value) {
        return;
      }
      this._needDepthPrePass = value;
      if (this._needDepthPrePass) {
        this.checkReadyOnEveryCall = true;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "isPrePassCapable", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "fogEnabled", {
    get: function() {
      return this._fogEnabled;
    },
    set: function(value) {
      if (this._fogEnabled === value) {
        return;
      }
      this._fogEnabled = value;
      this.markAsDirty(Material2.MiscDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "wireframe", {
    get: function() {
      switch (this._fillMode) {
        case Material2.WireFrameFillMode:
        case Material2.LineListDrawMode:
        case Material2.LineLoopDrawMode:
        case Material2.LineStripDrawMode:
          return true;
      }
      return this._scene.forceWireframe;
    },
    set: function(value) {
      this.fillMode = value ? Material2.WireFrameFillMode : Material2.TriangleFillMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "pointsCloud", {
    get: function() {
      switch (this._fillMode) {
        case Material2.PointFillMode:
        case Material2.PointListDrawMode:
          return true;
      }
      return this._scene.forcePointsCloud;
    },
    set: function(value) {
      this.fillMode = value ? Material2.PointFillMode : Material2.TriangleFillMode;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "fillMode", {
    get: function() {
      return this._fillMode;
    },
    set: function(value) {
      if (this._fillMode === value) {
        return;
      }
      this._fillMode = value;
      this.markAsDirty(Material2.MiscDirtyFlag);
    },
    enumerable: false,
    configurable: true
  });
  Material2.prototype._getDrawWrapper = function() {
    return this._drawWrapper;
  };
  Material2.prototype._setDrawWrapper = function(drawWrapper) {
    this._drawWrapper = drawWrapper;
  };
  Material2.prototype.toString = function(fullDetails) {
    var ret = "Name: " + this.name;
    return ret;
  };
  Material2.prototype.getClassName = function() {
    return "Material";
  };
  Object.defineProperty(Material2.prototype, "isFrozen", {
    get: function() {
      return this.checkReadyOnlyOnce;
    },
    enumerable: false,
    configurable: true
  });
  Material2.prototype.freeze = function() {
    this.markDirty();
    this.checkReadyOnlyOnce = true;
  };
  Material2.prototype.unfreeze = function() {
    this.markDirty();
    this.checkReadyOnlyOnce = false;
  };
  Material2.prototype.isReady = function(mesh, useInstances) {
    return true;
  };
  Material2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    var defines = subMesh.materialDefines;
    if (!defines) {
      return false;
    }
    this._eventInfo.isReadyForSubMesh = true;
    this._eventInfo.defines = defines;
    this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
    return this._eventInfo.isReadyForSubMesh;
  };
  Material2.prototype.getEffect = function() {
    return this._drawWrapper.effect;
  };
  Material2.prototype.getScene = function() {
    return this._scene;
  };
  Object.defineProperty(Material2.prototype, "transparencyMode", {
    get: function() {
      return this._transparencyMode;
    },
    set: function(value) {
      if (this._transparencyMode === value) {
        return;
      }
      this._transparencyMode = value;
      this._forceAlphaTest = value === Material2.MATERIAL_ALPHATESTANDBLEND;
      this._markAllSubMeshesAsTexturesAndMiscDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Material2.prototype, "_disableAlphaBlending", {
    get: function() {
      return this._transparencyMode === Material2.MATERIAL_OPAQUE || this._transparencyMode === Material2.MATERIAL_ALPHATEST;
    },
    enumerable: false,
    configurable: true
  });
  Material2.prototype.needAlphaBlending = function() {
    if (this._disableAlphaBlending) {
      return false;
    }
    return this.alpha < 1;
  };
  Material2.prototype.needAlphaBlendingForMesh = function(mesh) {
    if (this._disableAlphaBlending && mesh.visibility >= 1) {
      return false;
    }
    return this.needAlphaBlending() || mesh.visibility < 1 || mesh.hasVertexAlpha;
  };
  Material2.prototype.needAlphaTesting = function() {
    if (this._forceAlphaTest) {
      return true;
    }
    return false;
  };
  Material2.prototype._shouldTurnAlphaTestOn = function(mesh) {
    return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();
  };
  Material2.prototype.getAlphaTestTexture = function() {
    return null;
  };
  Material2.prototype.markDirty = function() {
    var meshes = this.getScene().meshes;
    for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
      var mesh = meshes_1[_i];
      if (!mesh.subMeshes) {
        continue;
      }
      for (var _a2 = 0, _b2 = mesh.subMeshes; _a2 < _b2.length; _a2++) {
        var subMesh = _b2[_a2];
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        if (!subMesh.effect) {
          continue;
        }
        subMesh.effect._wasPreviouslyReady = false;
      }
    }
  };
  Material2.prototype._preBind = function(effect, overrideOrientation) {
    if (overrideOrientation === void 0) {
      overrideOrientation = null;
    }
    var engine = this._scene.getEngine();
    var orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;
    var reverse = orientation === Material2.ClockWiseSideOrientation;
    engine.enableEffect(effect ? effect : this._getDrawWrapper());
    engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this.cullBackFaces, this.stencil, this.zOffsetUnits);
    return reverse;
  };
  Material2.prototype.bind = function(world, mesh) {
  };
  Material2.prototype.buildUniformLayout = function() {
    var ubo = this._uniformBuffer;
    this._eventInfo.ubo = ubo;
    this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);
    ubo.create();
    this._uniformBufferLayoutBuilt = true;
  };
  Material2.prototype.bindForSubMesh = function(world, mesh, subMesh) {
    var effect = subMesh.effect;
    if (!effect) {
      return;
    }
    this._eventInfo.subMesh = subMesh;
    this._callbackPluginEventBindForSubMesh(this._eventInfo);
  };
  Material2.prototype.bindOnlyWorldMatrix = function(world) {
  };
  Material2.prototype.bindView = function(effect) {
    if (!this._useUBO) {
      effect.setMatrix("view", this.getScene().getViewMatrix());
    } else {
      this._needToBindSceneUbo = true;
    }
  };
  Material2.prototype.bindViewProjection = function(effect) {
    if (!this._useUBO) {
      effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
      effect.setMatrix("projection", this.getScene().getProjectionMatrix());
    } else {
      this._needToBindSceneUbo = true;
    }
  };
  Material2.prototype.bindEyePosition = function(effect, variableName) {
    if (!this._useUBO) {
      this._scene.bindEyePosition(effect, variableName);
    } else {
      this._needToBindSceneUbo = true;
    }
  };
  Material2.prototype._afterBind = function(mesh, effect) {
    if (effect === void 0) {
      effect = null;
    }
    this._scene._cachedMaterial = this;
    if (this._needToBindSceneUbo) {
      if (effect) {
        this._needToBindSceneUbo = false;
        MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
        this._scene.finalizeSceneUbo();
      }
    }
    if (mesh) {
      this._scene._cachedVisibility = mesh.visibility;
    } else {
      this._scene._cachedVisibility = 1;
    }
    if (this._onBindObservable && mesh) {
      this._onBindObservable.notifyObservers(mesh);
    }
    if (this.disableDepthWrite) {
      var engine = this._scene.getEngine();
      this._cachedDepthWriteState = engine.getDepthWrite();
      engine.setDepthWrite(false);
    }
    if (this.disableColorWrite) {
      var engine = this._scene.getEngine();
      this._cachedColorWriteState = engine.getColorWrite();
      engine.setColorWrite(false);
    }
    if (this.depthFunction !== 0) {
      var engine = this._scene.getEngine();
      this._cachedDepthFunctionState = engine.getDepthFunction() || 0;
      engine.setDepthFunction(this.depthFunction);
    }
  };
  Material2.prototype.unbind = function() {
    if (this._onUnBindObservable) {
      this._onUnBindObservable.notifyObservers(this);
    }
    if (this.depthFunction !== 0) {
      var engine = this._scene.getEngine();
      engine.setDepthFunction(this._cachedDepthFunctionState);
    }
    if (this.disableDepthWrite) {
      var engine = this._scene.getEngine();
      engine.setDepthWrite(this._cachedDepthWriteState);
    }
    if (this.disableColorWrite) {
      var engine = this._scene.getEngine();
      engine.setColorWrite(this._cachedColorWriteState);
    }
  };
  Material2.prototype.getAnimatables = function() {
    this._eventInfo.animatables = [];
    this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);
    return this._eventInfo.animatables;
  };
  Material2.prototype.getActiveTextures = function() {
    this._eventInfo.activeTextures = [];
    this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);
    return this._eventInfo.activeTextures;
  };
  Material2.prototype.hasTexture = function(texture) {
    this._eventInfo.hasTexture = false;
    this._eventInfo.texture = texture;
    this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);
    return this._eventInfo.hasTexture;
  };
  Material2.prototype.clone = function(name2) {
    return null;
  };
  Material2.prototype.getBindedMeshes = function() {
    var _this = this;
    if (this.meshMap) {
      var result = new Array();
      for (var meshId in this.meshMap) {
        var mesh = this.meshMap[meshId];
        if (mesh) {
          result.push(mesh);
        }
      }
      return result;
    } else {
      var meshes = this._scene.meshes;
      return meshes.filter(function(mesh2) {
        return mesh2.material === _this;
      });
    }
  };
  Material2.prototype.forceCompilation = function(mesh, onCompiled, options, onError) {
    var _this = this;
    var localOptions = __assign({ clipPlane: false, useInstances: false }, options);
    var scene = this.getScene();
    var currentHotSwapingState = this.allowShaderHotSwapping;
    this.allowShaderHotSwapping = false;
    var checkReady = function() {
      if (!_this._scene || !_this._scene.getEngine()) {
        return;
      }
      var clipPlaneState = scene.clipPlane;
      if (localOptions.clipPlane) {
        scene.clipPlane = new Plane(0, 0, 0, 1);
      }
      if (_this._storeEffectOnSubMeshes) {
        var allDone = true, lastError = null;
        if (mesh.subMeshes) {
          var tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, void 0, false, false);
          if (tempSubMesh.materialDefines) {
            tempSubMesh.materialDefines._renderId = -1;
          }
          if (!_this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {
            if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {
              lastError = tempSubMesh.effect.getCompilationError();
            } else {
              allDone = false;
              setTimeout(checkReady, 16);
            }
          }
        }
        if (allDone) {
          _this.allowShaderHotSwapping = currentHotSwapingState;
          if (lastError) {
            if (onError) {
              onError(lastError);
            }
          }
          if (onCompiled) {
            onCompiled(_this);
          }
        }
      } else {
        if (_this.isReady()) {
          _this.allowShaderHotSwapping = currentHotSwapingState;
          if (onCompiled) {
            onCompiled(_this);
          }
        } else {
          setTimeout(checkReady, 16);
        }
      }
      if (localOptions.clipPlane) {
        scene.clipPlane = clipPlaneState;
      }
    };
    checkReady();
  };
  Material2.prototype.forceCompilationAsync = function(mesh, options) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      _this.forceCompilation(mesh, function() {
        resolve();
      }, options, function(reason) {
        reject(reason);
      });
    });
  };
  Material2.prototype.markAsDirty = function(flag) {
    if (this.getScene().blockMaterialDirtyMechanism) {
      return;
    }
    Material2._DirtyCallbackArray.length = 0;
    if (flag & Material2.TextureDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._TextureDirtyCallBack);
    }
    if (flag & Material2.LightDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._LightsDirtyCallBack);
    }
    if (flag & Material2.FresnelDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._FresnelDirtyCallBack);
    }
    if (flag & Material2.AttributesDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._AttributeDirtyCallBack);
    }
    if (flag & Material2.MiscDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._MiscDirtyCallBack);
    }
    if (flag & Material2.PrePassDirtyFlag) {
      Material2._DirtyCallbackArray.push(Material2._PrePassDirtyCallBack);
    }
    if (Material2._DirtyCallbackArray.length) {
      this._markAllSubMeshesAsDirty(Material2._RunDirtyCallBacks);
    }
    this.getScene().resetCachedMaterial();
  };
  Material2.prototype.resetDrawCache = function() {
    var meshes = this.getScene().meshes;
    for (var _i = 0, meshes_2 = meshes; _i < meshes_2.length; _i++) {
      var mesh = meshes_2[_i];
      if (!mesh.subMeshes) {
        continue;
      }
      for (var _a2 = 0, _b2 = mesh.subMeshes; _a2 < _b2.length; _a2++) {
        var subMesh = _b2[_a2];
        if (subMesh.getMaterial() !== this) {
          continue;
        }
        subMesh.resetDrawCache();
      }
    }
  };
  Material2.prototype._markAllSubMeshesAsDirty = function(func) {
    if (this.getScene().blockMaterialDirtyMechanism) {
      return;
    }
    var meshes = this.getScene().meshes;
    for (var _i = 0, meshes_3 = meshes; _i < meshes_3.length; _i++) {
      var mesh = meshes_3[_i];
      if (!mesh.subMeshes) {
        continue;
      }
      for (var _a2 = 0, _b2 = mesh.subMeshes; _a2 < _b2.length; _a2++) {
        var subMesh = _b2[_a2];
        if (mesh._renderId === 0 || subMesh.getMaterial() !== this) {
          continue;
        }
        for (var _c2 = 0, _d = subMesh._drawWrappers; _c2 < _d.length; _c2++) {
          var drawWrapper = _d[_c2];
          if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
            continue;
          }
          if (this._materialContext === drawWrapper.materialContext) {
            func(drawWrapper.defines);
          }
        }
      }
    }
  };
  Material2.prototype._markScenePrePassDirty = function() {
    if (this.getScene().blockMaterialDirtyMechanism) {
      return;
    }
    var prePassRenderer = this.getScene().enablePrePassRenderer();
    if (prePassRenderer) {
      prePassRenderer.markAsDirty();
    }
  };
  Material2.prototype._markAllSubMeshesAsAllDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._AllDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsImageProcessingDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._ImageProcessingDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._TextureDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsFresnelDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._FresnelDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsFresnelAndMiscDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._FresnelAndMiscDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsLightsDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._LightsDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsAttributesDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._AttributeDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsMiscDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._MiscDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsPrePassDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._MiscDirtyCallBack);
  };
  Material2.prototype._markAllSubMeshesAsTexturesAndMiscDirty = function() {
    this._markAllSubMeshesAsDirty(Material2._TextureAndMiscDirtyCallBack);
  };
  Material2.prototype.setPrePassRenderer = function(prePassRenderer) {
    return false;
  };
  Material2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
    var scene = this.getScene();
    scene.stopAnimation(this);
    scene.freeProcessedMaterials();
    scene.removeMaterial(this);
    this._eventInfo.forceDisposeTextures = forceDisposeTextures;
    this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);
    if (this._parentContainer) {
      var index = this._parentContainer.materials.indexOf(this);
      if (index > -1) {
        this._parentContainer.materials.splice(index, 1);
      }
      this._parentContainer = null;
    }
    if (notBoundToMesh !== true) {
      if (this.meshMap) {
        for (var meshId in this.meshMap) {
          var mesh = this.meshMap[meshId];
          if (mesh) {
            mesh.material = null;
            this.releaseVertexArrayObject(mesh, forceDisposeEffect);
          }
        }
      } else {
        var meshes = scene.meshes;
        for (var _i = 0, meshes_4 = meshes; _i < meshes_4.length; _i++) {
          var mesh = meshes_4[_i];
          if (mesh.material === this && !mesh.sourceMesh) {
            mesh.material = null;
            this.releaseVertexArrayObject(mesh, forceDisposeEffect);
          }
        }
      }
    }
    this._uniformBuffer.dispose();
    if (forceDisposeEffect && this._drawWrapper.effect) {
      if (!this._storeEffectOnSubMeshes) {
        this._drawWrapper.effect.dispose();
      }
      this._drawWrapper.effect = null;
    }
    this.metadata = null;
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    if (this._onBindObservable) {
      this._onBindObservable.clear();
    }
    if (this._onUnBindObservable) {
      this._onUnBindObservable.clear();
    }
    if (this._onEffectCreatedObservable) {
      this._onEffectCreatedObservable.clear();
    }
  };
  Material2.prototype.releaseVertexArrayObject = function(mesh, forceDisposeEffect) {
    if (mesh.geometry) {
      var geometry = mesh.geometry;
      if (this._storeEffectOnSubMeshes) {
        for (var _i = 0, _a2 = mesh.subMeshes; _i < _a2.length; _i++) {
          var subMesh = _a2[_i];
          geometry._releaseVertexArrayObject(subMesh.effect);
          if (forceDisposeEffect && subMesh.effect) {
            subMesh.effect.dispose();
          }
        }
      } else {
        geometry._releaseVertexArrayObject(this._drawWrapper.effect);
      }
    }
  };
  Material2.prototype.serialize = function() {
    var serializationObject = SerializationHelper.Serialize(this);
    serializationObject.stencil = this.stencil.serialize();
    serializationObject.uniqueId = this.uniqueId;
    return serializationObject;
  };
  Material2.Parse = function(parsedMaterial, scene, rootUrl) {
    if (!parsedMaterial.customType) {
      parsedMaterial.customType = "BABYLON.StandardMaterial";
    } else if (parsedMaterial.customType === "BABYLON.PBRMaterial" && parsedMaterial.overloadedAlbedo) {
      parsedMaterial.customType = "BABYLON.LegacyPBRMaterial";
      if (!BABYLON.LegacyPBRMaterial) {
        Logger.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.");
        return null;
      }
    }
    var materialType = Tools.Instantiate(parsedMaterial.customType);
    var material = materialType.Parse(parsedMaterial, scene, rootUrl);
    material._loadedUniqueId = parsedMaterial.uniqueId;
    return material;
  };
  Material2.TriangleFillMode = 0;
  Material2.WireFrameFillMode = 1;
  Material2.PointFillMode = 2;
  Material2.PointListDrawMode = 3;
  Material2.LineListDrawMode = 4;
  Material2.LineLoopDrawMode = 5;
  Material2.LineStripDrawMode = 6;
  Material2.TriangleStripDrawMode = 7;
  Material2.TriangleFanDrawMode = 8;
  Material2.ClockWiseSideOrientation = 0;
  Material2.CounterClockWiseSideOrientation = 1;
  Material2.TextureDirtyFlag = 1;
  Material2.LightDirtyFlag = 2;
  Material2.FresnelDirtyFlag = 4;
  Material2.AttributesDirtyFlag = 8;
  Material2.MiscDirtyFlag = 16;
  Material2.PrePassDirtyFlag = 32;
  Material2.AllDirtyFlag = 63;
  Material2.MATERIAL_OPAQUE = 0;
  Material2.MATERIAL_ALPHATEST = 1;
  Material2.MATERIAL_ALPHABLEND = 2;
  Material2.MATERIAL_ALPHATESTANDBLEND = 3;
  Material2.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;
  Material2.MATERIAL_NORMALBLENDMETHOD_RNM = 1;
  Material2.OnEventObservable = new Observable();
  Material2._AllDirtyCallBack = function(defines) {
    return defines.markAllAsDirty();
  };
  Material2._ImageProcessingDirtyCallBack = function(defines) {
    return defines.markAsImageProcessingDirty();
  };
  Material2._TextureDirtyCallBack = function(defines) {
    return defines.markAsTexturesDirty();
  };
  Material2._FresnelDirtyCallBack = function(defines) {
    return defines.markAsFresnelDirty();
  };
  Material2._MiscDirtyCallBack = function(defines) {
    return defines.markAsMiscDirty();
  };
  Material2._PrePassDirtyCallBack = function(defines) {
    return defines.markAsPrePassDirty();
  };
  Material2._LightsDirtyCallBack = function(defines) {
    return defines.markAsLightDirty();
  };
  Material2._AttributeDirtyCallBack = function(defines) {
    return defines.markAsAttributesDirty();
  };
  Material2._FresnelAndMiscDirtyCallBack = function(defines) {
    Material2._FresnelDirtyCallBack(defines);
    Material2._MiscDirtyCallBack(defines);
  };
  Material2._TextureAndMiscDirtyCallBack = function(defines) {
    Material2._TextureDirtyCallBack(defines);
    Material2._MiscDirtyCallBack(defines);
  };
  Material2._DirtyCallbackArray = [];
  Material2._RunDirtyCallBacks = function(defines) {
    for (var _i = 0, _a2 = Material2._DirtyCallbackArray; _i < _a2.length; _i++) {
      var cb = _a2[_i];
      cb(defines);
    }
  };
  __decorate([
    serialize()
  ], Material2.prototype, "id", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "metadata", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "checkReadyOnEveryCall", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "checkReadyOnlyOnce", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "state", void 0);
  __decorate([
    serialize("alpha")
  ], Material2.prototype, "_alpha", void 0);
  __decorate([
    serialize("backFaceCulling")
  ], Material2.prototype, "_backFaceCulling", void 0);
  __decorate([
    serialize("cullBackFaces")
  ], Material2.prototype, "_cullBackFaces", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "sideOrientation", void 0);
  __decorate([
    serialize("alphaMode")
  ], Material2.prototype, "_alphaMode", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "_needDepthPrePass", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "disableDepthWrite", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "disableColorWrite", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "forceDepthWrite", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "depthFunction", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "separateCullingPass", void 0);
  __decorate([
    serialize("fogEnabled")
  ], Material2.prototype, "_fogEnabled", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "pointSize", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "zOffset", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "zOffsetUnits", void 0);
  __decorate([
    serialize()
  ], Material2.prototype, "pointsCloud", null);
  __decorate([
    serialize()
  ], Material2.prototype, "fillMode", null);
  __decorate([
    serialize()
  ], Material2.prototype, "transparencyMode", null);
  return Material2;
}();
var MultiMaterial = function(_super) {
  __extends(MultiMaterial2, _super);
  function MultiMaterial2(name2, scene) {
    var _this = _super.call(this, name2, scene, true) || this;
    _this._waitingSubMaterialsUniqueIds = [];
    _this.getScene().multiMaterials.push(_this);
    _this.subMaterials = new Array();
    _this._storeEffectOnSubMeshes = true;
    return _this;
  }
  Object.defineProperty(MultiMaterial2.prototype, "subMaterials", {
    get: function() {
      return this._subMaterials;
    },
    set: function(value) {
      this._subMaterials = value;
      this._hookArray(value);
    },
    enumerable: false,
    configurable: true
  });
  MultiMaterial2.prototype.getChildren = function() {
    return this.subMaterials;
  };
  MultiMaterial2.prototype._hookArray = function(array) {
    var _this = this;
    var oldPush = array.push;
    array.push = function() {
      var items = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        items[_i] = arguments[_i];
      }
      var result = oldPush.apply(array, items);
      _this._markAllSubMeshesAsTexturesDirty();
      return result;
    };
    var oldSplice = array.splice;
    array.splice = function(index, deleteCount) {
      var deleted = oldSplice.apply(array, [index, deleteCount]);
      _this._markAllSubMeshesAsTexturesDirty();
      return deleted;
    };
  };
  MultiMaterial2.prototype.getSubMaterial = function(index) {
    if (index < 0 || index >= this.subMaterials.length) {
      return this.getScene().defaultMaterial;
    }
    return this.subMaterials[index];
  };
  MultiMaterial2.prototype.getActiveTextures = function() {
    var _a2;
    return (_a2 = _super.prototype.getActiveTextures.call(this)).concat.apply(_a2, this.subMaterials.map(function(subMaterial) {
      if (subMaterial) {
        return subMaterial.getActiveTextures();
      } else {
        return [];
      }
    }));
  };
  MultiMaterial2.prototype.hasTexture = function(texture) {
    var _a2;
    if (_super.prototype.hasTexture.call(this, texture)) {
      return true;
    }
    for (var i = 0; i < this.subMaterials.length; i++) {
      if ((_a2 = this.subMaterials[i]) === null || _a2 === void 0 ? void 0 : _a2.hasTexture(texture)) {
        return true;
      }
    }
    return false;
  };
  MultiMaterial2.prototype.getClassName = function() {
    return "MultiMaterial";
  };
  MultiMaterial2.prototype.isReadyForSubMesh = function(mesh, subMesh, useInstances) {
    for (var index = 0; index < this.subMaterials.length; index++) {
      var subMaterial = this.subMaterials[index];
      if (subMaterial) {
        if (subMaterial._storeEffectOnSubMeshes) {
          if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {
            return false;
          }
          continue;
        }
        if (!subMaterial.isReady(mesh)) {
          return false;
        }
      }
    }
    return true;
  };
  MultiMaterial2.prototype.clone = function(name2, cloneChildren) {
    var newMultiMaterial = new MultiMaterial2(name2, this.getScene());
    for (var index = 0; index < this.subMaterials.length; index++) {
      var subMaterial = null;
      var current = this.subMaterials[index];
      if (cloneChildren && current) {
        subMaterial = current.clone(name2 + "-" + current.name);
      } else {
        subMaterial = this.subMaterials[index];
      }
      newMultiMaterial.subMaterials.push(subMaterial);
    }
    return newMultiMaterial;
  };
  MultiMaterial2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    if (Tags) {
      serializationObject.tags = Tags.GetTags(this);
    }
    serializationObject.materialsUniqueIds = [];
    serializationObject.materials = [];
    for (var matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {
      var subMat = this.subMaterials[matIndex];
      if (subMat) {
        serializationObject.materialsUniqueIds.push(subMat.uniqueId);
        serializationObject.materials.push(subMat.id);
      } else {
        serializationObject.materialsUniqueIds.push(null);
        serializationObject.materials.push(null);
      }
    }
    return serializationObject;
  };
  MultiMaterial2.prototype.dispose = function(forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    if (forceDisposeChildren) {
      for (var index_1 = 0; index_1 < this.subMaterials.length; index_1++) {
        var subMaterial = this.subMaterials[index_1];
        if (subMaterial) {
          subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);
        }
      }
    }
    var index = scene.multiMaterials.indexOf(this);
    if (index >= 0) {
      scene.multiMaterials.splice(index, 1);
    }
    _super.prototype.dispose.call(this, forceDisposeEffect, forceDisposeTextures);
  };
  MultiMaterial2.ParseMultiMaterial = function(parsedMultiMaterial, scene) {
    var multiMaterial = new MultiMaterial2(parsedMultiMaterial.name, scene);
    multiMaterial.id = parsedMultiMaterial.id;
    multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;
    if (Tags) {
      Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);
    }
    if (parsedMultiMaterial.materialsUniqueIds) {
      multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;
    } else {
      parsedMultiMaterial.materials.forEach(function(subMatId) {
        return multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId));
      });
    }
    return multiMaterial;
  };
  return MultiMaterial2;
}(Material);
RegisterClass("BABYLON.MultiMaterial", MultiMaterial);
var MeshLODLevel = function() {
  function MeshLODLevel2(distanceOrScreenCoverage, mesh) {
    this.distanceOrScreenCoverage = distanceOrScreenCoverage;
    this.mesh = mesh;
  }
  return MeshLODLevel2;
}();
var _InstanceDataStorage = function() {
  function _InstanceDataStorage2() {
    this.visibleInstances = {};
    this.batchCache = new _InstancesBatch();
    this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();
    this.instancesBufferSize = 32 * 16 * 4;
  }
  return _InstanceDataStorage2;
}();
var _InstancesBatch = function() {
  function _InstancesBatch2() {
    this.mustReturn = false;
    this.visibleInstances = new Array();
    this.renderSelf = new Array();
    this.hardwareInstancedRendering = new Array();
  }
  return _InstancesBatch2;
}();
var _ThinInstanceDataStorage = function() {
  function _ThinInstanceDataStorage2() {
    this.instancesCount = 0;
    this.matrixBuffer = null;
    this.previousMatrixBuffer = null;
    this.matrixBufferSize = 32 * 16;
    this.matrixData = null;
    this.boundingVectors = [];
    this.worldMatrices = null;
  }
  return _ThinInstanceDataStorage2;
}();
var _InternalMeshDataInfo = function() {
  function _InternalMeshDataInfo2() {
    this._areNormalsFrozen = false;
    this._source = null;
    this.meshMap = null;
    this._preActivateId = -1;
    this._LODLevels = new Array();
    this._useLODScreenCoverage = false;
    this._effectiveMaterial = null;
    this._forcedInstanceCount = 0;
  }
  return _InternalMeshDataInfo2;
}();
var Mesh = function(_super) {
  __extends(Mesh2, _super);
  function Mesh2(name2, scene, parent, source, doNotCloneChildren, clonePhysicsImpostor) {
    if (scene === void 0) {
      scene = null;
    }
    if (parent === void 0) {
      parent = null;
    }
    if (source === void 0) {
      source = null;
    }
    if (clonePhysicsImpostor === void 0) {
      clonePhysicsImpostor = true;
    }
    var _this = _super.call(this, name2, scene) || this;
    _this._internalMeshDataInfo = new _InternalMeshDataInfo();
    _this.delayLoadState = 0;
    _this.instances = new Array();
    _this._creationDataStorage = null;
    _this._geometry = null;
    _this._instanceDataStorage = new _InstanceDataStorage();
    _this._thinInstanceDataStorage = new _ThinInstanceDataStorage();
    _this._shouldGenerateFlatShading = false;
    _this._originalBuilderSideOrientation = Mesh2.DEFAULTSIDE;
    _this.overrideMaterialSideOrientation = null;
    _this.ignoreCameraMaxZ = false;
    scene = _this.getScene();
    _this._onBeforeDraw = function(isInstance, world, effectiveMaterial) {
      if (isInstance && effectiveMaterial) {
        if (_this._uniformBuffer) {
          _this.transferToEffect(world);
        } else {
          effectiveMaterial.bindOnlyWorldMatrix(world);
        }
      }
    };
    if (source) {
      if (source._geometry) {
        source._geometry.applyToMesh(_this);
      }
      DeepCopier.DeepCopy(source, _this, [
        "name",
        "material",
        "skeleton",
        "instances",
        "parent",
        "uniqueId",
        "source",
        "metadata",
        "morphTargetManager",
        "hasInstances",
        "worldMatrixInstancedBuffer",
        "previousWorldMatrixInstancedBuffer",
        "hasLODLevels",
        "geometry",
        "isBlocked",
        "areNormalsFrozen",
        "facetNb",
        "isFacetDataEnabled",
        "lightSources",
        "useBones",
        "isAnInstance",
        "collider",
        "edgesRenderer",
        "forward",
        "up",
        "right",
        "absolutePosition",
        "absoluteScaling",
        "absoluteRotationQuaternion",
        "isWorldMatrixFrozen",
        "nonUniformScaling",
        "behaviors",
        "worldMatrixFromCache",
        "hasThinInstances",
        "cloneMeshMap",
        "hasBoundingInfo"
      ], ["_poseMatrix"]);
      _this._internalMeshDataInfo._source = source;
      if (scene.useClonedMeshMap) {
        if (!source._internalMeshDataInfo.meshMap) {
          source._internalMeshDataInfo.meshMap = {};
        }
        source._internalMeshDataInfo.meshMap[_this.uniqueId] = _this;
      }
      _this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;
      _this._creationDataStorage = source._creationDataStorage;
      if (source._ranges) {
        var ranges = source._ranges;
        for (var name_1 in ranges) {
          if (!Object.prototype.hasOwnProperty.call(ranges, name_1)) {
            continue;
          }
          if (!ranges[name_1]) {
            continue;
          }
          _this.createAnimationRange(name_1, ranges[name_1].from, ranges[name_1].to);
        }
      }
      if (source.metadata && source.metadata.clone) {
        _this.metadata = source.metadata.clone();
      } else {
        _this.metadata = source.metadata;
      }
      if (Tags && Tags.HasTags(source)) {
        Tags.AddTagsTo(_this, Tags.GetTags(source, true));
      }
      _this.setEnabled(source.isEnabled());
      _this.parent = source.parent;
      _this.setPivotMatrix(source.getPivotMatrix());
      _this.id = name2 + "." + source.id;
      _this.material = source.material;
      if (!doNotCloneChildren) {
        var directDescendants = source.getDescendants(true);
        for (var index = 0; index < directDescendants.length; index++) {
          var child = directDescendants[index];
          if (child.clone) {
            child.clone(name2 + "." + child.name, _this);
          }
        }
      }
      if (source.morphTargetManager) {
        _this.morphTargetManager = source.morphTargetManager;
      }
      if (scene.getPhysicsEngine) {
        var physicsEngine = scene.getPhysicsEngine();
        if (clonePhysicsImpostor && physicsEngine) {
          var impostor = physicsEngine.getImpostorForPhysicsObject(source);
          if (impostor) {
            _this.physicsImpostor = impostor.clone(_this);
          }
        }
      }
      for (var index = 0; index < scene.particleSystems.length; index++) {
        var system = scene.particleSystems[index];
        if (system.emitter === source) {
          system.clone(system.name, _this);
        }
      }
      _this.skeleton = source.skeleton;
      _this.refreshBoundingInfo(true, true);
      _this.computeWorldMatrix(true);
    }
    if (parent !== null) {
      _this.parent = parent;
    }
    _this._instanceDataStorage.hardwareInstancedRendering = _this.getEngine().getCaps().instancedArrays;
    _this._internalMeshDataInfo._onMeshReadyObserverAdded = function(observer) {
      observer.unregisterOnNextCall = true;
      if (_this.isReady(true)) {
        _this.onMeshReadyObservable.notifyObservers(_this);
      } else {
        if (!_this._internalMeshDataInfo._checkReadinessObserver) {
          _this._internalMeshDataInfo._checkReadinessObserver = _this._scene.onBeforeRenderObservable.add(function() {
            if (_this.isReady(true)) {
              _this._scene.onBeforeRenderObservable.remove(_this._internalMeshDataInfo._checkReadinessObserver);
              _this._internalMeshDataInfo._checkReadinessObserver = null;
              _this.onMeshReadyObservable.notifyObservers(_this);
            }
          });
        }
      }
    };
    _this.onMeshReadyObservable = new Observable(_this._internalMeshDataInfo._onMeshReadyObserverAdded);
    if (source) {
      source.onClonedObservable.notifyObservers(_this);
    }
    return _this;
  }
  Mesh2._GetDefaultSideOrientation = function(orientation) {
    return orientation || Mesh2.FRONTSIDE;
  };
  Object.defineProperty(Mesh2.prototype, "useLODScreenCoverage", {
    get: function() {
      return this._internalMeshDataInfo._useLODScreenCoverage;
    },
    set: function(value) {
      this._internalMeshDataInfo._useLODScreenCoverage = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "computeBonesUsingShaders", {
    get: function() {
      return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
    },
    set: function(value) {
      if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
        return;
      }
      if (value && this._internalMeshDataInfo._sourcePositions) {
        this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);
        if (this._internalMeshDataInfo._sourceNormals) {
          this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);
        }
        this._internalMeshDataInfo._sourcePositions = null;
        this._internalMeshDataInfo._sourceNormals = null;
      }
      this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
      this._markSubMeshesAsAttributesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeRenderObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBeforeRenderObservable) {
        this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBeforeRenderObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeBindObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBeforeBindObservable) {
        this._internalMeshDataInfo._onBeforeBindObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBeforeBindObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onAfterRenderObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onAfterRenderObservable) {
        this._internalMeshDataInfo._onAfterRenderObservable = new Observable();
      }
      return this._internalMeshDataInfo._onAfterRenderObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBetweenPassObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBetweenPassObservable) {
        this._internalMeshDataInfo._onBetweenPassObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBetweenPassObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeDrawObservable", {
    get: function() {
      if (!this._internalMeshDataInfo._onBeforeDrawObservable) {
        this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();
      }
      return this._internalMeshDataInfo._onBeforeDrawObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "onBeforeDraw", {
    set: function(callback) {
      if (this._onBeforeDrawObserver) {
        this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);
      }
      this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "hasInstances", {
    get: function() {
      return this.instances.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "hasThinInstances", {
    get: function() {
      var _a2;
      return ((_a2 = this._thinInstanceDataStorage.instancesCount) !== null && _a2 !== void 0 ? _a2 : 0) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "forcedInstanceCount", {
    get: function() {
      return this._internalMeshDataInfo._forcedInstanceCount;
    },
    set: function(count) {
      this._internalMeshDataInfo._forcedInstanceCount = count;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "source", {
    get: function() {
      return this._internalMeshDataInfo._source;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "cloneMeshMap", {
    get: function() {
      return this._internalMeshDataInfo.meshMap;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "isUnIndexed", {
    get: function() {
      return this._unIndexed;
    },
    set: function(value) {
      if (this._unIndexed !== value) {
        this._unIndexed = value;
        this._markSubMeshesAsAttributesDirty();
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "worldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.instancesData;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "previousWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.instancesPreviousData;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "manualUpdateOfWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.manualUpdate;
    },
    set: function(value) {
      this._instanceDataStorage.manualUpdate = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Mesh2.prototype, "manualUpdateOfPreviousWorldMatrixInstancedBuffer", {
    get: function() {
      return this._instanceDataStorage.previousManualUpdate;
    },
    set: function(value) {
      this._instanceDataStorage.previousManualUpdate = value;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.instantiateHierarchy = function(newParent, options, onNewNodeCreated) {
    if (newParent === void 0) {
      newParent = null;
    }
    var instance = this.getTotalVertices() > 0 && (!options || !options.doNotInstantiate) ? this.createInstance("instance of " + (this.name || this.id)) : this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
    instance.parent = newParent || this.parent;
    instance.position = this.position.clone();
    instance.scaling = this.scaling.clone();
    if (this.rotationQuaternion) {
      instance.rotationQuaternion = this.rotationQuaternion.clone();
    } else {
      instance.rotation = this.rotation.clone();
    }
    if (onNewNodeCreated) {
      onNewNodeCreated(this, instance);
    }
    for (var _i = 0, _a2 = this.getChildTransformNodes(true); _i < _a2.length; _i++) {
      var child = _a2[_i];
      child.instantiateHierarchy(instance, options, onNewNodeCreated);
    }
    return instance;
  };
  Mesh2.prototype.getClassName = function() {
    return "Mesh";
  };
  Object.defineProperty(Mesh2.prototype, "_isMesh", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.toString = function(fullDetails) {
    var ret = _super.prototype.toString.call(this, fullDetails);
    ret += ", n vertices: " + this.getTotalVertices();
    ret += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE");
    if (this.animations) {
      for (var i = 0; i < this.animations.length; i++) {
        ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
      }
    }
    if (fullDetails) {
      if (this._geometry) {
        var ib = this.getIndices();
        var vb = this.getVerticesData(VertexBuffer.PositionKind);
        if (vb && ib) {
          ret += ", flat shading: " + (vb.length / 3 === ib.length ? "YES" : "NO");
        }
      } else {
        ret += ", flat shading: UNKNOWN";
      }
    }
    return ret;
  };
  Mesh2.prototype._unBindEffect = function() {
    _super.prototype._unBindEffect.call(this);
    for (var _i = 0, _a2 = this.instances; _i < _a2.length; _i++) {
      var instance = _a2[_i];
      instance._unBindEffect();
    }
  };
  Object.defineProperty(Mesh2.prototype, "hasLODLevels", {
    get: function() {
      return this._internalMeshDataInfo._LODLevels.length > 0;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.getLODLevels = function() {
    return this._internalMeshDataInfo._LODLevels;
  };
  Mesh2.prototype._sortLODLevels = function() {
    var sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
    this._internalMeshDataInfo._LODLevels.sort(function(a, b) {
      if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {
        return sortingOrderFactor;
      }
      if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {
        return -sortingOrderFactor;
      }
      return 0;
    });
  };
  Mesh2.prototype.addLODLevel = function(distanceOrScreenCoverage, mesh) {
    if (mesh && mesh._masterMesh) {
      Logger.Warn("You cannot use a mesh as LOD level twice");
      return this;
    }
    var level = new MeshLODLevel(distanceOrScreenCoverage, mesh);
    this._internalMeshDataInfo._LODLevels.push(level);
    if (mesh) {
      mesh._masterMesh = this;
    }
    this._sortLODLevels();
    return this;
  };
  Mesh2.prototype.getLODLevelAtDistance = function(distance) {
    var internalDataInfo = this._internalMeshDataInfo;
    for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
      var level = internalDataInfo._LODLevels[index];
      if (level.distanceOrScreenCoverage === distance) {
        return level.mesh;
      }
    }
    return null;
  };
  Mesh2.prototype.removeLODLevel = function(mesh) {
    var internalDataInfo = this._internalMeshDataInfo;
    for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
      if (internalDataInfo._LODLevels[index].mesh === mesh) {
        internalDataInfo._LODLevels.splice(index, 1);
        if (mesh) {
          mesh._masterMesh = null;
        }
      }
    }
    this._sortLODLevels();
    return this;
  };
  Mesh2.prototype.getLOD = function(camera, boundingSphere) {
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {
      return this;
    }
    var bSphere;
    if (boundingSphere) {
      bSphere = boundingSphere;
    } else {
      var boundingInfo = this.getBoundingInfo();
      bSphere = boundingInfo.boundingSphere;
    }
    var distanceToCamera = bSphere.centerWorld.subtract(camera.globalPosition).length();
    var useScreenCoverage = internalDataInfo._useLODScreenCoverage;
    var compareValue = distanceToCamera;
    var compareSign = 1;
    if (useScreenCoverage) {
      var screenArea = camera.screenArea;
      var meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;
      meshArea = meshArea * meshArea * Math.PI;
      compareValue = meshArea / screenArea;
      compareSign = -1;
    }
    if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {
      if (this.onLODLevelSelection) {
        this.onLODLevelSelection(compareValue, this, this);
      }
      return this;
    }
    for (var index = 0; index < internalDataInfo._LODLevels.length; index++) {
      var level = internalDataInfo._LODLevels[index];
      if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {
        if (level.mesh) {
          if (level.mesh.delayLoadState === 4) {
            level.mesh._checkDelayState();
            return this;
          }
          if (level.mesh.delayLoadState === 2) {
            return this;
          }
          level.mesh._preActivate();
          level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        }
        if (this.onLODLevelSelection) {
          this.onLODLevelSelection(compareValue, this, level.mesh);
        }
        return level.mesh;
      }
    }
    if (this.onLODLevelSelection) {
      this.onLODLevelSelection(compareValue, this, this);
    }
    return this;
  };
  Object.defineProperty(Mesh2.prototype, "geometry", {
    get: function() {
      return this._geometry;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.getTotalVertices = function() {
    if (this._geometry === null || this._geometry === void 0) {
      return 0;
    }
    return this._geometry.getTotalVertices();
  };
  Mesh2.prototype.getVerticesData = function(kind, copyWhenShared, forceCopy) {
    var _a2, _b2;
    if (!this._geometry) {
      return null;
    }
    var data = (_b2 = (_a2 = this._userInstancedBuffersStorage) === null || _a2 === void 0 ? void 0 : _a2.vertexBuffers[kind]) === null || _b2 === void 0 ? void 0 : _b2.getFloatData(this._geometry.getTotalVertices(), forceCopy || copyWhenShared && this._geometry.meshes.length !== 1);
    if (!data) {
      data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);
    }
    return data;
  };
  Mesh2.prototype.getVertexBuffer = function(kind) {
    var _a2, _b2;
    if (!this._geometry) {
      return null;
    }
    return (_b2 = (_a2 = this._userInstancedBuffersStorage) === null || _a2 === void 0 ? void 0 : _a2.vertexBuffers[kind]) !== null && _b2 !== void 0 ? _b2 : this._geometry.getVertexBuffer(kind);
  };
  Mesh2.prototype.isVerticesDataPresent = function(kind) {
    var _a2;
    if (!this._geometry) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return ((_a2 = this._userInstancedBuffersStorage) === null || _a2 === void 0 ? void 0 : _a2.vertexBuffers[kind]) !== void 0 || this._geometry.isVerticesDataPresent(kind);
  };
  Mesh2.prototype.isVertexBufferUpdatable = function(kind) {
    var _a2, _b2;
    if (!this._geometry) {
      if (this._delayInfo) {
        return this._delayInfo.indexOf(kind) !== -1;
      }
      return false;
    }
    return ((_b2 = (_a2 = this._userInstancedBuffersStorage) === null || _a2 === void 0 ? void 0 : _a2.vertexBuffers[kind]) === null || _b2 === void 0 ? void 0 : _b2.isUpdatable()) || this._geometry.isVertexBufferUpdatable(kind);
  };
  Mesh2.prototype.getVerticesDataKinds = function() {
    if (!this._geometry) {
      var result_1 = new Array();
      if (this._delayInfo) {
        this._delayInfo.forEach(function(kind2) {
          result_1.push(kind2);
        });
      }
      return result_1;
    }
    var kinds = this._geometry.getVerticesDataKinds();
    if (this._userInstancedBuffersStorage) {
      for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {
        kinds.push(kind);
      }
    }
    return kinds;
  };
  Mesh2.prototype.getTotalIndices = function() {
    if (!this._geometry) {
      return 0;
    }
    return this._geometry.getTotalIndices();
  };
  Mesh2.prototype.getIndices = function(copyWhenShared, forceCopy) {
    if (!this._geometry) {
      return [];
    }
    return this._geometry.getIndices(copyWhenShared, forceCopy);
  };
  Object.defineProperty(Mesh2.prototype, "isBlocked", {
    get: function() {
      return this._masterMesh !== null && this._masterMesh !== void 0;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.isReady = function(completeCheck, forceInstanceSupport) {
    var _a2, _b2, _c2, _d, _e, _f;
    if (completeCheck === void 0) {
      completeCheck = false;
    }
    if (forceInstanceSupport === void 0) {
      forceInstanceSupport = false;
    }
    if (this.delayLoadState === 2) {
      return false;
    }
    if (!_super.prototype.isReady.call(this, completeCheck)) {
      return false;
    }
    if (!this.subMeshes || this.subMeshes.length === 0) {
      return true;
    }
    if (!completeCheck) {
      return true;
    }
    var engine = this.getEngine();
    var scene = this.getScene();
    var hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
    this.computeWorldMatrix();
    var mat = this.material || scene.defaultMaterial;
    if (mat) {
      if (mat._storeEffectOnSubMeshes) {
        for (var _i = 0, _g = this.subMeshes; _i < _g.length; _i++) {
          var subMesh = _g[_i];
          var effectiveMaterial = subMesh.getMaterial();
          if (effectiveMaterial) {
            if (effectiveMaterial._storeEffectOnSubMeshes) {
              if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
                return false;
              }
            } else {
              if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {
                return false;
              }
            }
          }
        }
      } else {
        if (!mat.isReady(this, hardwareInstancedRendering)) {
          return false;
        }
      }
    }
    var currentRenderPassId = engine.currentRenderPassId;
    for (var _h = 0, _j = this.lightSources; _h < _j.length; _h++) {
      var light = _j[_h];
      var generator = light.getShadowGenerator();
      if (generator && (!((_a2 = generator.getShadowMap()) === null || _a2 === void 0 ? void 0 : _a2.renderList) || ((_b2 = generator.getShadowMap()) === null || _b2 === void 0 ? void 0 : _b2.renderList) && ((_d = (_c2 = generator.getShadowMap()) === null || _c2 === void 0 ? void 0 : _c2.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {
        if (generator.getShadowMap()) {
          engine.currentRenderPassId = generator.getShadowMap().renderPassId;
        }
        for (var _k = 0, _l = this.subMeshes; _k < _l.length; _k++) {
          var subMesh = _l[_k];
          if (!generator.isReady(subMesh, hardwareInstancedRendering, (_f = (_e = subMesh.getMaterial()) === null || _e === void 0 ? void 0 : _e.needAlphaBlendingForMesh(this)) !== null && _f !== void 0 ? _f : false)) {
            engine.currentRenderPassId = currentRenderPassId;
            return false;
          }
        }
        engine.currentRenderPassId = currentRenderPassId;
      }
    }
    for (var _m = 0, _o = this._internalMeshDataInfo._LODLevels; _m < _o.length; _m++) {
      var lod = _o[_m];
      if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {
        return false;
      }
    }
    return true;
  };
  Object.defineProperty(Mesh2.prototype, "areNormalsFrozen", {
    get: function() {
      return this._internalMeshDataInfo._areNormalsFrozen;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype.freezeNormals = function() {
    this._internalMeshDataInfo._areNormalsFrozen = true;
    return this;
  };
  Mesh2.prototype.unfreezeNormals = function() {
    this._internalMeshDataInfo._areNormalsFrozen = false;
    return this;
  };
  Object.defineProperty(Mesh2.prototype, "overridenInstanceCount", {
    set: function(count) {
      this._instanceDataStorage.overridenInstanceCount = count;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._preActivate = function() {
    var internalDataInfo = this._internalMeshDataInfo;
    var sceneRenderId = this.getScene().getRenderId();
    if (internalDataInfo._preActivateId === sceneRenderId) {
      return this;
    }
    internalDataInfo._preActivateId = sceneRenderId;
    this._instanceDataStorage.visibleInstances = null;
    return this;
  };
  Mesh2.prototype._preActivateForIntermediateRendering = function(renderId) {
    if (this._instanceDataStorage.visibleInstances) {
      this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;
    }
    return this;
  };
  Mesh2.prototype._registerInstanceForRenderId = function(instance, renderId) {
    if (!this._instanceDataStorage.visibleInstances) {
      this._instanceDataStorage.visibleInstances = {
        defaultRenderId: renderId,
        selfDefaultRenderId: this._renderId
      };
    }
    if (!this._instanceDataStorage.visibleInstances[renderId]) {
      if (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen) {
        this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;
      }
      this._instanceDataStorage.previousRenderId = renderId;
      this._instanceDataStorage.visibleInstances[renderId] = new Array();
    }
    this._instanceDataStorage.visibleInstances[renderId].push(instance);
    return this;
  };
  Mesh2.prototype._afterComputeWorldMatrix = function() {
    _super.prototype._afterComputeWorldMatrix.call(this);
    if (!this.hasThinInstances) {
      return;
    }
    if (!this.doNotSyncBoundingInfo) {
      this.thinInstanceRefreshBoundingInfo(false);
    }
  };
  Mesh2.prototype._postActivate = function() {
    if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {
      this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);
      this.edgesRenderer.customInstances.push(this.getWorldMatrix());
    }
  };
  Mesh2.prototype.refreshBoundingInfo = function(applySkeleton, applyMorph) {
    if (applySkeleton === void 0) {
      applySkeleton = false;
    }
    if (applyMorph === void 0) {
      applyMorph = false;
    }
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
      return this;
    }
    var bias = this.geometry ? this.geometry.boundingBias : null;
    this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);
    return this;
  };
  Mesh2.prototype._createGlobalSubMesh = function(force) {
    var totalVertices = this.getTotalVertices();
    if (!totalVertices || !this.getIndices()) {
      return null;
    }
    if (this.subMeshes && this.subMeshes.length > 0) {
      var ib = this.getIndices();
      if (!ib) {
        return null;
      }
      var totalIndices = ib.length;
      var needToRecreate = false;
      if (force) {
        needToRecreate = true;
      } else {
        for (var _i = 0, _a2 = this.subMeshes; _i < _a2.length; _i++) {
          var submesh = _a2[_i];
          if (submesh.indexStart + submesh.indexCount > totalIndices) {
            needToRecreate = true;
            break;
          }
          if (submesh.verticesStart + submesh.verticesCount > totalVertices) {
            needToRecreate = true;
            break;
          }
        }
      }
      if (!needToRecreate) {
        return this.subMeshes[0];
      }
    }
    this.releaseSubMeshes();
    return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);
  };
  Mesh2.prototype.subdivide = function(count) {
    if (count < 1) {
      return;
    }
    var totalIndices = this.getTotalIndices();
    var subdivisionSize = totalIndices / count | 0;
    var offset = 0;
    while (subdivisionSize % 3 !== 0) {
      subdivisionSize++;
    }
    this.releaseSubMeshes();
    for (var index = 0; index < count; index++) {
      if (offset >= totalIndices) {
        break;
      }
      SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this);
      offset += subdivisionSize;
    }
    this.synchronizeInstances();
  };
  Mesh2.prototype.setVerticesData = function(kind, data, updatable, stride) {
    if (updatable === void 0) {
      updatable = false;
    }
    if (!this._geometry) {
      var vertexData = new VertexData();
      vertexData.set(data, kind);
      var scene = this.getScene();
      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
    } else {
      this._geometry.setVerticesData(kind, data, updatable, stride);
    }
    return this;
  };
  Mesh2.prototype.removeVerticesData = function(kind) {
    if (!this._geometry) {
      return;
    }
    this._geometry.removeVerticesData(kind);
  };
  Mesh2.prototype.markVerticesDataAsUpdatable = function(kind, updatable) {
    if (updatable === void 0) {
      updatable = true;
    }
    var vb = this.getVertexBuffer(kind);
    if (!vb || vb.isUpdatable() === updatable) {
      return;
    }
    this.setVerticesData(kind, this.getVerticesData(kind), updatable);
  };
  Mesh2.prototype.setVerticesBuffer = function(buffer, disposeExistingBuffer) {
    if (disposeExistingBuffer === void 0) {
      disposeExistingBuffer = true;
    }
    if (!this._geometry) {
      this._geometry = Geometry.CreateGeometryForMesh(this);
    }
    this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);
    return this;
  };
  Mesh2.prototype.updateVerticesData = function(kind, data, updateExtends, makeItUnique) {
    if (!this._geometry) {
      return this;
    }
    if (!makeItUnique) {
      this._geometry.updateVerticesData(kind, data, updateExtends);
    } else {
      this.makeGeometryUnique();
      this.updateVerticesData(kind, data, updateExtends, false);
    }
    return this;
  };
  Mesh2.prototype.updateMeshPositions = function(positionFunction, computeNormals) {
    if (computeNormals === void 0) {
      computeNormals = true;
    }
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions) {
      return this;
    }
    positionFunction(positions);
    this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
    if (computeNormals) {
      var indices = this.getIndices();
      var normals = this.getVerticesData(VertexBuffer.NormalKind);
      if (!normals) {
        return this;
      }
      VertexData.ComputeNormals(positions, indices, normals);
      this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
    }
    return this;
  };
  Mesh2.prototype.makeGeometryUnique = function() {
    if (!this._geometry) {
      return this;
    }
    if (this._geometry.meshes.length === 1) {
      return this;
    }
    var oldGeometry = this._geometry;
    var geometry = this._geometry.copy(Geometry.RandomId());
    oldGeometry.releaseForMesh(this, true);
    geometry.applyToMesh(this);
    return this;
  };
  Mesh2.prototype.setIndices = function(indices, totalVertices, updatable) {
    if (totalVertices === void 0) {
      totalVertices = null;
    }
    if (updatable === void 0) {
      updatable = false;
    }
    if (!this._geometry) {
      var vertexData = new VertexData();
      vertexData.indices = indices;
      var scene = this.getScene();
      new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
    } else {
      this._geometry.setIndices(indices, totalVertices, updatable);
    }
    return this;
  };
  Mesh2.prototype.updateIndices = function(indices, offset, gpuMemoryOnly) {
    if (gpuMemoryOnly === void 0) {
      gpuMemoryOnly = false;
    }
    if (!this._geometry) {
      return this;
    }
    this._geometry.updateIndices(indices, offset, gpuMemoryOnly);
    return this;
  };
  Mesh2.prototype.toLeftHanded = function() {
    if (!this._geometry) {
      return this;
    }
    this._geometry.toLeftHanded();
    return this;
  };
  Mesh2.prototype._bind = function(subMesh, effect, fillMode) {
    if (!this._geometry) {
      return this;
    }
    var engine = this.getScene().getEngine();
    if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {
      this.morphTargetManager._bind(effect);
    }
    var indexToBind;
    if (this._unIndexed) {
      indexToBind = null;
    } else {
      switch (fillMode) {
        case Material.PointFillMode:
          indexToBind = null;
          break;
        case Material.WireFrameFillMode:
          indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);
          break;
        default:
        case Material.TriangleFillMode:
          indexToBind = this._geometry.getIndexBuffer();
          break;
      }
    }
    if (!this._userInstancedBuffersStorage || this.hasThinInstances) {
      this._geometry._bind(effect, indexToBind);
    } else {
      this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
    }
    return this;
  };
  Mesh2.prototype._draw = function(subMesh, fillMode, instancesCount) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    if (this._internalMeshDataInfo._onBeforeDrawObservable) {
      this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
    }
    var scene = this.getScene();
    var engine = scene.getEngine();
    if (this._unIndexed || fillMode == Material.PointFillMode) {
      engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);
    } else if (fillMode == Material.WireFrameFillMode) {
      engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);
    } else {
      engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);
    }
    return this;
  };
  Mesh2.prototype.registerBeforeRender = function(func) {
    this.onBeforeRenderObservable.add(func);
    return this;
  };
  Mesh2.prototype.unregisterBeforeRender = function(func) {
    this.onBeforeRenderObservable.removeCallback(func);
    return this;
  };
  Mesh2.prototype.registerAfterRender = function(func) {
    this.onAfterRenderObservable.add(func);
    return this;
  };
  Mesh2.prototype.unregisterAfterRender = function(func) {
    this.onAfterRenderObservable.removeCallback(func);
    return this;
  };
  Mesh2.prototype._getInstancesRenderList = function(subMeshId, isReplacementMode) {
    if (isReplacementMode === void 0) {
      isReplacementMode = false;
    }
    if (this._instanceDataStorage.isFrozen) {
      if (isReplacementMode) {
        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;
        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;
        return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
      }
      if (this._instanceDataStorage.previousBatch) {
        return this._instanceDataStorage.previousBatch;
      }
    }
    var scene = this.getScene();
    var isInIntermediateRendering = scene._isInIntermediateRendering();
    var onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;
    var batchCache = this._instanceDataStorage.batchCache;
    batchCache.mustReturn = false;
    batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;
    batchCache.visibleInstances[subMeshId] = null;
    if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {
      var visibleInstances = this._instanceDataStorage.visibleInstances;
      var currentRenderId = scene.getRenderId();
      var defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;
      batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];
      if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {
        batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];
      }
    }
    batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== void 0;
    this._instanceDataStorage.previousBatch = batchCache;
    return batchCache;
  };
  Mesh2.prototype._renderWithInstances = function(subMesh, fillMode, batch, effect, engine) {
    var _a2;
    var visibleInstances = batch.visibleInstances[subMesh._id];
    if (!visibleInstances) {
      return this;
    }
    var instanceStorage = this._instanceDataStorage;
    var currentInstancesBufferSize = instanceStorage.instancesBufferSize;
    var instancesBuffer = instanceStorage.instancesBuffer;
    var instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;
    var matricesCount = visibleInstances.length + 1;
    var bufferSize = matricesCount * 16 * 4;
    while (instanceStorage.instancesBufferSize < bufferSize) {
      instanceStorage.instancesBufferSize *= 2;
    }
    if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
      instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);
    }
    if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
      instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);
    }
    var offset = 0;
    var instancesCount = 0;
    var renderSelf = batch.renderSelf[subMesh._id];
    var needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;
    if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {
      var world = this.getWorldMatrix();
      if (renderSelf) {
        if (this._scene.needsPreviousWorldMatrices) {
          if (!instanceStorage.masterMeshPreviousWorldMatrix) {
            instanceStorage.masterMeshPreviousWorldMatrix = world.clone();
            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
          } else {
            instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
            instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);
          }
        }
        world.copyToArray(instanceStorage.instancesData, offset);
        offset += 16;
        instancesCount++;
      }
      if (visibleInstances) {
        if (Mesh2.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a2 = subMesh.getMaterial()) === null || _a2 === void 0 ? void 0 : _a2.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {
          var cameraPosition = this._scene.activeCamera.globalPosition;
          for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
            var instanceMesh = visibleInstances[instanceIndex];
            instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
          }
          visibleInstances.sort(function(m1, m2) {
            return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;
          });
        }
        for (var instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
          var instance = visibleInstances[instanceIndex];
          var matrix = instance.getWorldMatrix();
          matrix.copyToArray(instanceStorage.instancesData, offset);
          if (this._scene.needsPreviousWorldMatrices) {
            if (!instance._previousWorldMatrix) {
              instance._previousWorldMatrix = matrix.clone();
              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
            } else {
              instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
              instance._previousWorldMatrix.copyFrom(matrix);
            }
          }
          offset += 16;
          instancesCount++;
        }
      }
    } else {
      instancesCount = (renderSelf ? 1 : 0) + visibleInstances.length;
    }
    if (needUpdateBuffer) {
      if (instancesBuffer) {
        instancesBuffer.dispose();
      }
      if (instancesPreviousBuffer) {
        instancesPreviousBuffer.dispose();
      }
      instancesBuffer = new Buffer2(engine, instanceStorage.instancesData, true, 16, false, true);
      instanceStorage.instancesBuffer = instancesBuffer;
      if (!this._userInstancedBuffersStorage) {
        this._userInstancedBuffersStorage = {
          data: {},
          vertexBuffers: {},
          strides: {},
          sizes: {},
          vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
        };
      }
      this._userInstancedBuffersStorage.vertexBuffers["world0"] = instancesBuffer.createVertexBuffer("world0", 0, 4);
      this._userInstancedBuffersStorage.vertexBuffers["world1"] = instancesBuffer.createVertexBuffer("world1", 4, 4);
      this._userInstancedBuffersStorage.vertexBuffers["world2"] = instancesBuffer.createVertexBuffer("world2", 8, 4);
      this._userInstancedBuffersStorage.vertexBuffers["world3"] = instancesBuffer.createVertexBuffer("world3", 12, 4);
      if (this._scene.needsPreviousWorldMatrices) {
        instancesPreviousBuffer = new Buffer2(engine, instanceStorage.instancesPreviousData, true, 16, false, true);
        instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld0"] = instancesPreviousBuffer.createVertexBuffer("previousWorld0", 0, 4);
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld1"] = instancesPreviousBuffer.createVertexBuffer("previousWorld1", 4, 4);
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld2"] = instancesPreviousBuffer.createVertexBuffer("previousWorld2", 8, 4);
        this._userInstancedBuffersStorage.vertexBuffers["previousWorld3"] = instancesPreviousBuffer.createVertexBuffer("previousWorld3", 12, 4);
      }
      this._invalidateInstanceVertexArrayObject();
    } else {
      if (!this._instanceDataStorage.isFrozen) {
        instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
        if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {
          instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);
        }
      }
    }
    this._processInstancedBuffers(visibleInstances, renderSelf);
    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
    if (engine._currentDrawContext) {
      engine._currentDrawContext.useInstancing = true;
    }
    this._bind(subMesh, effect, fillMode);
    this._draw(subMesh, fillMode, instancesCount);
    if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && !this._instanceDataStorage.isFrozen && !this._instanceDataStorage.previousManualUpdate) {
      instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
    }
    engine.unbindInstanceAttributes();
    return this;
  };
  Mesh2.prototype._renderWithThinInstances = function(subMesh, fillMode, effect, engine) {
    var _a2, _b2;
    var instancesCount = (_b2 = (_a2 = this._thinInstanceDataStorage) === null || _a2 === void 0 ? void 0 : _a2.instancesCount) !== null && _b2 !== void 0 ? _b2 : 0;
    this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
    if (engine._currentDrawContext) {
      engine._currentDrawContext.useInstancing = true;
    }
    this._bind(subMesh, effect, fillMode);
    this._draw(subMesh, fillMode, instancesCount);
    if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {
      if (!this._thinInstanceDataStorage.previousMatrixBuffer) {
        this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, false);
      } else {
        this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);
      }
    }
    engine.unbindInstanceAttributes();
  };
  Mesh2.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
  };
  Mesh2.prototype._processRendering = function(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {
    var scene = this.getScene();
    var engine = scene.getEngine();
    if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {
      this._renderWithThinInstances(subMesh, fillMode, effect, engine);
      return this;
    }
    if (hardwareInstancedRendering) {
      this._renderWithInstances(subMesh, fillMode, batch, effect, engine);
    } else {
      if (engine._currentDrawContext) {
        engine._currentDrawContext.useInstancing = false;
      }
      var instanceCount = 0;
      if (batch.renderSelf[subMesh._id]) {
        if (onBeforeDraw) {
          onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);
        }
        instanceCount++;
        this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);
      }
      var visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];
      if (visibleInstancesForSubMesh) {
        var visibleInstanceCount = visibleInstancesForSubMesh.length;
        instanceCount += visibleInstanceCount;
        for (var instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {
          var instance = visibleInstancesForSubMesh[instanceIndex];
          var world = instance.getWorldMatrix();
          if (onBeforeDraw) {
            onBeforeDraw(true, world, effectiveMaterial);
          }
          this._draw(subMesh, fillMode);
        }
      }
      scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);
    }
    return this;
  };
  Mesh2.prototype._rebuild = function(dispose) {
    if (dispose === void 0) {
      dispose = false;
    }
    if (this._instanceDataStorage.instancesBuffer) {
      if (dispose) {
        this._instanceDataStorage.instancesBuffer.dispose();
      }
      this._instanceDataStorage.instancesBuffer = null;
    }
    if (this._userInstancedBuffersStorage) {
      for (var kind in this._userInstancedBuffersStorage.vertexBuffers) {
        var buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];
        if (buffer) {
          if (dispose) {
            buffer.dispose();
          }
          this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
        }
      }
      if (this._userInstancedBuffersStorage.vertexArrayObjects) {
        this._userInstancedBuffersStorage.vertexArrayObjects = {};
      }
    }
    this._internalMeshDataInfo._effectiveMaterial = null;
    _super.prototype._rebuild.call(this, dispose);
  };
  Mesh2.prototype._freeze = function() {
    if (!this.subMeshes) {
      return;
    }
    for (var index = 0; index < this.subMeshes.length; index++) {
      this._getInstancesRenderList(index);
    }
    this._internalMeshDataInfo._effectiveMaterial = null;
    this._instanceDataStorage.isFrozen = true;
  };
  Mesh2.prototype._unFreeze = function() {
    this._instanceDataStorage.isFrozen = false;
    this._instanceDataStorage.previousBatch = null;
  };
  Mesh2.prototype.render = function(subMesh, enableAlphaMode, effectiveMeshReplacement) {
    var _a2, _b2, _c2;
    var scene = this.getScene();
    if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {
      this._internalAbstractMeshDataInfo._isActiveIntermediate = false;
    } else {
      this._internalAbstractMeshDataInfo._isActive = false;
    }
    if (this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {
      return this;
    }
    var batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);
    if (batch.mustReturn) {
      return this;
    }
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
      return this;
    }
    var engine = scene.getEngine();
    var oldCameraMaxZ = 0;
    var oldCamera = null;
    if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {
      oldCameraMaxZ = scene.activeCamera.maxZ;
      oldCamera = scene.activeCamera;
      scene.activeCamera.maxZ = 0;
      scene.updateTransformMatrix(true);
    }
    if (this._internalMeshDataInfo._onBeforeRenderObservable) {
      this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
    }
    var hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || subMesh.getRenderingMesh().hasThinInstances;
    var instanceDataStorage = this._instanceDataStorage;
    var material = subMesh.getMaterial();
    if (!material) {
      if (oldCamera) {
        oldCamera.maxZ = oldCameraMaxZ;
        scene.updateTransformMatrix(true);
      }
      return this;
    }
    if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {
      if (material._storeEffectOnSubMeshes) {
        if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
      } else if (!material.isReady(this, hardwareInstancedRendering)) {
        if (oldCamera) {
          oldCamera.maxZ = oldCameraMaxZ;
          scene.updateTransformMatrix(true);
        }
        return this;
      }
      this._internalMeshDataInfo._effectiveMaterial = material;
    } else if (material._storeEffectOnSubMeshes && !((_a2 = subMesh.effect) === null || _a2 === void 0 ? void 0 : _a2._wasPreviouslyReady) || !material._storeEffectOnSubMeshes && !((_b2 = material.getEffect()) === null || _b2 === void 0 ? void 0 : _b2._wasPreviouslyReady)) {
      if (oldCamera) {
        oldCamera.maxZ = oldCameraMaxZ;
        scene.updateTransformMatrix(true);
      }
      return this;
    }
    if (enableAlphaMode) {
      engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);
    }
    var drawWrapper;
    if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {
      drawWrapper = subMesh._drawWrapper;
    } else {
      drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
    }
    var effect = (_c2 = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _c2 !== void 0 ? _c2 : null;
    for (var _i = 0, _d = scene._beforeRenderingMeshStage; _i < _d.length; _i++) {
      var step = _d[_i];
      step.action(this, subMesh, batch, effect);
    }
    if (!drawWrapper || !effect) {
      if (oldCamera) {
        oldCamera.maxZ = oldCameraMaxZ;
        scene.updateTransformMatrix(true);
      }
      return this;
    }
    var effectiveMesh = effectiveMeshReplacement || this;
    var sideOrientation;
    if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {
      var mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
      sideOrientation = this.overrideMaterialSideOrientation;
      if (sideOrientation == null) {
        sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;
      }
      if (mainDeterminant < 0) {
        sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
      }
      instanceDataStorage.sideOrientation = sideOrientation;
    } else {
      sideOrientation = instanceDataStorage.sideOrientation;
    }
    var reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);
    if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {
      engine.setDepthWrite(true);
    }
    var fillMode = scene.forcePointsCloud ? Material.PointFillMode : scene.forceWireframe ? Material.WireFrameFillMode : this._internalMeshDataInfo._effectiveMaterial.fillMode;
    if (this._internalMeshDataInfo._onBeforeBindObservable) {
      this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);
    }
    if (!hardwareInstancedRendering) {
      this._bind(subMesh, effect, fillMode);
    }
    var effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;
    var world = effectiveMesh.getWorldMatrix();
    if (effectiveMaterial._storeEffectOnSubMeshes) {
      effectiveMaterial.bindForSubMesh(world, this, subMesh);
    } else {
      effectiveMaterial.bind(world, this);
    }
    if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {
      engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
      this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
      engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
      if (this._internalMeshDataInfo._onBetweenPassObservable) {
        this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);
      }
    }
    this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
    this._internalMeshDataInfo._effectiveMaterial.unbind();
    for (var _e = 0, _f = scene._afterRenderingMeshStage; _e < _f.length; _e++) {
      var step = _f[_e];
      step.action(this, subMesh, batch, effect);
    }
    if (this._internalMeshDataInfo._onAfterRenderObservable) {
      this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);
    }
    if (oldCamera) {
      oldCamera.maxZ = oldCameraMaxZ;
      scene.updateTransformMatrix(true);
    }
    return this;
  };
  Mesh2.prototype.cleanMatrixWeights = function() {
    if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
        this._normalizeSkinWeightsAndExtra();
      } else {
        this._normalizeSkinFourWeights();
      }
    }
  };
  Mesh2.prototype._normalizeSkinFourWeights = function() {
    var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    var numWeights = matricesWeights.length;
    for (var a = 0; a < numWeights; a += 4) {
      var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
      if (t === 0) {
        matricesWeights[a] = 1;
      } else {
        var recip = 1 / t;
        matricesWeights[a] *= recip;
        matricesWeights[a + 1] *= recip;
        matricesWeights[a + 2] *= recip;
        matricesWeights[a + 3] *= recip;
      }
    }
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
  };
  Mesh2.prototype._normalizeSkinWeightsAndExtra = function() {
    var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
    var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    var numWeights = matricesWeights.length;
    for (var a = 0; a < numWeights; a += 4) {
      var t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
      t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];
      if (t === 0) {
        matricesWeights[a] = 1;
      } else {
        var recip = 1 / t;
        matricesWeights[a] *= recip;
        matricesWeights[a + 1] *= recip;
        matricesWeights[a + 2] *= recip;
        matricesWeights[a + 3] *= recip;
        matricesWeightsExtra[a] *= recip;
        matricesWeightsExtra[a + 1] *= recip;
        matricesWeightsExtra[a + 2] *= recip;
        matricesWeightsExtra[a + 3] *= recip;
      }
    }
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
    this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);
  };
  Mesh2.prototype.validateSkinning = function() {
    var matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
    var matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    if (matricesWeights === null || this.skeleton == null) {
      return { skinned: false, valid: true, report: "not skinned" };
    }
    var numWeights = matricesWeights.length;
    var numberNotSorted = 0;
    var missingWeights = 0;
    var maxUsedWeights = 0;
    var numberNotNormalized = 0;
    var numInfluences = matricesWeightsExtra === null ? 4 : 8;
    var usedWeightCounts = new Array();
    for (var a = 0; a <= numInfluences; a++) {
      usedWeightCounts[a] = 0;
    }
    var toleranceEpsilon = 1e-3;
    for (var a = 0; a < numWeights; a += 4) {
      var lastWeight = matricesWeights[a];
      var t = lastWeight;
      var usedWeights = t === 0 ? 0 : 1;
      for (var b = 1; b < numInfluences; b++) {
        var d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];
        if (d > lastWeight) {
          numberNotSorted++;
        }
        if (d !== 0) {
          usedWeights++;
        }
        t += d;
        lastWeight = d;
      }
      usedWeightCounts[usedWeights]++;
      if (usedWeights > maxUsedWeights) {
        maxUsedWeights = usedWeights;
      }
      if (t === 0) {
        missingWeights++;
      } else {
        var recip = 1 / t;
        var tolerance = 0;
        for (var b = 0; b < numInfluences; b++) {
          if (b < 4) {
            tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);
          } else {
            tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);
          }
        }
        if (tolerance > toleranceEpsilon) {
          numberNotNormalized++;
        }
      }
    }
    var numBones = this.skeleton.bones.length;
    var matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
    var numBadBoneIndices = 0;
    for (var a = 0; a < numWeights; a += 4) {
      for (var b = 0; b < numInfluences; b++) {
        var index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];
        if (index >= numBones || index < 0) {
          numBadBoneIndices++;
        }
      }
    }
    var output = "Number of Weights = " + numWeights / 4 + "\nMaximum influences = " + maxUsedWeights + "\nMissing Weights = " + missingWeights + "\nNot Sorted = " + numberNotSorted + "\nNot Normalized = " + numberNotNormalized + "\nWeightCounts = [" + usedWeightCounts + "]\nNumber of bones = " + numBones + "\nBad Bone Indices = " + numBadBoneIndices;
    return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };
  };
  Mesh2.prototype._checkDelayState = function() {
    var scene = this.getScene();
    if (this._geometry) {
      this._geometry.load(scene);
    } else if (this.delayLoadState === 4) {
      this.delayLoadState = 2;
      this._queueLoad(scene);
    }
    return this;
  };
  Mesh2.prototype._queueLoad = function(scene) {
    var _this = this;
    scene._addPendingData(this);
    var getBinaryData = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
    Tools.LoadFile(this.delayLoadingFile, function(data) {
      if (data instanceof ArrayBuffer) {
        _this._delayLoadingFunction(data, _this);
      } else {
        _this._delayLoadingFunction(JSON.parse(data), _this);
      }
      _this.instances.forEach(function(instance) {
        instance.refreshBoundingInfo();
        instance._syncSubMeshes();
      });
      _this.delayLoadState = 1;
      scene._removePendingData(_this);
    }, function() {
    }, scene.offlineProvider, getBinaryData);
    return this;
  };
  Mesh2.prototype.isInFrustum = function(frustumPlanes) {
    if (this.delayLoadState === 2) {
      return false;
    }
    if (!_super.prototype.isInFrustum.call(this, frustumPlanes)) {
      return false;
    }
    this._checkDelayState();
    return true;
  };
  Mesh2.prototype.setMaterialById = function(id) {
    var materials = this.getScene().materials;
    var index;
    for (index = materials.length - 1; index > -1; index--) {
      if (materials[index].id === id) {
        this.material = materials[index];
        return this;
      }
    }
    var multiMaterials = this.getScene().multiMaterials;
    for (index = multiMaterials.length - 1; index > -1; index--) {
      if (multiMaterials[index].id === id) {
        this.material = multiMaterials[index];
        return this;
      }
    }
    return this;
  };
  Mesh2.prototype.getAnimatables = function() {
    var results = new Array();
    if (this.material) {
      results.push(this.material);
    }
    if (this.skeleton) {
      results.push(this.skeleton);
    }
    return results;
  };
  Mesh2.prototype.bakeTransformIntoVertices = function(transform2) {
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      return this;
    }
    var submeshes = this.subMeshes.splice(0);
    this._resetPointsArrayCache();
    var data = this.getVerticesData(VertexBuffer.PositionKind);
    var temp = new Array();
    var index;
    for (index = 0; index < data.length; index += 3) {
      Vector3.TransformCoordinates(Vector3.FromArray(data, index), transform2).toArray(temp, index);
    }
    this.setVerticesData(VertexBuffer.PositionKind, temp, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());
    if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
      data = this.getVerticesData(VertexBuffer.NormalKind);
      temp = [];
      for (index = 0; index < data.length; index += 3) {
        Vector3.TransformNormal(Vector3.FromArray(data, index), transform2).normalize().toArray(temp, index);
      }
      this.setVerticesData(VertexBuffer.NormalKind, temp, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());
    }
    if (transform2.determinant() < 0) {
      this.flipFaces();
    }
    this.releaseSubMeshes();
    this.subMeshes = submeshes;
    return this;
  };
  Mesh2.prototype.bakeCurrentTransformIntoVertices = function(bakeIndependenlyOfChildren) {
    if (bakeIndependenlyOfChildren === void 0) {
      bakeIndependenlyOfChildren = true;
    }
    this.bakeTransformIntoVertices(this.computeWorldMatrix(true));
    this.resetLocalMatrix(bakeIndependenlyOfChildren);
    return this;
  };
  Object.defineProperty(Mesh2.prototype, "_positions", {
    get: function() {
      if (this._internalAbstractMeshDataInfo._positions) {
        return this._internalAbstractMeshDataInfo._positions;
      }
      if (this._geometry) {
        return this._geometry._positions;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Mesh2.prototype._resetPointsArrayCache = function() {
    if (this._geometry) {
      this._geometry._resetPointsArrayCache();
    }
    return this;
  };
  Mesh2.prototype._generatePointsArray = function() {
    if (this._geometry) {
      return this._geometry._generatePointsArray();
    }
    return false;
  };
  Mesh2.prototype.clone = function(name2, newParent, doNotCloneChildren, clonePhysicsImpostor) {
    if (name2 === void 0) {
      name2 = "";
    }
    if (newParent === void 0) {
      newParent = null;
    }
    if (clonePhysicsImpostor === void 0) {
      clonePhysicsImpostor = true;
    }
    return new Mesh2(name2, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);
  };
  Mesh2.prototype.dispose = function(doNotRecurse, disposeMaterialAndTextures) {
    if (disposeMaterialAndTextures === void 0) {
      disposeMaterialAndTextures = false;
    }
    this.morphTargetManager = null;
    if (this._geometry) {
      this._geometry.releaseForMesh(this, true);
    }
    var internalDataInfo = this._internalMeshDataInfo;
    if (internalDataInfo._onBeforeDrawObservable) {
      internalDataInfo._onBeforeDrawObservable.clear();
    }
    if (internalDataInfo._onBeforeBindObservable) {
      internalDataInfo._onBeforeBindObservable.clear();
    }
    if (internalDataInfo._onBeforeRenderObservable) {
      internalDataInfo._onBeforeRenderObservable.clear();
    }
    if (internalDataInfo._onAfterRenderObservable) {
      internalDataInfo._onAfterRenderObservable.clear();
    }
    if (internalDataInfo._onBetweenPassObservable) {
      internalDataInfo._onBetweenPassObservable.clear();
    }
    if (this._scene.useClonedMeshMap) {
      if (internalDataInfo.meshMap) {
        for (var uniqueId in internalDataInfo.meshMap) {
          var mesh = internalDataInfo.meshMap[uniqueId];
          if (mesh) {
            mesh._internalMeshDataInfo._source = null;
            internalDataInfo.meshMap[uniqueId] = void 0;
          }
        }
      }
      if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {
        internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0;
      }
    } else {
      var meshes = this.getScene().meshes;
      for (var _i = 0, meshes_1 = meshes; _i < meshes_1.length; _i++) {
        var abstractMesh = meshes_1[_i];
        var mesh = abstractMesh;
        if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {
          mesh._internalMeshDataInfo._source = null;
        }
      }
    }
    internalDataInfo._source = null;
    this._disposeInstanceSpecificData();
    this._disposeThinInstanceSpecificData();
    if (this._internalMeshDataInfo._checkReadinessObserver) {
      this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);
    }
    _super.prototype.dispose.call(this, doNotRecurse, disposeMaterialAndTextures);
  };
  Mesh2.prototype._disposeInstanceSpecificData = function() {
  };
  Mesh2.prototype._disposeThinInstanceSpecificData = function() {
  };
  Mesh2.prototype._invalidateInstanceVertexArrayObject = function() {
  };
  Mesh2.prototype.applyDisplacementMap = function(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate) {
    var _this = this;
    if (forceUpdate === void 0) {
      forceUpdate = false;
    }
    var scene = this.getScene();
    var onload = function(img) {
      var heightMapWidth = img.width;
      var heightMapHeight = img.height;
      var canvas = _this.getEngine().createCanvas(heightMapWidth, heightMapHeight);
      var context = canvas.getContext("2d");
      context.drawImage(img, 0, 0);
      var buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;
      _this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);
      if (onSuccess) {
        onSuccess(_this);
      }
    };
    Tools.LoadImage(url, onload, function() {
    }, scene.offlineProvider);
    return this;
  };
  Mesh2.prototype.applyDisplacementMapFromBuffer = function(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate) {
    if (forceUpdate === void 0) {
      forceUpdate = false;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {
      Logger.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing");
      return this;
    }
    var positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);
    var normals = this.getVerticesData(VertexBuffer.NormalKind);
    var uvs = this.getVerticesData(VertexBuffer.UVKind);
    var position = Vector3.Zero();
    var normal = Vector3.Zero();
    var uv = Vector2.Zero();
    uvOffset = uvOffset || Vector2.Zero();
    uvScale = uvScale || new Vector2(1, 1);
    for (var index = 0; index < positions.length; index += 3) {
      Vector3.FromArrayToRef(positions, index, position);
      Vector3.FromArrayToRef(normals, index, normal);
      Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);
      var u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;
      var v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;
      var pos = (u + v * heightMapWidth) * 4;
      var r = buffer[pos] / 255;
      var g = buffer[pos + 1] / 255;
      var b = buffer[pos + 2] / 255;
      var gradient = r * 0.3 + g * 0.59 + b * 0.11;
      normal.normalize();
      normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);
      position = position.add(normal);
      position.toArray(positions, index);
    }
    VertexData.ComputeNormals(positions, this.getIndices(), normals);
    if (forceUpdate) {
      this.setVerticesData(VertexBuffer.PositionKind, positions);
      this.setVerticesData(VertexBuffer.NormalKind, normals);
      this.setVerticesData(VertexBuffer.UVKind, uvs);
    } else {
      this.updateVerticesData(VertexBuffer.PositionKind, positions);
      this.updateVerticesData(VertexBuffer.NormalKind, normals);
    }
    return this;
  };
  Mesh2.prototype.convertToFlatShadedMesh = function() {
    var kinds = this.getVerticesDataKinds();
    var vbs = {};
    var data = {};
    var newdata = {};
    var updatableNormals = false;
    var kindIndex;
    var kind;
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      var vertexBuffer = this.getVertexBuffer(kind);
      var vertexData = vertexBuffer.getData();
      if (vertexData instanceof Array || vertexData instanceof Float32Array) {
        if (vertexData.length === 0) {
          continue;
        }
      }
      if (kind === VertexBuffer.NormalKind) {
        updatableNormals = vertexBuffer.isUpdatable();
        kinds.splice(kindIndex, 1);
        kindIndex--;
        continue;
      }
      vbs[kind] = vertexBuffer;
      data[kind] = this.getVerticesData(kind);
      newdata[kind] = [];
    }
    var previousSubmeshes = this.subMeshes.slice(0);
    var indices = this.getIndices();
    var totalIndices = this.getTotalIndices();
    var index;
    for (index = 0; index < totalIndices; index++) {
      var vertexIndex = indices[index];
      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
        kind = kinds[kindIndex];
        if (!vbs[kind]) {
          continue;
        }
        var stride = vbs[kind].getStrideSize();
        for (var offset = 0; offset < stride; offset++) {
          newdata[kind].push(data[kind][vertexIndex * stride + offset]);
        }
      }
    }
    var normals = [];
    var positions = newdata[VertexBuffer.PositionKind];
    var useRightHandedSystem = this.getScene().useRightHandedSystem;
    var flipNormalGeneration;
    if (useRightHandedSystem) {
      flipNormalGeneration = this.overrideMaterialSideOrientation === 1;
    } else {
      flipNormalGeneration = this.overrideMaterialSideOrientation === 0;
    }
    for (index = 0; index < totalIndices; index += 3) {
      indices[index] = index;
      indices[index + 1] = index + 1;
      indices[index + 2] = index + 2;
      var p1 = Vector3.FromArray(positions, index * 3);
      var p2 = Vector3.FromArray(positions, (index + 1) * 3);
      var p3 = Vector3.FromArray(positions, (index + 2) * 3);
      var p1p2 = p1.subtract(p2);
      var p3p2 = p3.subtract(p2);
      var normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));
      if (flipNormalGeneration) {
        normal.scaleInPlace(-1);
      }
      for (var localIndex = 0; localIndex < 3; localIndex++) {
        normals.push(normal.x);
        normals.push(normal.y);
        normals.push(normal.z);
      }
    }
    this.setIndices(indices);
    this.setVerticesData(VertexBuffer.NormalKind, normals, updatableNormals);
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      if (!newdata[kind]) {
        continue;
      }
      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());
    }
    this.releaseSubMeshes();
    for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
      var previousOne = previousSubmeshes[submeshIndex];
      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
    }
    this.synchronizeInstances();
    return this;
  };
  Mesh2.prototype.convertToUnIndexedMesh = function() {
    var kinds = this.getVerticesDataKinds();
    var vbs = {};
    var data = {};
    var newdata = {};
    var kindIndex;
    var kind;
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      var vertexBuffer = this.getVertexBuffer(kind);
      vbs[kind] = vertexBuffer;
      data[kind] = vbs[kind].getData();
      newdata[kind] = [];
    }
    var previousSubmeshes = this.subMeshes.slice(0);
    var indices = this.getIndices();
    var totalIndices = this.getTotalIndices();
    var index;
    for (index = 0; index < totalIndices; index++) {
      var vertexIndex = indices[index];
      for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
        kind = kinds[kindIndex];
        var stride = vbs[kind].getStrideSize();
        for (var offset = 0; offset < stride; offset++) {
          newdata[kind].push(data[kind][vertexIndex * stride + offset]);
        }
      }
    }
    for (index = 0; index < totalIndices; index += 3) {
      indices[index] = index;
      indices[index + 1] = index + 1;
      indices[index + 2] = index + 2;
    }
    this.setIndices(indices);
    for (kindIndex = 0; kindIndex < kinds.length; kindIndex++) {
      kind = kinds[kindIndex];
      this.setVerticesData(kind, newdata[kind], vbs[kind].isUpdatable());
    }
    this.releaseSubMeshes();
    for (var submeshIndex = 0; submeshIndex < previousSubmeshes.length; submeshIndex++) {
      var previousOne = previousSubmeshes[submeshIndex];
      SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
    }
    this._unIndexed = true;
    this.synchronizeInstances();
    return this;
  };
  Mesh2.prototype.flipFaces = function(flipNormals) {
    if (flipNormals === void 0) {
      flipNormals = false;
    }
    var vertex_data = VertexData.ExtractFromMesh(this);
    var i;
    if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {
      for (i = 0; i < vertex_data.normals.length; i++) {
        vertex_data.normals[i] *= -1;
      }
    }
    if (vertex_data.indices) {
      var temp = void 0;
      for (i = 0; i < vertex_data.indices.length; i += 3) {
        temp = vertex_data.indices[i + 1];
        vertex_data.indices[i + 1] = vertex_data.indices[i + 2];
        vertex_data.indices[i + 2] = temp;
      }
    }
    vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    return this;
  };
  Mesh2.prototype.increaseVertices = function(numberPerEdge) {
    if (numberPerEdge === void 0) {
      numberPerEdge = 1;
    }
    var vertex_data = VertexData.ExtractFromMesh(this);
    var currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;
    var positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;
    var uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;
    var normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;
    if (!currentIndices || !positions) {
      Logger.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");
    } else {
      vertex_data.indices = currentIndices;
      vertex_data.positions = positions;
      if (uvs) {
        vertex_data.uvs = uvs;
      }
      if (normals) {
        vertex_data.normals = normals;
      }
      var segments = numberPerEdge + 1;
      var tempIndices = new Array();
      for (var i = 0; i < segments + 1; i++) {
        tempIndices[i] = new Array();
      }
      var a = void 0;
      var b = void 0;
      var deltaPosition = new Vector3(0, 0, 0);
      var deltaNormal = new Vector3(0, 0, 0);
      var deltaUV = new Vector2(0, 0);
      var indices = new Array();
      var vertexIndex = new Array();
      var side = new Array();
      var len = void 0;
      var positionPtr = positions.length;
      var uvPtr = void 0;
      if (uvs) {
        uvPtr = uvs.length;
      }
      var normalsPtr = void 0;
      if (normals) {
        normalsPtr = normals.length;
      }
      for (var i = 0; i < currentIndices.length; i += 3) {
        vertexIndex[0] = currentIndices[i];
        vertexIndex[1] = currentIndices[i + 1];
        vertexIndex[2] = currentIndices[i + 2];
        for (var j = 0; j < 3; j++) {
          a = vertexIndex[j];
          b = vertexIndex[(j + 1) % 3];
          if (side[a] === void 0 && side[b] === void 0) {
            side[a] = new Array();
            side[b] = new Array();
          } else {
            if (side[a] === void 0) {
              side[a] = new Array();
            }
            if (side[b] === void 0) {
              side[b] = new Array();
            }
          }
          if (side[a][b] === void 0 && side[b][a] === void 0) {
            side[a][b] = [];
            deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;
            deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;
            deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;
            if (normals) {
              deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;
              deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;
              deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;
            }
            if (uvs) {
              deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;
              deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;
            }
            side[a][b].push(a);
            for (var k = 1; k < segments; k++) {
              side[a][b].push(positions.length / 3);
              positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;
              positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;
              positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;
              if (normals) {
                normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;
                normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;
                normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;
              }
              if (uvs) {
                uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;
                uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;
              }
            }
            side[a][b].push(b);
            side[b][a] = new Array();
            len = side[a][b].length;
            for (var idx = 0; idx < len; idx++) {
              side[b][a][idx] = side[a][b][len - 1 - idx];
            }
          }
        }
        tempIndices[0][0] = currentIndices[i];
        tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];
        tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];
        for (var k = 2; k < segments; k++) {
          tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];
          tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];
          deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;
          deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;
          deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;
          if (normals) {
            deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;
            deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;
            deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;
          }
          if (uvs) {
            deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;
            deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;
          }
          for (var j = 1; j < k; j++) {
            tempIndices[k][j] = positions.length / 3;
            positions[positionPtr++] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;
            positions[positionPtr++] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;
            positions[positionPtr++] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;
            if (normals) {
              normals[normalsPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;
              normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;
              normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;
            }
            if (uvs) {
              uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;
              uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;
            }
          }
        }
        tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];
        indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);
        for (var k = 1; k < segments; k++) {
          var j = void 0;
          for (j = 0; j < k; j++) {
            indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
            indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);
          }
          indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
        }
      }
      vertex_data.indices = indices;
      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    }
  };
  Mesh2.prototype.forceSharedVertices = function() {
    var vertex_data = VertexData.ExtractFromMesh(this);
    var currentUVs = vertex_data.uvs;
    var currentIndices = vertex_data.indices;
    var currentPositions = vertex_data.positions;
    var currentColors = vertex_data.colors;
    if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {
      Logger.Warn("VertexData contains empty entries");
    } else {
      var positions = new Array();
      var indices = new Array();
      var uvs = new Array();
      var colors = new Array();
      var pstring = new Array();
      var indexPtr = 0;
      var uniquePositions = {};
      var ptr = void 0;
      var facet = void 0;
      for (var i = 0; i < currentIndices.length; i += 3) {
        facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]];
        pstring = new Array();
        for (var j = 0; j < 3; j++) {
          pstring[j] = "";
          for (var k = 0; k < 3; k++) {
            if (Math.abs(currentPositions[3 * facet[j] + k]) < 1e-8) {
              currentPositions[3 * facet[j] + k] = 0;
            }
            pstring[j] += currentPositions[3 * facet[j] + k] + "|";
          }
        }
        if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {
          for (var j = 0; j < 3; j++) {
            ptr = uniquePositions[pstring[j]];
            if (ptr === void 0) {
              uniquePositions[pstring[j]] = indexPtr;
              ptr = indexPtr++;
              for (var k = 0; k < 3; k++) {
                positions.push(currentPositions[3 * facet[j] + k]);
              }
              if (currentColors !== null && currentColors !== void 0) {
                for (var k = 0; k < 4; k++) {
                  colors.push(currentColors[4 * facet[j] + k]);
                }
              }
              if (currentUVs !== null && currentUVs !== void 0) {
                for (var k = 0; k < 2; k++) {
                  uvs.push(currentUVs[2 * facet[j] + k]);
                }
              }
            }
            indices.push(ptr);
          }
        }
      }
      var normals = new Array();
      VertexData.ComputeNormals(positions, indices, normals);
      vertex_data.positions = positions;
      vertex_data.indices = indices;
      vertex_data.normals = normals;
      if (currentUVs !== null && currentUVs !== void 0) {
        vertex_data.uvs = uvs;
      }
      if (currentColors !== null && currentColors !== void 0) {
        vertex_data.colors = colors;
      }
      vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
    }
  };
  Mesh2._instancedMeshFactory = function(name2, mesh) {
    throw _WarnImport("InstancedMesh");
  };
  Mesh2._PhysicsImpostorParser = function(scene, physicObject, jsonObject) {
    throw _WarnImport("PhysicsImpostor");
  };
  Mesh2.prototype.createInstance = function(name2) {
    return Mesh2._instancedMeshFactory(name2, this);
  };
  Mesh2.prototype.synchronizeInstances = function() {
    for (var instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {
      var instance = this.instances[instanceIndex];
      instance._syncSubMeshes();
    }
    return this;
  };
  Mesh2.prototype.optimizeIndices = function(successCallback) {
    var _this = this;
    var indices = this.getIndices();
    var positions = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positions || !indices) {
      return this;
    }
    var vectorPositions = new Array();
    for (var pos = 0; pos < positions.length; pos = pos + 3) {
      vectorPositions.push(Vector3.FromArray(positions, pos));
    }
    var dupes = new Array();
    AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, function(iteration) {
      var realPos = vectorPositions.length - 1 - iteration;
      var testedPosition = vectorPositions[realPos];
      for (var j = 0; j < realPos; ++j) {
        var againstPosition = vectorPositions[j];
        if (testedPosition.equals(againstPosition)) {
          dupes[realPos] = j;
          break;
        }
      }
    }, function() {
      for (var i = 0; i < indices.length; ++i) {
        indices[i] = dupes[indices[i]] || indices[i];
      }
      var originalSubMeshes = _this.subMeshes.slice(0);
      _this.setIndices(indices);
      _this.subMeshes = originalSubMeshes;
      if (successCallback) {
        successCallback(_this);
      }
    });
    return this;
  };
  Mesh2.prototype.serialize = function(serializationObject) {
    serializationObject.name = this.name;
    serializationObject.id = this.id;
    serializationObject.uniqueId = this.uniqueId;
    serializationObject.type = this.getClassName();
    if (Tags && Tags.HasTags(this)) {
      serializationObject.tags = Tags.GetTags(this);
    }
    serializationObject.position = this.position.asArray();
    if (this.rotationQuaternion) {
      serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();
    } else if (this.rotation) {
      serializationObject.rotation = this.rotation.asArray();
    }
    serializationObject.scaling = this.scaling.asArray();
    if (this._postMultiplyPivotMatrix) {
      serializationObject.pivotMatrix = this.getPivotMatrix().asArray();
    } else {
      serializationObject.localMatrix = this.getPivotMatrix().asArray();
    }
    serializationObject.isEnabled = this.isEnabled(false);
    serializationObject.isVisible = this.isVisible;
    serializationObject.infiniteDistance = this.infiniteDistance;
    serializationObject.pickable = this.isPickable;
    serializationObject.receiveShadows = this.receiveShadows;
    serializationObject.billboardMode = this.billboardMode;
    serializationObject.visibility = this.visibility;
    serializationObject.checkCollisions = this.checkCollisions;
    serializationObject.isBlocker = this.isBlocker;
    serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;
    if (this.parent) {
      serializationObject.parentId = this.parent.uniqueId;
    }
    serializationObject.isUnIndexed = this.isUnIndexed;
    var geometry = this._geometry;
    if (geometry && this.subMeshes) {
      serializationObject.geometryUniqueId = geometry.uniqueId;
      serializationObject.geometryId = geometry.id;
      serializationObject.subMeshes = [];
      for (var subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {
        var subMesh = this.subMeshes[subIndex];
        serializationObject.subMeshes.push({
          materialIndex: subMesh.materialIndex,
          verticesStart: subMesh.verticesStart,
          verticesCount: subMesh.verticesCount,
          indexStart: subMesh.indexStart,
          indexCount: subMesh.indexCount
        });
      }
    }
    if (this.material) {
      if (!this.material.doNotSerialize) {
        serializationObject.materialUniqueId = this.material.uniqueId;
        serializationObject.materialId = this.material.id;
      }
    } else {
      this.material = null;
      serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;
      serializationObject.materialId = this._scene.defaultMaterial.id;
    }
    if (this.morphTargetManager) {
      serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;
    }
    if (this.skeleton) {
      serializationObject.skeletonId = this.skeleton.id;
      serializationObject.numBoneInfluencers = this.numBoneInfluencers;
    }
    if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
      var impostor = this.getPhysicsImpostor();
      if (impostor) {
        serializationObject.physicsMass = impostor.getParam("mass");
        serializationObject.physicsFriction = impostor.getParam("friction");
        serializationObject.physicsRestitution = impostor.getParam("mass");
        serializationObject.physicsImpostor = impostor.type;
      }
    }
    if (this.metadata) {
      serializationObject.metadata = this.metadata;
    }
    serializationObject.instances = [];
    for (var index = 0; index < this.instances.length; index++) {
      var instance = this.instances[index];
      if (instance.doNotSerialize) {
        continue;
      }
      var serializationInstance = {
        name: instance.name,
        id: instance.id,
        isEnabled: instance.isEnabled(false),
        isVisible: instance.isVisible,
        isPickable: instance.isPickable,
        checkCollisions: instance.checkCollisions,
        position: instance.position.asArray(),
        scaling: instance.scaling.asArray()
      };
      if (instance.parent) {
        serializationInstance.parentId = instance.parent.uniqueId;
      }
      if (instance.rotationQuaternion) {
        serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();
      } else if (instance.rotation) {
        serializationInstance.rotation = instance.rotation.asArray();
      }
      if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
        var impostor = instance.getPhysicsImpostor();
        if (impostor) {
          serializationInstance.physicsMass = impostor.getParam("mass");
          serializationInstance.physicsFriction = impostor.getParam("friction");
          serializationInstance.physicsRestitution = impostor.getParam("mass");
          serializationInstance.physicsImpostor = impostor.type;
        }
      }
      if (instance.metadata) {
        serializationInstance.metadata = instance.metadata;
      }
      serializationObject.instances.push(serializationInstance);
      SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);
      serializationInstance.ranges = instance.serializeAnimationRanges();
    }
    if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {
      serializationObject.thinInstances = {
        instancesCount: this._thinInstanceDataStorage.instancesCount,
        matrixData: Array.from(this._thinInstanceDataStorage.matrixData),
        matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
        enablePicking: this.thinInstanceEnablePicking
      };
      if (this._userThinInstanceBuffersStorage) {
        var userThinInstance = {
          data: {},
          sizes: {},
          strides: {}
        };
        for (var kind in this._userThinInstanceBuffersStorage.data) {
          userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);
          userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];
          userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];
        }
        serializationObject.thinInstances.userThinInstance = userThinInstance;
      }
    }
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    serializationObject.ranges = this.serializeAnimationRanges();
    serializationObject.layerMask = this.layerMask;
    serializationObject.alphaIndex = this.alphaIndex;
    serializationObject.hasVertexAlpha = this.hasVertexAlpha;
    serializationObject.overlayAlpha = this.overlayAlpha;
    serializationObject.overlayColor = this.overlayColor.asArray();
    serializationObject.renderOverlay = this.renderOverlay;
    serializationObject.applyFog = this.applyFog;
    if (this.actionManager) {
      serializationObject.actions = this.actionManager.serialize(this.name);
    }
  };
  Mesh2.prototype._syncGeometryWithMorphTargetManager = function() {
    if (!this.geometry) {
      return;
    }
    this._markSubMeshesAsAttributesDirty();
    var morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;
    if (morphTargetManager && morphTargetManager.vertexCount) {
      if (morphTargetManager.vertexCount !== this.getTotalVertices()) {
        Logger.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.");
        this.morphTargetManager = null;
        return;
      }
      if (morphTargetManager.isUsingTextureForTargets) {
        return;
      }
      for (var index = 0; index < morphTargetManager.numInfluencers; index++) {
        var morphTarget = morphTargetManager.getActiveTarget(index);
        var positions = morphTarget.getPositions();
        if (!positions) {
          Logger.Error("Invalid morph target. Target must have positions.");
          return;
        }
        this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);
        var normals = morphTarget.getNormals();
        if (normals) {
          this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);
        }
        var tangents = morphTarget.getTangents();
        if (tangents) {
          this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);
        }
        var uvs = morphTarget.getUVs();
        if (uvs) {
          this.geometry.setVerticesData(VertexBuffer.UVKind + "_" + index, uvs, false, 2);
        }
      }
    } else {
      var index = 0;
      while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {
        this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);
        if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);
        }
        if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);
        }
        if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {
          this.geometry.removeVerticesData(VertexBuffer.UVKind + "_" + index);
        }
        index++;
      }
    }
  };
  Mesh2.Parse = function(parsedMesh, scene, rootUrl) {
    var mesh;
    if (parsedMesh.type && parsedMesh.type === "LinesMesh") {
      mesh = Mesh2._LinesMeshParser(parsedMesh, scene);
    } else if (parsedMesh.type && parsedMesh.type === "GroundMesh") {
      mesh = Mesh2._GroundMeshParser(parsedMesh, scene);
    } else if (parsedMesh.type && parsedMesh.type === "GoldbergMesh") {
      mesh = Mesh2._GoldbergMeshParser(parsedMesh, scene);
    } else {
      mesh = new Mesh2(parsedMesh.name, scene);
    }
    mesh.id = parsedMesh.id;
    if (Tags) {
      Tags.AddTagsTo(mesh, parsedMesh.tags);
    }
    mesh.position = Vector3.FromArray(parsedMesh.position);
    if (parsedMesh.metadata !== void 0) {
      mesh.metadata = parsedMesh.metadata;
    }
    if (parsedMesh.rotationQuaternion) {
      mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);
    } else if (parsedMesh.rotation) {
      mesh.rotation = Vector3.FromArray(parsedMesh.rotation);
    }
    mesh.scaling = Vector3.FromArray(parsedMesh.scaling);
    if (parsedMesh.localMatrix) {
      mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));
    } else if (parsedMesh.pivotMatrix) {
      mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));
    }
    mesh.setEnabled(parsedMesh.isEnabled);
    mesh.isVisible = parsedMesh.isVisible;
    mesh.infiniteDistance = parsedMesh.infiniteDistance;
    mesh.showBoundingBox = parsedMesh.showBoundingBox;
    mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;
    if (parsedMesh.applyFog !== void 0) {
      mesh.applyFog = parsedMesh.applyFog;
    }
    if (parsedMesh.pickable !== void 0) {
      mesh.isPickable = parsedMesh.pickable;
    }
    if (parsedMesh.alphaIndex !== void 0) {
      mesh.alphaIndex = parsedMesh.alphaIndex;
    }
    mesh.receiveShadows = parsedMesh.receiveShadows;
    mesh.billboardMode = parsedMesh.billboardMode;
    if (parsedMesh.visibility !== void 0) {
      mesh.visibility = parsedMesh.visibility;
    }
    mesh.checkCollisions = parsedMesh.checkCollisions;
    mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;
    if (parsedMesh.isBlocker !== void 0) {
      mesh.isBlocker = parsedMesh.isBlocker;
    }
    mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;
    if (parsedMesh.freezeWorldMatrix) {
      mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;
    }
    if (parsedMesh.parentId !== void 0) {
      mesh._waitingParentId = parsedMesh.parentId;
    }
    if (parsedMesh.actions !== void 0) {
      mesh._waitingData.actions = parsedMesh.actions;
    }
    if (parsedMesh.overlayAlpha !== void 0) {
      mesh.overlayAlpha = parsedMesh.overlayAlpha;
    }
    if (parsedMesh.overlayColor !== void 0) {
      mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);
    }
    if (parsedMesh.renderOverlay !== void 0) {
      mesh.renderOverlay = parsedMesh.renderOverlay;
    }
    mesh.isUnIndexed = !!parsedMesh.isUnIndexed;
    mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;
    if (parsedMesh.delayLoadingFile) {
      mesh.delayLoadState = 4;
      mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;
      mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));
      if (parsedMesh._binaryInfo) {
        mesh._binaryInfo = parsedMesh._binaryInfo;
      }
      mesh._delayInfo = [];
      if (parsedMesh.hasUVs) {
        mesh._delayInfo.push(VertexBuffer.UVKind);
      }
      if (parsedMesh.hasUVs2) {
        mesh._delayInfo.push(VertexBuffer.UV2Kind);
      }
      if (parsedMesh.hasUVs3) {
        mesh._delayInfo.push(VertexBuffer.UV3Kind);
      }
      if (parsedMesh.hasUVs4) {
        mesh._delayInfo.push(VertexBuffer.UV4Kind);
      }
      if (parsedMesh.hasUVs5) {
        mesh._delayInfo.push(VertexBuffer.UV5Kind);
      }
      if (parsedMesh.hasUVs6) {
        mesh._delayInfo.push(VertexBuffer.UV6Kind);
      }
      if (parsedMesh.hasColors) {
        mesh._delayInfo.push(VertexBuffer.ColorKind);
      }
      if (parsedMesh.hasMatricesIndices) {
        mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);
      }
      if (parsedMesh.hasMatricesWeights) {
        mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);
      }
      mesh._delayLoadingFunction = Geometry._ImportGeometry;
      if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {
        mesh._checkDelayState();
      }
    } else {
      Geometry._ImportGeometry(parsedMesh, mesh);
    }
    if (parsedMesh.materialUniqueId) {
      mesh._waitingMaterialId = parsedMesh.materialUniqueId;
    } else if (parsedMesh.materialId) {
      mesh._waitingMaterialId = parsedMesh.materialId;
    }
    if (parsedMesh.morphTargetManagerId > -1) {
      mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);
    }
    if (parsedMesh.skeletonId !== void 0 && parsedMesh.skeletonId !== null) {
      mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);
      if (parsedMesh.numBoneInfluencers) {
        mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;
      }
    }
    if (parsedMesh.animations) {
      for (var animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {
        var parsedAnimation = parsedMesh.animations[animationIndex];
        var internalClass = GetClass("BABYLON.Animation");
        if (internalClass) {
          mesh.animations.push(internalClass.Parse(parsedAnimation));
        }
      }
      Node.ParseAnimationRanges(mesh, parsedMesh, scene);
    }
    if (parsedMesh.autoAnimate) {
      scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1);
    }
    if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {
      mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));
    } else {
      mesh.layerMask = 268435455;
    }
    if (parsedMesh.physicsImpostor) {
      Mesh2._PhysicsImpostorParser(scene, mesh, parsedMesh);
    }
    if (parsedMesh.lodMeshIds) {
      mesh._waitingData.lods = {
        ids: parsedMesh.lodMeshIds,
        distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,
        coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null
      };
    }
    if (parsedMesh.instances) {
      for (var index = 0; index < parsedMesh.instances.length; index++) {
        var parsedInstance = parsedMesh.instances[index];
        var instance = mesh.createInstance(parsedInstance.name);
        if (parsedInstance.id) {
          instance.id = parsedInstance.id;
        }
        if (Tags) {
          if (parsedInstance.tags) {
            Tags.AddTagsTo(instance, parsedInstance.tags);
          } else {
            Tags.AddTagsTo(instance, parsedMesh.tags);
          }
        }
        instance.position = Vector3.FromArray(parsedInstance.position);
        if (parsedInstance.metadata !== void 0) {
          instance.metadata = parsedInstance.metadata;
        }
        if (parsedInstance.parentId !== void 0) {
          instance._waitingParentId = parsedInstance.parentId;
        }
        if (parsedInstance.isEnabled !== void 0 && parsedInstance.isEnabled !== null) {
          instance.setEnabled(parsedInstance.isEnabled);
        }
        if (parsedInstance.isVisible !== void 0 && parsedInstance.isVisible !== null) {
          instance.isVisible = parsedInstance.isVisible;
        }
        if (parsedInstance.isPickable !== void 0 && parsedInstance.isPickable !== null) {
          instance.isPickable = parsedInstance.isPickable;
        }
        if (parsedInstance.rotationQuaternion) {
          instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);
        } else if (parsedInstance.rotation) {
          instance.rotation = Vector3.FromArray(parsedInstance.rotation);
        }
        instance.scaling = Vector3.FromArray(parsedInstance.scaling);
        if (parsedInstance.checkCollisions != void 0 && parsedInstance.checkCollisions != null) {
          instance.checkCollisions = parsedInstance.checkCollisions;
        }
        if (parsedInstance.pickable != void 0 && parsedInstance.pickable != null) {
          instance.isPickable = parsedInstance.pickable;
        }
        if (parsedInstance.showBoundingBox != void 0 && parsedInstance.showBoundingBox != null) {
          instance.showBoundingBox = parsedInstance.showBoundingBox;
        }
        if (parsedInstance.showSubMeshesBoundingBox != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
          instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;
        }
        if (parsedInstance.alphaIndex != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
          instance.alphaIndex = parsedInstance.alphaIndex;
        }
        if (parsedInstance.physicsImpostor) {
          Mesh2._PhysicsImpostorParser(scene, instance, parsedInstance);
        }
        if (parsedInstance.animations) {
          for (var animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {
            var parsedAnimation = parsedInstance.animations[animationIndex];
            var internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              instance.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(instance, parsedInstance, scene);
          if (parsedInstance.autoAnimate) {
            scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1);
          }
        }
      }
    }
    if (parsedMesh.thinInstances) {
      var thinInstances = parsedMesh.thinInstances;
      mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;
      if (thinInstances.matrixData) {
        mesh.thinInstanceSetBuffer("matrix", new Float32Array(thinInstances.matrixData), 16, false);
        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
        mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;
      } else {
        mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
      }
      if (parsedMesh.thinInstances.userThinInstance) {
        var userThinInstance = parsedMesh.thinInstances.userThinInstance;
        for (var kind in userThinInstance.data) {
          mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);
          mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];
        }
      }
    }
    return mesh;
  };
  Mesh2.prototype.setPositionsForCPUSkinning = function() {
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourcePositions) {
      var source = this.getVerticesData(VertexBuffer.PositionKind);
      if (!source) {
        return internalDataInfo._sourcePositions;
      }
      internalDataInfo._sourcePositions = new Float32Array(source);
      if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
        this.setVerticesData(VertexBuffer.PositionKind, source, true);
      }
    }
    return internalDataInfo._sourcePositions;
  };
  Mesh2.prototype.setNormalsForCPUSkinning = function() {
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourceNormals) {
      var source = this.getVerticesData(VertexBuffer.NormalKind);
      if (!source) {
        return internalDataInfo._sourceNormals;
      }
      internalDataInfo._sourceNormals = new Float32Array(source);
      if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
        this.setVerticesData(VertexBuffer.NormalKind, source, true);
      }
    }
    return internalDataInfo._sourceNormals;
  };
  Mesh2.prototype.applySkeleton = function(skeleton) {
    if (!this.geometry) {
      return this;
    }
    if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {
      return this;
    }
    this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();
    if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
      return this;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
      return this;
    }
    if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
      return this;
    }
    var hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);
    var internalDataInfo = this._internalMeshDataInfo;
    if (!internalDataInfo._sourcePositions) {
      var submeshes = this.subMeshes.slice();
      this.setPositionsForCPUSkinning();
      this.subMeshes = submeshes;
    }
    if (hasNormals && !internalDataInfo._sourceNormals) {
      this.setNormalsForCPUSkinning();
    }
    var positionsData = this.getVerticesData(VertexBuffer.PositionKind);
    if (!positionsData) {
      return this;
    }
    if (!(positionsData instanceof Float32Array)) {
      positionsData = new Float32Array(positionsData);
    }
    var normalsData = this.getVerticesData(VertexBuffer.NormalKind);
    if (hasNormals) {
      if (!normalsData) {
        return this;
      }
      if (!(normalsData instanceof Float32Array)) {
        normalsData = new Float32Array(normalsData);
      }
    }
    var matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
    var matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
    if (!matricesWeightsData || !matricesIndicesData) {
      return this;
    }
    var needExtras = this.numBoneInfluencers > 4;
    var matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
    var matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
    var skeletonMatrices = skeleton.getTransformMatrices(this);
    var tempVector3 = Vector3.Zero();
    var finalMatrix = new Matrix();
    var tempMatrix = new Matrix();
    var matWeightIdx = 0;
    var inf;
    for (var index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {
      var weight = void 0;
      for (inf = 0; inf < 4; inf++) {
        weight = matricesWeightsData[matWeightIdx + inf];
        if (weight > 0) {
          Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
          finalMatrix.addToSelf(tempMatrix);
        }
      }
      if (needExtras) {
        for (inf = 0; inf < 4; inf++) {
          weight = matricesWeightsExtraData[matWeightIdx + inf];
          if (weight > 0) {
            Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
            finalMatrix.addToSelf(tempMatrix);
          }
        }
      }
      Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);
      tempVector3.toArray(positionsData, index);
      if (hasNormals) {
        Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);
        tempVector3.toArray(normalsData, index);
      }
      finalMatrix.reset();
    }
    this.updateVerticesData(VertexBuffer.PositionKind, positionsData);
    if (hasNormals) {
      this.updateVerticesData(VertexBuffer.NormalKind, normalsData);
    }
    return this;
  };
  Mesh2.MinMax = function(meshes) {
    var minVector = null;
    var maxVector = null;
    meshes.forEach(function(mesh) {
      var boundingInfo = mesh.getBoundingInfo();
      var boundingBox = boundingInfo.boundingBox;
      if (!minVector || !maxVector) {
        minVector = boundingBox.minimumWorld;
        maxVector = boundingBox.maximumWorld;
      } else {
        minVector.minimizeInPlace(boundingBox.minimumWorld);
        maxVector.maximizeInPlace(boundingBox.maximumWorld);
      }
    });
    if (!minVector || !maxVector) {
      return {
        min: Vector3.Zero(),
        max: Vector3.Zero()
      };
    }
    return {
      min: minVector,
      max: maxVector
    };
  };
  Mesh2.Center = function(meshesOrMinMaxVector) {
    var minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh2.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;
    return Vector3.Center(minMaxVector.min, minMaxVector.max);
  };
  Mesh2.MergeMeshes = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
    if (disposeSource === void 0) {
      disposeSource = true;
    }
    return runCoroutineSync(Mesh2._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));
  };
  Mesh2.MergeMeshesAsync = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
    if (disposeSource === void 0) {
      disposeSource = true;
    }
    return runCoroutineAsync(Mesh2._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());
  };
  Mesh2._MergeMeshesCoroutine = function(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, isAsync) {
    var index, totalVertices, materialArray, materialIndexArray, indiceArray, currentOverrideMaterialSideOrientation, mesh, material, matIndex, subIndex, subIndex, subIndex, source, getVertexDataFromMesh, _a2, sourceVertexData, sourceTransform, meshVertexDatas, i, mergeCoroutine, mergeCoroutineStep, vertexData, applyToCoroutine, applyToCoroutineStep, offset, _i, _b2, subMesh, newMultiMaterial, subIndex;
    if (disposeSource === void 0) {
      disposeSource = true;
    }
    return __generator(this, function(_c2) {
      switch (_c2.label) {
        case 0:
          meshes = meshes.filter(Boolean);
          if (meshes.length === 0) {
            return [2, null];
          }
          if (!allow32BitsIndices) {
            totalVertices = 0;
            for (index = 0; index < meshes.length; index++) {
              totalVertices += meshes[index].getTotalVertices();
              if (totalVertices >= 65536) {
                Logger.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices");
                return [2, null];
              }
            }
          }
          if (multiMultiMaterials) {
            subdivideWithSubMeshes = false;
          }
          materialArray = new Array();
          materialIndexArray = new Array();
          indiceArray = new Array();
          currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;
          for (index = 0; index < meshes.length; index++) {
            mesh = meshes[index];
            if (mesh.isAnInstance) {
              Logger.Warn("Cannot merge instance meshes.");
              return [2, null];
            }
            if (currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation) {
              Logger.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values.");
              return [2, null];
            }
            if (subdivideWithSubMeshes) {
              indiceArray.push(mesh.getTotalIndices());
            }
            if (multiMultiMaterials) {
              if (mesh.material) {
                material = mesh.material;
                if (material instanceof MultiMaterial) {
                  for (matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {
                    if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {
                      materialArray.push(material.subMaterials[matIndex]);
                    }
                  }
                  for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                    materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));
                    indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                  }
                } else {
                  if (materialArray.indexOf(material) < 0) {
                    materialArray.push(material);
                  }
                  for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                    materialIndexArray.push(materialArray.indexOf(material));
                    indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                  }
                }
              } else {
                for (subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                  materialIndexArray.push(0);
                  indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                }
              }
            }
          }
          source = meshes[0];
          getVertexDataFromMesh = function(mesh2) {
            var wm = mesh2.computeWorldMatrix(true);
            var vertexData2 = VertexData.ExtractFromMesh(mesh2, false, false);
            return [vertexData2, wm];
          };
          _a2 = getVertexDataFromMesh(source), sourceVertexData = _a2[0], sourceTransform = _a2[1];
          if (!isAsync)
            return [3, 2];
          return [4];
        case 1:
          _c2.sent();
          _c2.label = 2;
        case 2:
          meshVertexDatas = new Array(meshes.length - 1);
          i = 1;
          _c2.label = 3;
        case 3:
          if (!(i < meshes.length))
            return [3, 6];
          meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);
          if (!isAsync)
            return [3, 5];
          return [4];
        case 4:
          _c2.sent();
          _c2.label = 5;
        case 5:
          i++;
          return [3, 3];
        case 6:
          mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);
          mergeCoroutineStep = mergeCoroutine.next();
          _c2.label = 7;
        case 7:
          if (!!mergeCoroutineStep.done)
            return [3, 10];
          if (!isAsync)
            return [3, 9];
          return [4];
        case 8:
          _c2.sent();
          _c2.label = 9;
        case 9:
          mergeCoroutineStep = mergeCoroutine.next();
          return [3, 7];
        case 10:
          vertexData = mergeCoroutineStep.value;
          if (!meshSubclass) {
            meshSubclass = new Mesh2(source.name + "_merged", source.getScene());
          }
          applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, void 0, isAsync);
          applyToCoroutineStep = applyToCoroutine.next();
          _c2.label = 11;
        case 11:
          if (!!applyToCoroutineStep.done)
            return [3, 14];
          if (!isAsync)
            return [3, 13];
          return [4];
        case 12:
          _c2.sent();
          _c2.label = 13;
        case 13:
          applyToCoroutineStep = applyToCoroutine.next();
          return [3, 11];
        case 14:
          meshSubclass.checkCollisions = source.checkCollisions;
          meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;
          if (disposeSource) {
            for (index = 0; index < meshes.length; index++) {
              meshes[index].dispose();
            }
          }
          if (subdivideWithSubMeshes || multiMultiMaterials) {
            meshSubclass.releaseSubMeshes();
            index = 0;
            offset = 0;
            while (index < indiceArray.length) {
              SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, void 0, false);
              offset += indiceArray[index];
              index++;
            }
            for (_i = 0, _b2 = meshSubclass.subMeshes; _i < _b2.length; _i++) {
              subMesh = _b2[_i];
              subMesh.refreshBoundingInfo();
            }
            meshSubclass.computeWorldMatrix(true);
          }
          if (multiMultiMaterials) {
            newMultiMaterial = new MultiMaterial(source.name + "_merged", source.getScene());
            newMultiMaterial.subMaterials = materialArray;
            for (subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {
              meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];
            }
            meshSubclass.material = newMultiMaterial;
          } else {
            meshSubclass.material = source.material;
          }
          return [2, meshSubclass];
      }
    });
  };
  Mesh2.prototype.addInstance = function(instance) {
    instance._indexInSourceMeshInstanceArray = this.instances.length;
    this.instances.push(instance);
  };
  Mesh2.prototype.removeInstance = function(instance) {
    var index = instance._indexInSourceMeshInstanceArray;
    if (index != -1) {
      if (index !== this.instances.length - 1) {
        var last = this.instances[this.instances.length - 1];
        this.instances[index] = last;
        last._indexInSourceMeshInstanceArray = index;
      }
      instance._indexInSourceMeshInstanceArray = -1;
      this.instances.pop();
    }
  };
  Mesh2.prototype._shouldConvertRHS = function() {
    return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;
  };
  Mesh2.FRONTSIDE = VertexData.FRONTSIDE;
  Mesh2.BACKSIDE = VertexData.BACKSIDE;
  Mesh2.DOUBLESIDE = VertexData.DOUBLESIDE;
  Mesh2.DEFAULTSIDE = VertexData.DEFAULTSIDE;
  Mesh2.NO_CAP = 0;
  Mesh2.CAP_START = 1;
  Mesh2.CAP_END = 2;
  Mesh2.CAP_ALL = 3;
  Mesh2.NO_FLIP = 0;
  Mesh2.FLIP_TILE = 1;
  Mesh2.ROTATE_TILE = 2;
  Mesh2.FLIP_ROW = 3;
  Mesh2.ROTATE_ROW = 4;
  Mesh2.FLIP_N_ROTATE_TILE = 5;
  Mesh2.FLIP_N_ROTATE_ROW = 6;
  Mesh2.CENTER = 0;
  Mesh2.LEFT = 1;
  Mesh2.RIGHT = 2;
  Mesh2.TOP = 3;
  Mesh2.BOTTOM = 4;
  Mesh2.INSTANCEDMESH_SORT_TRANSPARENT = false;
  Mesh2._GroundMeshParser = function(parsedMesh, scene) {
    throw _WarnImport("GroundMesh");
  };
  Mesh2._GoldbergMeshParser = function(parsedMesh, scene) {
    throw _WarnImport("GoldbergMesh");
  };
  Mesh2._LinesMeshParser = function(parsedMesh, scene) {
    throw _WarnImport("LinesMesh");
  };
  return Mesh2;
}(AbstractMesh);
RegisterClass("BABYLON.Mesh", Mesh);
Mesh.prototype.setMaterialByID = function(id) {
  return this.setMaterialById(id);
};
Mesh.CreateDisc = Mesh.CreateDisc || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateBox = Mesh.CreateBox || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateSphere = Mesh.CreateSphere || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateCylinder = Mesh.CreateCylinder || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateTorusKnot = Mesh.CreateTorusKnot || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateTorus = Mesh.CreateTorus || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreatePlane = Mesh.CreatePlane || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateGround = Mesh.CreateGround || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateTiledGround = Mesh.CreateTiledGround || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateGroundFromHeightMap = Mesh.CreateGroundFromHeightMap || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateTube = Mesh.CreateTube || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreatePolyhedron = Mesh.CreatePolyhedron || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateIcoSphere = Mesh.CreateIcoSphere || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateDecal = Mesh.CreateDecal || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.CreateCapsule = Mesh.CreateCapsule || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
Mesh.ExtendToGoldberg = Mesh.ExtendToGoldberg || function() {
  throw new Error("Import MeshBuilder to populate this function");
};
var ColorGradient = function() {
  function ColorGradient2(gradient, color1, color2) {
    this.gradient = gradient;
    this.color1 = color1;
    this.color2 = color2;
  }
  ColorGradient2.prototype.getColorToRef = function(result) {
    if (!this.color2) {
      result.copyFrom(this.color1);
      return;
    }
    Color4.LerpToRef(this.color1, this.color2, Math.random(), result);
  };
  return ColorGradient2;
}();
var Color3Gradient = function() {
  function Color3Gradient2(gradient, color) {
    this.gradient = gradient;
    this.color = color;
  }
  return Color3Gradient2;
}();
var FactorGradient = function() {
  function FactorGradient2(gradient, factor1, factor2) {
    this.gradient = gradient;
    this.factor1 = factor1;
    this.factor2 = factor2;
  }
  FactorGradient2.prototype.getFactor = function() {
    if (this.factor2 === void 0 || this.factor2 === this.factor1) {
      return this.factor1;
    }
    return this.factor1 + (this.factor2 - this.factor1) * Math.random();
  };
  return FactorGradient2;
}();
var GradientHelper = function() {
  function GradientHelper2() {
  }
  GradientHelper2.GetCurrentGradient = function(ratio, gradients, updateFunc) {
    if (gradients[0].gradient > ratio) {
      updateFunc(gradients[0], gradients[0], 1);
      return;
    }
    for (var gradientIndex = 0; gradientIndex < gradients.length - 1; gradientIndex++) {
      var currentGradient = gradients[gradientIndex];
      var nextGradient = gradients[gradientIndex + 1];
      if (ratio >= currentGradient.gradient && ratio <= nextGradient.gradient) {
        var scale = (ratio - currentGradient.gradient) / (nextGradient.gradient - currentGradient.gradient);
        updateFunc(currentGradient, nextGradient, scale);
        return;
      }
    }
    var lastIndex = gradients.length - 1;
    updateFunc(gradients[lastIndex], gradients[lastIndex], 1);
  };
  return GradientHelper2;
}();
var BoxParticleEmitter = function() {
  function BoxParticleEmitter2() {
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
    this.minEmitBox = new Vector3(-0.5, -0.5, -0.5);
    this.maxEmitBox = new Vector3(0.5, 0.5, 0.5);
  }
  BoxParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.x = randX;
      directionToUpdate.y = randY;
      directionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  BoxParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var randX = Scalar.RandomRange(this.minEmitBox.x, this.maxEmitBox.x);
    var randY = Scalar.RandomRange(this.minEmitBox.y, this.maxEmitBox.y);
    var randZ = Scalar.RandomRange(this.minEmitBox.z, this.maxEmitBox.z);
    if (isLocal) {
      positionToUpdate.x = randX;
      positionToUpdate.y = randY;
      positionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  };
  BoxParticleEmitter2.prototype.clone = function() {
    var newOne = new BoxParticleEmitter2();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  BoxParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
    uboOrEffect.setVector3("minEmitBox", this.minEmitBox);
    uboOrEffect.setVector3("maxEmitBox", this.maxEmitBox);
  };
  BoxParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
    ubo.addUniform("minEmitBox", 3);
    ubo.addUniform("maxEmitBox", 3);
  };
  BoxParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define BOXEMITTER";
  };
  BoxParticleEmitter2.prototype.getClassName = function() {
    return "BoxParticleEmitter";
  };
  BoxParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    serializationObject.minEmitBox = this.minEmitBox.asArray();
    serializationObject.maxEmitBox = this.maxEmitBox.asArray();
    return serializationObject;
  };
  BoxParticleEmitter2.prototype.parse = function(serializationObject) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
    Vector3.FromArrayToRef(serializationObject.minEmitBox, 0, this.minEmitBox);
    Vector3.FromArrayToRef(serializationObject.maxEmitBox, 0, this.maxEmitBox);
  };
  return BoxParticleEmitter2;
}();
var ConeParticleEmitter = function() {
  function ConeParticleEmitter2(radius, angle, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (angle === void 0) {
      angle = Math.PI;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    this.directionRandomizer = directionRandomizer;
    this.radiusRange = 1;
    this.heightRange = 1;
    this.emitFromSpawnPointOnly = false;
    this.angle = angle;
    this.radius = radius;
  }
  Object.defineProperty(ConeParticleEmitter2.prototype, "radius", {
    get: function() {
      return this._radius;
    },
    set: function(value) {
      this._radius = value;
      this._buildHeight();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ConeParticleEmitter2.prototype, "angle", {
    get: function() {
      return this._angle;
    },
    set: function(value) {
      this._angle = value;
      this._buildHeight();
    },
    enumerable: false,
    configurable: true
  });
  ConeParticleEmitter2.prototype._buildHeight = function() {
    if (this._angle !== 0) {
      this._height = this._radius / Math.tan(this._angle / 2);
    } else {
      this._height = 1;
    }
  };
  ConeParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    if (isLocal) {
      TmpVectors.Vector3[0].copyFrom(particle._localPosition).normalize();
    } else {
      particle.position.subtractToRef(worldMatrix.getTranslation(), TmpVectors.Vector3[0]).normalize();
    }
    var randX = Scalar.RandomRange(0, this.directionRandomizer);
    var randY = Scalar.RandomRange(0, this.directionRandomizer);
    var randZ = Scalar.RandomRange(0, this.directionRandomizer);
    directionToUpdate.x = TmpVectors.Vector3[0].x + randX;
    directionToUpdate.y = TmpVectors.Vector3[0].y + randY;
    directionToUpdate.z = TmpVectors.Vector3[0].z + randZ;
    directionToUpdate.normalize();
  };
  ConeParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var s = Scalar.RandomRange(0, Math.PI * 2);
    var h;
    if (!this.emitFromSpawnPointOnly) {
      h = Scalar.RandomRange(0, this.heightRange);
      h = 1 - h * h;
    } else {
      h = 1e-4;
    }
    var radius = this._radius - Scalar.RandomRange(0, this._radius * this.radiusRange);
    radius = radius * h;
    var randX = radius * Math.sin(s);
    var randZ = radius * Math.cos(s);
    var randY = h * this._height;
    if (isLocal) {
      positionToUpdate.x = randX;
      positionToUpdate.y = randY;
      positionToUpdate.z = randZ;
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  };
  ConeParticleEmitter2.prototype.clone = function() {
    var newOne = new ConeParticleEmitter2(this._radius, this._angle, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  ConeParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
    uboOrEffect.setFloat2("radius", this._radius, this.radiusRange);
    uboOrEffect.setFloat("coneAngle", this._angle);
    uboOrEffect.setFloat2("height", this._height, this.heightRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  };
  ConeParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
    ubo.addUniform("radius", 2);
    ubo.addUniform("coneAngle", 1);
    ubo.addUniform("height", 2);
    ubo.addUniform("directionRandomizer", 1);
  };
  ConeParticleEmitter2.prototype.getEffectDefines = function() {
    var defines = "#define CONEEMITTER";
    if (this.emitFromSpawnPointOnly) {
      defines += "\n#define CONEEMITTERSPAWNPOINT";
    }
    return defines;
  };
  ConeParticleEmitter2.prototype.getClassName = function() {
    return "ConeParticleEmitter";
  };
  ConeParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this._radius;
    serializationObject.angle = this._angle;
    serializationObject.directionRandomizer = this.directionRandomizer;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.heightRange = this.heightRange;
    serializationObject.emitFromSpawnPointOnly = this.emitFromSpawnPointOnly;
    return serializationObject;
  };
  ConeParticleEmitter2.prototype.parse = function(serializationObject) {
    this.radius = serializationObject.radius;
    this.angle = serializationObject.angle;
    this.directionRandomizer = serializationObject.directionRandomizer;
    this.radiusRange = serializationObject.radiusRange !== void 0 ? serializationObject.radiusRange : 1;
    this.heightRange = serializationObject.radiusRange !== void 0 ? serializationObject.heightRange : 1;
    this.emitFromSpawnPointOnly = serializationObject.emitFromSpawnPointOnly !== void 0 ? serializationObject.emitFromSpawnPointOnly : false;
  };
  return ConeParticleEmitter2;
}();
var CylinderParticleEmitter = function() {
  function CylinderParticleEmitter2(radius, height, radiusRange, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    this.radius = radius;
    this.height = height;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
    this._tempVector = Vector3.Zero();
  }
  CylinderParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal, inverseWorldMatrix) {
    particle.position.subtractToRef(worldMatrix.getTranslation(), this._tempVector);
    this._tempVector.normalize();
    Vector3.TransformNormalToRef(this._tempVector, inverseWorldMatrix, this._tempVector);
    var randY = Scalar.RandomRange(-this.directionRandomizer / 2, this.directionRandomizer / 2);
    var angle = Math.atan2(this._tempVector.x, this._tempVector.z);
    angle += Scalar.RandomRange(-Math.PI / 2, Math.PI / 2) * this.directionRandomizer;
    this._tempVector.y = randY;
    this._tempVector.x = Math.sin(angle);
    this._tempVector.z = Math.cos(angle);
    this._tempVector.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(this._tempVector);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(this._tempVector.x, this._tempVector.y, this._tempVector.z, worldMatrix, directionToUpdate);
  };
  CylinderParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var yPos = Scalar.RandomRange(-this.height / 2, this.height / 2);
    var angle = Scalar.RandomRange(0, 2 * Math.PI);
    var radiusDistribution = Scalar.RandomRange((1 - this.radiusRange) * (1 - this.radiusRange), 1);
    var positionRadius = Math.sqrt(radiusDistribution) * this.radius;
    var xPos = positionRadius * Math.cos(angle);
    var zPos = positionRadius * Math.sin(angle);
    if (isLocal) {
      positionToUpdate.copyFromFloats(xPos, yPos, zPos);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(xPos, yPos, zPos, worldMatrix, positionToUpdate);
  };
  CylinderParticleEmitter2.prototype.clone = function() {
    var newOne = new CylinderParticleEmitter2(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  CylinderParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("height", this.height);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  };
  CylinderParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("height", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("directionRandomizer", 1);
  };
  CylinderParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define CYLINDEREMITTER";
  };
  CylinderParticleEmitter2.prototype.getClassName = function() {
    return "CylinderParticleEmitter";
  };
  CylinderParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.height = this.height;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  };
  CylinderParticleEmitter2.prototype.parse = function(serializationObject) {
    this.radius = serializationObject.radius;
    this.height = serializationObject.height;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  };
  return CylinderParticleEmitter2;
}();
var CylinderDirectedParticleEmitter = function(_super) {
  __extends(CylinderDirectedParticleEmitter2, _super);
  function CylinderDirectedParticleEmitter2(radius, height, radiusRange, direction1, direction2) {
    if (radius === void 0) {
      radius = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (direction1 === void 0) {
      direction1 = new Vector3(0, 1, 0);
    }
    if (direction2 === void 0) {
      direction2 = new Vector3(0, 1, 0);
    }
    var _this = _super.call(this, radius, height, radiusRange) || this;
    _this.direction1 = direction1;
    _this.direction2 = direction2;
    return _this;
  }
  CylinderDirectedParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate) {
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  CylinderDirectedParticleEmitter2.prototype.clone = function() {
    var newOne = new CylinderDirectedParticleEmitter2(this.radius, this.height, this.radiusRange, this.direction1, this.direction2);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  CylinderDirectedParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("height", this.height);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  };
  CylinderDirectedParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("height", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  };
  CylinderDirectedParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define CYLINDEREMITTER\n#define DIRECTEDCYLINDEREMITTER";
  };
  CylinderDirectedParticleEmitter2.prototype.getClassName = function() {
    return "CylinderDirectedParticleEmitter";
  };
  CylinderDirectedParticleEmitter2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  };
  CylinderDirectedParticleEmitter2.prototype.parse = function(serializationObject) {
    _super.prototype.parse.call(this, serializationObject);
    this.direction1.copyFrom(serializationObject.direction1);
    this.direction2.copyFrom(serializationObject.direction2);
  };
  return CylinderDirectedParticleEmitter2;
}(CylinderParticleEmitter);
var HemisphericParticleEmitter = function() {
  function HemisphericParticleEmitter2(radius, radiusRange, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    this.radius = radius;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
  }
  HemisphericParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
    var randX = Scalar.RandomRange(0, this.directionRandomizer);
    var randY = Scalar.RandomRange(0, this.directionRandomizer);
    var randZ = Scalar.RandomRange(0, this.directionRandomizer);
    direction.x += randX;
    direction.y += randY;
    direction.z += randZ;
    direction.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(direction);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
  };
  HemisphericParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);
    var v = Scalar.RandomRange(0, 1);
    var phi = Scalar.RandomRange(0, 2 * Math.PI);
    var theta = Math.acos(2 * v - 1);
    var randX = randRadius * Math.cos(phi) * Math.sin(theta);
    var randY = randRadius * Math.cos(theta);
    var randZ = randRadius * Math.sin(phi) * Math.sin(theta);
    if (isLocal) {
      positionToUpdate.copyFromFloats(randX, Math.abs(randY), randZ);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, Math.abs(randY), randZ, worldMatrix, positionToUpdate);
  };
  HemisphericParticleEmitter2.prototype.clone = function() {
    var newOne = new HemisphericParticleEmitter2(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  HemisphericParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  };
  HemisphericParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("directionRandomizer", 1);
  };
  HemisphericParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define HEMISPHERICEMITTER";
  };
  HemisphericParticleEmitter2.prototype.getClassName = function() {
    return "HemisphericParticleEmitter";
  };
  HemisphericParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  };
  HemisphericParticleEmitter2.prototype.parse = function(serializationObject) {
    this.radius = serializationObject.radius;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  };
  return HemisphericParticleEmitter2;
}();
var PointParticleEmitter = function() {
  function PointParticleEmitter2() {
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
  }
  PointParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  PointParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    if (isLocal) {
      positionToUpdate.copyFromFloats(0, 0, 0);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(0, 0, 0, worldMatrix, positionToUpdate);
  };
  PointParticleEmitter2.prototype.clone = function() {
    var newOne = new PointParticleEmitter2();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  PointParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  };
  PointParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  };
  PointParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define POINTEMITTER";
  };
  PointParticleEmitter2.prototype.getClassName = function() {
    return "PointParticleEmitter";
  };
  PointParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  };
  PointParticleEmitter2.prototype.parse = function(serializationObject) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
  };
  return PointParticleEmitter2;
}();
var SphereParticleEmitter = function() {
  function SphereParticleEmitter2(radius, radiusRange, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    this.radius = radius;
    this.radiusRange = radiusRange;
    this.directionRandomizer = directionRandomizer;
  }
  SphereParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var direction = particle.position.subtract(worldMatrix.getTranslation()).normalize();
    var randX = Scalar.RandomRange(0, this.directionRandomizer);
    var randY = Scalar.RandomRange(0, this.directionRandomizer);
    var randZ = Scalar.RandomRange(0, this.directionRandomizer);
    direction.x += randX;
    direction.y += randY;
    direction.z += randZ;
    direction.normalize();
    if (isLocal) {
      directionToUpdate.copyFrom(direction);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(direction.x, direction.y, direction.z, worldMatrix, directionToUpdate);
  };
  SphereParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var randRadius = this.radius - Scalar.RandomRange(0, this.radius * this.radiusRange);
    var v = Scalar.RandomRange(0, 1);
    var phi = Scalar.RandomRange(0, 2 * Math.PI);
    var theta = Math.acos(2 * v - 1);
    var randX = randRadius * Math.cos(phi) * Math.sin(theta);
    var randY = randRadius * Math.cos(theta);
    var randZ = randRadius * Math.sin(phi) * Math.sin(theta);
    if (isLocal) {
      positionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformCoordinatesFromFloatsToRef(randX, randY, randZ, worldMatrix, positionToUpdate);
  };
  SphereParticleEmitter2.prototype.clone = function() {
    var newOne = new SphereParticleEmitter2(this.radius, this.directionRandomizer);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  SphereParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setFloat("directionRandomizer", this.directionRandomizer);
  };
  SphereParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("directionRandomizer", 1);
  };
  SphereParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define SPHEREEMITTER";
  };
  SphereParticleEmitter2.prototype.getClassName = function() {
    return "SphereParticleEmitter";
  };
  SphereParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.radius = this.radius;
    serializationObject.radiusRange = this.radiusRange;
    serializationObject.directionRandomizer = this.directionRandomizer;
    return serializationObject;
  };
  SphereParticleEmitter2.prototype.parse = function(serializationObject) {
    this.radius = serializationObject.radius;
    this.radiusRange = serializationObject.radiusRange;
    this.directionRandomizer = serializationObject.directionRandomizer;
  };
  return SphereParticleEmitter2;
}();
var SphereDirectedParticleEmitter = function(_super) {
  __extends(SphereDirectedParticleEmitter2, _super);
  function SphereDirectedParticleEmitter2(radius, direction1, direction2) {
    if (radius === void 0) {
      radius = 1;
    }
    if (direction1 === void 0) {
      direction1 = new Vector3(0, 1, 0);
    }
    if (direction2 === void 0) {
      direction2 = new Vector3(0, 1, 0);
    }
    var _this = _super.call(this, radius) || this;
    _this.direction1 = direction1;
    _this.direction2 = direction2;
    return _this;
  }
  SphereDirectedParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate) {
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  SphereDirectedParticleEmitter2.prototype.clone = function() {
    var newOne = new SphereDirectedParticleEmitter2(this.radius, this.direction1, this.direction2);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  SphereDirectedParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
    uboOrEffect.setFloat("radius", this.radius);
    uboOrEffect.setFloat("radiusRange", this.radiusRange);
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  };
  SphereDirectedParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
    ubo.addUniform("radius", 1);
    ubo.addUniform("radiusRange", 1);
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  };
  SphereDirectedParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define SPHEREEMITTER\n#define DIRECTEDSPHEREEMITTER";
  };
  SphereDirectedParticleEmitter2.prototype.getClassName = function() {
    return "SphereDirectedParticleEmitter";
  };
  SphereDirectedParticleEmitter2.prototype.serialize = function() {
    var serializationObject = _super.prototype.serialize.call(this);
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    return serializationObject;
  };
  SphereDirectedParticleEmitter2.prototype.parse = function(serializationObject) {
    _super.prototype.parse.call(this, serializationObject);
    this.direction1.copyFrom(serializationObject.direction1);
    this.direction2.copyFrom(serializationObject.direction2);
  };
  return SphereDirectedParticleEmitter2;
}(SphereParticleEmitter);
var CustomParticleEmitter = function() {
  function CustomParticleEmitter2() {
    this.particlePositionGenerator = function() {
    };
    this.particleDestinationGenerator = function() {
    };
  }
  CustomParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    var tmpVector = TmpVectors.Vector3[0];
    if (this.particleDestinationGenerator) {
      this.particleDestinationGenerator(-1, particle, tmpVector);
      var diffVector = TmpVectors.Vector3[1];
      tmpVector.subtractToRef(particle.position, diffVector);
      diffVector.scaleToRef(1 / particle.lifeTime, tmpVector);
    } else {
      tmpVector.set(0, 0, 0);
    }
    if (isLocal) {
      directionToUpdate.copyFrom(tmpVector);
      return;
    }
    Vector3.TransformNormalToRef(tmpVector, worldMatrix, directionToUpdate);
  };
  CustomParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    var tmpVector = TmpVectors.Vector3[0];
    if (this.particlePositionGenerator) {
      this.particlePositionGenerator(-1, particle, tmpVector);
    } else {
      tmpVector.set(0, 0, 0);
    }
    if (isLocal) {
      positionToUpdate.copyFrom(tmpVector);
      return;
    }
    Vector3.TransformCoordinatesToRef(tmpVector, worldMatrix, positionToUpdate);
  };
  CustomParticleEmitter2.prototype.clone = function() {
    var newOne = new CustomParticleEmitter2();
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  CustomParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
  };
  CustomParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
  };
  CustomParticleEmitter2.prototype.getEffectDefines = function() {
    return "#define CUSTOMEMITTER";
  };
  CustomParticleEmitter2.prototype.getClassName = function() {
    return "CustomParticleEmitter";
  };
  CustomParticleEmitter2.prototype.serialize = function() {
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    return serializationObject;
  };
  CustomParticleEmitter2.prototype.parse = function(serializationObject) {
  };
  return CustomParticleEmitter2;
}();
var MeshParticleEmitter = function() {
  function MeshParticleEmitter2(mesh) {
    if (mesh === void 0) {
      mesh = null;
    }
    this._indices = null;
    this._positions = null;
    this._normals = null;
    this._storedNormal = Vector3.Zero();
    this._mesh = null;
    this.direction1 = new Vector3(0, 1, 0);
    this.direction2 = new Vector3(0, 1, 0);
    this.useMeshNormalsForDirection = true;
    this.mesh = mesh;
  }
  Object.defineProperty(MeshParticleEmitter2.prototype, "mesh", {
    get: function() {
      return this._mesh;
    },
    set: function(value) {
      if (this._mesh === value) {
        return;
      }
      this._mesh = value;
      if (value) {
        this._indices = value.getIndices();
        this._positions = value.getVerticesData(VertexBuffer.PositionKind);
        this._normals = value.getVerticesData(VertexBuffer.NormalKind);
      } else {
        this._indices = null;
        this._positions = null;
        this._normals = null;
      }
    },
    enumerable: false,
    configurable: true
  });
  MeshParticleEmitter2.prototype.startDirectionFunction = function(worldMatrix, directionToUpdate, particle, isLocal) {
    if (this.useMeshNormalsForDirection && this._normals) {
      Vector3.TransformNormalToRef(this._storedNormal, worldMatrix, directionToUpdate);
      return;
    }
    var randX = Scalar.RandomRange(this.direction1.x, this.direction2.x);
    var randY = Scalar.RandomRange(this.direction1.y, this.direction2.y);
    var randZ = Scalar.RandomRange(this.direction1.z, this.direction2.z);
    if (isLocal) {
      directionToUpdate.copyFromFloats(randX, randY, randZ);
      return;
    }
    Vector3.TransformNormalFromFloatsToRef(randX, randY, randZ, worldMatrix, directionToUpdate);
  };
  MeshParticleEmitter2.prototype.startPositionFunction = function(worldMatrix, positionToUpdate, particle, isLocal) {
    if (!this._indices || !this._positions) {
      return;
    }
    var randomFaceIndex = 3 * Math.random() * (this._indices.length / 3) | 0;
    var bu = Math.random();
    var bv = Math.random() * (1 - bu);
    var bw = 1 - bu - bv;
    var faceIndexA = this._indices[randomFaceIndex];
    var faceIndexB = this._indices[randomFaceIndex + 1];
    var faceIndexC = this._indices[randomFaceIndex + 2];
    var vertexA = TmpVectors.Vector3[0];
    var vertexB = TmpVectors.Vector3[1];
    var vertexC = TmpVectors.Vector3[2];
    var randomVertex = TmpVectors.Vector3[3];
    Vector3.FromArrayToRef(this._positions, faceIndexA * 3, vertexA);
    Vector3.FromArrayToRef(this._positions, faceIndexB * 3, vertexB);
    Vector3.FromArrayToRef(this._positions, faceIndexC * 3, vertexC);
    randomVertex.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
    randomVertex.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
    randomVertex.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
    if (isLocal) {
      positionToUpdate.copyFromFloats(randomVertex.x, randomVertex.y, randomVertex.z);
    } else {
      Vector3.TransformCoordinatesFromFloatsToRef(randomVertex.x, randomVertex.y, randomVertex.z, worldMatrix, positionToUpdate);
    }
    if (this.useMeshNormalsForDirection && this._normals) {
      Vector3.FromArrayToRef(this._normals, faceIndexA * 3, vertexA);
      Vector3.FromArrayToRef(this._normals, faceIndexB * 3, vertexB);
      Vector3.FromArrayToRef(this._normals, faceIndexC * 3, vertexC);
      this._storedNormal.x = bu * vertexA.x + bv * vertexB.x + bw * vertexC.x;
      this._storedNormal.y = bu * vertexA.y + bv * vertexB.y + bw * vertexC.y;
      this._storedNormal.z = bu * vertexA.z + bv * vertexB.z + bw * vertexC.z;
    }
  };
  MeshParticleEmitter2.prototype.clone = function() {
    var newOne = new MeshParticleEmitter2(this.mesh);
    DeepCopier.DeepCopy(this, newOne);
    return newOne;
  };
  MeshParticleEmitter2.prototype.applyToShader = function(uboOrEffect) {
    uboOrEffect.setVector3("direction1", this.direction1);
    uboOrEffect.setVector3("direction2", this.direction2);
  };
  MeshParticleEmitter2.prototype.buildUniformLayout = function(ubo) {
    ubo.addUniform("direction1", 3);
    ubo.addUniform("direction2", 3);
  };
  MeshParticleEmitter2.prototype.getEffectDefines = function() {
    return "";
  };
  MeshParticleEmitter2.prototype.getClassName = function() {
    return "MeshParticleEmitter";
  };
  MeshParticleEmitter2.prototype.serialize = function() {
    var _a2;
    var serializationObject = {};
    serializationObject.type = this.getClassName();
    serializationObject.direction1 = this.direction1.asArray();
    serializationObject.direction2 = this.direction2.asArray();
    serializationObject.meshId = (_a2 = this.mesh) === null || _a2 === void 0 ? void 0 : _a2.id;
    serializationObject.useMeshNormalsForDirection = this.useMeshNormalsForDirection;
    return serializationObject;
  };
  MeshParticleEmitter2.prototype.parse = function(serializationObject, scene) {
    Vector3.FromArrayToRef(serializationObject.direction1, 0, this.direction1);
    Vector3.FromArrayToRef(serializationObject.direction2, 0, this.direction2);
    if (serializationObject.meshId && scene) {
      this.mesh = scene.getLastMeshById(serializationObject.meshId);
    }
    this.useMeshNormalsForDirection = serializationObject.useMeshNormalsForDirection;
  };
  return MeshParticleEmitter2;
}();
var BaseParticleSystem = function() {
  function BaseParticleSystem2(name2) {
    this.animations = [];
    this.renderingGroupId = 0;
    this.emitter = Vector3.Zero();
    this.emitRate = 10;
    this.manualEmitCount = -1;
    this.updateSpeed = 0.01;
    this.targetStopDuration = 0;
    this.disposeOnStop = false;
    this.minEmitPower = 1;
    this.maxEmitPower = 1;
    this.minLifeTime = 1;
    this.maxLifeTime = 1;
    this.minSize = 1;
    this.maxSize = 1;
    this.minScaleX = 1;
    this.maxScaleX = 1;
    this.minScaleY = 1;
    this.maxScaleY = 1;
    this.minInitialRotation = 0;
    this.maxInitialRotation = 0;
    this.minAngularSpeed = 0;
    this.maxAngularSpeed = 0;
    this.layerMask = 268435455;
    this.customShader = null;
    this.preventAutoStart = false;
    this._rootUrl = "";
    this.noiseStrength = new Vector3(10, 10, 10);
    this.onAnimationEnd = null;
    this.blendMode = BaseParticleSystem2.BLENDMODE_ONEONE;
    this.forceDepthWrite = false;
    this.preWarmCycles = 0;
    this.preWarmStepOffset = 1;
    this.spriteCellChangeSpeed = 1;
    this.startSpriteCellID = 0;
    this.endSpriteCellID = 0;
    this.spriteCellWidth = 0;
    this.spriteCellHeight = 0;
    this.spriteCellLoop = true;
    this.spriteRandomStartCell = false;
    this.translationPivot = new Vector2(0, 0);
    this.beginAnimationOnStart = false;
    this.beginAnimationFrom = 0;
    this.beginAnimationTo = 60;
    this.beginAnimationLoop = false;
    this.worldOffset = new Vector3(0, 0, 0);
    this.gravity = Vector3.Zero();
    this._colorGradients = null;
    this._sizeGradients = null;
    this._lifeTimeGradients = null;
    this._angularSpeedGradients = null;
    this._velocityGradients = null;
    this._limitVelocityGradients = null;
    this._dragGradients = null;
    this._emitRateGradients = null;
    this._startSizeGradients = null;
    this._rampGradients = null;
    this._colorRemapGradients = null;
    this._alphaRemapGradients = null;
    this.startDelay = 0;
    this.limitVelocityDamping = 0.4;
    this.color1 = new Color4(1, 1, 1, 1);
    this.color2 = new Color4(1, 1, 1, 1);
    this.colorDead = new Color4(0, 0, 0, 1);
    this.textureMask = new Color4(1, 1, 1, 1);
    this._isSubEmitter = false;
    this._billboardMode = 7;
    this._isBillboardBased = true;
    this._imageProcessingConfigurationDefines = new ImageProcessingConfigurationDefines();
    this.id = name2;
    this.name = name2;
  }
  Object.defineProperty(BaseParticleSystem2.prototype, "noiseTexture", {
    get: function() {
      return this._noiseTexture;
    },
    set: function(value) {
      if (this._noiseTexture === value) {
        return;
      }
      this._noiseTexture = value;
      this._reset();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "isAnimationSheetEnabled", {
    get: function() {
      return this._isAnimationSheetEnabled;
    },
    set: function(value) {
      if (this._isAnimationSheetEnabled == value) {
        return;
      }
      this._isAnimationSheetEnabled = value;
      this._reset();
    },
    enumerable: false,
    configurable: true
  });
  BaseParticleSystem2.prototype.getScene = function() {
    return this._scene;
  };
  BaseParticleSystem2.prototype._hasTargetStopDurationDependantGradient = function() {
    return this._startSizeGradients && this._startSizeGradients.length > 0 || this._emitRateGradients && this._emitRateGradients.length > 0 || this._lifeTimeGradients && this._lifeTimeGradients.length > 0;
  };
  BaseParticleSystem2.prototype.getDragGradients = function() {
    return this._dragGradients;
  };
  BaseParticleSystem2.prototype.getLimitVelocityGradients = function() {
    return this._limitVelocityGradients;
  };
  BaseParticleSystem2.prototype.getColorGradients = function() {
    return this._colorGradients;
  };
  BaseParticleSystem2.prototype.getSizeGradients = function() {
    return this._sizeGradients;
  };
  BaseParticleSystem2.prototype.getColorRemapGradients = function() {
    return this._colorRemapGradients;
  };
  BaseParticleSystem2.prototype.getAlphaRemapGradients = function() {
    return this._alphaRemapGradients;
  };
  BaseParticleSystem2.prototype.getLifeTimeGradients = function() {
    return this._lifeTimeGradients;
  };
  BaseParticleSystem2.prototype.getAngularSpeedGradients = function() {
    return this._angularSpeedGradients;
  };
  BaseParticleSystem2.prototype.getVelocityGradients = function() {
    return this._velocityGradients;
  };
  BaseParticleSystem2.prototype.getStartSizeGradients = function() {
    return this._startSizeGradients;
  };
  BaseParticleSystem2.prototype.getEmitRateGradients = function() {
    return this._emitRateGradients;
  };
  Object.defineProperty(BaseParticleSystem2.prototype, "direction1", {
    get: function() {
      if (this.particleEmitterType.direction1) {
        return this.particleEmitterType.direction1;
      }
      return Vector3.Zero();
    },
    set: function(value) {
      if (this.particleEmitterType.direction1) {
        this.particleEmitterType.direction1 = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "direction2", {
    get: function() {
      if (this.particleEmitterType.direction2) {
        return this.particleEmitterType.direction2;
      }
      return Vector3.Zero();
    },
    set: function(value) {
      if (this.particleEmitterType.direction2) {
        this.particleEmitterType.direction2 = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "minEmitBox", {
    get: function() {
      if (this.particleEmitterType.minEmitBox) {
        return this.particleEmitterType.minEmitBox;
      }
      return Vector3.Zero();
    },
    set: function(value) {
      if (this.particleEmitterType.minEmitBox) {
        this.particleEmitterType.minEmitBox = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "maxEmitBox", {
    get: function() {
      if (this.particleEmitterType.maxEmitBox) {
        return this.particleEmitterType.maxEmitBox;
      }
      return Vector3.Zero();
    },
    set: function(value) {
      if (this.particleEmitterType.maxEmitBox) {
        this.particleEmitterType.maxEmitBox = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "billboardMode", {
    get: function() {
      return this._billboardMode;
    },
    set: function(value) {
      if (this._billboardMode === value) {
        return;
      }
      this._billboardMode = value;
      this._reset();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "isBillboardBased", {
    get: function() {
      return this._isBillboardBased;
    },
    set: function(value) {
      if (this._isBillboardBased === value) {
        return;
      }
      this._isBillboardBased = value;
      this._reset();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseParticleSystem2.prototype, "imageProcessingConfiguration", {
    get: function() {
      return this._imageProcessingConfiguration;
    },
    set: function(value) {
      this._attachImageProcessingConfiguration(value);
    },
    enumerable: false,
    configurable: true
  });
  BaseParticleSystem2.prototype._attachImageProcessingConfiguration = function(configuration) {
    if (configuration === this._imageProcessingConfiguration) {
      return;
    }
    if (!configuration && this._scene) {
      this._imageProcessingConfiguration = this._scene.imageProcessingConfiguration;
    } else {
      this._imageProcessingConfiguration = configuration;
    }
  };
  BaseParticleSystem2.prototype._reset = function() {
  };
  BaseParticleSystem2.prototype._removeGradientAndTexture = function(gradient, gradients, texture) {
    if (!gradients) {
      return this;
    }
    var index = 0;
    for (var _i = 0, gradients_1 = gradients; _i < gradients_1.length; _i++) {
      var valueGradient = gradients_1[_i];
      if (valueGradient.gradient === gradient) {
        gradients.splice(index, 1);
        break;
      }
      index++;
    }
    if (texture) {
      texture.dispose();
    }
    return this;
  };
  BaseParticleSystem2.prototype.createPointEmitter = function(direction1, direction2) {
    var particleEmitter = new PointParticleEmitter();
    particleEmitter.direction1 = direction1;
    particleEmitter.direction2 = direction2;
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createHemisphericEmitter = function(radius, radiusRange) {
    if (radius === void 0) {
      radius = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    var particleEmitter = new HemisphericParticleEmitter(radius, radiusRange);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createSphereEmitter = function(radius, radiusRange) {
    if (radius === void 0) {
      radius = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    var particleEmitter = new SphereParticleEmitter(radius, radiusRange);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createDirectedSphereEmitter = function(radius, direction1, direction2) {
    if (radius === void 0) {
      radius = 1;
    }
    if (direction1 === void 0) {
      direction1 = new Vector3(0, 1, 0);
    }
    if (direction2 === void 0) {
      direction2 = new Vector3(0, 1, 0);
    }
    var particleEmitter = new SphereDirectedParticleEmitter(radius, direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createCylinderEmitter = function(radius, height, radiusRange, directionRandomizer) {
    if (radius === void 0) {
      radius = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (directionRandomizer === void 0) {
      directionRandomizer = 0;
    }
    var particleEmitter = new CylinderParticleEmitter(radius, height, radiusRange, directionRandomizer);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createDirectedCylinderEmitter = function(radius, height, radiusRange, direction1, direction2) {
    if (radius === void 0) {
      radius = 1;
    }
    if (height === void 0) {
      height = 1;
    }
    if (radiusRange === void 0) {
      radiusRange = 1;
    }
    if (direction1 === void 0) {
      direction1 = new Vector3(0, 1, 0);
    }
    if (direction2 === void 0) {
      direction2 = new Vector3(0, 1, 0);
    }
    var particleEmitter = new CylinderDirectedParticleEmitter(radius, height, radiusRange, direction1, direction2);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createConeEmitter = function(radius, angle) {
    if (radius === void 0) {
      radius = 1;
    }
    if (angle === void 0) {
      angle = Math.PI / 4;
    }
    var particleEmitter = new ConeParticleEmitter(radius, angle);
    this.particleEmitterType = particleEmitter;
    return particleEmitter;
  };
  BaseParticleSystem2.prototype.createBoxEmitter = function(direction1, direction2, minEmitBox, maxEmitBox) {
    var particleEmitter = new BoxParticleEmitter();
    this.particleEmitterType = particleEmitter;
    this.direction1 = direction1;
    this.direction2 = direction2;
    this.minEmitBox = minEmitBox;
    this.maxEmitBox = maxEmitBox;
    return particleEmitter;
  };
  BaseParticleSystem2.BLENDMODE_ONEONE = 0;
  BaseParticleSystem2.BLENDMODE_STANDARD = 1;
  BaseParticleSystem2.BLENDMODE_ADD = 2;
  BaseParticleSystem2.BLENDMODE_MULTIPLY = 3;
  BaseParticleSystem2.BLENDMODE_MULTIPLYADD = 4;
  return BaseParticleSystem2;
}();
var Size = function() {
  function Size2(width, height) {
    this.width = width;
    this.height = height;
  }
  Size2.prototype.toString = function() {
    return "{W: ".concat(this.width, ", H: ").concat(this.height, "}");
  };
  Size2.prototype.getClassName = function() {
    return "Size";
  };
  Size2.prototype.getHashCode = function() {
    var hash = this.width | 0;
    hash = hash * 397 ^ (this.height | 0);
    return hash;
  };
  Size2.prototype.copyFrom = function(src) {
    this.width = src.width;
    this.height = src.height;
  };
  Size2.prototype.copyFromFloats = function(width, height) {
    this.width = width;
    this.height = height;
    return this;
  };
  Size2.prototype.set = function(width, height) {
    return this.copyFromFloats(width, height);
  };
  Size2.prototype.multiplyByFloats = function(w, h) {
    return new Size2(this.width * w, this.height * h);
  };
  Size2.prototype.clone = function() {
    return new Size2(this.width, this.height);
  };
  Size2.prototype.equals = function(other) {
    if (!other) {
      return false;
    }
    return this.width === other.width && this.height === other.height;
  };
  Object.defineProperty(Size2.prototype, "surface", {
    get: function() {
      return this.width * this.height;
    },
    enumerable: false,
    configurable: true
  });
  Size2.Zero = function() {
    return new Size2(0, 0);
  };
  Size2.prototype.add = function(otherSize) {
    var r = new Size2(this.width + otherSize.width, this.height + otherSize.height);
    return r;
  };
  Size2.prototype.subtract = function(otherSize) {
    var r = new Size2(this.width - otherSize.width, this.height - otherSize.height);
    return r;
  };
  Size2.Lerp = function(start, end, amount) {
    var w = start.width + (end.width - start.width) * amount;
    var h = start.height + (end.height - start.height) * amount;
    return new Size2(w, h);
  };
  return Size2;
}();
var ThinTexture = function() {
  function ThinTexture2(internalTexture) {
    this._wrapU = 1;
    this._wrapV = 1;
    this.wrapR = 1;
    this.anisotropicFilteringLevel = 4;
    this.delayLoadState = 0;
    this._texture = null;
    this._engine = null;
    this._cachedSize = Size.Zero();
    this._cachedBaseSize = Size.Zero();
    this._initialSamplingMode = 2;
    this._texture = internalTexture;
    if (this._texture) {
      this._engine = this._texture.getEngine();
    }
  }
  Object.defineProperty(ThinTexture2.prototype, "wrapU", {
    get: function() {
      return this._wrapU;
    },
    set: function(value) {
      this._wrapU = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "wrapV", {
    get: function() {
      return this._wrapV;
    },
    set: function(value) {
      this._wrapV = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "coordinatesMode", {
    get: function() {
      return 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "isCube", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.isCube;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.isCube = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "is3D", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is3D;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is3D = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ThinTexture2.prototype, "is2DArray", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is2DArray;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is2DArray = value;
    },
    enumerable: false,
    configurable: true
  });
  ThinTexture2.prototype.getClassName = function() {
    return "ThinTexture";
  };
  ThinTexture2.prototype.isReady = function() {
    if (this.delayLoadState === 4) {
      this.delayLoad();
      return false;
    }
    if (this._texture) {
      return this._texture.isReady;
    }
    return false;
  };
  ThinTexture2.prototype.delayLoad = function() {
  };
  ThinTexture2.prototype.getInternalTexture = function() {
    return this._texture;
  };
  ThinTexture2.prototype.getSize = function() {
    if (this._texture) {
      if (this._texture.width) {
        this._cachedSize.width = this._texture.width;
        this._cachedSize.height = this._texture.height;
        return this._cachedSize;
      }
      if (this._texture._size) {
        this._cachedSize.width = this._texture._size;
        this._cachedSize.height = this._texture._size;
        return this._cachedSize;
      }
    }
    return this._cachedSize;
  };
  ThinTexture2.prototype.getBaseSize = function() {
    if (!this.isReady() || !this._texture) {
      this._cachedBaseSize.width = 0;
      this._cachedBaseSize.height = 0;
      return this._cachedBaseSize;
    }
    if (this._texture._size) {
      this._cachedBaseSize.width = this._texture._size;
      this._cachedBaseSize.height = this._texture._size;
      return this._cachedBaseSize;
    }
    this._cachedBaseSize.width = this._texture.baseWidth;
    this._cachedBaseSize.height = this._texture.baseHeight;
    return this._cachedBaseSize;
  };
  Object.defineProperty(ThinTexture2.prototype, "samplingMode", {
    get: function() {
      if (!this._texture) {
        return this._initialSamplingMode;
      }
      return this._texture.samplingMode;
    },
    enumerable: false,
    configurable: true
  });
  ThinTexture2.prototype.updateSamplingMode = function(samplingMode) {
    if (this._texture && this._engine) {
      this._engine.updateTextureSamplingMode(samplingMode, this._texture);
    }
  };
  ThinTexture2.prototype.releaseInternalTexture = function() {
    if (this._texture) {
      this._texture.dispose();
      this._texture = null;
    }
  };
  ThinTexture2.prototype.dispose = function() {
    if (this._texture) {
      this.releaseInternalTexture();
      this._engine = null;
    }
  };
  return ThinTexture2;
}();
var BaseTexture = function(_super) {
  __extends(BaseTexture2, _super);
  function BaseTexture2(sceneOrEngine) {
    var _this = _super.call(this, null) || this;
    _this.metadata = null;
    _this.reservedDataStore = null;
    _this._hasAlpha = false;
    _this._getAlphaFromRGB = false;
    _this.level = 1;
    _this._coordinatesIndex = 0;
    _this._coordinatesMode = 0;
    _this.wrapR = 1;
    _this.anisotropicFilteringLevel = BaseTexture2.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;
    _this._isCube = false;
    _this._gammaSpace = true;
    _this.invertZ = false;
    _this.lodLevelInAlpha = false;
    _this.isRenderTarget = false;
    _this._prefiltered = false;
    _this._forceSerialize = false;
    _this.animations = new Array();
    _this.onDisposeObservable = new Observable();
    _this._onDisposeObserver = null;
    _this._scene = null;
    _this._uid = null;
    _this._parentContainer = null;
    _this._loadingError = false;
    if (sceneOrEngine) {
      if (BaseTexture2._IsScene(sceneOrEngine)) {
        _this._scene = sceneOrEngine;
      } else {
        _this._engine = sceneOrEngine;
      }
    } else {
      _this._scene = EngineStore.LastCreatedScene;
    }
    if (_this._scene) {
      _this.uniqueId = _this._scene.getUniqueId();
      _this._scene.addTexture(_this);
      _this._engine = _this._scene.getEngine();
    }
    _this._uid = null;
    return _this;
  }
  Object.defineProperty(BaseTexture2.prototype, "hasAlpha", {
    get: function() {
      return this._hasAlpha;
    },
    set: function(value) {
      var _this = this;
      if (this._hasAlpha === value) {
        return;
      }
      this._hasAlpha = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1, function(mat) {
          return mat.hasTexture(_this);
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "getAlphaFromRGB", {
    get: function() {
      return this._getAlphaFromRGB;
    },
    set: function(value) {
      var _this = this;
      if (this._getAlphaFromRGB === value) {
        return;
      }
      this._getAlphaFromRGB = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1, function(mat) {
          return mat.hasTexture(_this);
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "coordinatesIndex", {
    get: function() {
      return this._coordinatesIndex;
    },
    set: function(value) {
      var _this = this;
      if (this._coordinatesIndex === value) {
        return;
      }
      this._coordinatesIndex = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1, function(mat) {
          return mat.hasTexture(_this);
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "coordinatesMode", {
    get: function() {
      return this._coordinatesMode;
    },
    set: function(value) {
      var _this = this;
      if (this._coordinatesMode === value) {
        return;
      }
      this._coordinatesMode = value;
      if (this._scene) {
        this._scene.markAllMaterialsAsDirty(1, function(mat) {
          return mat.hasTexture(_this);
        });
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapU", {
    get: function() {
      return this._wrapU;
    },
    set: function(value) {
      this._wrapU = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "wrapV", {
    get: function() {
      return this._wrapV;
    },
    set: function(value) {
      this._wrapV = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "isCube", {
    get: function() {
      if (!this._texture) {
        return this._isCube;
      }
      return this._texture.isCube;
    },
    set: function(value) {
      if (!this._texture) {
        this._isCube = value;
      } else {
        this._texture.isCube = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "is3D", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is3D;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is3D = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "is2DArray", {
    get: function() {
      if (!this._texture) {
        return false;
      }
      return this._texture.is2DArray;
    },
    set: function(value) {
      if (!this._texture) {
        return;
      }
      this._texture.is2DArray = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "gammaSpace", {
    get: function() {
      if (!this._texture) {
        return this._gammaSpace;
      } else {
        if (this._texture._gammaSpace === null) {
          this._texture._gammaSpace = this._gammaSpace;
        }
      }
      return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
    },
    set: function(gamma) {
      if (!this._texture) {
        if (this._gammaSpace === gamma) {
          return;
        }
        this._gammaSpace = gamma;
      } else {
        if (this._texture._gammaSpace === gamma) {
          return;
        }
        this._texture._gammaSpace = gamma;
      }
      this._markAllSubMeshesAsTexturesDirty();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "isRGBD", {
    get: function() {
      return this._texture != null && this._texture._isRGBD;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._isRGBD = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "noMipmap", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "lodGenerationOffset", {
    get: function() {
      if (this._texture) {
        return this._texture._lodGenerationOffset;
      }
      return 0;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._lodGenerationOffset = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "lodGenerationScale", {
    get: function() {
      if (this._texture) {
        return this._texture._lodGenerationScale;
      }
      return 0;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._lodGenerationScale = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "linearSpecularLOD", {
    get: function() {
      if (this._texture) {
        return this._texture._linearSpecularLOD;
      }
      return false;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._linearSpecularLOD = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "irradianceTexture", {
    get: function() {
      if (this._texture) {
        return this._texture._irradianceTexture;
      }
      return null;
    },
    set: function(value) {
      if (this._texture) {
        this._texture._irradianceTexture = value;
      }
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "uid", {
    get: function() {
      if (!this._uid) {
        this._uid = RandomGUID();
      }
      return this._uid;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.toString = function() {
    return this.name;
  };
  BaseTexture2.prototype.getClassName = function() {
    return "BaseTexture";
  };
  Object.defineProperty(BaseTexture2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "isBlocking", {
    get: function() {
      return true;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "loadingError", {
    get: function() {
      return this._loadingError;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "errorObject", {
    get: function() {
      return this._errorObject;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.getScene = function() {
    return this._scene;
  };
  BaseTexture2.prototype._getEngine = function() {
    return this._engine;
  };
  BaseTexture2.prototype.checkTransformsAreIdentical = function(texture) {
    return texture !== null;
  };
  BaseTexture2.prototype.getTextureMatrix = function() {
    return Matrix.IdentityReadOnly;
  };
  BaseTexture2.prototype.getReflectionTextureMatrix = function() {
    return Matrix.IdentityReadOnly;
  };
  BaseTexture2.prototype.isReadyOrNotBlocking = function() {
    return !this.isBlocking || this.isReady() || this.loadingError;
  };
  BaseTexture2.prototype.scale = function(ratio) {
  };
  Object.defineProperty(BaseTexture2.prototype, "canRescale", {
    get: function() {
      return false;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype._getFromCache = function(url, noMipmap, sampling, invertY, useSRGBBuffer) {
    var engine = this._getEngine();
    if (!engine) {
      return null;
    }
    var correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
    var texturesCache = engine.getLoadedTexturesCache();
    for (var index = 0; index < texturesCache.length; index++) {
      var texturesCacheEntry = texturesCache[index];
      if (useSRGBBuffer === void 0 || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {
        if (invertY === void 0 || invertY === texturesCacheEntry.invertY) {
          if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {
            if (!sampling || sampling === texturesCacheEntry.samplingMode) {
              texturesCacheEntry.incrementReferences();
              return texturesCacheEntry;
            }
          }
        }
      }
    }
    return null;
  };
  BaseTexture2.prototype._rebuild = function() {
  };
  BaseTexture2.prototype.clone = function() {
    return null;
  };
  Object.defineProperty(BaseTexture2.prototype, "textureType", {
    get: function() {
      if (!this._texture) {
        return 0;
      }
      return this._texture.type !== void 0 ? this._texture.type : 0;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "textureFormat", {
    get: function() {
      if (!this._texture) {
        return 5;
      }
      return this._texture.format !== void 0 ? this._texture.format : 5;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype._markAllSubMeshesAsTexturesDirty = function() {
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    scene.markAllMaterialsAsDirty(1);
  };
  BaseTexture2.prototype.readPixels = function(faceIndex, level, buffer, flushRenderer, noDataConversion, x, y, width, height) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (level === void 0) {
      level = 0;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (flushRenderer === void 0) {
      flushRenderer = true;
    }
    if (noDataConversion === void 0) {
      noDataConversion = false;
    }
    if (x === void 0) {
      x = 0;
    }
    if (y === void 0) {
      y = 0;
    }
    if (width === void 0) {
      width = Number.MAX_VALUE;
    }
    if (height === void 0) {
      height = Number.MAX_VALUE;
    }
    if (!this._texture) {
      return null;
    }
    var engine = this._getEngine();
    if (!engine) {
      return null;
    }
    var size = this.getSize();
    var maxWidth = size.width;
    var maxHeight = size.height;
    if (level !== 0) {
      maxWidth = maxWidth / Math.pow(2, level);
      maxHeight = maxHeight / Math.pow(2, level);
      maxWidth = Math.round(maxWidth);
      maxHeight = Math.round(maxHeight);
    }
    width = Math.min(maxWidth, width);
    height = Math.min(maxHeight, height);
    try {
      if (this._texture.isCube) {
        return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);
      }
      return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);
    } catch (e) {
      return null;
    }
  };
  BaseTexture2.prototype._readPixelsSync = function(faceIndex, level, buffer, flushRenderer, noDataConversion) {
    if (faceIndex === void 0) {
      faceIndex = 0;
    }
    if (level === void 0) {
      level = 0;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (flushRenderer === void 0) {
      flushRenderer = true;
    }
    if (noDataConversion === void 0) {
      noDataConversion = false;
    }
    if (!this._texture) {
      return null;
    }
    var size = this.getSize();
    var width = size.width;
    var height = size.height;
    var engine = this._getEngine();
    if (!engine) {
      return null;
    }
    if (level != 0) {
      width = width / Math.pow(2, level);
      height = height / Math.pow(2, level);
      width = Math.round(width);
      height = Math.round(height);
    }
    try {
      if (this._texture.isCube) {
        return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);
      }
      return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);
    } catch (e) {
      return null;
    }
  };
  Object.defineProperty(BaseTexture2.prototype, "_lodTextureHigh", {
    get: function() {
      if (this._texture) {
        return this._texture._lodTextureHigh;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "_lodTextureMid", {
    get: function() {
      if (this._texture) {
        return this._texture._lodTextureMid;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(BaseTexture2.prototype, "_lodTextureLow", {
    get: function() {
      if (this._texture) {
        return this._texture._lodTextureLow;
      }
      return null;
    },
    enumerable: false,
    configurable: true
  });
  BaseTexture2.prototype.dispose = function() {
    if (this._scene) {
      if (this._scene.stopAnimation) {
        this._scene.stopAnimation(this);
      }
      this._scene._removePendingData(this);
      var index = this._scene.textures.indexOf(this);
      if (index >= 0) {
        this._scene.textures.splice(index, 1);
      }
      this._scene.onTextureRemovedObservable.notifyObservers(this);
      this._scene = null;
      if (this._parentContainer) {
        var index_1 = this._parentContainer.textures.indexOf(this);
        if (index_1 > -1) {
          this._parentContainer.textures.splice(index_1, 1);
        }
        this._parentContainer = null;
      }
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.metadata = null;
    _super.prototype.dispose.call(this);
  };
  BaseTexture2.prototype.serialize = function() {
    if (!this.name) {
      return null;
    }
    var serializationObject = SerializationHelper.Serialize(this);
    SerializationHelper.AppendSerializedAnimations(this, serializationObject);
    return serializationObject;
  };
  BaseTexture2.WhenAllReady = function(textures, callback) {
    var numRemaining = textures.length;
    if (numRemaining === 0) {
      callback();
      return;
    }
    for (var i = 0; i < textures.length; i++) {
      var texture = textures[i];
      if (texture.isReady()) {
        if (--numRemaining === 0) {
          callback();
        }
      } else {
        var onLoadObservable = texture.onLoadObservable;
        if (onLoadObservable) {
          onLoadObservable.addOnce(function() {
            if (--numRemaining === 0) {
              callback();
            }
          });
        } else {
          if (--numRemaining === 0) {
            callback();
          }
        }
      }
    }
  };
  BaseTexture2._IsScene = function(sceneOrEngine) {
    return sceneOrEngine.getClassName() === "Scene";
  };
  BaseTexture2.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "uniqueId", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "name", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "metadata", void 0);
  __decorate([
    serialize("hasAlpha")
  ], BaseTexture2.prototype, "_hasAlpha", void 0);
  __decorate([
    serialize("getAlphaFromRGB")
  ], BaseTexture2.prototype, "_getAlphaFromRGB", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "level", void 0);
  __decorate([
    serialize("coordinatesIndex")
  ], BaseTexture2.prototype, "_coordinatesIndex", void 0);
  __decorate([
    serialize("coordinatesMode")
  ], BaseTexture2.prototype, "_coordinatesMode", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "wrapU", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "wrapV", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "wrapR", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "anisotropicFilteringLevel", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "isCube", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "is3D", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "is2DArray", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "gammaSpace", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "invertZ", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "lodLevelInAlpha", void 0);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "lodGenerationOffset", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "lodGenerationScale", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "linearSpecularLOD", null);
  __decorate([
    serializeAsTexture()
  ], BaseTexture2.prototype, "irradianceTexture", null);
  __decorate([
    serialize()
  ], BaseTexture2.prototype, "isRenderTarget", void 0);
  return BaseTexture2;
}(ThinTexture);
function GenerateBase64StringFromPixelData(pixels, size, invertY) {
  if (invertY === void 0) {
    invertY = false;
  }
  var width = size.width;
  var height = size.height;
  if (pixels instanceof Float32Array) {
    var len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;
    var npixels = new Uint8Array(len);
    while (--len >= 0) {
      var val = pixels[len];
      if (val < 0) {
        val = 0;
      } else if (val > 1) {
        val = 1;
      }
      npixels[len] = val * 255;
    }
    pixels = npixels;
  }
  var canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  var imageData = ctx.createImageData(width, height);
  var castData = imageData.data;
  castData.set(pixels);
  ctx.putImageData(imageData, 0, 0);
  if (invertY) {
    var canvas2 = document.createElement("canvas");
    canvas2.width = width;
    canvas2.height = height;
    var ctx2 = canvas2.getContext("2d");
    if (!ctx2) {
      return null;
    }
    ctx2.translate(0, height);
    ctx2.scale(1, -1);
    ctx2.drawImage(canvas, 0, 0);
    return canvas2.toDataURL("image/png");
  }
  return canvas.toDataURL("image/png");
}
function GenerateBase64StringFromTexture(texture, faceIndex, level) {
  if (faceIndex === void 0) {
    faceIndex = 0;
  }
  if (level === void 0) {
    level = 0;
  }
  var internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return null;
  }
  var pixels = texture._readPixelsSync(faceIndex, level);
  if (!pixels) {
    return null;
  }
  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
function GenerateBase64StringFromTextureAsync(texture, faceIndex, level) {
  if (faceIndex === void 0) {
    faceIndex = 0;
  }
  if (level === void 0) {
    level = 0;
  }
  return __awaiter(this, void 0, void 0, function() {
    var internalTexture, pixels;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          internalTexture = texture.getInternalTexture();
          if (!internalTexture) {
            return [2, null];
          }
          return [4, texture.readPixels(faceIndex, level)];
        case 1:
          pixels = _a2.sent();
          if (!pixels) {
            return [2, null];
          }
          return [2, GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY)];
      }
    });
  });
}
var Texture = function(_super) {
  __extends(Texture2, _super);
  function Texture2(url, sceneOrEngine, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, mimeType, loaderOptions, creationFlags, forcedExtension) {
    if (samplingMode === void 0) {
      samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (buffer === void 0) {
      buffer = null;
    }
    if (deleteBuffer === void 0) {
      deleteBuffer = false;
    }
    var _this = this;
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j;
    _this = _super.call(this, sceneOrEngine) || this;
    _this.url = null;
    _this.uOffset = 0;
    _this.vOffset = 0;
    _this.uScale = 1;
    _this.vScale = 1;
    _this.uAng = 0;
    _this.vAng = 0;
    _this.wAng = 0;
    _this.uRotationCenter = 0.5;
    _this.vRotationCenter = 0.5;
    _this.wRotationCenter = 0.5;
    _this.homogeneousRotationInUVTransform = false;
    _this.inspectableCustomProperties = null;
    _this._noMipmap = false;
    _this._invertY = false;
    _this._rowGenerationMatrix = null;
    _this._cachedTextureMatrix = null;
    _this._projectionModeMatrix = null;
    _this._t0 = null;
    _this._t1 = null;
    _this._t2 = null;
    _this._cachedUOffset = -1;
    _this._cachedVOffset = -1;
    _this._cachedUScale = 0;
    _this._cachedVScale = 0;
    _this._cachedUAng = -1;
    _this._cachedVAng = -1;
    _this._cachedWAng = -1;
    _this._cachedProjectionMatrixId = -1;
    _this._cachedURotationCenter = -1;
    _this._cachedVRotationCenter = -1;
    _this._cachedWRotationCenter = -1;
    _this._cachedHomogeneousRotationInUVTransform = false;
    _this._cachedCoordinatesMode = -1;
    _this._buffer = null;
    _this._deleteBuffer = false;
    _this._format = null;
    _this._delayedOnLoad = null;
    _this._delayedOnError = null;
    _this.onLoadObservable = new Observable();
    _this._isBlocking = true;
    _this.name = url || "";
    _this.url = url;
    var noMipmap;
    var useSRGBBuffer = false;
    var internalTexture = null;
    if (typeof noMipmapOrOptions === "object" && noMipmapOrOptions !== null) {
      noMipmap = (_a2 = noMipmapOrOptions.noMipmap) !== null && _a2 !== void 0 ? _a2 : false;
      invertY = (_b2 = noMipmapOrOptions.invertY) !== null && _b2 !== void 0 ? _b2 : CompatibilityOptions.UseOpenGLOrientationForUV ? false : true;
      samplingMode = (_c2 = noMipmapOrOptions.samplingMode) !== null && _c2 !== void 0 ? _c2 : Texture2.TRILINEAR_SAMPLINGMODE;
      onLoad = (_d = noMipmapOrOptions.onLoad) !== null && _d !== void 0 ? _d : null;
      onError = (_e = noMipmapOrOptions.onError) !== null && _e !== void 0 ? _e : null;
      buffer = (_f = noMipmapOrOptions.buffer) !== null && _f !== void 0 ? _f : null;
      deleteBuffer = (_g = noMipmapOrOptions.deleteBuffer) !== null && _g !== void 0 ? _g : false;
      format = noMipmapOrOptions.format;
      mimeType = noMipmapOrOptions.mimeType;
      loaderOptions = noMipmapOrOptions.loaderOptions;
      creationFlags = noMipmapOrOptions.creationFlags;
      useSRGBBuffer = (_h = noMipmapOrOptions.useSRGBBuffer) !== null && _h !== void 0 ? _h : false;
      internalTexture = (_j = noMipmapOrOptions.internalTexture) !== null && _j !== void 0 ? _j : null;
    } else {
      noMipmap = !!noMipmapOrOptions;
    }
    _this._noMipmap = noMipmap;
    _this._invertY = invertY === void 0 ? CompatibilityOptions.UseOpenGLOrientationForUV ? false : true : invertY;
    _this._initialSamplingMode = samplingMode;
    _this._buffer = buffer;
    _this._deleteBuffer = deleteBuffer;
    _this._mimeType = mimeType;
    _this._loaderOptions = loaderOptions;
    _this._creationFlags = creationFlags;
    _this._useSRGBBuffer = useSRGBBuffer;
    _this._forcedExtension = forcedExtension;
    if (format) {
      _this._format = format;
    }
    var scene = _this.getScene();
    var engine = _this._getEngine();
    if (!engine) {
      return _this;
    }
    engine.onBeforeTextureInitObservable.notifyObservers(_this);
    var load = function() {
      if (_this._texture) {
        if (_this._texture._invertVScale) {
          _this.vScale *= -1;
          _this.vOffset += 1;
        }
        if (_this._texture._cachedWrapU !== null) {
          _this.wrapU = _this._texture._cachedWrapU;
          _this._texture._cachedWrapU = null;
        }
        if (_this._texture._cachedWrapV !== null) {
          _this.wrapV = _this._texture._cachedWrapV;
          _this._texture._cachedWrapV = null;
        }
        if (_this._texture._cachedWrapR !== null) {
          _this.wrapR = _this._texture._cachedWrapR;
          _this._texture._cachedWrapR = null;
        }
      }
      if (_this.onLoadObservable.hasObservers()) {
        _this.onLoadObservable.notifyObservers(_this);
      }
      if (onLoad) {
        onLoad();
      }
      if (!_this.isBlocking && scene) {
        scene.resetCachedMaterial();
      }
    };
    var errorHandler = function(message, exception) {
      _this._loadingError = true;
      _this._errorObject = { message, exception };
      if (onError) {
        onError(message, exception);
      }
      Texture2.OnTextureLoadErrorObservable.notifyObservers(_this);
    };
    if (!_this.url) {
      _this._delayedOnLoad = load;
      _this._delayedOnError = errorHandler;
      return _this;
    }
    _this._texture = internalTexture !== null && internalTexture !== void 0 ? internalTexture : _this._getFromCache(_this.url, noMipmap, samplingMode, _this._invertY, useSRGBBuffer);
    if (!_this._texture) {
      if (!scene || !scene.useDelayedTextureLoading) {
        try {
          _this._texture = engine.createTexture(_this.url, noMipmap, _this._invertY, scene, samplingMode, load, errorHandler, _this._buffer, void 0, _this._format, _this._forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer);
        } catch (e) {
          errorHandler("error loading", e);
          throw e;
        }
        if (deleteBuffer) {
          _this._buffer = null;
        }
      } else {
        _this.delayLoadState = 4;
        _this._delayedOnLoad = load;
        _this._delayedOnError = errorHandler;
      }
    } else {
      if (_this._texture.isReady) {
        TimingTools.SetImmediate(function() {
          return load();
        });
      } else {
        var loadObserver_1 = _this._texture.onLoadedObservable.add(load);
        _this._texture.onErrorObservable.add(function(e) {
          var _a3;
          errorHandler(e.message, e.exception);
          (_a3 = _this._texture) === null || _a3 === void 0 ? void 0 : _a3.onLoadedObservable.remove(loadObserver_1);
        });
      }
    }
    return _this;
  }
  Object.defineProperty(Texture2.prototype, "noMipmap", {
    get: function() {
      return this._noMipmap;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "mimeType", {
    get: function() {
      return this._mimeType;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "isBlocking", {
    get: function() {
      return this._isBlocking;
    },
    set: function(value) {
      this._isBlocking = value;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Texture2.prototype, "invertY", {
    get: function() {
      return this._invertY;
    },
    enumerable: false,
    configurable: true
  });
  Texture2.prototype.updateURL = function(url, buffer, onLoad, forcedExtension) {
    if (buffer === void 0) {
      buffer = null;
    }
    if (this.url) {
      this.releaseInternalTexture();
      this.getScene().markAllMaterialsAsDirty(1);
    }
    if (!this.name || this.name.startsWith("data:")) {
      this.name = url;
    }
    this.url = url;
    this._buffer = buffer;
    this._forcedExtension = forcedExtension;
    this.delayLoadState = 4;
    if (onLoad) {
      this._delayedOnLoad = onLoad;
    }
    this.delayLoad();
  };
  Texture2.prototype.delayLoad = function() {
    if (this.delayLoadState !== 4) {
      return;
    }
    var scene = this.getScene();
    if (!scene) {
      return;
    }
    this.delayLoadState = 1;
    this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer);
    if (!this._texture) {
      this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer);
      if (this._deleteBuffer) {
        this._buffer = null;
      }
    } else {
      if (this._delayedOnLoad) {
        if (this._texture.isReady) {
          TimingTools.SetImmediate(this._delayedOnLoad);
        } else {
          this._texture.onLoadedObservable.add(this._delayedOnLoad);
        }
      }
    }
    this._delayedOnLoad = null;
    this._delayedOnError = null;
  };
  Texture2.prototype._prepareRowForTextureGeneration = function(x, y, z, t) {
    x *= this._cachedUScale;
    y *= this._cachedVScale;
    x -= this.uRotationCenter * this._cachedUScale;
    y -= this.vRotationCenter * this._cachedVScale;
    z -= this.wRotationCenter;
    Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);
    t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;
    t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;
    t.z += this.wRotationCenter;
  };
  Texture2.prototype.checkTransformsAreIdentical = function(texture) {
    return texture !== null && this.uOffset === texture.uOffset && this.vOffset === texture.vOffset && this.uScale === texture.uScale && this.vScale === texture.vScale && this.uAng === texture.uAng && this.vAng === texture.vAng && this.wAng === texture.wAng;
  };
  Texture2.prototype.getTextureMatrix = function(uBase) {
    var _this = this;
    if (uBase === void 0) {
      uBase = 1;
    }
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * uBase === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {
      return this._cachedTextureMatrix;
    }
    this._cachedUOffset = this.uOffset;
    this._cachedVOffset = this.vOffset;
    this._cachedUScale = this.uScale * uBase;
    this._cachedVScale = this.vScale;
    this._cachedUAng = this.uAng;
    this._cachedVAng = this.vAng;
    this._cachedWAng = this.wAng;
    this._cachedURotationCenter = this.uRotationCenter;
    this._cachedVRotationCenter = this.vRotationCenter;
    this._cachedWRotationCenter = this.wRotationCenter;
    this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;
    if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {
      this._cachedTextureMatrix = Matrix.Zero();
      this._rowGenerationMatrix = new Matrix();
      this._t0 = Vector3.Zero();
      this._t1 = Vector3.Zero();
      this._t2 = Vector3.Zero();
    }
    Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);
    if (this.homogeneousRotationInUVTransform) {
      Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);
      Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);
      Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);
      Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);
      TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);
      this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);
      this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);
    } else {
      this._prepareRowForTextureGeneration(0, 0, 0, this._t0);
      this._prepareRowForTextureGeneration(1, 0, 0, this._t1);
      this._prepareRowForTextureGeneration(0, 1, 0, this._t2);
      this._t1.subtractInPlace(this._t0);
      this._t2.subtractInPlace(this._t0);
      Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix);
    }
    var scene = this.getScene();
    if (!scene) {
      return this._cachedTextureMatrix;
    }
    scene.markAllMaterialsAsDirty(1, function(mat) {
      return mat.hasTexture(_this);
    });
    return this._cachedTextureMatrix;
  };
  Texture2.prototype.getReflectionTextureMatrix = function() {
    var _this = this;
    var scene = this.getScene();
    if (!scene) {
      return this._cachedTextureMatrix;
    }
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale === this._cachedUScale && this.vScale === this._cachedVScale && this.coordinatesMode === this._cachedCoordinatesMode) {
      if (this.coordinatesMode === Texture2.PROJECTION_MODE) {
        if (this._cachedProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {
          return this._cachedTextureMatrix;
        }
      } else {
        return this._cachedTextureMatrix;
      }
    }
    if (!this._cachedTextureMatrix) {
      this._cachedTextureMatrix = Matrix.Zero();
    }
    if (!this._projectionModeMatrix) {
      this._projectionModeMatrix = Matrix.Zero();
    }
    var flagMaterialsAsTextureDirty = this._cachedCoordinatesMode !== this.coordinatesMode;
    this._cachedUOffset = this.uOffset;
    this._cachedVOffset = this.vOffset;
    this._cachedUScale = this.uScale;
    this._cachedVScale = this.vScale;
    this._cachedCoordinatesMode = this.coordinatesMode;
    switch (this.coordinatesMode) {
      case Texture2.PLANAR_MODE: {
        Matrix.IdentityToRef(this._cachedTextureMatrix);
        this._cachedTextureMatrix[0] = this.uScale;
        this._cachedTextureMatrix[5] = this.vScale;
        this._cachedTextureMatrix[12] = this.uOffset;
        this._cachedTextureMatrix[13] = this.vOffset;
        break;
      }
      case Texture2.PROJECTION_MODE: {
        Matrix.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
        var projectionMatrix = scene.getProjectionMatrix();
        this._cachedProjectionMatrixId = projectionMatrix.updateFlag;
        projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedTextureMatrix);
        break;
      }
      default:
        Matrix.IdentityToRef(this._cachedTextureMatrix);
        break;
    }
    if (flagMaterialsAsTextureDirty) {
      scene.markAllMaterialsAsDirty(1, function(mat) {
        return mat.getActiveTextures().indexOf(_this) !== -1;
      });
    }
    return this._cachedTextureMatrix;
  };
  Texture2.prototype.clone = function() {
    var _this = this;
    var options = {
      noMipmap: this._noMipmap,
      invertY: this._invertY,
      samplingMode: this.samplingMode,
      onLoad: void 0,
      onError: void 0,
      buffer: this._texture ? this._texture._buffer : void 0,
      deleteBuffer: this._deleteBuffer,
      format: this.textureFormat,
      mimeType: this.mimeType,
      loaderOptions: this._loaderOptions,
      creationFlags: this._creationFlags,
      useSRGBBuffer: this._useSRGBBuffer
    };
    return SerializationHelper.Clone(function() {
      return new Texture2(_this._texture ? _this._texture.url : null, _this.getScene(), options);
    }, this);
  };
  Texture2.prototype.serialize = function() {
    var savedName = this.name;
    if (!Texture2.SerializeBuffers) {
      if (this.name.startsWith("data:")) {
        this.name = "";
      }
    }
    if (this.name.startsWith("data:") && this.url === this.name) {
      this.url = "";
    }
    var serializationObject = _super.prototype.serialize.call(this);
    if (!serializationObject) {
      return null;
    }
    if (Texture2.SerializeBuffers || Texture2.ForceSerializeBuffers) {
      if (typeof this._buffer === "string" && this._buffer.substr(0, 5) === "data:") {
        serializationObject.base64String = this._buffer;
        serializationObject.name = serializationObject.name.replace("data:", "");
      } else if (this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array) {
        serializationObject.base64String = "data:image/png;base64," + EncodeArrayBufferToBase64(this._buffer);
      } else if (Texture2.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) {
        serializationObject.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);
      }
    }
    serializationObject.invertY = this._invertY;
    serializationObject.samplingMode = this.samplingMode;
    serializationObject._creationFlags = this._creationFlags;
    serializationObject._useSRGBBuffer = this._useSRGBBuffer;
    this.name = savedName;
    return serializationObject;
  };
  Texture2.prototype.getClassName = function() {
    return "Texture";
  };
  Texture2.prototype.dispose = function() {
    _super.prototype.dispose.call(this);
    this.onLoadObservable.clear();
    this._delayedOnLoad = null;
    this._delayedOnError = null;
  };
  Texture2.Parse = function(parsedTexture, scene, rootUrl) {
    if (parsedTexture.customType) {
      var customTexture = InstantiationTools.Instantiate(parsedTexture.customType);
      var parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);
      if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {
        if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {
          parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);
        }
      }
      return parsedCustomTexture;
    }
    if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {
      return Texture2._CubeTextureParser(parsedTexture, scene, rootUrl);
    }
    if (!parsedTexture.name && !parsedTexture.isRenderTarget) {
      return null;
    }
    var onLoaded = function() {
      if (texture && texture._texture) {
        texture._texture._cachedWrapU = null;
        texture._texture._cachedWrapV = null;
        texture._texture._cachedWrapR = null;
      }
      if (parsedTexture.samplingMode) {
        var sampling = parsedTexture.samplingMode;
        if (texture && texture.samplingMode !== sampling) {
          texture.updateSamplingMode(sampling);
        }
      }
      if (texture && parsedTexture.animations) {
        for (var animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
          var parsedAnimation = parsedTexture.animations[animationIndex];
          var internalClass = GetClass("BABYLON.Animation");
          if (internalClass) {
            texture.animations.push(internalClass.Parse(parsedAnimation));
          }
        }
      }
    };
    var texture = SerializationHelper.Parse(function() {
      var _a2, _b2, _c2;
      var generateMipMaps = true;
      if (parsedTexture.noMipmap) {
        generateMipMaps = false;
      }
      if (parsedTexture.mirrorPlane) {
        var mirrorTexture = Texture2._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);
        mirrorTexture._waitingRenderList = parsedTexture.renderList;
        mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);
        onLoaded();
        return mirrorTexture;
      } else if (parsedTexture.isRenderTarget) {
        var renderTargetTexture = null;
        if (parsedTexture.isCube) {
          if (scene.reflectionProbes) {
            for (var index = 0; index < scene.reflectionProbes.length; index++) {
              var probe = scene.reflectionProbes[index];
              if (probe.name === parsedTexture.name) {
                return probe.cubeTexture;
              }
            }
          }
        } else {
          renderTargetTexture = Texture2._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps, (_a2 = parsedTexture._creationFlags) !== null && _a2 !== void 0 ? _a2 : 0);
          renderTargetTexture._waitingRenderList = parsedTexture.renderList;
        }
        onLoaded();
        return renderTargetTexture;
      } else {
        var texture_1;
        if (parsedTexture.base64String) {
          texture_1 = Texture2.CreateFromBase64String(parsedTexture.base64String, parsedTexture.name, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, onLoaded, (_b2 = parsedTexture._creationFlags) !== null && _b2 !== void 0 ? _b2 : 0, (_c2 = parsedTexture._useSRGBBuffer) !== null && _c2 !== void 0 ? _c2 : false);
        } else {
          var url = void 0;
          if (parsedTexture.name && parsedTexture.name.indexOf("://") > 0) {
            url = parsedTexture.name;
          } else {
            url = rootUrl + parsedTexture.name;
          }
          if (parsedTexture.url && (parsedTexture.url.startsWith("data:") || Texture2.UseSerializedUrlIfAny)) {
            url = parsedTexture.url;
          }
          texture_1 = new Texture2(url, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, onLoaded);
        }
        return texture_1;
      }
    }, parsedTexture, scene);
    return texture;
  };
  Texture2.CreateFromBase64String = function(data, name2, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, format, creationFlags) {
    if (samplingMode === void 0) {
      samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (format === void 0) {
      format = 5;
    }
    return new Texture2("data:" + name2, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, void 0, void 0, creationFlags);
  };
  Texture2.LoadFromDataString = function(name2, buffer, scene, deleteBuffer, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, format, creationFlags) {
    if (deleteBuffer === void 0) {
      deleteBuffer = false;
    }
    if (invertY === void 0) {
      invertY = true;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture2.TRILINEAR_SAMPLINGMODE;
    }
    if (onLoad === void 0) {
      onLoad = null;
    }
    if (onError === void 0) {
      onError = null;
    }
    if (format === void 0) {
      format = 5;
    }
    if (name2.substr(0, 5) !== "data:") {
      name2 = "data:" + name2;
    }
    return new Texture2(name2, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, void 0, void 0, creationFlags);
  };
  Texture2.SerializeBuffers = true;
  Texture2.ForceSerializeBuffers = false;
  Texture2.OnTextureLoadErrorObservable = new Observable();
  Texture2._CubeTextureParser = function(jsonTexture, scene, rootUrl) {
    throw _WarnImport("CubeTexture");
  };
  Texture2._CreateMirror = function(name2, renderTargetSize, scene, generateMipMaps) {
    throw _WarnImport("MirrorTexture");
  };
  Texture2._CreateRenderTargetTexture = function(name2, renderTargetSize, scene, generateMipMaps, creationFlags) {
    throw _WarnImport("RenderTargetTexture");
  };
  Texture2.NEAREST_SAMPLINGMODE = 1;
  Texture2.NEAREST_NEAREST_MIPLINEAR = 8;
  Texture2.BILINEAR_SAMPLINGMODE = 2;
  Texture2.LINEAR_LINEAR_MIPNEAREST = 11;
  Texture2.TRILINEAR_SAMPLINGMODE = 3;
  Texture2.LINEAR_LINEAR_MIPLINEAR = 3;
  Texture2.NEAREST_NEAREST_MIPNEAREST = 4;
  Texture2.NEAREST_LINEAR_MIPNEAREST = 5;
  Texture2.NEAREST_LINEAR_MIPLINEAR = 6;
  Texture2.NEAREST_LINEAR = 7;
  Texture2.NEAREST_NEAREST = 1;
  Texture2.LINEAR_NEAREST_MIPNEAREST = 9;
  Texture2.LINEAR_NEAREST_MIPLINEAR = 10;
  Texture2.LINEAR_LINEAR = 2;
  Texture2.LINEAR_NEAREST = 12;
  Texture2.EXPLICIT_MODE = 0;
  Texture2.SPHERICAL_MODE = 1;
  Texture2.PLANAR_MODE = 2;
  Texture2.CUBIC_MODE = 3;
  Texture2.PROJECTION_MODE = 4;
  Texture2.SKYBOX_MODE = 5;
  Texture2.INVCUBIC_MODE = 6;
  Texture2.EQUIRECTANGULAR_MODE = 7;
  Texture2.FIXED_EQUIRECTANGULAR_MODE = 8;
  Texture2.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
  Texture2.CLAMP_ADDRESSMODE = 0;
  Texture2.WRAP_ADDRESSMODE = 1;
  Texture2.MIRROR_ADDRESSMODE = 2;
  Texture2.UseSerializedUrlIfAny = false;
  __decorate([
    serialize()
  ], Texture2.prototype, "url", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uOffset", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vOffset", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uScale", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vScale", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uAng", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vAng", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "wAng", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "uRotationCenter", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "vRotationCenter", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "wRotationCenter", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "homogeneousRotationInUVTransform", void 0);
  __decorate([
    serialize()
  ], Texture2.prototype, "isBlocking", null);
  return Texture2;
}(BaseTexture);
RegisterClass("BABYLON.Texture", Texture);
SerializationHelper._TextureParser = Texture.Parse;
ThinEngine.prototype.updateRawTexture = function(texture, data, format, invertY, compression, type, useSRGBBuffer) {
  if (compression === void 0) {
    compression = null;
  }
  if (type === void 0) {
    type = 0;
  }
  if (useSRGBBuffer === void 0) {
    useSRGBBuffer = false;
  }
  if (!texture) {
    return;
  }
  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
  var internalFormat = this._getInternalFormat(format);
  var textureType = this._getWebGLTextureType(type);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
    texture.format = format;
    texture.type = type;
    texture.invertY = invertY;
    texture._compression = compression;
  }
  if (texture.width % 4 !== 0) {
    this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
  }
  if (compression && data) {
    this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);
  } else {
    this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);
  }
  if (texture.generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression, type, creationFlags, useSRGBBuffer) {
  if (compression === void 0) {
    compression = null;
  }
  if (type === void 0) {
    type = 0;
  }
  if (useSRGBBuffer === void 0) {
    useSRGBBuffer = false;
  }
  var texture = new InternalTexture(this, InternalTextureSource.Raw);
  texture.baseWidth = width;
  texture.baseHeight = height;
  texture.width = width;
  texture.height = height;
  texture.format = format;
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  texture.invertY = invertY;
  texture._compression = compression;
  texture.type = type;
  texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);
  if (!this._doNotHandleContextLost) {
    texture._bufferView = data;
  }
  this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);
  this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);
  this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);
  if (generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_2D);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  this._internalTexturesCache.push(texture);
  return texture;
};
ThinEngine.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression) {
  if (compression === void 0) {
    compression = null;
  }
  var gl = this._gl;
  var texture = new InternalTexture(this, InternalTextureSource.CubeRaw);
  texture.isCube = true;
  texture.format = format;
  texture.type = type;
  if (!this._doNotHandleContextLost) {
    texture._bufferViewArray = data;
  }
  var textureType = this._getWebGLTextureType(type);
  var internalFormat = this._getInternalFormat(format);
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
  }
  if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {
    generateMipMaps = false;
    samplingMode = 1;
    Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
  } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {
    generateMipMaps = false;
    Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
  } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {
    generateMipMaps = false;
    Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
  }
  var width = size;
  var height = width;
  texture.width = width;
  texture.height = height;
  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
  if (!isPot) {
    generateMipMaps = false;
  }
  if (data) {
    this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
  if (data && generateMipMaps) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
  texture.generateMipMaps = generateMipMaps;
  texture.samplingMode = samplingMode;
  return texture;
};
ThinEngine.prototype.updateRawCubeTexture = function(texture, data, format, type, invertY, compression, level) {
  if (compression === void 0) {
    compression = null;
  }
  if (level === void 0) {
    level = 0;
  }
  texture._bufferViewArray = data;
  texture.format = format;
  texture.type = type;
  texture.invertY = invertY;
  texture._compression = compression;
  var gl = this._gl;
  var textureType = this._getWebGLTextureType(type);
  var internalFormat = this._getInternalFormat(format);
  var internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
  var needConversion = false;
  if (internalFormat === gl.RGB) {
    internalFormat = gl.RGBA;
    needConversion = true;
  }
  this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
  this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
  if (texture.width % 4 !== 0) {
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
  }
  for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
    var faceData = data[faceIndex];
    if (compression) {
      gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);
    } else {
      if (needConversion) {
        faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);
      }
      gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);
    }
  }
  var isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
  if (isPot && texture.generateMipMaps && level === 0) {
    this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
  }
  this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
  texture.isReady = true;
};
ThinEngine.prototype.createRawCubeTextureFromUrl = function(url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad, onError, samplingMode, invertY) {
  var _this = this;
  if (onLoad === void 0) {
    onLoad = null;
  }
  if (onError === void 0) {
    onError = null;
  }
  if (samplingMode === void 0) {
    samplingMode = 3;
  }
  if (invertY === void 0) {
    invertY = false;
  }
  var gl = this._gl;
  var texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
  scene === null || scene === void 0 ? void 0 : scene._addPendingData(texture);
  texture.url = url;
  this._internalTexturesCache.push(texture);
  var onerror = function(request, exception) {
    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);
    if (onError && request) {
      onError(request.status + " " + request.statusText, exception);
    }
  };
  var internalCallback = function(data) {
    var width = texture.width;
    var faceDataArrays = callback(data);
    if (!faceDataArrays) {
      return;
    }
    if (mipmapGenerator) {
      var textureType = _this._getWebGLTextureType(type);
      var internalFormat = _this._getInternalFormat(format);
      var internalSizedFomat = _this._getRGBABufferInternalSizedFormat(type);
      var needConversion = false;
      if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
        needConversion = true;
      }
      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      _this._unpackFlipY(false);
      var mipData = mipmapGenerator(faceDataArrays);
      for (var level = 0; level < mipData.length; level++) {
        var mipSize = width >> level;
        for (var faceIndex = 0; faceIndex < 6; faceIndex++) {
          var mipFaceData = mipData[level][faceIndex];
          if (needConversion) {
            mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
          }
          gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);
        }
      }
      _this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    } else {
      _this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);
    }
    texture.isReady = true;
    scene === null || scene === void 0 ? void 0 : scene._removePendingData(texture);
    texture.onLoadedObservable.notifyObservers(texture);
    texture.onLoadedObservable.clear();
    if (onLoad) {
      onLoad();
    }
  };
  this._loadFile(url, function(data) {
    internalCallback(data);
  }, void 0, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);
  return texture;
};
function _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {
  var rgbaData;
  var val1 = 1;
  if (textureType === 1) {
    rgbaData = new Float32Array(width * height * 4);
  } else if (textureType === 2) {
    rgbaData = new Uint16Array(width * height * 4);
    val1 = 15360;
  } else if (textureType === 7) {
    rgbaData = new Uint32Array(width * height * 4);
  } else {
    rgbaData = new Uint8Array(width * height * 4);
  }
  for (var x = 0; x < width; x++) {
    for (var y = 0; y < height; y++) {
      var index = (y * width + x) * 3;
      var newIndex = (y * width + x) * 4;
      rgbaData[newIndex + 0] = rgbData[index + 0];
      rgbaData[newIndex + 1] = rgbData[index + 1];
      rgbaData[newIndex + 2] = rgbData[index + 2];
      rgbaData[newIndex + 3] = val1;
    }
  }
  return rgbaData;
}
function _makeCreateRawTextureFunction(is3D) {
  return function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression, textureType) {
    if (compression === void 0) {
      compression = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var target2 = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    var source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;
    var texture = new InternalTexture(this, source);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.baseDepth = depth;
    texture.width = width;
    texture.height = height;
    texture.depth = depth;
    texture.format = format;
    texture.type = textureType;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    if (is3D) {
      texture.is3D = true;
    } else {
      texture.is2DArray = true;
    }
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
    }
    if (is3D) {
      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
    } else {
      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
    }
    this._bindTextureDirectly(target2, texture, true);
    var filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    this._gl.texParameteri(target2, this._gl.TEXTURE_MAG_FILTER, filters.mag);
    this._gl.texParameteri(target2, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      this._gl.generateMipmap(target2);
    }
    this._bindTextureDirectly(target2, null);
    this._internalTexturesCache.push(texture);
    return texture;
  };
}
ThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);
ThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);
function _makeUpdateRawTextureFunction(is3D) {
  return function(texture, data, format, invertY, compression, textureType) {
    if (compression === void 0) {
      compression = null;
    }
    if (textureType === void 0) {
      textureType = 0;
    }
    var target2 = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    var internalType = this._getWebGLTextureType(textureType);
    var internalFormat = this._getInternalFormat(format);
    var internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);
    this._bindTextureDirectly(target2, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
      texture.format = format;
      texture.invertY = invertY;
      texture._compression = compression;
    }
    if (texture.width % 4 !== 0) {
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
    }
    if (compression && data) {
      this._gl.compressedTexImage3D(target2, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);
    } else {
      this._gl.texImage3D(target2, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);
    }
    if (texture.generateMipMaps) {
      this._gl.generateMipmap(target2);
    }
    this._bindTextureDirectly(target2, null);
    texture.isReady = true;
  };
}
ThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);
ThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);
var RawTexture = function(_super) {
  __extends(RawTexture2, _super);
  function RawTexture2(data, width, height, format, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (type === void 0) {
      type = 0;
    }
    var _this = _super.call(this, null, sceneOrEngine, !generateMipMaps, invertY, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, creationFlags) || this;
    _this.format = format;
    if (!_this._engine) {
      return _this;
    }
    if (!_this._engine._caps.textureFloatLinearFiltering && type === 1) {
      samplingMode = 1;
    }
    if (!_this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {
      samplingMode = 1;
    }
    _this._texture = _this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0, useSRGBBuffer !== null && useSRGBBuffer !== void 0 ? useSRGBBuffer : false);
    _this.wrapU = Texture.CLAMP_ADDRESSMODE;
    _this.wrapV = Texture.CLAMP_ADDRESSMODE;
    return _this;
  }
  RawTexture2.prototype.update = function(data) {
    this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);
  };
  RawTexture2.CreateLuminanceTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    return new RawTexture2(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  };
  RawTexture2.CreateLuminanceAlphaTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    return new RawTexture2(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  };
  RawTexture2.CreateAlphaTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    return new RawTexture2(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);
  };
  RawTexture2.CreateRGBTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (type === void 0) {
      type = 0;
    }
    if (creationFlags === void 0) {
      creationFlags = 0;
    }
    if (useSRGBBuffer === void 0) {
      useSRGBBuffer = false;
    }
    return new RawTexture2(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
  };
  RawTexture2.CreateRGBATexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (type === void 0) {
      type = 0;
    }
    if (creationFlags === void 0) {
      creationFlags = 0;
    }
    if (useSRGBBuffer === void 0) {
      useSRGBBuffer = false;
    }
    return new RawTexture2(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
  };
  RawTexture2.CreateRGBAStorageTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, useSRGBBuffer) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = 3;
    }
    if (type === void 0) {
      type = 0;
    }
    if (useSRGBBuffer === void 0) {
      useSRGBBuffer = false;
    }
    return new RawTexture2(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);
  };
  RawTexture2.CreateRTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    if (type === void 0) {
      type = 1;
    }
    return new RawTexture2(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
  };
  RawTexture2.CreateRStorageTexture = function(data, width, height, sceneOrEngine, generateMipMaps, invertY, samplingMode, type) {
    if (generateMipMaps === void 0) {
      generateMipMaps = true;
    }
    if (invertY === void 0) {
      invertY = false;
    }
    if (samplingMode === void 0) {
      samplingMode = Texture.TRILINEAR_SAMPLINGMODE;
    }
    if (type === void 0) {
      type = 1;
    }
    return new RawTexture2(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);
  };
  return RawTexture2;
}(Texture);
var Particle = function() {
  function Particle2(particleSystem) {
    this.particleSystem = particleSystem;
    this.position = Vector3.Zero();
    this.direction = Vector3.Zero();
    this.color = new Color4(0, 0, 0, 0);
    this.colorStep = new Color4(0, 0, 0, 0);
    this.lifeTime = 1;
    this.age = 0;
    this.size = 0;
    this.scale = new Vector2(1, 1);
    this.angle = 0;
    this.angularSpeed = 0;
    this.cellIndex = 0;
    this._attachedSubEmitters = null;
    this._currentColor1 = new Color4(0, 0, 0, 0);
    this._currentColor2 = new Color4(0, 0, 0, 0);
    this._currentSize1 = 0;
    this._currentSize2 = 0;
    this._currentAngularSpeed1 = 0;
    this._currentAngularSpeed2 = 0;
    this._currentVelocity1 = 0;
    this._currentVelocity2 = 0;
    this._currentLimitVelocity1 = 0;
    this._currentLimitVelocity2 = 0;
    this._currentDrag1 = 0;
    this._currentDrag2 = 0;
    this.id = Particle2._Count++;
    if (!this.particleSystem.isAnimationSheetEnabled) {
      return;
    }
    this._updateCellInfoFromSystem();
  }
  Particle2.prototype._updateCellInfoFromSystem = function() {
    this.cellIndex = this.particleSystem.startSpriteCellID;
  };
  Particle2.prototype.updateCellIndex = function() {
    var offsetAge = this.age;
    var changeSpeed = this.particleSystem.spriteCellChangeSpeed;
    if (this.particleSystem.spriteRandomStartCell) {
      if (this._randomCellOffset === void 0) {
        this._randomCellOffset = Math.random() * this.lifeTime;
      }
      if (changeSpeed === 0) {
        changeSpeed = 1;
        offsetAge = this._randomCellOffset;
      } else {
        offsetAge += this._randomCellOffset;
      }
    }
    var dist = this._initialEndSpriteCellID - this._initialStartSpriteCellID;
    var ratio;
    if (this._initialSpriteCellLoop) {
      ratio = Scalar.Clamp(offsetAge * changeSpeed % this.lifeTime / this.lifeTime);
    } else {
      ratio = Scalar.Clamp(offsetAge * changeSpeed / this.lifeTime);
    }
    this.cellIndex = this._initialStartSpriteCellID + ratio * dist | 0;
  };
  Particle2.prototype._inheritParticleInfoToSubEmitter = function(subEmitter) {
    if (subEmitter.particleSystem.emitter.position) {
      var emitterMesh = subEmitter.particleSystem.emitter;
      emitterMesh.position.copyFrom(this.position);
      if (subEmitter.inheritDirection) {
        var temp = TmpVectors.Vector3[0];
        this.direction.normalizeToRef(temp);
        emitterMesh.setDirection(temp, 0, Math.PI / 2);
      }
    } else {
      var emitterPosition = subEmitter.particleSystem.emitter;
      emitterPosition.copyFrom(this.position);
    }
    this.direction.scaleToRef(subEmitter.inheritedVelocityAmount / 2, TmpVectors.Vector3[0]);
    subEmitter.particleSystem._inheritedVelocityOffset.copyFrom(TmpVectors.Vector3[0]);
  };
  Particle2.prototype._inheritParticleInfoToSubEmitters = function() {
    var _this = this;
    if (this._attachedSubEmitters && this._attachedSubEmitters.length > 0) {
      this._attachedSubEmitters.forEach(function(subEmitter) {
        _this._inheritParticleInfoToSubEmitter(subEmitter);
      });
    }
  };
  Particle2.prototype._reset = function() {
    this.age = 0;
    this.id = Particle2._Count++;
    this._currentColorGradient = null;
    this._currentSizeGradient = null;
    this._currentAngularSpeedGradient = null;
    this._currentVelocityGradient = null;
    this._currentLimitVelocityGradient = null;
    this._currentDragGradient = null;
    this.cellIndex = this.particleSystem.startSpriteCellID;
    this._randomCellOffset = void 0;
  };
  Particle2.prototype.copyTo = function(other) {
    other.position.copyFrom(this.position);
    if (this._initialDirection) {
      if (other._initialDirection) {
        other._initialDirection.copyFrom(this._initialDirection);
      } else {
        other._initialDirection = this._initialDirection.clone();
      }
    } else {
      other._initialDirection = null;
    }
    other.direction.copyFrom(this.direction);
    if (this._localPosition) {
      if (other._localPosition) {
        other._localPosition.copyFrom(this._localPosition);
      } else {
        other._localPosition = this._localPosition.clone();
      }
    }
    other.color.copyFrom(this.color);
    other.colorStep.copyFrom(this.colorStep);
    other.lifeTime = this.lifeTime;
    other.age = this.age;
    other._randomCellOffset = this._randomCellOffset;
    other.size = this.size;
    other.scale.copyFrom(this.scale);
    other.angle = this.angle;
    other.angularSpeed = this.angularSpeed;
    other.particleSystem = this.particleSystem;
    other.cellIndex = this.cellIndex;
    other.id = this.id;
    other._attachedSubEmitters = this._attachedSubEmitters;
    if (this._currentColorGradient) {
      other._currentColorGradient = this._currentColorGradient;
      other._currentColor1.copyFrom(this._currentColor1);
      other._currentColor2.copyFrom(this._currentColor2);
    }
    if (this._currentSizeGradient) {
      other._currentSizeGradient = this._currentSizeGradient;
      other._currentSize1 = this._currentSize1;
      other._currentSize2 = this._currentSize2;
    }
    if (this._currentAngularSpeedGradient) {
      other._currentAngularSpeedGradient = this._currentAngularSpeedGradient;
      other._currentAngularSpeed1 = this._currentAngularSpeed1;
      other._currentAngularSpeed2 = this._currentAngularSpeed2;
    }
    if (this._currentVelocityGradient) {
      other._currentVelocityGradient = this._currentVelocityGradient;
      other._currentVelocity1 = this._currentVelocity1;
      other._currentVelocity2 = this._currentVelocity2;
    }
    if (this._currentLimitVelocityGradient) {
      other._currentLimitVelocityGradient = this._currentLimitVelocityGradient;
      other._currentLimitVelocity1 = this._currentLimitVelocity1;
      other._currentLimitVelocity2 = this._currentLimitVelocity2;
    }
    if (this._currentDragGradient) {
      other._currentDragGradient = this._currentDragGradient;
      other._currentDrag1 = this._currentDrag1;
      other._currentDrag2 = this._currentDrag2;
    }
    if (this.particleSystem.isAnimationSheetEnabled) {
      other._initialStartSpriteCellID = this._initialStartSpriteCellID;
      other._initialEndSpriteCellID = this._initialEndSpriteCellID;
      other._initialSpriteCellLoop = this._initialSpriteCellLoop;
    }
    if (this.particleSystem.useRampGradients) {
      if (other.remapData && this.remapData) {
        other.remapData.copyFrom(this.remapData);
      } else {
        other.remapData = new Vector4(0, 0, 0, 0);
      }
    }
    if (this._randomNoiseCoordinates1) {
      if (other._randomNoiseCoordinates1) {
        other._randomNoiseCoordinates1.copyFrom(this._randomNoiseCoordinates1);
        other._randomNoiseCoordinates2.copyFrom(this._randomNoiseCoordinates2);
      } else {
        other._randomNoiseCoordinates1 = this._randomNoiseCoordinates1.clone();
        other._randomNoiseCoordinates2 = this._randomNoiseCoordinates2.clone();
      }
    }
  };
  Particle2._Count = 0;
  return Particle2;
}();
var SubEmitterType;
(function(SubEmitterType2) {
  SubEmitterType2[SubEmitterType2["ATTACHED"] = 0] = "ATTACHED";
  SubEmitterType2[SubEmitterType2["END"] = 1] = "END";
})(SubEmitterType || (SubEmitterType = {}));
var SubEmitter = function() {
  function SubEmitter2(particleSystem) {
    this.particleSystem = particleSystem;
    this.type = SubEmitterType.END;
    this.inheritDirection = false;
    this.inheritedVelocityAmount = 0;
    if (!particleSystem.emitter || !particleSystem.emitter.dispose) {
      var internalClass = GetClass("BABYLON.AbstractMesh");
      particleSystem.emitter = new internalClass("SubemitterSystemEmitter", particleSystem.getScene());
      particleSystem._disposeEmitterOnDispose = true;
    }
  }
  SubEmitter2.prototype.clone = function() {
    var emitter = this.particleSystem.emitter;
    if (!emitter) {
      emitter = new Vector3();
    } else if (emitter instanceof Vector3) {
      emitter = emitter.clone();
    } else if (emitter.getClassName().indexOf("Mesh") !== -1) {
      var internalClass = GetClass("BABYLON.Mesh");
      emitter = new internalClass("", emitter.getScene());
      emitter.isVisible = false;
    }
    var clone = new SubEmitter2(this.particleSystem.clone(this.particleSystem.name, emitter));
    clone.particleSystem.name += "Clone";
    clone.type = this.type;
    clone.inheritDirection = this.inheritDirection;
    clone.inheritedVelocityAmount = this.inheritedVelocityAmount;
    clone.particleSystem._disposeEmitterOnDispose = true;
    clone.particleSystem.disposeOnStop = true;
    return clone;
  };
  SubEmitter2.prototype.serialize = function(serializeTexture) {
    if (serializeTexture === void 0) {
      serializeTexture = false;
    }
    var serializationObject = {};
    serializationObject.type = this.type;
    serializationObject.inheritDirection = this.inheritDirection;
    serializationObject.inheritedVelocityAmount = this.inheritedVelocityAmount;
    serializationObject.particleSystem = this.particleSystem.serialize(serializeTexture);
    return serializationObject;
  };
  SubEmitter2._ParseParticleSystem = function(system, sceneOrEngine, rootUrl, doNotStart) {
    throw _WarnImport("ParseParticle");
  };
  SubEmitter2.Parse = function(serializationObject, sceneOrEngine, rootUrl) {
    var system = serializationObject.particleSystem;
    var subEmitter = new SubEmitter2(SubEmitter2._ParseParticleSystem(system, sceneOrEngine, rootUrl, true));
    subEmitter.type = serializationObject.type;
    subEmitter.inheritDirection = serializationObject.inheritDirection;
    subEmitter.inheritedVelocityAmount = serializationObject.inheritedVelocityAmount;
    subEmitter.particleSystem._isSubEmitter = true;
    return subEmitter;
  };
  SubEmitter2.prototype.dispose = function() {
    this.particleSystem.dispose();
  };
  return SubEmitter2;
}();
var name$d = "clipPlaneFragmentDeclaration";
var shader$c = "#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n";
ShaderStore.IncludesShadersStore[name$d] = shader$c;
var name$c = "imageProcessingDeclaration";
var shader$b = "#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#ifdef VIGNETTE\nuniform vec2 vInverseScreenSize;\nuniform vec4 vignetteSettings1;\nuniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;\nuniform vec4 vCameraColorCurveNeutral;\nuniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif\n";
ShaderStore.IncludesShadersStore[name$c] = shader$b;
var name$b = "helperFunctions";
var shader$a = "const float PI=3.1415926535897932384626433832795;\nconst float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;\nconst float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;\nconst vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);\nconst float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {\nvec3 i0=inMatrix[0];\nvec3 i1=inMatrix[1];\nvec3 i2=inMatrix[2];\nmat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);\nreturn outMatrix;\n}\nmat3 inverseMat3(mat3 inMatrix) {\nfloat a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];\nfloat a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];\nfloat a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];\nfloat b01=a22*a11-a12*a21;\nfloat b11=-a22*a10+a12*a20;\nfloat b21=a21*a10-a11*a20;\nfloat det=a00*b01+a01*b11+a02*b21;\nreturn mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;\n}\nfloat toLinearSpace(float color)\n{\nreturn pow(color,LinearEncodePowerApprox);\n}\nvec3 toLinearSpace(vec3 color)\n{\nreturn pow(color,vec3(LinearEncodePowerApprox));\n}\nvec4 toLinearSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n}\nvec3 toGammaSpace(vec3 color)\n{\nreturn pow(color,vec3(GammaEncodePowerApprox));\n}\nvec4 toGammaSpace(vec4 color)\n{\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n}\nfloat toGammaSpace(float color)\n{\nreturn pow(color,GammaEncodePowerApprox);\n}\nfloat square(float value)\n{\nreturn value*value;\n}\nvec3 square(vec3 value)\n{\nreturn value*value;\n}\nfloat pow5(float value) {\nfloat sq=value*value;\nreturn sq*sq*value;\n}\nfloat getLuminance(vec3 color)\n{\nreturn clamp(dot(color,LuminanceEncodeApprox),0.,1.);\n}\nfloat getRand(vec2 seed) {\nreturn fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);\n}\nfloat dither(vec2 seed,float varianceAmount) {\nfloat rand=getRand(seed);\nfloat dither=mix(-varianceAmount/255.0,varianceAmount/255.0,rand);\nreturn dither;\n}\nconst float rgbdMaxRange=255.0;\nvec4 toRGBD(vec3 color) {\nfloat maxRGB=maxEps(max(color.r,max(color.g,color.b)));\nfloat D =max(rgbdMaxRange/maxRGB,1.);\nD =clamp(floor(D)/255.0,0.,1.);\nvec3 rgb=color.rgb*D;\nrgb=toGammaSpace(rgb);\nreturn vec4(clamp(rgb,0.,1.),D); \n}\nvec3 fromRGBD(vec4 rgbd) {\nrgbd.rgb=toLinearSpace(rgbd.rgb);\nreturn rgbd.rgb/rgbd.a;\n}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {\nvec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;\nvec3 halfSize=cubeSize*0.5;\nvec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;\nvec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;\nvec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);\nfloat distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);\nvec3 intersectPositionWS=vertexPos+origVec*distance;\nreturn intersectPositionWS-cubePos;\n}\n";
ShaderStore.IncludesShadersStore[name$b] = shader$a;
var name$a = "imageProcessingFunctions";
var shader$9 = "#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n/** \n* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\n* sampler3dSetting.x=textureOffset (0.5/textureSize).\n* sampler3dSetting.y=textureSize.\n*/\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{\nfloat sliceSize=2.0*sampler3dSetting.x; \n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);\nfloat sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;\nsliceUV.x+=sliceInteger*sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice0Color=texture2D(colorTransform,sliceUV);\nsliceUV.x+=sliceSize;\nsliceUV=saturate(sliceUV);\nvec4 slice1Color=texture2D(colorTransform,sliceUV);\nvec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;\n}\n#endif\n#ifdef TONEMAPPING_ACES\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);\nconst mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108, 1.10813,-0.07276),\nvec3(-0.07367,-0.00605, 1.07602)\n);\nvec3 RRTAndODTFit(vec3 v)\n{\nvec3 a=v*(v+0.0245786)-0.000090537;\nvec3 b=v*(0.983729*v+0.4329510)+0.238081;\nreturn a/b;\n}\nvec3 ACESFitted(vec3 color)\n{\ncolor=ACESInputMat*color;\ncolor=RRTAndODTFit(color);\ncolor=ACESOutputMat*color;\ncolor=saturate(color);\nreturn color;\n}\n#endif\nvec4 applyImageProcessing(vec4 result) {\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;\nviewportXY=viewportXY*2.0-1.0;\nvec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);\nfloat vignetteTerm=dot(vignetteXY1,vignetteXY1);\nfloat vignette=pow(vignetteTerm,vignetteSettings2.w);\nvec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);\nresult.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\n#else\nconst float tonemappingCalibration=1.590579;\nresult.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\n#endif\nresult.rgb=toGammaSpace(result.rgb);\nresult.rgb=saturate(result.rgb);\n#ifdef CONTRAST\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);\nif (contrast<1.0) {\nresult.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);\n} else {\nresult.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);\n}\n#endif\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\nfloat luma=getLuminance(result.rgb);\nvec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));\nvec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;\nresult.rgb*=colorCurve.rgb;\nresult.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\nreturn result;\n}";
ShaderStore.IncludesShadersStore[name$a] = shader$9;
var name$9 = "clipPlaneFragment";
var shader$8 = "#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{\ndiscard;\n}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{\ndiscard;\n}\n#endif\n";
ShaderStore.IncludesShadersStore[name$9] = shader$8;
var name$8 = "particlesPixelShader";
var shader$7 = "varying vec2 vUV;\nvarying vec4 vColor;\nuniform vec4 textureMask;\nuniform sampler2D diffuseSampler;\n#include<clipPlaneFragmentDeclaration>\n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\n#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\nuniform sampler2D rampSampler;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec4 textureColor=texture2D(diffuseSampler,vUV);\nvec4 baseColor=(textureColor*textureMask+(vec4(1.,1.,1.,1.)-textureMask))*vColor;\n#ifdef RAMPGRADIENT\nfloat alpha=baseColor.a;\nfloat remappedColorIndex=clamp((alpha-remapRanges.x)/remapRanges.y,0.0,1.0);\nvec4 rampColor=texture2D(rampSampler,vec2(1.0-remappedColorIndex,0.));\nbaseColor.rgb*=rampColor.rgb;\nfloat finalAlpha=baseColor.a;\nbaseColor.a=clamp((alpha*rampColor.a-remapRanges.z)/remapRanges.w,0.0,1.0);\n#endif\n#ifdef BLENDMULTIPLYMODE\nfloat sourceAlpha=vColor.a*textureColor.a;\nbaseColor.rgb=baseColor.rgb*sourceAlpha+vec3(1.0)*(1.0-sourceAlpha);\n#endif\n#ifdef IMAGEPROCESSINGPOSTPROCESS\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\n#else\n#ifdef IMAGEPROCESSING\nbaseColor.rgb=toLinearSpace(baseColor.rgb);\nbaseColor=applyImageProcessing(baseColor);\n#endif\n#endif\ngl_FragColor=baseColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}";
ShaderStore.ShadersStore[name$8] = shader$7;
var name$7 = "clipPlaneVertexDeclaration";
var shader$6 = "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;\nvarying float fClipDistance6;\n#endif\n";
ShaderStore.IncludesShadersStore[name$7] = shader$6;
var name$6 = "clipPlaneVertex";
var shader$5 = "#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n";
ShaderStore.IncludesShadersStore[name$6] = shader$5;
var name$5 = "particlesVertexShader";
var shader$4 = "attribute vec3 position;\nattribute vec4 color;\nattribute float angle;\nattribute vec2 size;\n#ifdef ANIMATESHEET\nattribute float cellIndex;\n#endif\n#ifndef BILLBOARD\nattribute vec3 direction;\n#endif\n#ifdef BILLBOARDSTRETCHED\nattribute vec3 direction;\n#endif\n#ifdef RAMPGRADIENT\nattribute vec4 remapData;\n#endif\nattribute vec2 offset;\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec2 translationPivot;\n#ifdef ANIMATESHEET\nuniform vec3 particlesInfos; \n#endif\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec3 vPositionW;\n#ifdef RAMPGRADIENT\nvarying vec4 remapRanges;\n#endif\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform mat4 invView;\n#endif\n#include<clipPlaneVertexDeclaration>\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\n#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\nvec3 zaxis=normalize(cross(yaxis,xaxis));\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\nmat3 rotMatrix= mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\nreturn position+alignedCorner;\n}\n#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\nvec3 normalizedToCamera=normalize(toCamera);\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\nmat3 rotMatrix= mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\nreturn position+alignedCorner;\n}\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec2 cornerPos;\ncornerPos=(vec2(offset.x-0.5,offset.y -0.5)-translationPivot)*size+translationPivot;\n#ifdef BILLBOARD\nvec3 rotatedCorner;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.y=0.;\nvec3 yaxis=position-eyePosition;\nyaxis.y=0.;\nvPositionW=rotate(normalize(yaxis),rotatedCorner);\nvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\nvec3 toCamera=position-eyePosition;\nvPositionW=rotateAlign(toCamera,rotatedCorner);\nvec3 viewPos=(view*vec4(vPositionW,1.0)).xyz;\n#else\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\nvec3 viewPos=(view*vec4(position,1.0)).xyz+rotatedCorner;\nvPositionW=(invView*vec4(viewPos,1)).xyz;\n#endif\n#ifdef RAMPGRADIENT\nremapRanges=remapData;\n#endif\ngl_Position=projection*vec4(viewPos,1.0);\n#else\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.y=0.;\nvec3 yaxis=normalize(direction);\nvPositionW=rotate(yaxis,rotatedCorner);\ngl_Position=projection*view*vec4(vPositionW,1.0);\n#endif\nvColor=color;\n#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex*particlesInfos.z);\nfloat columnOffset=cellIndex-rowOffset/particlesInfos.z;\nvec2 uvScale=particlesInfos.xy;\nvec2 uvOffset=vec2(offset.x ,1.0-offset.y);\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\n#else\nvUV=offset;\n#endif\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=vec4(vPositionW,1.0);\n#endif\n#include<clipPlaneVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}";
ShaderStore.ShadersStore[name$5] = shader$4;
var ParticleSystem = function(_super) {
  __extends(ParticleSystem2, _super);
  function ParticleSystem2(name2, capacity, sceneOrEngine, customEffect, isAnimationSheetEnabled, epsilon) {
    if (customEffect === void 0) {
      customEffect = null;
    }
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    if (epsilon === void 0) {
      epsilon = 0.01;
    }
    var _this = _super.call(this, name2) || this;
    _this._emitterInverseWorldMatrix = Matrix.Identity();
    _this._inheritedVelocityOffset = new Vector3();
    _this.onDisposeObservable = new Observable();
    _this.onStoppedObservable = new Observable();
    _this._particles = new Array();
    _this._stockParticles = new Array();
    _this._newPartsExcess = 0;
    _this._vertexBuffers = {};
    _this._scaledColorStep = new Color4(0, 0, 0, 0);
    _this._colorDiff = new Color4(0, 0, 0, 0);
    _this._scaledDirection = Vector3.Zero();
    _this._scaledGravity = Vector3.Zero();
    _this._currentRenderId = -1;
    _this._useInstancing = false;
    _this._started = false;
    _this._stopped = false;
    _this._actualFrame = 0;
    _this._currentEmitRate1 = 0;
    _this._currentEmitRate2 = 0;
    _this._currentStartSize1 = 0;
    _this._currentStartSize2 = 0;
    _this._rawTextureWidth = 256;
    _this._useRampGradients = false;
    _this._disposeEmitterOnDispose = false;
    _this.isLocal = false;
    _this._onBeforeDrawParticlesObservable = null;
    _this.recycleParticle = function(particle) {
      var lastParticle = _this._particles.pop();
      if (lastParticle !== particle) {
        lastParticle.copyTo(particle);
      }
      _this._stockParticles.push(lastParticle);
    };
    _this._createParticle = function() {
      var particle;
      if (_this._stockParticles.length !== 0) {
        particle = _this._stockParticles.pop();
        particle._reset();
      } else {
        particle = new Particle(_this);
      }
      if (_this._subEmitters && _this._subEmitters.length > 0) {
        var subEmitters = _this._subEmitters[Math.floor(Math.random() * _this._subEmitters.length)];
        particle._attachedSubEmitters = [];
        subEmitters.forEach(function(subEmitter) {
          if (subEmitter.type === SubEmitterType.ATTACHED) {
            var newEmitter = subEmitter.clone();
            particle._attachedSubEmitters.push(newEmitter);
            newEmitter.particleSystem.start();
          }
        });
      }
      return particle;
    };
    _this._emitFromParticle = function(particle) {
      if (!_this._subEmitters || _this._subEmitters.length === 0) {
        return;
      }
      var templateIndex = Math.floor(Math.random() * _this._subEmitters.length);
      _this._subEmitters[templateIndex].forEach(function(subEmitter) {
        if (subEmitter.type === SubEmitterType.END) {
          var subSystem = subEmitter.clone();
          particle._inheritParticleInfoToSubEmitter(subSystem);
          subSystem.particleSystem._rootParticleSystem = _this;
          _this.activeSubSystems.push(subSystem.particleSystem);
          subSystem.particleSystem.start();
        }
      });
    };
    _this._capacity = capacity;
    _this._epsilon = epsilon;
    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;
    if (!sceneOrEngine || sceneOrEngine.getClassName() === "Scene") {
      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;
      _this._engine = _this._scene.getEngine();
      _this.uniqueId = _this._scene.getUniqueId();
      _this._scene.particleSystems.push(_this);
    } else {
      _this._engine = sceneOrEngine;
      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, _this._engine.isNDCHalfZRange);
    }
    if (_this._engine.getCaps().vertexArrayObject) {
      _this._vertexArrayObject = null;
    }
    _this._attachImageProcessingConfiguration(null);
    _this._customWrappers = { 0: new DrawWrapper(_this._engine) };
    _this._customWrappers[0].effect = customEffect;
    _this._drawWrappers = [];
    _this._useInstancing = _this._engine.getCaps().instancedArrays;
    _this._createIndexBuffer();
    _this._createVertexBuffers();
    _this.particleEmitterType = new BoxParticleEmitter();
    var noiseTextureData = null;
    _this.updateFunction = function(particles) {
      var _a2;
      var noiseTextureSize = null;
      if (_this.noiseTexture) {
        noiseTextureSize = _this.noiseTexture.getSize();
        (_a2 = _this.noiseTexture.getContent()) === null || _a2 === void 0 ? void 0 : _a2.then(function(data) {
          noiseTextureData = data;
        });
      }
      var _loop_1 = function(index2) {
        var particle = particles[index2];
        var scaledUpdateSpeed = _this._scaledUpdateSpeed;
        var previousAge = particle.age;
        particle.age += scaledUpdateSpeed;
        if (particle.age > particle.lifeTime) {
          var diff = particle.age - previousAge;
          var oldDiff = particle.lifeTime - previousAge;
          scaledUpdateSpeed = oldDiff * scaledUpdateSpeed / diff;
          particle.age = particle.lifeTime;
        }
        var ratio = particle.age / particle.lifeTime;
        if (_this._colorGradients && _this._colorGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._colorGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentColorGradient) {
              particle._currentColor1.copyFrom(particle._currentColor2);
              nextGradient.getColorToRef(particle._currentColor2);
              particle._currentColorGradient = currentGradient;
            }
            Color4.LerpToRef(particle._currentColor1, particle._currentColor2, scale, particle.color);
          });
        } else {
          particle.colorStep.scaleToRef(scaledUpdateSpeed, _this._scaledColorStep);
          particle.color.addInPlace(_this._scaledColorStep);
          if (particle.color.a < 0) {
            particle.color.a = 0;
          }
        }
        if (_this._angularSpeedGradients && _this._angularSpeedGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._angularSpeedGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentAngularSpeedGradient) {
              particle._currentAngularSpeed1 = particle._currentAngularSpeed2;
              particle._currentAngularSpeed2 = nextGradient.getFactor();
              particle._currentAngularSpeedGradient = currentGradient;
            }
            particle.angularSpeed = Scalar.Lerp(particle._currentAngularSpeed1, particle._currentAngularSpeed2, scale);
          });
        }
        particle.angle += particle.angularSpeed * scaledUpdateSpeed;
        var directionScale = scaledUpdateSpeed;
        if (_this._velocityGradients && _this._velocityGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._velocityGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentVelocityGradient) {
              particle._currentVelocity1 = particle._currentVelocity2;
              particle._currentVelocity2 = nextGradient.getFactor();
              particle._currentVelocityGradient = currentGradient;
            }
            directionScale *= Scalar.Lerp(particle._currentVelocity1, particle._currentVelocity2, scale);
          });
        }
        particle.direction.scaleToRef(directionScale, _this._scaledDirection);
        if (_this._limitVelocityGradients && _this._limitVelocityGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._limitVelocityGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentLimitVelocityGradient) {
              particle._currentLimitVelocity1 = particle._currentLimitVelocity2;
              particle._currentLimitVelocity2 = nextGradient.getFactor();
              particle._currentLimitVelocityGradient = currentGradient;
            }
            var limitVelocity = Scalar.Lerp(particle._currentLimitVelocity1, particle._currentLimitVelocity2, scale);
            var currentVelocity = particle.direction.length();
            if (currentVelocity > limitVelocity) {
              particle.direction.scaleInPlace(_this.limitVelocityDamping);
            }
          });
        }
        if (_this._dragGradients && _this._dragGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._dragGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentDragGradient) {
              particle._currentDrag1 = particle._currentDrag2;
              particle._currentDrag2 = nextGradient.getFactor();
              particle._currentDragGradient = currentGradient;
            }
            var drag = Scalar.Lerp(particle._currentDrag1, particle._currentDrag2, scale);
            _this._scaledDirection.scaleInPlace(1 - drag);
          });
        }
        if (_this.isLocal && particle._localPosition) {
          particle._localPosition.addInPlace(_this._scaledDirection);
          Vector3.TransformCoordinatesToRef(particle._localPosition, _this._emitterWorldMatrix, particle.position);
        } else {
          particle.position.addInPlace(_this._scaledDirection);
        }
        if (noiseTextureData && noiseTextureSize && particle._randomNoiseCoordinates1) {
          var fetchedColorR = _this._fetchR(particle._randomNoiseCoordinates1.x, particle._randomNoiseCoordinates1.y, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          var fetchedColorG = _this._fetchR(particle._randomNoiseCoordinates1.z, particle._randomNoiseCoordinates2.x, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          var fetchedColorB = _this._fetchR(particle._randomNoiseCoordinates2.y, particle._randomNoiseCoordinates2.z, noiseTextureSize.width, noiseTextureSize.height, noiseTextureData);
          var force = TmpVectors.Vector3[0];
          var scaledForce = TmpVectors.Vector3[1];
          force.copyFromFloats((2 * fetchedColorR - 1) * _this.noiseStrength.x, (2 * fetchedColorG - 1) * _this.noiseStrength.y, (2 * fetchedColorB - 1) * _this.noiseStrength.z);
          force.scaleToRef(scaledUpdateSpeed, scaledForce);
          particle.direction.addInPlace(scaledForce);
        }
        _this.gravity.scaleToRef(scaledUpdateSpeed, _this._scaledGravity);
        particle.direction.addInPlace(_this._scaledGravity);
        if (_this._sizeGradients && _this._sizeGradients.length > 0) {
          GradientHelper.GetCurrentGradient(ratio, _this._sizeGradients, function(currentGradient, nextGradient, scale) {
            if (currentGradient !== particle._currentSizeGradient) {
              particle._currentSize1 = particle._currentSize2;
              particle._currentSize2 = nextGradient.getFactor();
              particle._currentSizeGradient = currentGradient;
            }
            particle.size = Scalar.Lerp(particle._currentSize1, particle._currentSize2, scale);
          });
        }
        if (_this._useRampGradients) {
          if (_this._colorRemapGradients && _this._colorRemapGradients.length > 0) {
            GradientHelper.GetCurrentGradient(ratio, _this._colorRemapGradients, function(currentGradient, nextGradient, scale) {
              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);
              particle.remapData.x = min;
              particle.remapData.y = max - min;
            });
          }
          if (_this._alphaRemapGradients && _this._alphaRemapGradients.length > 0) {
            GradientHelper.GetCurrentGradient(ratio, _this._alphaRemapGradients, function(currentGradient, nextGradient, scale) {
              var min = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
              var max = Scalar.Lerp(currentGradient.factor2, nextGradient.factor2, scale);
              particle.remapData.z = min;
              particle.remapData.w = max - min;
            });
          }
        }
        if (_this._isAnimationSheetEnabled) {
          particle.updateCellIndex();
        }
        particle._inheritParticleInfoToSubEmitters();
        if (particle.age >= particle.lifeTime) {
          _this._emitFromParticle(particle);
          if (particle._attachedSubEmitters) {
            particle._attachedSubEmitters.forEach(function(subEmitter) {
              subEmitter.particleSystem.disposeOnStop = true;
              subEmitter.particleSystem.stop();
            });
            particle._attachedSubEmitters = null;
          }
          _this.recycleParticle(particle);
          index2--;
          return out_index_1 = index2, "continue";
        }
        out_index_1 = index2;
      };
      var out_index_1;
      for (var index = 0; index < particles.length; index++) {
        _loop_1(index);
        index = out_index_1;
      }
    };
    return _this;
  }
  Object.defineProperty(ParticleSystem2.prototype, "onDispose", {
    set: function(callback) {
      if (this._onDisposeObserver) {
        this.onDisposeObservable.remove(this._onDisposeObserver);
      }
      this._onDisposeObserver = this.onDisposeObservable.add(callback);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleSystem2.prototype, "useRampGradients", {
    get: function() {
      return this._useRampGradients;
    },
    set: function(value) {
      if (this._useRampGradients === value) {
        return;
      }
      this._useRampGradients = value;
      this._resetEffect();
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleSystem2.prototype, "particles", {
    get: function() {
      return this._particles;
    },
    enumerable: false,
    configurable: true
  });
  ParticleSystem2.prototype.getActiveCount = function() {
    return this._particles.length;
  };
  ParticleSystem2.prototype.getClassName = function() {
    return "ParticleSystem";
  };
  ParticleSystem2.prototype.isStopping = function() {
    return this._stopped && this.isAlive();
  };
  ParticleSystem2.prototype.getCustomEffect = function(blendMode) {
    var _a2, _b2;
    if (blendMode === void 0) {
      blendMode = 0;
    }
    return (_b2 = (_a2 = this._customWrappers[blendMode]) === null || _a2 === void 0 ? void 0 : _a2.effect) !== null && _b2 !== void 0 ? _b2 : this._customWrappers[0].effect;
  };
  ParticleSystem2.prototype._getCustomDrawWrapper = function(blendMode) {
    var _a2;
    if (blendMode === void 0) {
      blendMode = 0;
    }
    return (_a2 = this._customWrappers[blendMode]) !== null && _a2 !== void 0 ? _a2 : this._customWrappers[0];
  };
  ParticleSystem2.prototype.setCustomEffect = function(effect, blendMode) {
    if (blendMode === void 0) {
      blendMode = 0;
    }
    this._customWrappers[blendMode] = new DrawWrapper(this._engine);
    this._customWrappers[blendMode].effect = effect;
    if (this._customWrappers[blendMode].drawContext) {
      this._customWrappers[blendMode].drawContext.useInstancing = this._useInstancing;
    }
  };
  Object.defineProperty(ParticleSystem2.prototype, "onBeforeDrawParticlesObservable", {
    get: function() {
      if (!this._onBeforeDrawParticlesObservable) {
        this._onBeforeDrawParticlesObservable = new Observable();
      }
      return this._onBeforeDrawParticlesObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleSystem2.prototype, "vertexShaderName", {
    get: function() {
      return "particles";
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleSystem2.prototype, "vertexBuffers", {
    get: function() {
      return this._vertexBuffers;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(ParticleSystem2.prototype, "indexBuffer", {
    get: function() {
      return this._indexBuffer;
    },
    enumerable: false,
    configurable: true
  });
  ParticleSystem2.prototype._addFactorGradient = function(factorGradients, gradient, factor, factor2) {
    var newGradient = new FactorGradient(gradient, factor, factor2);
    factorGradients.push(newGradient);
    factorGradients.sort(function(a, b) {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
  };
  ParticleSystem2.prototype._removeFactorGradient = function(factorGradients, gradient) {
    if (!factorGradients) {
      return;
    }
    var index = 0;
    for (var _i = 0, factorGradients_1 = factorGradients; _i < factorGradients_1.length; _i++) {
      var factorGradient = factorGradients_1[_i];
      if (factorGradient.gradient === gradient) {
        factorGradients.splice(index, 1);
        break;
      }
      index++;
    }
  };
  ParticleSystem2.prototype.addLifeTimeGradient = function(gradient, factor, factor2) {
    if (!this._lifeTimeGradients) {
      this._lifeTimeGradients = [];
    }
    this._addFactorGradient(this._lifeTimeGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeLifeTimeGradient = function(gradient) {
    this._removeFactorGradient(this._lifeTimeGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addSizeGradient = function(gradient, factor, factor2) {
    if (!this._sizeGradients) {
      this._sizeGradients = [];
    }
    this._addFactorGradient(this._sizeGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeSizeGradient = function(gradient) {
    this._removeFactorGradient(this._sizeGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addColorRemapGradient = function(gradient, min, max) {
    if (!this._colorRemapGradients) {
      this._colorRemapGradients = [];
    }
    this._addFactorGradient(this._colorRemapGradients, gradient, min, max);
    return this;
  };
  ParticleSystem2.prototype.removeColorRemapGradient = function(gradient) {
    this._removeFactorGradient(this._colorRemapGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addAlphaRemapGradient = function(gradient, min, max) {
    if (!this._alphaRemapGradients) {
      this._alphaRemapGradients = [];
    }
    this._addFactorGradient(this._alphaRemapGradients, gradient, min, max);
    return this;
  };
  ParticleSystem2.prototype.removeAlphaRemapGradient = function(gradient) {
    this._removeFactorGradient(this._alphaRemapGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addAngularSpeedGradient = function(gradient, factor, factor2) {
    if (!this._angularSpeedGradients) {
      this._angularSpeedGradients = [];
    }
    this._addFactorGradient(this._angularSpeedGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeAngularSpeedGradient = function(gradient) {
    this._removeFactorGradient(this._angularSpeedGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addVelocityGradient = function(gradient, factor, factor2) {
    if (!this._velocityGradients) {
      this._velocityGradients = [];
    }
    this._addFactorGradient(this._velocityGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeVelocityGradient = function(gradient) {
    this._removeFactorGradient(this._velocityGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addLimitVelocityGradient = function(gradient, factor, factor2) {
    if (!this._limitVelocityGradients) {
      this._limitVelocityGradients = [];
    }
    this._addFactorGradient(this._limitVelocityGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeLimitVelocityGradient = function(gradient) {
    this._removeFactorGradient(this._limitVelocityGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addDragGradient = function(gradient, factor, factor2) {
    if (!this._dragGradients) {
      this._dragGradients = [];
    }
    this._addFactorGradient(this._dragGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeDragGradient = function(gradient) {
    this._removeFactorGradient(this._dragGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addEmitRateGradient = function(gradient, factor, factor2) {
    if (!this._emitRateGradients) {
      this._emitRateGradients = [];
    }
    this._addFactorGradient(this._emitRateGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeEmitRateGradient = function(gradient) {
    this._removeFactorGradient(this._emitRateGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype.addStartSizeGradient = function(gradient, factor, factor2) {
    if (!this._startSizeGradients) {
      this._startSizeGradients = [];
    }
    this._addFactorGradient(this._startSizeGradients, gradient, factor, factor2);
    return this;
  };
  ParticleSystem2.prototype.removeStartSizeGradient = function(gradient) {
    this._removeFactorGradient(this._startSizeGradients, gradient);
    return this;
  };
  ParticleSystem2.prototype._createRampGradientTexture = function() {
    if (!this._rampGradients || !this._rampGradients.length || this._rampGradientsTexture || !this._scene) {
      return;
    }
    var data = new Uint8Array(this._rawTextureWidth * 4);
    var tmpColor = TmpColors.Color3[0];
    var _loop_2 = function(x2) {
      var ratio = x2 / this_1._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, this_1._rampGradients, function(currentGradient, nextGradient, scale) {
        Color3.LerpToRef(currentGradient.color, nextGradient.color, scale, tmpColor);
        data[x2 * 4] = tmpColor.r * 255;
        data[x2 * 4 + 1] = tmpColor.g * 255;
        data[x2 * 4 + 2] = tmpColor.b * 255;
        data[x2 * 4 + 3] = 255;
      });
    };
    var this_1 = this;
    for (var x = 0; x < this._rawTextureWidth; x++) {
      _loop_2(x);
    }
    this._rampGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);
  };
  ParticleSystem2.prototype.getRampGradients = function() {
    return this._rampGradients;
  };
  ParticleSystem2.prototype.forceRefreshGradients = function() {
    this._syncRampGradientTexture();
  };
  ParticleSystem2.prototype._syncRampGradientTexture = function() {
    if (!this._rampGradients) {
      return;
    }
    this._rampGradients.sort(function(a, b) {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
    if (this._rampGradientsTexture) {
      this._rampGradientsTexture.dispose();
      this._rampGradientsTexture = null;
    }
    this._createRampGradientTexture();
  };
  ParticleSystem2.prototype.addRampGradient = function(gradient, color) {
    if (!this._rampGradients) {
      this._rampGradients = [];
    }
    var rampGradient = new Color3Gradient(gradient, color);
    this._rampGradients.push(rampGradient);
    this._syncRampGradientTexture();
    return this;
  };
  ParticleSystem2.prototype.removeRampGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._rampGradients, this._rampGradientsTexture);
    this._rampGradientsTexture = null;
    if (this._rampGradients && this._rampGradients.length > 0) {
      this._createRampGradientTexture();
    }
    return this;
  };
  ParticleSystem2.prototype.addColorGradient = function(gradient, color1, color2) {
    if (!this._colorGradients) {
      this._colorGradients = [];
    }
    var colorGradient = new ColorGradient(gradient, color1, color2);
    this._colorGradients.push(colorGradient);
    this._colorGradients.sort(function(a, b) {
      if (a.gradient < b.gradient) {
        return -1;
      } else if (a.gradient > b.gradient) {
        return 1;
      }
      return 0;
    });
    return this;
  };
  ParticleSystem2.prototype.removeColorGradient = function(gradient) {
    if (!this._colorGradients) {
      return this;
    }
    var index = 0;
    for (var _i = 0, _a2 = this._colorGradients; _i < _a2.length; _i++) {
      var colorGradient = _a2[_i];
      if (colorGradient.gradient === gradient) {
        this._colorGradients.splice(index, 1);
        break;
      }
      index++;
    }
    return this;
  };
  ParticleSystem2.prototype.resetDrawCache = function() {
    for (var _i = 0, _a2 = this._drawWrappers; _i < _a2.length; _i++) {
      var drawWrappers = _a2[_i];
      if (drawWrappers) {
        for (var _b2 = 0, drawWrappers_1 = drawWrappers; _b2 < drawWrappers_1.length; _b2++) {
          var drawWrapper = drawWrappers_1[_b2];
          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();
        }
      }
    }
    this._drawWrappers = [];
  };
  ParticleSystem2.prototype._fetchR = function(u, v, width, height, pixels) {
    u = Math.abs(u) * 0.5 + 0.5;
    v = Math.abs(v) * 0.5 + 0.5;
    var wrappedU = u * width % width | 0;
    var wrappedV = v * height % height | 0;
    var position = (wrappedU + wrappedV * width) * 4;
    return pixels[position] / 255;
  };
  ParticleSystem2.prototype._reset = function() {
    this._resetEffect();
  };
  ParticleSystem2.prototype._resetEffect = function() {
    if (this._vertexBuffer) {
      this._vertexBuffer.dispose();
      this._vertexBuffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    this._createVertexBuffers();
  };
  ParticleSystem2.prototype._createVertexBuffers = function() {
    this._vertexBufferSize = this._useInstancing ? 10 : 12;
    if (this._isAnimationSheetEnabled) {
      this._vertexBufferSize += 1;
    }
    if (!this._isBillboardBased || this.billboardMode === ParticleSystem2.BILLBOARDMODE_STRETCHED) {
      this._vertexBufferSize += 3;
    }
    if (this._useRampGradients) {
      this._vertexBufferSize += 4;
    }
    var engine = this._engine;
    var vertexSize = this._vertexBufferSize * (this._useInstancing ? 1 : 4);
    this._vertexData = new Float32Array(this._capacity * vertexSize);
    this._vertexBuffer = new Buffer2(engine, this._vertexData, true, vertexSize);
    var dataOffset = 0;
    var positions = this._vertexBuffer.createVertexBuffer(VertexBuffer.PositionKind, dataOffset, 3, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.PositionKind] = positions;
    dataOffset += 3;
    var colors = this._vertexBuffer.createVertexBuffer(VertexBuffer.ColorKind, dataOffset, 4, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers[VertexBuffer.ColorKind] = colors;
    dataOffset += 4;
    var options = this._vertexBuffer.createVertexBuffer("angle", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers["angle"] = options;
    dataOffset += 1;
    var size = this._vertexBuffer.createVertexBuffer("size", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
    this._vertexBuffers["size"] = size;
    dataOffset += 2;
    if (this._isAnimationSheetEnabled) {
      var cellIndexBuffer = this._vertexBuffer.createVertexBuffer("cellIndex", dataOffset, 1, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["cellIndex"] = cellIndexBuffer;
      dataOffset += 1;
    }
    if (!this._isBillboardBased || this.billboardMode === ParticleSystem2.BILLBOARDMODE_STRETCHED) {
      var directionBuffer = this._vertexBuffer.createVertexBuffer("direction", dataOffset, 3, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["direction"] = directionBuffer;
      dataOffset += 3;
    }
    if (this._useRampGradients) {
      var rampDataBuffer = this._vertexBuffer.createVertexBuffer("remapData", dataOffset, 4, this._vertexBufferSize, this._useInstancing);
      this._vertexBuffers["remapData"] = rampDataBuffer;
      dataOffset += 4;
    }
    var offsets;
    if (this._useInstancing) {
      var spriteData = new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]);
      this._spriteBuffer = new Buffer2(engine, spriteData, false, 2);
      offsets = this._spriteBuffer.createVertexBuffer("offset", 0, 2);
    } else {
      offsets = this._vertexBuffer.createVertexBuffer("offset", dataOffset, 2, this._vertexBufferSize, this._useInstancing);
      dataOffset += 2;
    }
    this._vertexBuffers["offset"] = offsets;
    this.resetDrawCache();
  };
  ParticleSystem2.prototype._createIndexBuffer = function() {
    if (this._useInstancing) {
      return;
    }
    var indices = [];
    var index = 0;
    for (var count = 0; count < this._capacity; count++) {
      indices.push(index);
      indices.push(index + 1);
      indices.push(index + 2);
      indices.push(index);
      indices.push(index + 2);
      indices.push(index + 3);
      index += 4;
    }
    this._indexBuffer = this._engine.createIndexBuffer(indices);
  };
  ParticleSystem2.prototype.getCapacity = function() {
    return this._capacity;
  };
  ParticleSystem2.prototype.isAlive = function() {
    return this._alive;
  };
  ParticleSystem2.prototype.isStarted = function() {
    return this._started;
  };
  ParticleSystem2.prototype._prepareSubEmitterInternalArray = function() {
    var _this = this;
    this._subEmitters = new Array();
    if (this.subEmitters) {
      this.subEmitters.forEach(function(subEmitter) {
        if (subEmitter instanceof ParticleSystem2) {
          _this._subEmitters.push([new SubEmitter(subEmitter)]);
        } else if (subEmitter instanceof SubEmitter) {
          _this._subEmitters.push([subEmitter]);
        } else if (subEmitter instanceof Array) {
          _this._subEmitters.push(subEmitter);
        }
      });
    }
  };
  ParticleSystem2.prototype.start = function(delay) {
    var _this = this;
    var _a2;
    if (delay === void 0) {
      delay = this.startDelay;
    }
    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
      throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
    }
    if (delay) {
      setTimeout(function() {
        _this.start(0);
      }, delay);
      return;
    }
    this._prepareSubEmitterInternalArray();
    this._started = true;
    this._stopped = false;
    this._actualFrame = 0;
    if (this._subEmitters && this._subEmitters.length != 0) {
      this.activeSubSystems = new Array();
    }
    if (this._emitRateGradients) {
      if (this._emitRateGradients.length > 0) {
        this._currentEmitRateGradient = this._emitRateGradients[0];
        this._currentEmitRate1 = this._currentEmitRateGradient.getFactor();
        this._currentEmitRate2 = this._currentEmitRate1;
      }
      if (this._emitRateGradients.length > 1) {
        this._currentEmitRate2 = this._emitRateGradients[1].getFactor();
      }
    }
    if (this._startSizeGradients) {
      if (this._startSizeGradients.length > 0) {
        this._currentStartSizeGradient = this._startSizeGradients[0];
        this._currentStartSize1 = this._currentStartSizeGradient.getFactor();
        this._currentStartSize2 = this._currentStartSize1;
      }
      if (this._startSizeGradients.length > 1) {
        this._currentStartSize2 = this._startSizeGradients[1].getFactor();
      }
    }
    if (this.preWarmCycles) {
      if (((_a2 = this.emitter) === null || _a2 === void 0 ? void 0 : _a2.getClassName().indexOf("Mesh")) !== -1) {
        this.emitter.computeWorldMatrix(true);
      }
      var noiseTextureAsProcedural_1 = this.noiseTexture;
      if (noiseTextureAsProcedural_1 && noiseTextureAsProcedural_1.onGeneratedObservable) {
        noiseTextureAsProcedural_1.onGeneratedObservable.addOnce(function() {
          setTimeout(function() {
            for (var index2 = 0; index2 < _this.preWarmCycles; index2++) {
              _this.animate(true);
              noiseTextureAsProcedural_1.render();
            }
          });
        });
      } else {
        for (var index = 0; index < this.preWarmCycles; index++) {
          this.animate(true);
        }
      }
    }
    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {
      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
    }
  };
  ParticleSystem2.prototype.stop = function(stopSubEmitters) {
    if (stopSubEmitters === void 0) {
      stopSubEmitters = true;
    }
    if (this._stopped) {
      return;
    }
    this.onStoppedObservable.notifyObservers(this);
    this._stopped = true;
    if (stopSubEmitters) {
      this._stopSubEmitters();
    }
  };
  ParticleSystem2.prototype.reset = function() {
    this._stockParticles = [];
    this._particles = [];
  };
  ParticleSystem2.prototype._appendParticleVertex = function(index, particle, offsetX, offsetY) {
    var offset = index * this._vertexBufferSize;
    this._vertexData[offset++] = particle.position.x + this.worldOffset.x;
    this._vertexData[offset++] = particle.position.y + this.worldOffset.y;
    this._vertexData[offset++] = particle.position.z + this.worldOffset.z;
    this._vertexData[offset++] = particle.color.r;
    this._vertexData[offset++] = particle.color.g;
    this._vertexData[offset++] = particle.color.b;
    this._vertexData[offset++] = particle.color.a;
    this._vertexData[offset++] = particle.angle;
    this._vertexData[offset++] = particle.scale.x * particle.size;
    this._vertexData[offset++] = particle.scale.y * particle.size;
    if (this._isAnimationSheetEnabled) {
      this._vertexData[offset++] = particle.cellIndex;
    }
    if (!this._isBillboardBased) {
      if (particle._initialDirection) {
        var initialDirection = particle._initialDirection;
        if (this.isLocal) {
          Vector3.TransformNormalToRef(initialDirection, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
          initialDirection = TmpVectors.Vector3[0];
        }
        if (initialDirection.x === 0 && initialDirection.z === 0) {
          initialDirection.x = 1e-3;
        }
        this._vertexData[offset++] = initialDirection.x;
        this._vertexData[offset++] = initialDirection.y;
        this._vertexData[offset++] = initialDirection.z;
      } else {
        var direction = particle.direction;
        if (this.isLocal) {
          Vector3.TransformNormalToRef(direction, this._emitterWorldMatrix, TmpVectors.Vector3[0]);
          direction = TmpVectors.Vector3[0];
        }
        if (direction.x === 0 && direction.z === 0) {
          direction.x = 1e-3;
        }
        this._vertexData[offset++] = direction.x;
        this._vertexData[offset++] = direction.y;
        this._vertexData[offset++] = direction.z;
      }
    } else if (this.billboardMode === ParticleSystem2.BILLBOARDMODE_STRETCHED) {
      this._vertexData[offset++] = particle.direction.x;
      this._vertexData[offset++] = particle.direction.y;
      this._vertexData[offset++] = particle.direction.z;
    }
    if (this._useRampGradients && particle.remapData) {
      this._vertexData[offset++] = particle.remapData.x;
      this._vertexData[offset++] = particle.remapData.y;
      this._vertexData[offset++] = particle.remapData.z;
      this._vertexData[offset++] = particle.remapData.w;
    }
    if (!this._useInstancing) {
      if (this._isAnimationSheetEnabled) {
        if (offsetX === 0) {
          offsetX = this._epsilon;
        } else if (offsetX === 1) {
          offsetX = 1 - this._epsilon;
        }
        if (offsetY === 0) {
          offsetY = this._epsilon;
        } else if (offsetY === 1) {
          offsetY = 1 - this._epsilon;
        }
      }
      this._vertexData[offset++] = offsetX;
      this._vertexData[offset++] = offsetY;
    }
  };
  ParticleSystem2.prototype._stopSubEmitters = function() {
    if (!this.activeSubSystems) {
      return;
    }
    this.activeSubSystems.forEach(function(subSystem) {
      subSystem.stop(true);
    });
    this.activeSubSystems = new Array();
  };
  ParticleSystem2.prototype._removeFromRoot = function() {
    if (!this._rootParticleSystem) {
      return;
    }
    var index = this._rootParticleSystem.activeSubSystems.indexOf(this);
    if (index !== -1) {
      this._rootParticleSystem.activeSubSystems.splice(index, 1);
    }
    this._rootParticleSystem = null;
  };
  ParticleSystem2.prototype._update = function(newParticles) {
    var _this = this;
    this._alive = this._particles.length > 0;
    if (this.emitter.position) {
      var emitterMesh = this.emitter;
      this._emitterWorldMatrix = emitterMesh.getWorldMatrix();
    } else {
      var emitterPosition = this.emitter;
      this._emitterWorldMatrix = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);
    }
    this._emitterWorldMatrix.invertToRef(this._emitterInverseWorldMatrix);
    this.updateFunction(this._particles);
    var particle;
    var _loop_3 = function(index2) {
      if (this_2._particles.length === this_2._capacity) {
        return "break";
      }
      particle = this_2._createParticle();
      this_2._particles.push(particle);
      if (this_2.targetStopDuration && this_2._lifeTimeGradients && this_2._lifeTimeGradients.length > 0) {
        var ratio_1 = Scalar.Clamp(this_2._actualFrame / this_2.targetStopDuration);
        GradientHelper.GetCurrentGradient(ratio_1, this_2._lifeTimeGradients, function(currentGradient, nextGradient) {
          var factorGradient1 = currentGradient;
          var factorGradient2 = nextGradient;
          var lifeTime1 = factorGradient1.getFactor();
          var lifeTime2 = factorGradient2.getFactor();
          var gradient = (ratio_1 - factorGradient1.gradient) / (factorGradient2.gradient - factorGradient1.gradient);
          particle.lifeTime = Scalar.Lerp(lifeTime1, lifeTime2, gradient);
        });
      } else {
        particle.lifeTime = Scalar.RandomRange(this_2.minLifeTime, this_2.maxLifeTime);
      }
      var emitPower = Scalar.RandomRange(this_2.minEmitPower, this_2.maxEmitPower);
      if (this_2.startPositionFunction) {
        this_2.startPositionFunction(this_2._emitterWorldMatrix, particle.position, particle, this_2.isLocal);
      } else {
        this_2.particleEmitterType.startPositionFunction(this_2._emitterWorldMatrix, particle.position, particle, this_2.isLocal);
      }
      if (this_2.isLocal) {
        if (!particle._localPosition) {
          particle._localPosition = particle.position.clone();
        } else {
          particle._localPosition.copyFrom(particle.position);
        }
        Vector3.TransformCoordinatesToRef(particle._localPosition, this_2._emitterWorldMatrix, particle.position);
      }
      if (this_2.startDirectionFunction) {
        this_2.startDirectionFunction(this_2._emitterWorldMatrix, particle.direction, particle, this_2.isLocal);
      } else {
        this_2.particleEmitterType.startDirectionFunction(this_2._emitterWorldMatrix, particle.direction, particle, this_2.isLocal, this_2._emitterInverseWorldMatrix);
      }
      if (emitPower === 0) {
        if (!particle._initialDirection) {
          particle._initialDirection = particle.direction.clone();
        } else {
          particle._initialDirection.copyFrom(particle.direction);
        }
      } else {
        particle._initialDirection = null;
      }
      particle.direction.scaleInPlace(emitPower);
      if (!this_2._sizeGradients || this_2._sizeGradients.length === 0) {
        particle.size = Scalar.RandomRange(this_2.minSize, this_2.maxSize);
      } else {
        particle._currentSizeGradient = this_2._sizeGradients[0];
        particle._currentSize1 = particle._currentSizeGradient.getFactor();
        particle.size = particle._currentSize1;
        if (this_2._sizeGradients.length > 1) {
          particle._currentSize2 = this_2._sizeGradients[1].getFactor();
        } else {
          particle._currentSize2 = particle._currentSize1;
        }
      }
      particle.scale.copyFromFloats(Scalar.RandomRange(this_2.minScaleX, this_2.maxScaleX), Scalar.RandomRange(this_2.minScaleY, this_2.maxScaleY));
      if (this_2._startSizeGradients && this_2._startSizeGradients[0] && this_2.targetStopDuration) {
        var ratio = this_2._actualFrame / this_2.targetStopDuration;
        GradientHelper.GetCurrentGradient(ratio, this_2._startSizeGradients, function(currentGradient, nextGradient, scale) {
          if (currentGradient !== _this._currentStartSizeGradient) {
            _this._currentStartSize1 = _this._currentStartSize2;
            _this._currentStartSize2 = nextGradient.getFactor();
            _this._currentStartSizeGradient = currentGradient;
          }
          var value = Scalar.Lerp(_this._currentStartSize1, _this._currentStartSize2, scale);
          particle.scale.scaleInPlace(value);
        });
      }
      if (!this_2._angularSpeedGradients || this_2._angularSpeedGradients.length === 0) {
        particle.angularSpeed = Scalar.RandomRange(this_2.minAngularSpeed, this_2.maxAngularSpeed);
      } else {
        particle._currentAngularSpeedGradient = this_2._angularSpeedGradients[0];
        particle.angularSpeed = particle._currentAngularSpeedGradient.getFactor();
        particle._currentAngularSpeed1 = particle.angularSpeed;
        if (this_2._angularSpeedGradients.length > 1) {
          particle._currentAngularSpeed2 = this_2._angularSpeedGradients[1].getFactor();
        } else {
          particle._currentAngularSpeed2 = particle._currentAngularSpeed1;
        }
      }
      particle.angle = Scalar.RandomRange(this_2.minInitialRotation, this_2.maxInitialRotation);
      if (this_2._velocityGradients && this_2._velocityGradients.length > 0) {
        particle._currentVelocityGradient = this_2._velocityGradients[0];
        particle._currentVelocity1 = particle._currentVelocityGradient.getFactor();
        if (this_2._velocityGradients.length > 1) {
          particle._currentVelocity2 = this_2._velocityGradients[1].getFactor();
        } else {
          particle._currentVelocity2 = particle._currentVelocity1;
        }
      }
      if (this_2._limitVelocityGradients && this_2._limitVelocityGradients.length > 0) {
        particle._currentLimitVelocityGradient = this_2._limitVelocityGradients[0];
        particle._currentLimitVelocity1 = particle._currentLimitVelocityGradient.getFactor();
        if (this_2._limitVelocityGradients.length > 1) {
          particle._currentLimitVelocity2 = this_2._limitVelocityGradients[1].getFactor();
        } else {
          particle._currentLimitVelocity2 = particle._currentLimitVelocity1;
        }
      }
      if (this_2._dragGradients && this_2._dragGradients.length > 0) {
        particle._currentDragGradient = this_2._dragGradients[0];
        particle._currentDrag1 = particle._currentDragGradient.getFactor();
        if (this_2._dragGradients.length > 1) {
          particle._currentDrag2 = this_2._dragGradients[1].getFactor();
        } else {
          particle._currentDrag2 = particle._currentDrag1;
        }
      }
      if (!this_2._colorGradients || this_2._colorGradients.length === 0) {
        var step = Scalar.RandomRange(0, 1);
        Color4.LerpToRef(this_2.color1, this_2.color2, step, particle.color);
        this_2.colorDead.subtractToRef(particle.color, this_2._colorDiff);
        this_2._colorDiff.scaleToRef(1 / particle.lifeTime, particle.colorStep);
      } else {
        particle._currentColorGradient = this_2._colorGradients[0];
        particle._currentColorGradient.getColorToRef(particle.color);
        particle._currentColor1.copyFrom(particle.color);
        if (this_2._colorGradients.length > 1) {
          this_2._colorGradients[1].getColorToRef(particle._currentColor2);
        } else {
          particle._currentColor2.copyFrom(particle.color);
        }
      }
      if (this_2._isAnimationSheetEnabled) {
        particle._initialStartSpriteCellID = this_2.startSpriteCellID;
        particle._initialEndSpriteCellID = this_2.endSpriteCellID;
        particle._initialSpriteCellLoop = this_2.spriteCellLoop;
      }
      particle.direction.addInPlace(this_2._inheritedVelocityOffset);
      if (this_2._useRampGradients) {
        particle.remapData = new Vector4(0, 1, 0, 1);
      }
      if (this_2.noiseTexture) {
        if (particle._randomNoiseCoordinates1) {
          particle._randomNoiseCoordinates1.copyFromFloats(Math.random(), Math.random(), Math.random());
          particle._randomNoiseCoordinates2.copyFromFloats(Math.random(), Math.random(), Math.random());
        } else {
          particle._randomNoiseCoordinates1 = new Vector3(Math.random(), Math.random(), Math.random());
          particle._randomNoiseCoordinates2 = new Vector3(Math.random(), Math.random(), Math.random());
        }
      }
      particle._inheritParticleInfoToSubEmitters();
    };
    var this_2 = this;
    for (var index = 0; index < newParticles; index++) {
      var state_1 = _loop_3();
      if (state_1 === "break")
        break;
    }
  };
  ParticleSystem2._GetAttributeNamesOrOptions = function(isAnimationSheetEnabled, isBillboardBased, useRampGradients) {
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    if (isBillboardBased === void 0) {
      isBillboardBased = false;
    }
    if (useRampGradients === void 0) {
      useRampGradients = false;
    }
    var attributeNamesOrOptions = [VertexBuffer.PositionKind, VertexBuffer.ColorKind, "angle", "offset", "size"];
    if (isAnimationSheetEnabled) {
      attributeNamesOrOptions.push("cellIndex");
    }
    if (!isBillboardBased) {
      attributeNamesOrOptions.push("direction");
    }
    if (useRampGradients) {
      attributeNamesOrOptions.push("remapData");
    }
    return attributeNamesOrOptions;
  };
  ParticleSystem2._GetEffectCreationOptions = function(isAnimationSheetEnabled) {
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    var effectCreationOption = [
      "invView",
      "view",
      "projection",
      "vClipPlane",
      "vClipPlane2",
      "vClipPlane3",
      "vClipPlane4",
      "vClipPlane5",
      "vClipPlane6",
      "textureMask",
      "translationPivot",
      "eyePosition"
    ];
    if (isAnimationSheetEnabled) {
      effectCreationOption.push("particlesInfos");
    }
    return effectCreationOption;
  };
  ParticleSystem2.prototype.fillDefines = function(defines, blendMode) {
    if (this._scene) {
      if (this._scene.clipPlane) {
        defines.push("#define CLIPPLANE");
      }
      if (this._scene.clipPlane2) {
        defines.push("#define CLIPPLANE2");
      }
      if (this._scene.clipPlane3) {
        defines.push("#define CLIPPLANE3");
      }
      if (this._scene.clipPlane4) {
        defines.push("#define CLIPPLANE4");
      }
      if (this._scene.clipPlane5) {
        defines.push("#define CLIPPLANE5");
      }
      if (this._scene.clipPlane6) {
        defines.push("#define CLIPPLANE6");
      }
    }
    if (this._isAnimationSheetEnabled) {
      defines.push("#define ANIMATESHEET");
    }
    if (blendMode === ParticleSystem2.BLENDMODE_MULTIPLY) {
      defines.push("#define BLENDMULTIPLYMODE");
    }
    if (this._useRampGradients) {
      defines.push("#define RAMPGRADIENT");
    }
    if (this._isBillboardBased) {
      defines.push("#define BILLBOARD");
      switch (this.billboardMode) {
        case ParticleSystem2.BILLBOARDMODE_Y:
          defines.push("#define BILLBOARDY");
          break;
        case ParticleSystem2.BILLBOARDMODE_STRETCHED:
          defines.push("#define BILLBOARDSTRETCHED");
          break;
        case ParticleSystem2.BILLBOARDMODE_ALL:
          defines.push("#define BILLBOARDMODE_ALL");
          break;
      }
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
      defines.push(this._imageProcessingConfigurationDefines.toString());
    }
  };
  ParticleSystem2.prototype.fillUniformsAttributesAndSamplerNames = function(uniforms, attributes, samplers) {
    attributes.push.apply(attributes, ParticleSystem2._GetAttributeNamesOrOptions(this._isAnimationSheetEnabled, this._isBillboardBased && this.billboardMode !== ParticleSystem2.BILLBOARDMODE_STRETCHED, this._useRampGradients));
    uniforms.push.apply(uniforms, ParticleSystem2._GetEffectCreationOptions(this._isAnimationSheetEnabled));
    samplers.push("diffuseSampler", "rampSampler");
    if (this._imageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);
    }
  };
  ParticleSystem2.prototype._getWrapper = function(blendMode) {
    var customWrapper = this._getCustomDrawWrapper(blendMode);
    if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {
      return customWrapper;
    }
    var defines = [];
    this.fillDefines(defines, blendMode);
    var currentRenderPassId = this._engine._features.supportRenderPasses ? this._engine.currentRenderPassId : 0;
    var drawWrappers = this._drawWrappers[currentRenderPassId];
    if (!drawWrappers) {
      drawWrappers = this._drawWrappers[currentRenderPassId] = [];
    }
    var drawWrapper = drawWrappers[blendMode];
    if (!drawWrapper) {
      drawWrapper = new DrawWrapper(this._engine);
      if (drawWrapper.drawContext) {
        drawWrapper.drawContext.useInstancing = this._useInstancing;
      }
      drawWrappers[blendMode] = drawWrapper;
    }
    var join = defines.join("\n");
    if (drawWrapper.defines !== join) {
      var attributesNamesOrOptions = [];
      var effectCreationOption = [];
      var samplers = [];
      this.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, samplers);
      drawWrapper.setEffect(this._engine.createEffect("particles", attributesNamesOrOptions, effectCreationOption, samplers, join), join);
    }
    return drawWrapper;
  };
  ParticleSystem2.prototype.animate = function(preWarmOnly) {
    var _this = this;
    var _a2;
    if (preWarmOnly === void 0) {
      preWarmOnly = false;
    }
    if (!this._started) {
      return;
    }
    if (!preWarmOnly && this._scene) {
      if (!this.isReady()) {
        return;
      }
      if (this._currentRenderId === this._scene.getFrameId()) {
        return;
      }
      this._currentRenderId = this._scene.getFrameId();
    }
    this._scaledUpdateSpeed = this.updateSpeed * (preWarmOnly ? this.preWarmStepOffset : ((_a2 = this._scene) === null || _a2 === void 0 ? void 0 : _a2.getAnimationRatio()) || 1);
    var newParticles;
    if (this.manualEmitCount > -1) {
      newParticles = this.manualEmitCount;
      this._newPartsExcess = 0;
      this.manualEmitCount = 0;
    } else {
      var rate_1 = this.emitRate;
      if (this._emitRateGradients && this._emitRateGradients.length > 0 && this.targetStopDuration) {
        var ratio = this._actualFrame / this.targetStopDuration;
        GradientHelper.GetCurrentGradient(ratio, this._emitRateGradients, function(currentGradient, nextGradient, scale) {
          if (currentGradient !== _this._currentEmitRateGradient) {
            _this._currentEmitRate1 = _this._currentEmitRate2;
            _this._currentEmitRate2 = nextGradient.getFactor();
            _this._currentEmitRateGradient = currentGradient;
          }
          rate_1 = Scalar.Lerp(_this._currentEmitRate1, _this._currentEmitRate2, scale);
        });
      }
      newParticles = rate_1 * this._scaledUpdateSpeed >> 0;
      this._newPartsExcess += rate_1 * this._scaledUpdateSpeed - newParticles;
    }
    if (this._newPartsExcess > 1) {
      newParticles += this._newPartsExcess >> 0;
      this._newPartsExcess -= this._newPartsExcess >> 0;
    }
    this._alive = false;
    if (!this._stopped) {
      this._actualFrame += this._scaledUpdateSpeed;
      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
        this.stop();
      }
    } else {
      newParticles = 0;
    }
    this._update(newParticles);
    if (this._stopped) {
      if (!this._alive) {
        this._started = false;
        if (this.onAnimationEnd) {
          this.onAnimationEnd();
        }
        if (this.disposeOnStop && this._scene) {
          this._scene._toBeDisposed.push(this);
        }
      }
    }
    if (!preWarmOnly) {
      var offset = 0;
      for (var index = 0; index < this._particles.length; index++) {
        var particle = this._particles[index];
        this._appendParticleVertices(offset, particle);
        offset += this._useInstancing ? 1 : 4;
      }
      if (this._vertexBuffer) {
        this._vertexBuffer.updateDirectly(this._vertexData, 0, this._particles.length);
      }
    }
    if (this.manualEmitCount === 0 && this.disposeOnStop) {
      this.stop();
    }
  };
  ParticleSystem2.prototype._appendParticleVertices = function(offset, particle) {
    this._appendParticleVertex(offset++, particle, 0, 0);
    if (!this._useInstancing) {
      this._appendParticleVertex(offset++, particle, 1, 0);
      this._appendParticleVertex(offset++, particle, 1, 1);
      this._appendParticleVertex(offset++, particle, 0, 1);
    }
  };
  ParticleSystem2.prototype.rebuild = function() {
    var _a2, _b2;
    if (this._engine.getCaps().vertexArrayObject) {
      this._vertexArrayObject = null;
    }
    this._createIndexBuffer();
    (_a2 = this._spriteBuffer) === null || _a2 === void 0 ? void 0 : _a2._rebuild();
    (_b2 = this._vertexBuffer) === null || _b2 === void 0 ? void 0 : _b2._rebuild();
    for (var key in this._vertexBuffers) {
      this._vertexBuffers[key]._rebuild();
    }
    this.resetDrawCache();
  };
  ParticleSystem2.prototype.isReady = function() {
    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
      return false;
    }
    if (this.blendMode !== ParticleSystem2.BLENDMODE_MULTIPLYADD) {
      if (!this._getWrapper(this.blendMode).effect.isReady()) {
        return false;
      }
    } else {
      if (!this._getWrapper(ParticleSystem2.BLENDMODE_MULTIPLY).effect.isReady()) {
        return false;
      }
      if (!this._getWrapper(ParticleSystem2.BLENDMODE_ADD).effect.isReady()) {
        return false;
      }
    }
    return true;
  };
  ParticleSystem2.prototype._render = function(blendMode) {
    var _a2, _b2;
    var drawWrapper = this._getWrapper(blendMode);
    var effect = drawWrapper.effect;
    var engine = this._engine;
    engine.enableEffect(drawWrapper);
    var viewMatrix = (_a2 = this.defaultViewMatrix) !== null && _a2 !== void 0 ? _a2 : this._scene.getViewMatrix();
    effect.setTexture("diffuseSampler", this.particleTexture);
    effect.setMatrix("view", viewMatrix);
    effect.setMatrix("projection", (_b2 = this.defaultProjectionMatrix) !== null && _b2 !== void 0 ? _b2 : this._scene.getProjectionMatrix());
    if (this._isAnimationSheetEnabled && this.particleTexture) {
      var baseSize = this.particleTexture.getBaseSize();
      effect.setFloat3("particlesInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, this.spriteCellWidth / baseSize.width);
    }
    effect.setVector2("translationPivot", this.translationPivot);
    effect.setFloat4("textureMask", this.textureMask.r, this.textureMask.g, this.textureMask.b, this.textureMask.a);
    if (this._isBillboardBased && this._scene) {
      var camera = this._scene.activeCamera;
      effect.setVector3("eyePosition", camera.globalPosition);
    }
    if (this._rampGradientsTexture) {
      if (!this._rampGradients || !this._rampGradients.length) {
        this._rampGradientsTexture.dispose();
        this._rampGradientsTexture = null;
      }
      effect.setTexture("rampSampler", this._rampGradientsTexture);
    }
    var defines = effect.defines;
    if (this._scene) {
      if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {
        ThinMaterialHelper.BindClipPlane(effect, this._scene);
      }
    }
    if (defines.indexOf("#define BILLBOARDMODE_ALL") >= 0) {
      viewMatrix.invertToRef(TmpVectors.Matrix[0]);
      effect.setMatrix("invView", TmpVectors.Matrix[0]);
    }
    if (this._vertexArrayObject !== void 0) {
      if (!this._vertexArrayObject) {
        this._vertexArrayObject = this._engine.recordVertexArrayObject(this._vertexBuffers, this._indexBuffer, effect);
      }
      this._engine.bindVertexArrayObject(this._vertexArrayObject, this._indexBuffer);
    } else {
      engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
    }
    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
      this._imageProcessingConfiguration.bind(effect);
    }
    switch (blendMode) {
      case ParticleSystem2.BLENDMODE_ADD:
        engine.setAlphaMode(1);
        break;
      case ParticleSystem2.BLENDMODE_ONEONE:
        engine.setAlphaMode(6);
        break;
      case ParticleSystem2.BLENDMODE_STANDARD:
        engine.setAlphaMode(2);
        break;
      case ParticleSystem2.BLENDMODE_MULTIPLY:
        engine.setAlphaMode(4);
        break;
    }
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.notifyObservers(effect);
    }
    if (this._useInstancing) {
      engine.drawArraysType(7, 0, 4, this._particles.length);
    } else {
      engine.drawElementsType(0, 0, this._particles.length * 6);
    }
    return this._particles.length;
  };
  ParticleSystem2.prototype.render = function() {
    if (!this.isReady() || !this._particles.length) {
      return 0;
    }
    var engine = this._engine;
    if (engine.setState) {
      engine.setState(false);
      if (this.forceDepthWrite) {
        engine.setDepthWrite(true);
      }
    }
    var outparticles = 0;
    if (this.blendMode === ParticleSystem2.BLENDMODE_MULTIPLYADD) {
      outparticles = this._render(ParticleSystem2.BLENDMODE_MULTIPLY) + this._render(ParticleSystem2.BLENDMODE_ADD);
    } else {
      outparticles = this._render(this.blendMode);
    }
    this._engine.unbindInstanceAttributes();
    this._engine.setAlphaMode(0);
    return outparticles;
  };
  ParticleSystem2.prototype.dispose = function(disposeTexture) {
    if (disposeTexture === void 0) {
      disposeTexture = true;
    }
    this.resetDrawCache();
    if (this._vertexBuffer) {
      this._vertexBuffer.dispose();
      this._vertexBuffer = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    if (this._indexBuffer) {
      this._engine._releaseBuffer(this._indexBuffer);
      this._indexBuffer = null;
    }
    if (this._vertexArrayObject) {
      this._engine.releaseVertexArrayObject(this._vertexArrayObject);
      this._vertexArrayObject = null;
    }
    if (disposeTexture && this.particleTexture) {
      this.particleTexture.dispose();
      this.particleTexture = null;
    }
    if (disposeTexture && this.noiseTexture) {
      this.noiseTexture.dispose();
      this.noiseTexture = null;
    }
    if (this._rampGradientsTexture) {
      this._rampGradientsTexture.dispose();
      this._rampGradientsTexture = null;
    }
    this._removeFromRoot();
    if (this.subEmitters && !this._subEmitters) {
      this._prepareSubEmitterInternalArray();
    }
    if (this._subEmitters && this._subEmitters.length) {
      for (var index = 0; index < this._subEmitters.length; index++) {
        for (var _i = 0, _a2 = this._subEmitters[index]; _i < _a2.length; _i++) {
          var subEmitter = _a2[_i];
          subEmitter.dispose();
        }
      }
      this._subEmitters = [];
      this.subEmitters = [];
    }
    if (this._disposeEmitterOnDispose && this.emitter && this.emitter.dispose) {
      this.emitter.dispose(true);
    }
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.clear();
    }
    if (this._scene) {
      var index = this._scene.particleSystems.indexOf(this);
      if (index > -1) {
        this._scene.particleSystems.splice(index, 1);
      }
      this._scene._activeParticleSystems.dispose();
    }
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
    this.onStoppedObservable.clear();
    this.reset();
  };
  ParticleSystem2.prototype.clone = function(name2, newEmitter) {
    var custom = __assign({}, this._customWrappers);
    var program = null;
    var engine = this._engine;
    if (engine.createEffectForParticles) {
      if (this.customShader != null) {
        program = this.customShader;
        var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
        var effect = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
        if (!custom[0]) {
          this.setCustomEffect(effect, 0);
        } else {
          custom[0].effect = effect;
        }
      }
    }
    var serialization = this.serialize();
    var result = ParticleSystem2.Parse(serialization, this._scene || this._engine, this._rootUrl);
    result.name = name2;
    result.customShader = program;
    result._customWrappers = custom;
    if (newEmitter === void 0) {
      newEmitter = this.emitter;
    }
    if (this.noiseTexture) {
      result.noiseTexture = this.noiseTexture.clone();
    }
    result.emitter = newEmitter;
    if (!this.preventAutoStart) {
      result.start();
    }
    return result;
  };
  ParticleSystem2.prototype.serialize = function(serializeTexture) {
    if (serializeTexture === void 0) {
      serializeTexture = false;
    }
    var serializationObject = {};
    ParticleSystem2._Serialize(serializationObject, this, serializeTexture);
    serializationObject.textureMask = this.textureMask.asArray();
    serializationObject.customShader = this.customShader;
    serializationObject.preventAutoStart = this.preventAutoStart;
    if (this.subEmitters) {
      serializationObject.subEmitters = [];
      if (!this._subEmitters) {
        this._prepareSubEmitterInternalArray();
      }
      for (var _i = 0, _a2 = this._subEmitters; _i < _a2.length; _i++) {
        var subs = _a2[_i];
        var cell = [];
        for (var _b2 = 0, subs_1 = subs; _b2 < subs_1.length; _b2++) {
          var sub = subs_1[_b2];
          cell.push(sub.serialize(serializeTexture));
        }
        serializationObject.subEmitters.push(cell);
      }
    }
    return serializationObject;
  };
  ParticleSystem2._Serialize = function(serializationObject, particleSystem, serializeTexture) {
    serializationObject.name = particleSystem.name;
    serializationObject.id = particleSystem.id;
    serializationObject.capacity = particleSystem.getCapacity();
    serializationObject.disposeOnStop = particleSystem.disposeOnStop;
    serializationObject.manualEmitCount = particleSystem.manualEmitCount;
    if (particleSystem.emitter.position) {
      var emitterMesh = particleSystem.emitter;
      serializationObject.emitterId = emitterMesh.id;
    } else {
      var emitterPosition = particleSystem.emitter;
      serializationObject.emitter = emitterPosition.asArray();
    }
    if (particleSystem.particleEmitterType) {
      serializationObject.particleEmitterType = particleSystem.particleEmitterType.serialize();
    }
    if (particleSystem.particleTexture) {
      if (serializeTexture) {
        serializationObject.texture = particleSystem.particleTexture.serialize();
      } else {
        serializationObject.textureName = particleSystem.particleTexture.name;
        serializationObject.invertY = !!particleSystem.particleTexture._invertY;
      }
    }
    serializationObject.isLocal = particleSystem.isLocal;
    SerializationHelper.AppendSerializedAnimations(particleSystem, serializationObject);
    serializationObject.beginAnimationOnStart = particleSystem.beginAnimationOnStart;
    serializationObject.beginAnimationFrom = particleSystem.beginAnimationFrom;
    serializationObject.beginAnimationTo = particleSystem.beginAnimationTo;
    serializationObject.beginAnimationLoop = particleSystem.beginAnimationLoop;
    serializationObject.startDelay = particleSystem.startDelay;
    serializationObject.renderingGroupId = particleSystem.renderingGroupId;
    serializationObject.isBillboardBased = particleSystem.isBillboardBased;
    serializationObject.billboardMode = particleSystem.billboardMode;
    serializationObject.minAngularSpeed = particleSystem.minAngularSpeed;
    serializationObject.maxAngularSpeed = particleSystem.maxAngularSpeed;
    serializationObject.minSize = particleSystem.minSize;
    serializationObject.maxSize = particleSystem.maxSize;
    serializationObject.minScaleX = particleSystem.minScaleX;
    serializationObject.maxScaleX = particleSystem.maxScaleX;
    serializationObject.minScaleY = particleSystem.minScaleY;
    serializationObject.maxScaleY = particleSystem.maxScaleY;
    serializationObject.minEmitPower = particleSystem.minEmitPower;
    serializationObject.maxEmitPower = particleSystem.maxEmitPower;
    serializationObject.minLifeTime = particleSystem.minLifeTime;
    serializationObject.maxLifeTime = particleSystem.maxLifeTime;
    serializationObject.emitRate = particleSystem.emitRate;
    serializationObject.gravity = particleSystem.gravity.asArray();
    serializationObject.noiseStrength = particleSystem.noiseStrength.asArray();
    serializationObject.color1 = particleSystem.color1.asArray();
    serializationObject.color2 = particleSystem.color2.asArray();
    serializationObject.colorDead = particleSystem.colorDead.asArray();
    serializationObject.updateSpeed = particleSystem.updateSpeed;
    serializationObject.targetStopDuration = particleSystem.targetStopDuration;
    serializationObject.blendMode = particleSystem.blendMode;
    serializationObject.preWarmCycles = particleSystem.preWarmCycles;
    serializationObject.preWarmStepOffset = particleSystem.preWarmStepOffset;
    serializationObject.minInitialRotation = particleSystem.minInitialRotation;
    serializationObject.maxInitialRotation = particleSystem.maxInitialRotation;
    serializationObject.startSpriteCellID = particleSystem.startSpriteCellID;
    serializationObject.spriteCellLoop = particleSystem.spriteCellLoop;
    serializationObject.endSpriteCellID = particleSystem.endSpriteCellID;
    serializationObject.spriteCellChangeSpeed = particleSystem.spriteCellChangeSpeed;
    serializationObject.spriteCellWidth = particleSystem.spriteCellWidth;
    serializationObject.spriteCellHeight = particleSystem.spriteCellHeight;
    serializationObject.spriteRandomStartCell = particleSystem.spriteRandomStartCell;
    serializationObject.isAnimationSheetEnabled = particleSystem.isAnimationSheetEnabled;
    var colorGradients = particleSystem.getColorGradients();
    if (colorGradients) {
      serializationObject.colorGradients = [];
      for (var _i = 0, colorGradients_1 = colorGradients; _i < colorGradients_1.length; _i++) {
        var colorGradient = colorGradients_1[_i];
        var serializedGradient = {
          gradient: colorGradient.gradient,
          color1: colorGradient.color1.asArray()
        };
        if (colorGradient.color2) {
          serializedGradient.color2 = colorGradient.color2.asArray();
        } else {
          serializedGradient.color2 = colorGradient.color1.asArray();
        }
        serializationObject.colorGradients.push(serializedGradient);
      }
    }
    var rampGradients = particleSystem.getRampGradients();
    if (rampGradients) {
      serializationObject.rampGradients = [];
      for (var _a2 = 0, rampGradients_1 = rampGradients; _a2 < rampGradients_1.length; _a2++) {
        var rampGradient = rampGradients_1[_a2];
        var serializedGradient = {
          gradient: rampGradient.gradient,
          color: rampGradient.color.asArray()
        };
        serializationObject.rampGradients.push(serializedGradient);
      }
      serializationObject.useRampGradients = particleSystem.useRampGradients;
    }
    var colorRemapGradients = particleSystem.getColorRemapGradients();
    if (colorRemapGradients) {
      serializationObject.colorRemapGradients = [];
      for (var _b2 = 0, colorRemapGradients_1 = colorRemapGradients; _b2 < colorRemapGradients_1.length; _b2++) {
        var colorRemapGradient = colorRemapGradients_1[_b2];
        var serializedGradient = {
          gradient: colorRemapGradient.gradient,
          factor1: colorRemapGradient.factor1
        };
        if (colorRemapGradient.factor2 !== void 0) {
          serializedGradient.factor2 = colorRemapGradient.factor2;
        } else {
          serializedGradient.factor2 = colorRemapGradient.factor1;
        }
        serializationObject.colorRemapGradients.push(serializedGradient);
      }
    }
    var alphaRemapGradients = particleSystem.getAlphaRemapGradients();
    if (alphaRemapGradients) {
      serializationObject.alphaRemapGradients = [];
      for (var _c2 = 0, alphaRemapGradients_1 = alphaRemapGradients; _c2 < alphaRemapGradients_1.length; _c2++) {
        var alphaRemapGradient = alphaRemapGradients_1[_c2];
        var serializedGradient = {
          gradient: alphaRemapGradient.gradient,
          factor1: alphaRemapGradient.factor1
        };
        if (alphaRemapGradient.factor2 !== void 0) {
          serializedGradient.factor2 = alphaRemapGradient.factor2;
        } else {
          serializedGradient.factor2 = alphaRemapGradient.factor1;
        }
        serializationObject.alphaRemapGradients.push(serializedGradient);
      }
    }
    var sizeGradients = particleSystem.getSizeGradients();
    if (sizeGradients) {
      serializationObject.sizeGradients = [];
      for (var _d = 0, sizeGradients_1 = sizeGradients; _d < sizeGradients_1.length; _d++) {
        var sizeGradient = sizeGradients_1[_d];
        var serializedGradient = {
          gradient: sizeGradient.gradient,
          factor1: sizeGradient.factor1
        };
        if (sizeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = sizeGradient.factor2;
        } else {
          serializedGradient.factor2 = sizeGradient.factor1;
        }
        serializationObject.sizeGradients.push(serializedGradient);
      }
    }
    var angularSpeedGradients = particleSystem.getAngularSpeedGradients();
    if (angularSpeedGradients) {
      serializationObject.angularSpeedGradients = [];
      for (var _e = 0, angularSpeedGradients_1 = angularSpeedGradients; _e < angularSpeedGradients_1.length; _e++) {
        var angularSpeedGradient = angularSpeedGradients_1[_e];
        var serializedGradient = {
          gradient: angularSpeedGradient.gradient,
          factor1: angularSpeedGradient.factor1
        };
        if (angularSpeedGradient.factor2 !== void 0) {
          serializedGradient.factor2 = angularSpeedGradient.factor2;
        } else {
          serializedGradient.factor2 = angularSpeedGradient.factor1;
        }
        serializationObject.angularSpeedGradients.push(serializedGradient);
      }
    }
    var velocityGradients = particleSystem.getVelocityGradients();
    if (velocityGradients) {
      serializationObject.velocityGradients = [];
      for (var _f = 0, velocityGradients_1 = velocityGradients; _f < velocityGradients_1.length; _f++) {
        var velocityGradient = velocityGradients_1[_f];
        var serializedGradient = {
          gradient: velocityGradient.gradient,
          factor1: velocityGradient.factor1
        };
        if (velocityGradient.factor2 !== void 0) {
          serializedGradient.factor2 = velocityGradient.factor2;
        } else {
          serializedGradient.factor2 = velocityGradient.factor1;
        }
        serializationObject.velocityGradients.push(serializedGradient);
      }
    }
    var dragGradients = particleSystem.getDragGradients();
    if (dragGradients) {
      serializationObject.dragGradients = [];
      for (var _g = 0, dragGradients_1 = dragGradients; _g < dragGradients_1.length; _g++) {
        var dragGradient = dragGradients_1[_g];
        var serializedGradient = {
          gradient: dragGradient.gradient,
          factor1: dragGradient.factor1
        };
        if (dragGradient.factor2 !== void 0) {
          serializedGradient.factor2 = dragGradient.factor2;
        } else {
          serializedGradient.factor2 = dragGradient.factor1;
        }
        serializationObject.dragGradients.push(serializedGradient);
      }
    }
    var emitRateGradients = particleSystem.getEmitRateGradients();
    if (emitRateGradients) {
      serializationObject.emitRateGradients = [];
      for (var _h = 0, emitRateGradients_1 = emitRateGradients; _h < emitRateGradients_1.length; _h++) {
        var emitRateGradient = emitRateGradients_1[_h];
        var serializedGradient = {
          gradient: emitRateGradient.gradient,
          factor1: emitRateGradient.factor1
        };
        if (emitRateGradient.factor2 !== void 0) {
          serializedGradient.factor2 = emitRateGradient.factor2;
        } else {
          serializedGradient.factor2 = emitRateGradient.factor1;
        }
        serializationObject.emitRateGradients.push(serializedGradient);
      }
    }
    var startSizeGradients = particleSystem.getStartSizeGradients();
    if (startSizeGradients) {
      serializationObject.startSizeGradients = [];
      for (var _j = 0, startSizeGradients_1 = startSizeGradients; _j < startSizeGradients_1.length; _j++) {
        var startSizeGradient = startSizeGradients_1[_j];
        var serializedGradient = {
          gradient: startSizeGradient.gradient,
          factor1: startSizeGradient.factor1
        };
        if (startSizeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = startSizeGradient.factor2;
        } else {
          serializedGradient.factor2 = startSizeGradient.factor1;
        }
        serializationObject.startSizeGradients.push(serializedGradient);
      }
    }
    var lifeTimeGradients = particleSystem.getLifeTimeGradients();
    if (lifeTimeGradients) {
      serializationObject.lifeTimeGradients = [];
      for (var _k = 0, lifeTimeGradients_1 = lifeTimeGradients; _k < lifeTimeGradients_1.length; _k++) {
        var lifeTimeGradient = lifeTimeGradients_1[_k];
        var serializedGradient = {
          gradient: lifeTimeGradient.gradient,
          factor1: lifeTimeGradient.factor1
        };
        if (lifeTimeGradient.factor2 !== void 0) {
          serializedGradient.factor2 = lifeTimeGradient.factor2;
        } else {
          serializedGradient.factor2 = lifeTimeGradient.factor1;
        }
        serializationObject.lifeTimeGradients.push(serializedGradient);
      }
    }
    var limitVelocityGradients = particleSystem.getLimitVelocityGradients();
    if (limitVelocityGradients) {
      serializationObject.limitVelocityGradients = [];
      for (var _l = 0, limitVelocityGradients_1 = limitVelocityGradients; _l < limitVelocityGradients_1.length; _l++) {
        var limitVelocityGradient = limitVelocityGradients_1[_l];
        var serializedGradient = {
          gradient: limitVelocityGradient.gradient,
          factor1: limitVelocityGradient.factor1
        };
        if (limitVelocityGradient.factor2 !== void 0) {
          serializedGradient.factor2 = limitVelocityGradient.factor2;
        } else {
          serializedGradient.factor2 = limitVelocityGradient.factor1;
        }
        serializationObject.limitVelocityGradients.push(serializedGradient);
      }
      serializationObject.limitVelocityDamping = particleSystem.limitVelocityDamping;
    }
    if (particleSystem.noiseTexture) {
      serializationObject.noiseTexture = particleSystem.noiseTexture.serialize();
    }
  };
  ParticleSystem2._Parse = function(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl) {
    var _a2, _b2, _c2;
    var scene;
    if (sceneOrEngine instanceof ThinEngine) {
      scene = null;
    } else {
      scene = sceneOrEngine;
    }
    var internalClass = GetClass("BABYLON.Texture");
    if (internalClass && scene) {
      if (parsedParticleSystem.texture) {
        particleSystem.particleTexture = internalClass.Parse(parsedParticleSystem.texture, scene, rootUrl);
      } else if (parsedParticleSystem.textureName) {
        particleSystem.particleTexture = new internalClass(rootUrl + parsedParticleSystem.textureName, scene, false, parsedParticleSystem.invertY !== void 0 ? parsedParticleSystem.invertY : true);
        particleSystem.particleTexture.name = parsedParticleSystem.textureName;
      }
    }
    if (!parsedParticleSystem.emitterId && parsedParticleSystem.emitterId !== 0 && parsedParticleSystem.emitter === void 0) {
      particleSystem.emitter = Vector3.Zero();
    } else if (parsedParticleSystem.emitterId && scene) {
      particleSystem.emitter = scene.getLastMeshById(parsedParticleSystem.emitterId);
    } else {
      particleSystem.emitter = Vector3.FromArray(parsedParticleSystem.emitter);
    }
    particleSystem.isLocal = !!parsedParticleSystem.isLocal;
    if (parsedParticleSystem.renderingGroupId !== void 0) {
      particleSystem.renderingGroupId = parsedParticleSystem.renderingGroupId;
    }
    if (parsedParticleSystem.isBillboardBased !== void 0) {
      particleSystem.isBillboardBased = parsedParticleSystem.isBillboardBased;
    }
    if (parsedParticleSystem.billboardMode !== void 0) {
      particleSystem.billboardMode = parsedParticleSystem.billboardMode;
    }
    if (parsedParticleSystem.animations) {
      for (var animationIndex = 0; animationIndex < parsedParticleSystem.animations.length; animationIndex++) {
        var parsedAnimation = parsedParticleSystem.animations[animationIndex];
        var internalClass_1 = GetClass("BABYLON.Animation");
        if (internalClass_1) {
          particleSystem.animations.push(internalClass_1.Parse(parsedAnimation));
        }
      }
      particleSystem.beginAnimationOnStart = parsedParticleSystem.beginAnimationOnStart;
      particleSystem.beginAnimationFrom = parsedParticleSystem.beginAnimationFrom;
      particleSystem.beginAnimationTo = parsedParticleSystem.beginAnimationTo;
      particleSystem.beginAnimationLoop = parsedParticleSystem.beginAnimationLoop;
    }
    if (parsedParticleSystem.autoAnimate && scene) {
      scene.beginAnimation(particleSystem, parsedParticleSystem.autoAnimateFrom, parsedParticleSystem.autoAnimateTo, parsedParticleSystem.autoAnimateLoop, parsedParticleSystem.autoAnimateSpeed || 1);
    }
    particleSystem.startDelay = parsedParticleSystem.startDelay | 0;
    particleSystem.minAngularSpeed = parsedParticleSystem.minAngularSpeed;
    particleSystem.maxAngularSpeed = parsedParticleSystem.maxAngularSpeed;
    particleSystem.minSize = parsedParticleSystem.minSize;
    particleSystem.maxSize = parsedParticleSystem.maxSize;
    if (parsedParticleSystem.minScaleX) {
      particleSystem.minScaleX = parsedParticleSystem.minScaleX;
      particleSystem.maxScaleX = parsedParticleSystem.maxScaleX;
      particleSystem.minScaleY = parsedParticleSystem.minScaleY;
      particleSystem.maxScaleY = parsedParticleSystem.maxScaleY;
    }
    if (parsedParticleSystem.preWarmCycles !== void 0) {
      particleSystem.preWarmCycles = parsedParticleSystem.preWarmCycles;
      particleSystem.preWarmStepOffset = parsedParticleSystem.preWarmStepOffset;
    }
    if (parsedParticleSystem.minInitialRotation !== void 0) {
      particleSystem.minInitialRotation = parsedParticleSystem.minInitialRotation;
      particleSystem.maxInitialRotation = parsedParticleSystem.maxInitialRotation;
    }
    particleSystem.minLifeTime = parsedParticleSystem.minLifeTime;
    particleSystem.maxLifeTime = parsedParticleSystem.maxLifeTime;
    particleSystem.minEmitPower = parsedParticleSystem.minEmitPower;
    particleSystem.maxEmitPower = parsedParticleSystem.maxEmitPower;
    particleSystem.emitRate = parsedParticleSystem.emitRate;
    particleSystem.gravity = Vector3.FromArray(parsedParticleSystem.gravity);
    if (parsedParticleSystem.noiseStrength) {
      particleSystem.noiseStrength = Vector3.FromArray(parsedParticleSystem.noiseStrength);
    }
    particleSystem.color1 = Color4.FromArray(parsedParticleSystem.color1);
    particleSystem.color2 = Color4.FromArray(parsedParticleSystem.color2);
    particleSystem.colorDead = Color4.FromArray(parsedParticleSystem.colorDead);
    particleSystem.updateSpeed = parsedParticleSystem.updateSpeed;
    particleSystem.targetStopDuration = parsedParticleSystem.targetStopDuration;
    particleSystem.blendMode = parsedParticleSystem.blendMode;
    if (parsedParticleSystem.colorGradients) {
      for (var _i = 0, _d = parsedParticleSystem.colorGradients; _i < _d.length; _i++) {
        var colorGradient = _d[_i];
        particleSystem.addColorGradient(colorGradient.gradient, Color4.FromArray(colorGradient.color1), colorGradient.color2 ? Color4.FromArray(colorGradient.color2) : void 0);
      }
    }
    if (parsedParticleSystem.rampGradients) {
      for (var _e = 0, _f = parsedParticleSystem.rampGradients; _e < _f.length; _e++) {
        var rampGradient = _f[_e];
        particleSystem.addRampGradient(rampGradient.gradient, Color3.FromArray(rampGradient.color));
      }
      particleSystem.useRampGradients = parsedParticleSystem.useRampGradients;
    }
    if (parsedParticleSystem.colorRemapGradients) {
      for (var _g = 0, _h = parsedParticleSystem.colorRemapGradients; _g < _h.length; _g++) {
        var colorRemapGradient = _h[_g];
        particleSystem.addColorRemapGradient(colorRemapGradient.gradient, colorRemapGradient.factor1 !== void 0 ? colorRemapGradient.factor1 : colorRemapGradient.factor, colorRemapGradient.factor2);
      }
    }
    if (parsedParticleSystem.alphaRemapGradients) {
      for (var _j = 0, _k = parsedParticleSystem.alphaRemapGradients; _j < _k.length; _j++) {
        var alphaRemapGradient = _k[_j];
        particleSystem.addAlphaRemapGradient(alphaRemapGradient.gradient, alphaRemapGradient.factor1 !== void 0 ? alphaRemapGradient.factor1 : alphaRemapGradient.factor, alphaRemapGradient.factor2);
      }
    }
    if (parsedParticleSystem.sizeGradients) {
      for (var _l = 0, _m = parsedParticleSystem.sizeGradients; _l < _m.length; _l++) {
        var sizeGradient = _m[_l];
        particleSystem.addSizeGradient(sizeGradient.gradient, sizeGradient.factor1 !== void 0 ? sizeGradient.factor1 : sizeGradient.factor, sizeGradient.factor2);
      }
    }
    if (parsedParticleSystem.angularSpeedGradients) {
      for (var _o = 0, _p = parsedParticleSystem.angularSpeedGradients; _o < _p.length; _o++) {
        var angularSpeedGradient = _p[_o];
        particleSystem.addAngularSpeedGradient(angularSpeedGradient.gradient, angularSpeedGradient.factor1 !== void 0 ? angularSpeedGradient.factor1 : angularSpeedGradient.factor, angularSpeedGradient.factor2);
      }
    }
    if (parsedParticleSystem.velocityGradients) {
      for (var _q = 0, _r = parsedParticleSystem.velocityGradients; _q < _r.length; _q++) {
        var velocityGradient = _r[_q];
        particleSystem.addVelocityGradient(velocityGradient.gradient, velocityGradient.factor1 !== void 0 ? velocityGradient.factor1 : velocityGradient.factor, velocityGradient.factor2);
      }
    }
    if (parsedParticleSystem.dragGradients) {
      for (var _s = 0, _t = parsedParticleSystem.dragGradients; _s < _t.length; _s++) {
        var dragGradient = _t[_s];
        particleSystem.addDragGradient(dragGradient.gradient, dragGradient.factor1 !== void 0 ? dragGradient.factor1 : dragGradient.factor, dragGradient.factor2);
      }
    }
    if (parsedParticleSystem.emitRateGradients) {
      for (var _u = 0, _v = parsedParticleSystem.emitRateGradients; _u < _v.length; _u++) {
        var emitRateGradient = _v[_u];
        particleSystem.addEmitRateGradient(emitRateGradient.gradient, emitRateGradient.factor1 !== void 0 ? emitRateGradient.factor1 : emitRateGradient.factor, emitRateGradient.factor2);
      }
    }
    if (parsedParticleSystem.startSizeGradients) {
      for (var _w = 0, _x = parsedParticleSystem.startSizeGradients; _w < _x.length; _w++) {
        var startSizeGradient = _x[_w];
        particleSystem.addStartSizeGradient(startSizeGradient.gradient, startSizeGradient.factor1 !== void 0 ? startSizeGradient.factor1 : startSizeGradient.factor, startSizeGradient.factor2);
      }
    }
    if (parsedParticleSystem.lifeTimeGradients) {
      for (var _y = 0, _z = parsedParticleSystem.lifeTimeGradients; _y < _z.length; _y++) {
        var lifeTimeGradient = _z[_y];
        particleSystem.addLifeTimeGradient(lifeTimeGradient.gradient, lifeTimeGradient.factor1 !== void 0 ? lifeTimeGradient.factor1 : lifeTimeGradient.factor, lifeTimeGradient.factor2);
      }
    }
    if (parsedParticleSystem.limitVelocityGradients) {
      for (var _0 = 0, _1 = parsedParticleSystem.limitVelocityGradients; _0 < _1.length; _0++) {
        var limitVelocityGradient = _1[_0];
        particleSystem.addLimitVelocityGradient(limitVelocityGradient.gradient, limitVelocityGradient.factor1 !== void 0 ? limitVelocityGradient.factor1 : limitVelocityGradient.factor, limitVelocityGradient.factor2);
      }
      particleSystem.limitVelocityDamping = parsedParticleSystem.limitVelocityDamping;
    }
    if (parsedParticleSystem.noiseTexture && scene) {
      var internalClass_2 = GetClass("BABYLON.ProceduralTexture");
      particleSystem.noiseTexture = internalClass_2.Parse(parsedParticleSystem.noiseTexture, scene, rootUrl);
    }
    var emitterType;
    if (parsedParticleSystem.particleEmitterType) {
      switch (parsedParticleSystem.particleEmitterType.type) {
        case "SphereParticleEmitter":
          emitterType = new SphereParticleEmitter();
          break;
        case "SphereDirectedParticleEmitter":
          emitterType = new SphereDirectedParticleEmitter();
          break;
        case "ConeEmitter":
        case "ConeParticleEmitter":
          emitterType = new ConeParticleEmitter();
          break;
        case "CylinderParticleEmitter":
          emitterType = new CylinderParticleEmitter();
          break;
        case "CylinderDirectedParticleEmitter":
          emitterType = new CylinderDirectedParticleEmitter();
          break;
        case "HemisphericParticleEmitter":
          emitterType = new HemisphericParticleEmitter();
          break;
        case "PointParticleEmitter":
          emitterType = new PointParticleEmitter();
          break;
        case "MeshParticleEmitter":
          emitterType = new MeshParticleEmitter();
          break;
        case "BoxEmitter":
        case "BoxParticleEmitter":
        default:
          emitterType = new BoxParticleEmitter();
          break;
      }
      emitterType.parse(parsedParticleSystem.particleEmitterType, scene);
    } else {
      emitterType = new BoxParticleEmitter();
      emitterType.parse(parsedParticleSystem, scene);
    }
    particleSystem.particleEmitterType = emitterType;
    particleSystem.startSpriteCellID = parsedParticleSystem.startSpriteCellID;
    particleSystem.endSpriteCellID = parsedParticleSystem.endSpriteCellID;
    particleSystem.spriteCellLoop = (_a2 = parsedParticleSystem.spriteCellLoop) !== null && _a2 !== void 0 ? _a2 : true;
    particleSystem.spriteCellWidth = parsedParticleSystem.spriteCellWidth;
    particleSystem.spriteCellHeight = parsedParticleSystem.spriteCellHeight;
    particleSystem.spriteCellChangeSpeed = parsedParticleSystem.spriteCellChangeSpeed;
    particleSystem.spriteRandomStartCell = parsedParticleSystem.spriteRandomStartCell;
    particleSystem.disposeOnStop = (_b2 = parsedParticleSystem.disposeOnStop) !== null && _b2 !== void 0 ? _b2 : false;
    particleSystem.manualEmitCount = (_c2 = parsedParticleSystem.manualEmitCount) !== null && _c2 !== void 0 ? _c2 : -1;
  };
  ParticleSystem2.Parse = function(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart, capacity) {
    if (doNotStart === void 0) {
      doNotStart = false;
    }
    var name2 = parsedParticleSystem.name;
    var custom = null;
    var program = null;
    var engine;
    var scene;
    if (sceneOrEngine instanceof ThinEngine) {
      engine = sceneOrEngine;
    } else {
      scene = sceneOrEngine;
      engine = scene.getEngine();
    }
    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {
      program = parsedParticleSystem.customShader;
      var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
      custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines);
    }
    var particleSystem = new ParticleSystem2(name2, capacity || parsedParticleSystem.capacity, sceneOrEngine, custom, parsedParticleSystem.isAnimationSheetEnabled);
    particleSystem.customShader = program;
    particleSystem._rootUrl = rootUrl;
    if (parsedParticleSystem.id) {
      particleSystem.id = parsedParticleSystem.id;
    }
    if (parsedParticleSystem.subEmitters) {
      particleSystem.subEmitters = [];
      for (var _i = 0, _a2 = parsedParticleSystem.subEmitters; _i < _a2.length; _i++) {
        var cell = _a2[_i];
        var cellArray = [];
        for (var _b2 = 0, cell_1 = cell; _b2 < cell_1.length; _b2++) {
          var sub = cell_1[_b2];
          cellArray.push(SubEmitter.Parse(sub, sceneOrEngine, rootUrl));
        }
        particleSystem.subEmitters.push(cellArray);
      }
    }
    ParticleSystem2._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);
    if (parsedParticleSystem.textureMask) {
      particleSystem.textureMask = Color4.FromArray(parsedParticleSystem.textureMask);
    }
    if (parsedParticleSystem.preventAutoStart) {
      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
    }
    if (!doNotStart && !particleSystem.preventAutoStart) {
      particleSystem.start();
    }
    return particleSystem;
  };
  ParticleSystem2.BILLBOARDMODE_Y = 2;
  ParticleSystem2.BILLBOARDMODE_ALL = 7;
  ParticleSystem2.BILLBOARDMODE_STRETCHED = 8;
  return ParticleSystem2;
}(BaseParticleSystem);
SubEmitter._ParseParticleSystem = ParticleSystem.Parse;
var name$4 = "clipPlaneFragmentDeclaration2";
var shader$3 = "#ifdef CLIPPLANE\nin float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nin float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nin float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nin float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nin float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nin float fClipDistance6;\n#endif\n";
ShaderStore.IncludesShadersStore[name$4] = shader$3;
var name$3 = "gpuRenderParticlesPixelShader";
var shader$2 = "precision highp float;\nuniform sampler2D diffuseSampler;\nvarying vec2 vUV;\nvarying vec4 vColor;\n#include<clipPlaneFragmentDeclaration2> \n#include<imageProcessingDeclaration>\n#include<helperFunctions>\n#include<imageProcessingFunctions>\nvoid main() {\n#include<clipPlaneFragment> \nvec4 textureColor=texture2D(diffuseSampler,vUV);\ngl_FragColor=textureColor*vColor;\n#ifdef BLENDMULTIPLYMODE\nfloat alpha=vColor.a*textureColor.a;\ngl_FragColor.rgb=gl_FragColor.rgb*alpha+vec3(1.0)*(1.0-alpha);\n#endif \n#ifdef IMAGEPROCESSINGPOSTPROCESS\ngl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);\n#else\n#ifdef IMAGEPROCESSING\ngl_FragColor.rgb=toLinearSpace(gl_FragColor.rgb);\ngl_FragColor=applyImageProcessing(gl_FragColor);\n#endif\n#endif\n}\n";
ShaderStore.ShadersStore[name$3] = shader$2;
var name$2 = "clipPlaneVertexDeclaration2";
var shader$1 = "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;\nout float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;\nout float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;\nout float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;\nout float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;\nout float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;\nout float fClipDistance6;\n#endif\n";
ShaderStore.IncludesShadersStore[name$2] = shader$1;
var name$1 = "gpuRenderParticlesVertexShader";
var shader = "precision highp float;\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec2 translationPivot;\nuniform vec3 worldOffset;\n#ifdef LOCAL\nuniform mat4 emitterWM;\n#endif\nattribute vec3 position;\nattribute float age;\nattribute float life;\nattribute vec3 size;\n#ifndef BILLBOARD\nattribute vec3 initialDirection;\n#endif\n#ifdef BILLBOARDSTRETCHED\nattribute vec3 direction;\n#endif\nattribute float angle;\n#ifdef ANIMATESHEET\nattribute float cellIndex;\n#endif\nattribute vec2 offset;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec3 vPositionW;\n#if defined(BILLBOARD) && !defined(BILLBOARDY) && !defined(BILLBOARDSTRETCHED)\nuniform mat4 invView;\n#endif\n#include<clipPlaneVertexDeclaration2>\n#ifdef COLORGRADIENTS\nuniform sampler2D colorGradientSampler;\n#else\nuniform vec4 colorDead;\nattribute vec4 color;\n#endif\n#ifdef ANIMATESHEET\nuniform vec3 sheetInfos;\n#endif\n#ifdef BILLBOARD\nuniform vec3 eyePosition;\n#endif\nvec3 rotate(vec3 yaxis,vec3 rotatedCorner) {\nvec3 xaxis=normalize(cross(vec3(0.,1.0,0.),yaxis));\nvec3 zaxis=normalize(cross(yaxis,xaxis));\nvec3 row0=vec3(xaxis.x,xaxis.y,xaxis.z);\nvec3 row1=vec3(yaxis.x,yaxis.y,yaxis.z);\nvec3 row2=vec3(zaxis.x,zaxis.y,zaxis.z);\nmat3 rotMatrix= mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\n#ifdef LOCAL\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\n#else\nreturn (position+worldOffset)+alignedCorner;\n#endif\n}\n#ifdef BILLBOARDSTRETCHED\nvec3 rotateAlign(vec3 toCamera,vec3 rotatedCorner) {\nvec3 normalizedToCamera=normalize(toCamera);\nvec3 normalizedCrossDirToCamera=normalize(cross(normalize(direction),normalizedToCamera));\nvec3 crossProduct=normalize(cross(normalizedToCamera,normalizedCrossDirToCamera));\nvec3 row0=vec3(normalizedCrossDirToCamera.x,normalizedCrossDirToCamera.y,normalizedCrossDirToCamera.z);\nvec3 row1=vec3(crossProduct.x,crossProduct.y,crossProduct.z);\nvec3 row2=vec3(normalizedToCamera.x,normalizedToCamera.y,normalizedToCamera.z);\nmat3 rotMatrix= mat3(row0,row1,row2);\nvec3 alignedCorner=rotMatrix*rotatedCorner;\n#ifdef LOCAL\nreturn ((emitterWM*vec4(position,1.0)).xyz+worldOffset)+alignedCorner;\n#else\nreturn (position+worldOffset)+alignedCorner;\n#endif\n}\n#endif\nvoid main() {\n#ifdef ANIMATESHEET\nfloat rowOffset=floor(cellIndex/sheetInfos.z);\nfloat columnOffset=cellIndex-rowOffset*sheetInfos.z;\nvec2 uvScale=sheetInfos.xy;\nvec2 uvOffset=vec2(uv.x ,1.0-uv.y);\nvUV=(uvOffset+vec2(columnOffset,rowOffset))*uvScale;\n#else\nvUV=uv;\n#endif\nfloat ratio=age/life;\n#ifdef COLORGRADIENTS\nvColor=texture2D(colorGradientSampler,vec2(ratio,0));\n#else\nvColor=color*vec4(1.0-ratio)+colorDead*vec4(ratio);\n#endif\nvec2 cornerPos=(offset-translationPivot)*size.yz*size.x+translationPivot;\n#ifdef BILLBOARD\nvec4 rotatedCorner;\nrotatedCorner.w=0.;\n#ifdef BILLBOARDY\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.y=0.;\nvec3 yaxis=(position+worldOffset)-eyePosition;\nyaxis.y=0.;\nvPositionW=rotate(normalize(yaxis),rotatedCorner.xyz);\nvec4 viewPosition=(view*vec4(vPositionW,1.0));\n#elif defined(BILLBOARDSTRETCHED)\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\nvec3 toCamera=(position+worldOffset)-eyePosition;\nvPositionW=rotateAlign(toCamera,rotatedCorner.xyz);\nvec4 viewPosition=(view*vec4(vPositionW,1.0));\n#else\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nrotatedCorner.z=0.;\n#ifdef LOCAL\nvec4 viewPosition=view*vec4(((emitterWM*vec4(position,1.0)).xyz+worldOffset),1.0)+rotatedCorner;\n#else\nvec4 viewPosition=view*vec4((position+worldOffset),1.0)+rotatedCorner;\n#endif\nvPositionW=(invView*viewPosition).xyz;\n#endif\n#else\nvec3 rotatedCorner;\nrotatedCorner.x=cornerPos.x*cos(angle)-cornerPos.y*sin(angle);\nrotatedCorner.y=0.;\nrotatedCorner.z=cornerPos.x*sin(angle)+cornerPos.y*cos(angle);\nvec3 yaxis=normalize(initialDirection);\nvPositionW=rotate(yaxis,rotatedCorner);\nvec4 viewPosition=view*vec4(vPositionW,1.0);\n#endif\ngl_Position=projection*viewPosition;\n#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nvec4 worldPos=vec4(vPositionW,1.0);\n#endif\n#include<clipPlaneVertex>\n}";
ShaderStore.ShadersStore[name$1] = shader;
var GPUParticleSystem = function(_super) {
  __extends(GPUParticleSystem2, _super);
  function GPUParticleSystem2(name2, options, sceneOrEngine, customEffect, isAnimationSheetEnabled) {
    if (customEffect === void 0) {
      customEffect = null;
    }
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    var _this = _super.call(this, name2) || this;
    _this.layerMask = 268435455;
    _this._accumulatedCount = 0;
    _this._targetIndex = 0;
    _this._currentRenderId = -1;
    _this._currentRenderingCameraUniqueId = -1;
    _this._started = false;
    _this._stopped = false;
    _this._timeDelta = 0;
    _this._actualFrame = 0;
    _this._rawTextureWidth = 256;
    _this.onDisposeObservable = new Observable();
    _this.onStoppedObservable = new Observable();
    _this.forceDepthWrite = false;
    _this._preWarmDone = false;
    _this.isLocal = false;
    _this._onBeforeDrawParticlesObservable = null;
    if (!sceneOrEngine || sceneOrEngine.getClassName() === "Scene") {
      _this._scene = sceneOrEngine || EngineStore.LastCreatedScene;
      _this._engine = _this._scene.getEngine();
      _this.uniqueId = _this._scene.getUniqueId();
      _this._scene.particleSystems.push(_this);
    } else {
      _this._engine = sceneOrEngine;
      _this.defaultProjectionMatrix = Matrix.PerspectiveFovLH(0.8, 1, 0.1, 100, _this._engine.isNDCHalfZRange);
    }
    if (_this._engine.getCaps().supportComputeShaders) {
      if (!GetClass("BABYLON.ComputeShaderParticleSystem")) {
        throw new Error("The ComputeShaderParticleSystem class is not available! Make sure you have imported it.");
      }
      _this._platform = new (GetClass("BABYLON.ComputeShaderParticleSystem"))(_this, _this._engine);
    } else {
      if (!GetClass("BABYLON.WebGL2ParticleSystem")) {
        throw new Error("The WebGL2ParticleSystem class is not available! Make sure you have imported it.");
      }
      _this._platform = new (GetClass("BABYLON.WebGL2ParticleSystem"))(_this, _this._engine);
    }
    _this._customWrappers = { 0: new DrawWrapper(_this._engine) };
    _this._customWrappers[0].effect = customEffect;
    _this._drawWrappers = { 0: new DrawWrapper(_this._engine) };
    if (_this._drawWrappers[0].drawContext) {
      _this._drawWrappers[0].drawContext.useInstancing = true;
    }
    _this._attachImageProcessingConfiguration(null);
    options = options !== null && options !== void 0 ? options : {};
    if (!options.randomTextureSize) {
      delete options.randomTextureSize;
    }
    var fullOptions = __assign({ capacity: 5e4, randomTextureSize: _this._engine.getCaps().maxTextureSize }, options);
    var optionsAsNumber = options;
    if (isFinite(optionsAsNumber)) {
      fullOptions.capacity = optionsAsNumber;
    }
    _this._capacity = fullOptions.capacity;
    _this._activeCount = fullOptions.capacity;
    _this._currentActiveCount = 0;
    _this._isAnimationSheetEnabled = isAnimationSheetEnabled;
    _this.particleEmitterType = new BoxParticleEmitter();
    var maxTextureSize = Math.min(_this._engine.getCaps().maxTextureSize, fullOptions.randomTextureSize);
    var d = [];
    for (var i = 0; i < maxTextureSize; ++i) {
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
    }
    _this._randomTexture = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);
    _this._randomTexture.name = "GPUParticleSystem_random1";
    _this._randomTexture.wrapU = 1;
    _this._randomTexture.wrapV = 1;
    d = [];
    for (var i = 0; i < maxTextureSize; ++i) {
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
      d.push(Math.random());
    }
    _this._randomTexture2 = new RawTexture(new Float32Array(d), maxTextureSize, 1, 5, sceneOrEngine, false, false, 1, 1);
    _this._randomTexture2.name = "GPUParticleSystem_random2";
    _this._randomTexture2.wrapU = 1;
    _this._randomTexture2.wrapV = 1;
    _this._randomTextureSize = maxTextureSize;
    return _this;
  }
  Object.defineProperty(GPUParticleSystem2, "IsSupported", {
    get: function() {
      if (!EngineStore.LastCreatedEngine) {
        return false;
      }
      var caps = EngineStore.LastCreatedEngine.getCaps();
      return caps.supportTransformFeedbacks || caps.supportComputeShaders;
    },
    enumerable: false,
    configurable: true
  });
  GPUParticleSystem2.prototype.getCapacity = function() {
    return this._capacity;
  };
  Object.defineProperty(GPUParticleSystem2.prototype, "activeParticleCount", {
    get: function() {
      return this._activeCount;
    },
    set: function(value) {
      this._activeCount = Math.min(value, this._capacity);
    },
    enumerable: false,
    configurable: true
  });
  GPUParticleSystem2.prototype.isReady = function() {
    if (!this.emitter || this._imageProcessingConfiguration && !this._imageProcessingConfiguration.isReady() || !this.particleTexture || !this.particleTexture.isReady()) {
      return false;
    }
    if (this.blendMode !== ParticleSystem.BLENDMODE_MULTIPLYADD) {
      if (!this._getWrapper(this.blendMode).effect.isReady()) {
        return false;
      }
    } else {
      if (!this._getWrapper(ParticleSystem.BLENDMODE_MULTIPLY).effect.isReady()) {
        return false;
      }
      if (!this._getWrapper(ParticleSystem.BLENDMODE_ADD).effect.isReady()) {
        return false;
      }
    }
    if (!this._platform.isUpdateBufferCreated()) {
      this._recreateUpdateEffect();
      return false;
    }
    return this._platform.isUpdateBufferReady();
  };
  GPUParticleSystem2.prototype.isStarted = function() {
    return this._started;
  };
  GPUParticleSystem2.prototype.isStopped = function() {
    return this._stopped;
  };
  GPUParticleSystem2.prototype.isStopping = function() {
    return false;
  };
  GPUParticleSystem2.prototype.getActiveCount = function() {
    return this._currentActiveCount;
  };
  GPUParticleSystem2.prototype.start = function(delay) {
    var _this = this;
    if (delay === void 0) {
      delay = this.startDelay;
    }
    if (!this.targetStopDuration && this._hasTargetStopDurationDependantGradient()) {
      throw "Particle system started with a targetStopDuration dependant gradient (eg. startSizeGradients) but no targetStopDuration set";
    }
    if (delay) {
      setTimeout(function() {
        _this.start(0);
      }, delay);
      return;
    }
    this._started = true;
    this._stopped = false;
    this._preWarmDone = false;
    if (this.beginAnimationOnStart && this.animations && this.animations.length > 0 && this._scene) {
      this._scene.beginAnimation(this, this.beginAnimationFrom, this.beginAnimationTo, this.beginAnimationLoop);
    }
  };
  GPUParticleSystem2.prototype.stop = function() {
    if (this._stopped) {
      return;
    }
    this._stopped = true;
  };
  GPUParticleSystem2.prototype.reset = function() {
    this._releaseBuffers();
    this._platform.releaseVertexBuffers();
    this._currentActiveCount = 0;
    this._targetIndex = 0;
  };
  GPUParticleSystem2.prototype.getClassName = function() {
    return "GPUParticleSystem";
  };
  GPUParticleSystem2.prototype.getCustomEffect = function(blendMode) {
    var _a2, _b2;
    if (blendMode === void 0) {
      blendMode = 0;
    }
    return (_b2 = (_a2 = this._customWrappers[blendMode]) === null || _a2 === void 0 ? void 0 : _a2.effect) !== null && _b2 !== void 0 ? _b2 : this._customWrappers[0].effect;
  };
  GPUParticleSystem2.prototype._getCustomDrawWrapper = function(blendMode) {
    var _a2;
    if (blendMode === void 0) {
      blendMode = 0;
    }
    return (_a2 = this._customWrappers[blendMode]) !== null && _a2 !== void 0 ? _a2 : this._customWrappers[0];
  };
  GPUParticleSystem2.prototype.setCustomEffect = function(effect, blendMode) {
    if (blendMode === void 0) {
      blendMode = 0;
    }
    this._customWrappers[blendMode] = new DrawWrapper(this._engine);
    this._customWrappers[blendMode].effect = effect;
  };
  Object.defineProperty(GPUParticleSystem2.prototype, "onBeforeDrawParticlesObservable", {
    get: function() {
      if (!this._onBeforeDrawParticlesObservable) {
        this._onBeforeDrawParticlesObservable = new Observable();
      }
      return this._onBeforeDrawParticlesObservable;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(GPUParticleSystem2.prototype, "vertexShaderName", {
    get: function() {
      return "gpuRenderParticles";
    },
    enumerable: false,
    configurable: true
  });
  GPUParticleSystem2.prototype._removeGradientAndTexture = function(gradient, gradients, texture) {
    _super.prototype._removeGradientAndTexture.call(this, gradient, gradients, texture);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.addColorGradient = function(gradient, color1) {
    if (!this._colorGradients) {
      this._colorGradients = [];
    }
    var colorGradient = new ColorGradient(gradient, color1);
    this._colorGradients.push(colorGradient);
    this._refreshColorGradient(true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype._refreshColorGradient = function(reorder) {
    if (reorder === void 0) {
      reorder = false;
    }
    if (this._colorGradients) {
      if (reorder) {
        this._colorGradients.sort(function(a, b) {
          if (a.gradient < b.gradient) {
            return -1;
          } else if (a.gradient > b.gradient) {
            return 1;
          }
          return 0;
        });
      }
      if (this._colorGradientsTexture) {
        this._colorGradientsTexture.dispose();
        this._colorGradientsTexture = null;
      }
    }
  };
  GPUParticleSystem2.prototype.forceRefreshGradients = function() {
    this._refreshColorGradient();
    this._refreshFactorGradient(this._sizeGradients, "_sizeGradientsTexture");
    this._refreshFactorGradient(this._angularSpeedGradients, "_angularSpeedGradientsTexture");
    this._refreshFactorGradient(this._velocityGradients, "_velocityGradientsTexture");
    this._refreshFactorGradient(this._limitVelocityGradients, "_limitVelocityGradientsTexture");
    this._refreshFactorGradient(this._dragGradients, "_dragGradientsTexture");
    this.reset();
  };
  GPUParticleSystem2.prototype.removeColorGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._colorGradients, this._colorGradientsTexture);
    this._colorGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype.resetDrawCache = function() {
    var _a2;
    for (var blendMode in this._drawWrappers) {
      var drawWrapper = this._drawWrappers[blendMode];
      (_a2 = drawWrapper.drawContext) === null || _a2 === void 0 ? void 0 : _a2.reset();
    }
  };
  GPUParticleSystem2.prototype._addFactorGradient = function(factorGradients, gradient, factor) {
    var valueGradient = new FactorGradient(gradient, factor);
    factorGradients.push(valueGradient);
    this._releaseBuffers();
  };
  GPUParticleSystem2.prototype.addSizeGradient = function(gradient, factor) {
    if (!this._sizeGradients) {
      this._sizeGradients = [];
    }
    this._addFactorGradient(this._sizeGradients, gradient, factor);
    this._refreshFactorGradient(this._sizeGradients, "_sizeGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeSizeGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._sizeGradients, this._sizeGradientsTexture);
    this._sizeGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype._refreshFactorGradient = function(factorGradients, textureName, reorder) {
    if (reorder === void 0) {
      reorder = false;
    }
    if (!factorGradients) {
      return;
    }
    if (reorder) {
      factorGradients.sort(function(a, b) {
        if (a.gradient < b.gradient) {
          return -1;
        } else if (a.gradient > b.gradient) {
          return 1;
        }
        return 0;
      });
    }
    var that = this;
    if (that[textureName]) {
      that[textureName].dispose();
      that[textureName] = null;
    }
  };
  GPUParticleSystem2.prototype.addAngularSpeedGradient = function(gradient, factor) {
    if (!this._angularSpeedGradients) {
      this._angularSpeedGradients = [];
    }
    this._addFactorGradient(this._angularSpeedGradients, gradient, factor);
    this._refreshFactorGradient(this._angularSpeedGradients, "_angularSpeedGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeAngularSpeedGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._angularSpeedGradients, this._angularSpeedGradientsTexture);
    this._angularSpeedGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype.addVelocityGradient = function(gradient, factor) {
    if (!this._velocityGradients) {
      this._velocityGradients = [];
    }
    this._addFactorGradient(this._velocityGradients, gradient, factor);
    this._refreshFactorGradient(this._velocityGradients, "_velocityGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeVelocityGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._velocityGradients, this._velocityGradientsTexture);
    this._velocityGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype.addLimitVelocityGradient = function(gradient, factor) {
    if (!this._limitVelocityGradients) {
      this._limitVelocityGradients = [];
    }
    this._addFactorGradient(this._limitVelocityGradients, gradient, factor);
    this._refreshFactorGradient(this._limitVelocityGradients, "_limitVelocityGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeLimitVelocityGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._limitVelocityGradients, this._limitVelocityGradientsTexture);
    this._limitVelocityGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype.addDragGradient = function(gradient, factor) {
    if (!this._dragGradients) {
      this._dragGradients = [];
    }
    this._addFactorGradient(this._dragGradients, gradient, factor);
    this._refreshFactorGradient(this._dragGradients, "_dragGradientsTexture", true);
    this._releaseBuffers();
    return this;
  };
  GPUParticleSystem2.prototype.removeDragGradient = function(gradient) {
    this._removeGradientAndTexture(gradient, this._dragGradients, this._dragGradientsTexture);
    this._dragGradientsTexture = null;
    return this;
  };
  GPUParticleSystem2.prototype.addEmitRateGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.removeEmitRateGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.addStartSizeGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.removeStartSizeGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.addColorRemapGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.removeColorRemapGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.addAlphaRemapGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.removeAlphaRemapGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.addRampGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.removeRampGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.getRampGradients = function() {
    return null;
  };
  Object.defineProperty(GPUParticleSystem2.prototype, "useRampGradients", {
    get: function() {
      return false;
    },
    set: function(value) {
    },
    enumerable: false,
    configurable: true
  });
  GPUParticleSystem2.prototype.addLifeTimeGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype.removeLifeTimeGradient = function() {
    return this;
  };
  GPUParticleSystem2.prototype._reset = function() {
    this._releaseBuffers();
  };
  GPUParticleSystem2.prototype._createVertexBuffers = function(updateBuffer, renderBuffer, spriteSource) {
    var renderVertexBuffers = {};
    renderVertexBuffers["position"] = renderBuffer.createVertexBuffer("position", 0, 3, this._attributesStrideSize, true);
    var offset = 3;
    renderVertexBuffers["age"] = renderBuffer.createVertexBuffer("age", offset, 1, this._attributesStrideSize, true);
    offset += 1;
    renderVertexBuffers["size"] = renderBuffer.createVertexBuffer("size", offset, 3, this._attributesStrideSize, true);
    offset += 3;
    renderVertexBuffers["life"] = renderBuffer.createVertexBuffer("life", offset, 1, this._attributesStrideSize, true);
    offset += 1;
    offset += 4;
    if (this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED) {
      renderVertexBuffers["direction"] = renderBuffer.createVertexBuffer("direction", offset, 3, this._attributesStrideSize, true);
    }
    offset += 3;
    if (this._platform.alignDataInBuffer) {
      offset += 1;
    }
    if (this.particleEmitterType instanceof CustomParticleEmitter) {
      offset += 3;
      if (this._platform.alignDataInBuffer) {
        offset += 1;
      }
    }
    if (!this._colorGradientsTexture) {
      renderVertexBuffers["color"] = renderBuffer.createVertexBuffer("color", offset, 4, this._attributesStrideSize, true);
      offset += 4;
    }
    if (!this._isBillboardBased) {
      renderVertexBuffers["initialDirection"] = renderBuffer.createVertexBuffer("initialDirection", offset, 3, this._attributesStrideSize, true);
      offset += 3;
      if (this._platform.alignDataInBuffer) {
        offset += 1;
      }
    }
    if (this.noiseTexture) {
      renderVertexBuffers["noiseCoordinates1"] = renderBuffer.createVertexBuffer("noiseCoordinates1", offset, 3, this._attributesStrideSize, true);
      offset += 3;
      if (this._platform.alignDataInBuffer) {
        offset += 1;
      }
      renderVertexBuffers["noiseCoordinates2"] = renderBuffer.createVertexBuffer("noiseCoordinates2", offset, 3, this._attributesStrideSize, true);
      offset += 3;
      if (this._platform.alignDataInBuffer) {
        offset += 1;
      }
    }
    renderVertexBuffers["angle"] = renderBuffer.createVertexBuffer("angle", offset, 1, this._attributesStrideSize, true);
    if (this._angularSpeedGradientsTexture) {
      offset++;
    } else {
      offset += 2;
    }
    if (this._isAnimationSheetEnabled) {
      renderVertexBuffers["cellIndex"] = renderBuffer.createVertexBuffer("cellIndex", offset, 1, this._attributesStrideSize, true);
      offset += 1;
      if (this.spriteRandomStartCell) {
        renderVertexBuffers["cellStartOffset"] = renderBuffer.createVertexBuffer("cellStartOffset", offset, 1, this._attributesStrideSize, true);
        offset += 1;
      }
    }
    renderVertexBuffers["offset"] = spriteSource.createVertexBuffer("offset", 0, 2);
    renderVertexBuffers["uv"] = spriteSource.createVertexBuffer("uv", 2, 2);
    this._platform.createVertexBuffers(updateBuffer, renderVertexBuffers);
    this.resetDrawCache();
  };
  GPUParticleSystem2.prototype._initialize = function(force) {
    if (force === void 0) {
      force = false;
    }
    if (this._buffer0 && !force) {
      return;
    }
    var engine = this._engine;
    var data = new Array();
    this._attributesStrideSize = 21;
    this._targetIndex = 0;
    if (this._platform.alignDataInBuffer) {
      this._attributesStrideSize += 1;
    }
    if (this.particleEmitterType instanceof CustomParticleEmitter) {
      this._attributesStrideSize += 3;
      if (this._platform.alignDataInBuffer) {
        this._attributesStrideSize += 1;
      }
    }
    if (!this.isBillboardBased) {
      this._attributesStrideSize += 3;
      if (this._platform.alignDataInBuffer) {
        this._attributesStrideSize += 1;
      }
    }
    if (this._colorGradientsTexture) {
      this._attributesStrideSize -= 4;
    }
    if (this._angularSpeedGradientsTexture) {
      this._attributesStrideSize -= 1;
    }
    if (this._isAnimationSheetEnabled) {
      this._attributesStrideSize += 1;
      if (this.spriteRandomStartCell) {
        this._attributesStrideSize += 1;
      }
    }
    if (this.noiseTexture) {
      this._attributesStrideSize += 6;
      if (this._platform.alignDataInBuffer) {
        this._attributesStrideSize += 2;
      }
    }
    if (this._platform.alignDataInBuffer) {
      this._attributesStrideSize += 3 - (this._attributesStrideSize + 3 & 3);
    }
    var usingCustomEmitter = this.particleEmitterType instanceof CustomParticleEmitter;
    var tmpVector = TmpVectors.Vector3[0];
    var offset = 0;
    for (var particleIndex = 0; particleIndex < this._capacity; particleIndex++) {
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(0);
      data.push(Math.random());
      data.push(Math.random());
      data.push(Math.random());
      data.push(Math.random());
      if (usingCustomEmitter) {
        this.particleEmitterType.particleDestinationGenerator(particleIndex, null, tmpVector);
        data.push(tmpVector.x);
        data.push(tmpVector.y);
        data.push(tmpVector.z);
      } else {
        data.push(0);
        data.push(0);
        data.push(0);
      }
      if (this._platform.alignDataInBuffer) {
        data.push(0);
      }
      offset += 16;
      if (usingCustomEmitter) {
        this.particleEmitterType.particlePositionGenerator(particleIndex, null, tmpVector);
        data.push(tmpVector.x);
        data.push(tmpVector.y);
        data.push(tmpVector.z);
        if (this._platform.alignDataInBuffer) {
          data.push(0);
        }
        offset += 4;
      }
      if (!this._colorGradientsTexture) {
        data.push(0);
        data.push(0);
        data.push(0);
        data.push(0);
        offset += 4;
      }
      if (!this.isBillboardBased) {
        data.push(0);
        data.push(0);
        data.push(0);
        if (this._platform.alignDataInBuffer) {
          data.push(0);
        }
        offset += 4;
      }
      if (this.noiseTexture) {
        data.push(Math.random());
        data.push(Math.random());
        data.push(Math.random());
        if (this._platform.alignDataInBuffer) {
          data.push(0);
        }
        data.push(Math.random());
        data.push(Math.random());
        data.push(Math.random());
        if (this._platform.alignDataInBuffer) {
          data.push(0);
        }
        offset += 8;
      }
      data.push(0);
      offset += 1;
      if (!this._angularSpeedGradientsTexture) {
        data.push(0);
        offset += 1;
      }
      if (this._isAnimationSheetEnabled) {
        data.push(0);
        offset += 1;
        if (this.spriteRandomStartCell) {
          data.push(0);
          offset += 1;
        }
      }
      if (this._platform.alignDataInBuffer) {
        var numDummies = 3 - (offset + 3 & 3);
        offset += numDummies;
        while (numDummies-- > 0) {
          data.push(0);
        }
      }
    }
    var spriteData = new Float32Array([0.5, 0.5, 1, 1, -0.5, 0.5, 0, 1, 0.5, -0.5, 1, 0, -0.5, -0.5, 0, 0]);
    var bufferData1 = this._platform.createParticleBuffer(data);
    var bufferData2 = this._platform.createParticleBuffer(data);
    this._buffer0 = new Buffer2(engine, bufferData1, false, this._attributesStrideSize);
    this._buffer1 = new Buffer2(engine, bufferData2, false, this._attributesStrideSize);
    this._spriteBuffer = new Buffer2(engine, spriteData, false, 4);
    this._createVertexBuffers(this._buffer0, this._buffer1, this._spriteBuffer);
    this._createVertexBuffers(this._buffer1, this._buffer0, this._spriteBuffer);
    this._sourceBuffer = this._buffer0;
    this._targetBuffer = this._buffer1;
  };
  GPUParticleSystem2.prototype._recreateUpdateEffect = function() {
    var defines = this.particleEmitterType ? this.particleEmitterType.getEffectDefines() : "";
    if (this._isBillboardBased) {
      defines += "\n#define BILLBOARD";
    }
    if (this._colorGradientsTexture) {
      defines += "\n#define COLORGRADIENTS";
    }
    if (this._sizeGradientsTexture) {
      defines += "\n#define SIZEGRADIENTS";
    }
    if (this._angularSpeedGradientsTexture) {
      defines += "\n#define ANGULARSPEEDGRADIENTS";
    }
    if (this._velocityGradientsTexture) {
      defines += "\n#define VELOCITYGRADIENTS";
    }
    if (this._limitVelocityGradientsTexture) {
      defines += "\n#define LIMITVELOCITYGRADIENTS";
    }
    if (this._dragGradientsTexture) {
      defines += "\n#define DRAGGRADIENTS";
    }
    if (this.isAnimationSheetEnabled) {
      defines += "\n#define ANIMATESHEET";
      if (this.spriteRandomStartCell) {
        defines += "\n#define ANIMATESHEETRANDOMSTART";
      }
    }
    if (this.noiseTexture) {
      defines += "\n#define NOISE";
    }
    if (this.isLocal) {
      defines += "\n#define LOCAL";
    }
    if (this._platform.isUpdateBufferCreated() && this._cachedUpdateDefines === defines) {
      return;
    }
    this._cachedUpdateDefines = defines;
    this._updateBuffer = this._platform.createUpdateBuffer(defines);
  };
  GPUParticleSystem2.prototype._getWrapper = function(blendMode) {
    var customWrapper = this._getCustomDrawWrapper(blendMode);
    if (customWrapper === null || customWrapper === void 0 ? void 0 : customWrapper.effect) {
      return customWrapper;
    }
    var defines = [];
    this.fillDefines(defines, blendMode);
    var drawWrapper = this._drawWrappers[blendMode];
    if (!drawWrapper) {
      drawWrapper = new DrawWrapper(this._engine);
      if (drawWrapper.drawContext) {
        drawWrapper.drawContext.useInstancing = true;
      }
      this._drawWrappers[blendMode] = drawWrapper;
    }
    var join = defines.join("\n");
    if (drawWrapper.defines !== join) {
      var attributes = [];
      var uniforms = [];
      var samplers = [];
      this.fillUniformsAttributesAndSamplerNames(uniforms, attributes, samplers);
      drawWrapper.setEffect(this._engine.createEffect("gpuRenderParticles", attributes, uniforms, samplers, join), join);
    }
    return drawWrapper;
  };
  GPUParticleSystem2._GetAttributeNamesOrOptions = function(hasColorGradients, isAnimationSheetEnabled, isBillboardBased, isBillboardStretched) {
    if (hasColorGradients === void 0) {
      hasColorGradients = false;
    }
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    if (isBillboardBased === void 0) {
      isBillboardBased = false;
    }
    if (isBillboardStretched === void 0) {
      isBillboardStretched = false;
    }
    var attributeNamesOrOptions = [VertexBuffer.PositionKind, "age", "life", "size", "angle"];
    if (!hasColorGradients) {
      attributeNamesOrOptions.push(VertexBuffer.ColorKind);
    }
    if (isAnimationSheetEnabled) {
      attributeNamesOrOptions.push("cellIndex");
    }
    if (!isBillboardBased) {
      attributeNamesOrOptions.push("initialDirection");
    }
    if (!isBillboardStretched) {
      attributeNamesOrOptions.push("direction");
    }
    attributeNamesOrOptions.push("offset", VertexBuffer.UVKind);
    return attributeNamesOrOptions;
  };
  GPUParticleSystem2._GetEffectCreationOptions = function(isAnimationSheetEnabled) {
    if (isAnimationSheetEnabled === void 0) {
      isAnimationSheetEnabled = false;
    }
    var effectCreationOption = [
      "emitterWM",
      "worldOffset",
      "view",
      "projection",
      "colorDead",
      "invView",
      "vClipPlane",
      "vClipPlane2",
      "vClipPlane3",
      "vClipPlane4",
      "vClipPlane5",
      "vClipPlane6",
      "translationPivot",
      "eyePosition"
    ];
    if (isAnimationSheetEnabled) {
      effectCreationOption.push("sheetInfos");
    }
    return effectCreationOption;
  };
  GPUParticleSystem2.prototype.fillDefines = function(defines, blendMode) {
    if (blendMode === void 0) {
      blendMode = 0;
    }
    if (this._scene) {
      if (this._scene.clipPlane) {
        defines.push("#define CLIPPLANE");
      }
      if (this._scene.clipPlane2) {
        defines.push("#define CLIPPLANE2");
      }
      if (this._scene.clipPlane3) {
        defines.push("#define CLIPPLANE3");
      }
      if (this._scene.clipPlane4) {
        defines.push("#define CLIPPLANE4");
      }
      if (this._scene.clipPlane5) {
        defines.push("#define CLIPPLANE5");
      }
      if (this._scene.clipPlane6) {
        defines.push("#define CLIPPLANE6");
      }
    }
    if (blendMode === ParticleSystem.BLENDMODE_MULTIPLY) {
      defines.push("#define BLENDMULTIPLYMODE");
    }
    if (this.isLocal) {
      defines.push("#define LOCAL");
    }
    if (this._isBillboardBased) {
      defines.push("#define BILLBOARD");
      switch (this.billboardMode) {
        case ParticleSystem.BILLBOARDMODE_Y:
          defines.push("#define BILLBOARDY");
          break;
        case ParticleSystem.BILLBOARDMODE_STRETCHED:
          defines.push("#define BILLBOARDSTRETCHED");
          break;
        case ParticleSystem.BILLBOARDMODE_ALL:
          defines.push("#define BILLBOARDMODE_ALL");
          break;
      }
    }
    if (this._colorGradientsTexture) {
      defines.push("#define COLORGRADIENTS");
    }
    if (this.isAnimationSheetEnabled) {
      defines.push("#define ANIMATESHEET");
    }
    if (this._imageProcessingConfiguration) {
      this._imageProcessingConfiguration.prepareDefines(this._imageProcessingConfigurationDefines);
      defines.push("" + this._imageProcessingConfigurationDefines.toString());
    }
  };
  GPUParticleSystem2.prototype.fillUniformsAttributesAndSamplerNames = function(uniforms, attributes, samplers) {
    attributes.push.apply(attributes, GPUParticleSystem2._GetAttributeNamesOrOptions(!!this._colorGradientsTexture, this._isAnimationSheetEnabled, this._isBillboardBased, this._isBillboardBased && this.billboardMode === ParticleSystem.BILLBOARDMODE_STRETCHED));
    uniforms.push.apply(uniforms, GPUParticleSystem2._GetEffectCreationOptions(this._isAnimationSheetEnabled));
    samplers.push("diffuseSampler", "colorGradientSampler");
    if (this._imageProcessingConfiguration) {
      ImageProcessingConfiguration.PrepareUniforms(uniforms, this._imageProcessingConfigurationDefines);
      ImageProcessingConfiguration.PrepareSamplers(samplers, this._imageProcessingConfigurationDefines);
    }
  };
  GPUParticleSystem2.prototype.animate = function(preWarm) {
    var _a2;
    if (preWarm === void 0) {
      preWarm = false;
    }
    this._timeDelta = this.updateSpeed * (preWarm ? this.preWarmStepOffset : ((_a2 = this._scene) === null || _a2 === void 0 ? void 0 : _a2.getAnimationRatio()) || 1);
    this._actualFrame += this._timeDelta;
    if (!this._stopped) {
      if (this.targetStopDuration && this._actualFrame >= this.targetStopDuration) {
        this.stop();
      }
    }
  };
  GPUParticleSystem2.prototype._createFactorGradientTexture = function(factorGradients, textureName) {
    var texture = this[textureName];
    if (!factorGradients || !factorGradients.length || texture) {
      return;
    }
    var data = new Float32Array(this._rawTextureWidth);
    var _loop_1 = function(x2) {
      var ratio = x2 / this_1._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, factorGradients, function(currentGradient, nextGradient, scale) {
        data[x2] = Scalar.Lerp(currentGradient.factor1, nextGradient.factor1, scale);
      });
    };
    var this_1 = this;
    for (var x = 0; x < this._rawTextureWidth; x++) {
      _loop_1(x);
    }
    this[textureName] = RawTexture.CreateRTexture(data, this._rawTextureWidth, 1, this._scene || this._engine, false, false, 1);
  };
  GPUParticleSystem2.prototype._createSizeGradientTexture = function() {
    this._createFactorGradientTexture(this._sizeGradients, "_sizeGradientsTexture");
  };
  GPUParticleSystem2.prototype._createAngularSpeedGradientTexture = function() {
    this._createFactorGradientTexture(this._angularSpeedGradients, "_angularSpeedGradientsTexture");
  };
  GPUParticleSystem2.prototype._createVelocityGradientTexture = function() {
    this._createFactorGradientTexture(this._velocityGradients, "_velocityGradientsTexture");
  };
  GPUParticleSystem2.prototype._createLimitVelocityGradientTexture = function() {
    this._createFactorGradientTexture(this._limitVelocityGradients, "_limitVelocityGradientsTexture");
  };
  GPUParticleSystem2.prototype._createDragGradientTexture = function() {
    this._createFactorGradientTexture(this._dragGradients, "_dragGradientsTexture");
  };
  GPUParticleSystem2.prototype._createColorGradientTexture = function() {
    if (!this._colorGradients || !this._colorGradients.length || this._colorGradientsTexture) {
      return;
    }
    var data = new Uint8Array(this._rawTextureWidth * 4);
    var tmpColor = TmpColors.Color4[0];
    var _loop_2 = function(x2) {
      var ratio = x2 / this_2._rawTextureWidth;
      GradientHelper.GetCurrentGradient(ratio, this_2._colorGradients, function(currentGradient, nextGradient, scale) {
        Color4.LerpToRef(currentGradient.color1, nextGradient.color1, scale, tmpColor);
        data[x2 * 4] = tmpColor.r * 255;
        data[x2 * 4 + 1] = tmpColor.g * 255;
        data[x2 * 4 + 2] = tmpColor.b * 255;
        data[x2 * 4 + 3] = tmpColor.a * 255;
      });
    };
    var this_2 = this;
    for (var x = 0; x < this._rawTextureWidth; x++) {
      _loop_2(x);
    }
    this._colorGradientsTexture = RawTexture.CreateRGBATexture(data, this._rawTextureWidth, 1, this._scene, false, false, 1);
  };
  GPUParticleSystem2.prototype._render = function(blendMode, emitterWM) {
    var _a2, _b2;
    var drawWrapper = this._getWrapper(blendMode);
    var effect = drawWrapper.effect;
    this._engine.enableEffect(drawWrapper);
    var viewMatrix = ((_a2 = this._scene) === null || _a2 === void 0 ? void 0 : _a2.getViewMatrix()) || Matrix.IdentityReadOnly;
    effect.setMatrix("view", viewMatrix);
    effect.setMatrix("projection", (_b2 = this.defaultProjectionMatrix) !== null && _b2 !== void 0 ? _b2 : this._scene.getProjectionMatrix());
    effect.setTexture("diffuseSampler", this.particleTexture);
    effect.setVector2("translationPivot", this.translationPivot);
    effect.setVector3("worldOffset", this.worldOffset);
    if (this.isLocal) {
      effect.setMatrix("emitterWM", emitterWM);
    }
    if (this._colorGradientsTexture) {
      effect.setTexture("colorGradientSampler", this._colorGradientsTexture);
    } else {
      effect.setDirectColor4("colorDead", this.colorDead);
    }
    if (this._isAnimationSheetEnabled && this.particleTexture) {
      var baseSize = this.particleTexture.getBaseSize();
      effect.setFloat3("sheetInfos", this.spriteCellWidth / baseSize.width, this.spriteCellHeight / baseSize.height, baseSize.width / this.spriteCellWidth);
    }
    if (this._isBillboardBased && this._scene) {
      var camera = this._scene.activeCamera;
      effect.setVector3("eyePosition", camera.globalPosition);
    }
    var defines = effect.defines;
    if (this._scene) {
      if (this._scene.clipPlane || this._scene.clipPlane2 || this._scene.clipPlane3 || this._scene.clipPlane4 || this._scene.clipPlane5 || this._scene.clipPlane6) {
        MaterialHelper.BindClipPlane(effect, this._scene);
      }
    }
    if (defines.indexOf("#define BILLBOARDMODE_ALL") >= 0) {
      var invView = viewMatrix.clone();
      invView.invert();
      effect.setMatrix("invView", invView);
    }
    if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
      this._imageProcessingConfiguration.bind(effect);
    }
    switch (blendMode) {
      case ParticleSystem.BLENDMODE_ADD:
        this._engine.setAlphaMode(1);
        break;
      case ParticleSystem.BLENDMODE_ONEONE:
        this._engine.setAlphaMode(6);
        break;
      case ParticleSystem.BLENDMODE_STANDARD:
        this._engine.setAlphaMode(2);
        break;
      case ParticleSystem.BLENDMODE_MULTIPLY:
        this._engine.setAlphaMode(4);
        break;
    }
    this._platform.bindDrawBuffers(this._targetIndex, effect);
    if (this._onBeforeDrawParticlesObservable) {
      this._onBeforeDrawParticlesObservable.notifyObservers(effect);
    }
    this._engine.drawArraysType(7, 0, 4, this._currentActiveCount);
    this._engine.setAlphaMode(0);
    return this._currentActiveCount;
  };
  GPUParticleSystem2.prototype.render = function(preWarm, forceUpdateOnly) {
    if (preWarm === void 0) {
      preWarm = false;
    }
    if (forceUpdateOnly === void 0) {
      forceUpdateOnly = false;
    }
    if (!this._started) {
      return 0;
    }
    this._createColorGradientTexture();
    this._createSizeGradientTexture();
    this._createAngularSpeedGradientTexture();
    this._createVelocityGradientTexture();
    this._createLimitVelocityGradientTexture();
    this._createDragGradientTexture();
    this._recreateUpdateEffect();
    if (!this.isReady()) {
      return 0;
    }
    if (!preWarm && this._scene) {
      if (!this._preWarmDone && this.preWarmCycles) {
        for (var index = 0; index < this.preWarmCycles; index++) {
          this.animate(true);
          this.render(true, true);
        }
        this._preWarmDone = true;
      }
      if (this._currentRenderId === this._scene.getFrameId() && (!this._scene.activeCamera || this._scene.activeCamera && this._currentRenderingCameraUniqueId === this._scene.activeCamera.uniqueId)) {
        return 0;
      }
      this._currentRenderId = this._scene.getFrameId();
      if (this._scene.activeCamera) {
        this._currentRenderingCameraUniqueId = this._scene.activeCamera.uniqueId;
      }
    }
    this._initialize();
    this._accumulatedCount += this.emitRate * this._timeDelta;
    if (this._accumulatedCount > 1) {
      var intPart = this._accumulatedCount | 0;
      this._accumulatedCount -= intPart;
      this._currentActiveCount = Math.min(this._activeCount, this._currentActiveCount + intPart);
    }
    if (!this._currentActiveCount) {
      return 0;
    }
    var emitterWM;
    if (this.emitter.position) {
      var emitterMesh = this.emitter;
      emitterWM = emitterMesh.getWorldMatrix();
    } else {
      var emitterPosition = this.emitter;
      emitterWM = Matrix.Translation(emitterPosition.x, emitterPosition.y, emitterPosition.z);
    }
    var engine = this._engine;
    this._platform.preUpdateParticleBuffer();
    this._updateBuffer.setFloat("currentCount", this._currentActiveCount);
    this._updateBuffer.setFloat("timeDelta", this._timeDelta);
    this._updateBuffer.setFloat("stopFactor", this._stopped ? 0 : 1);
    this._updateBuffer.setInt("randomTextureSize", this._randomTextureSize);
    this._updateBuffer.setFloat2("lifeTime", this.minLifeTime, this.maxLifeTime);
    this._updateBuffer.setFloat2("emitPower", this.minEmitPower, this.maxEmitPower);
    if (!this._colorGradientsTexture) {
      this._updateBuffer.setDirectColor4("color1", this.color1);
      this._updateBuffer.setDirectColor4("color2", this.color2);
    }
    this._updateBuffer.setFloat2("sizeRange", this.minSize, this.maxSize);
    this._updateBuffer.setFloat4("scaleRange", this.minScaleX, this.maxScaleX, this.minScaleY, this.maxScaleY);
    this._updateBuffer.setFloat4("angleRange", this.minAngularSpeed, this.maxAngularSpeed, this.minInitialRotation, this.maxInitialRotation);
    this._updateBuffer.setVector3("gravity", this.gravity);
    if (this._limitVelocityGradientsTexture) {
      this._updateBuffer.setFloat("limitVelocityDamping", this.limitVelocityDamping);
    }
    if (this.particleEmitterType) {
      this.particleEmitterType.applyToShader(this._updateBuffer);
    }
    if (this._isAnimationSheetEnabled) {
      this._updateBuffer.setFloat4("cellInfos", this.startSpriteCellID, this.endSpriteCellID, this.spriteCellChangeSpeed, this.spriteCellLoop ? 1 : 0);
    }
    if (this.noiseTexture) {
      this._updateBuffer.setVector3("noiseStrength", this.noiseStrength);
    }
    if (!this.isLocal) {
      this._updateBuffer.setMatrix("emitterWM", emitterWM);
    }
    this._platform.updateParticleBuffer(this._targetIndex, this._targetBuffer, this._currentActiveCount);
    var outparticles = 0;
    if (!preWarm && !forceUpdateOnly) {
      engine.setState(false);
      if (this.forceDepthWrite) {
        engine.setDepthWrite(true);
      }
      if (this.blendMode === ParticleSystem.BLENDMODE_MULTIPLYADD) {
        outparticles = this._render(ParticleSystem.BLENDMODE_MULTIPLY, emitterWM) + this._render(ParticleSystem.BLENDMODE_ADD, emitterWM);
      } else {
        outparticles = this._render(this.blendMode, emitterWM);
      }
      this._engine.setAlphaMode(0);
    }
    this._targetIndex++;
    if (this._targetIndex === 2) {
      this._targetIndex = 0;
    }
    var tmpBuffer = this._sourceBuffer;
    this._sourceBuffer = this._targetBuffer;
    this._targetBuffer = tmpBuffer;
    return outparticles;
  };
  GPUParticleSystem2.prototype.rebuild = function() {
    this._initialize(true);
  };
  GPUParticleSystem2.prototype._releaseBuffers = function() {
    if (this._buffer0) {
      this._buffer0.dispose();
      this._buffer0 = null;
    }
    if (this._buffer1) {
      this._buffer1.dispose();
      this._buffer1 = null;
    }
    if (this._spriteBuffer) {
      this._spriteBuffer.dispose();
      this._spriteBuffer = null;
    }
    this._platform.releaseBuffers();
  };
  GPUParticleSystem2.prototype.dispose = function(disposeTexture) {
    if (disposeTexture === void 0) {
      disposeTexture = true;
    }
    for (var blendMode in this._drawWrappers) {
      var drawWrapper = this._drawWrappers[blendMode];
      drawWrapper.dispose();
    }
    this._drawWrappers = {};
    if (this._scene) {
      var index = this._scene.particleSystems.indexOf(this);
      if (index > -1) {
        this._scene.particleSystems.splice(index, 1);
      }
    }
    this._releaseBuffers();
    this._platform.releaseVertexBuffers();
    if (this._colorGradientsTexture) {
      this._colorGradientsTexture.dispose();
      this._colorGradientsTexture = null;
    }
    if (this._sizeGradientsTexture) {
      this._sizeGradientsTexture.dispose();
      this._sizeGradientsTexture = null;
    }
    if (this._angularSpeedGradientsTexture) {
      this._angularSpeedGradientsTexture.dispose();
      this._angularSpeedGradientsTexture = null;
    }
    if (this._velocityGradientsTexture) {
      this._velocityGradientsTexture.dispose();
      this._velocityGradientsTexture = null;
    }
    if (this._limitVelocityGradientsTexture) {
      this._limitVelocityGradientsTexture.dispose();
      this._limitVelocityGradientsTexture = null;
    }
    if (this._dragGradientsTexture) {
      this._dragGradientsTexture.dispose();
      this._dragGradientsTexture = null;
    }
    if (this._randomTexture) {
      this._randomTexture.dispose();
      this._randomTexture = null;
    }
    if (this._randomTexture2) {
      this._randomTexture2.dispose();
      this._randomTexture2 = null;
    }
    if (disposeTexture && this.particleTexture) {
      this.particleTexture.dispose();
      this.particleTexture = null;
    }
    if (disposeTexture && this.noiseTexture) {
      this.noiseTexture.dispose();
      this.noiseTexture = null;
    }
    this.onStoppedObservable.clear();
    this.onDisposeObservable.notifyObservers(this);
    this.onDisposeObservable.clear();
  };
  GPUParticleSystem2.prototype.clone = function(name2, newEmitter) {
    var custom = __assign({}, this._customWrappers);
    var program = null;
    var engine = this._engine;
    if (engine.createEffectForParticles) {
      if (this.customShader != null) {
        program = this.customShader;
        var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
        custom[0] = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, void 0, void 0, void 0, this);
      }
    }
    var serialization = this.serialize();
    var result = GPUParticleSystem2.Parse(serialization, this._scene || this._engine, this._rootUrl);
    result.name = name2;
    result.customShader = program;
    result._customWrappers = custom;
    if (newEmitter === void 0) {
      newEmitter = this.emitter;
    }
    if (this.noiseTexture) {
      result.noiseTexture = this.noiseTexture.clone();
    }
    result.emitter = newEmitter;
    return result;
  };
  GPUParticleSystem2.prototype.serialize = function(serializeTexture) {
    if (serializeTexture === void 0) {
      serializeTexture = false;
    }
    var serializationObject = {};
    ParticleSystem._Serialize(serializationObject, this, serializeTexture);
    serializationObject.activeParticleCount = this.activeParticleCount;
    serializationObject.randomTextureSize = this._randomTextureSize;
    serializationObject.customShader = this.customShader;
    return serializationObject;
  };
  GPUParticleSystem2.Parse = function(parsedParticleSystem, sceneOrEngine, rootUrl, doNotStart, capacity) {
    if (doNotStart === void 0) {
      doNotStart = false;
    }
    var name2 = parsedParticleSystem.name;
    var engine;
    var scene;
    if (sceneOrEngine instanceof ThinEngine) {
      engine = sceneOrEngine;
    } else {
      scene = sceneOrEngine;
      engine = scene.getEngine();
    }
    var particleSystem = new GPUParticleSystem2(name2, { capacity: capacity || parsedParticleSystem.capacity, randomTextureSize: parsedParticleSystem.randomTextureSize }, sceneOrEngine, null, parsedParticleSystem.isAnimationSheetEnabled);
    particleSystem._rootUrl = rootUrl;
    if (parsedParticleSystem.customShader && engine.createEffectForParticles) {
      var program = parsedParticleSystem.customShader;
      var defines = program.shaderOptions.defines.length > 0 ? program.shaderOptions.defines.join("\n") : "";
      var custom = engine.createEffectForParticles(program.shaderPath.fragmentElement, program.shaderOptions.uniforms, program.shaderOptions.samplers, defines, void 0, void 0, void 0, particleSystem);
      particleSystem.setCustomEffect(custom, 0);
      particleSystem.customShader = program;
    }
    if (parsedParticleSystem.id) {
      particleSystem.id = parsedParticleSystem.id;
    }
    if (parsedParticleSystem.activeParticleCount) {
      particleSystem.activeParticleCount = parsedParticleSystem.activeParticleCount;
    }
    ParticleSystem._Parse(parsedParticleSystem, particleSystem, sceneOrEngine, rootUrl);
    if (parsedParticleSystem.preventAutoStart) {
      particleSystem.preventAutoStart = parsedParticleSystem.preventAutoStart;
    }
    if (!doNotStart && !particleSystem.preventAutoStart) {
      particleSystem.start();
    }
    return particleSystem;
  };
  return GPUParticleSystem2;
}(BaseParticleSystem);
AbstractScene.AddParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function(parsedData, scene, container, rootUrl) {
  var individualParser = AbstractScene.GetIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM);
  if (!individualParser) {
    return;
  }
  if (parsedData.particleSystems !== void 0 && parsedData.particleSystems !== null) {
    for (var index = 0, cache = parsedData.particleSystems.length; index < cache; index++) {
      var parsedParticleSystem = parsedData.particleSystems[index];
      container.particleSystems.push(individualParser(parsedParticleSystem, scene, rootUrl));
    }
  }
});
AbstractScene.AddIndividualParser(SceneComponentConstants.NAME_PARTICLESYSTEM, function(parsedParticleSystem, scene, rootUrl) {
  if (parsedParticleSystem.activeParticleCount) {
    var ps = GPUParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
    return ps;
  } else {
    var ps = ParticleSystem.Parse(parsedParticleSystem, scene, rootUrl);
    return ps;
  }
});
Engine.prototype.createEffectForParticles = function(fragmentName, uniformsNames, samplers, defines, fallbacks, onCompiled, onError, particleSystem) {
  var _a2;
  if (uniformsNames === void 0) {
    uniformsNames = [];
  }
  if (samplers === void 0) {
    samplers = [];
  }
  if (defines === void 0) {
    defines = "";
  }
  var attributesNamesOrOptions = [];
  var effectCreationOption = [];
  var allSamplers = [];
  if (particleSystem) {
    particleSystem.fillUniformsAttributesAndSamplerNames(effectCreationOption, attributesNamesOrOptions, allSamplers);
  } else {
    attributesNamesOrOptions = ParticleSystem._GetAttributeNamesOrOptions();
    effectCreationOption = ParticleSystem._GetEffectCreationOptions();
  }
  if (defines.indexOf(" BILLBOARD") === -1) {
    defines += "\n#define BILLBOARD\n";
  }
  if (samplers.indexOf("diffuseSampler") === -1) {
    samplers.push("diffuseSampler");
  }
  return this.createEffect({
    vertex: (_a2 = particleSystem === null || particleSystem === void 0 ? void 0 : particleSystem.vertexShaderName) !== null && _a2 !== void 0 ? _a2 : "particles",
    fragmentElement: fragmentName
  }, attributesNamesOrOptions, effectCreationOption.concat(uniformsNames), allSamplers.concat(samplers), defines, fallbacks, onCompiled, onError);
};
Mesh.prototype.getEmittedParticleSystems = function() {
  var results = new Array();
  for (var index = 0; index < this.getScene().particleSystems.length; index++) {
    var particleSystem = this.getScene().particleSystems[index];
    if (particleSystem.emitter === this) {
      results.push(particleSystem);
    }
  }
  return results;
};
Mesh.prototype.getHierarchyEmittedParticleSystems = function() {
  var results = new Array();
  var descendants = this.getDescendants();
  descendants.push(this);
  for (var index = 0; index < this.getScene().particleSystems.length; index++) {
    var particleSystem = this.getScene().particleSystems[index];
    var emitter = particleSystem.emitter;
    if (emitter.position && descendants.indexOf(emitter) !== -1) {
      results.push(particleSystem);
    }
  }
  return results;
};
function CreateCaiDanYaBombParticle(scene, position) {
  ParticleHelper.BaseAssetsUrl = "/game_njcb/scene/particle";
  ParticleHelper.CreateAsync("bombParticleSystem", scene).then(function(set) {
    set.systems.forEach((s) => {
      s.disposeOnStop = true;
    });
    set.systems[0].emitter = position;
    set.start();
  });
}
class PaintedEggshellDuck {
  constructor(scene, emitter) {
    this.duckAsset = { rootUrl: ConfigAsset.paintedEggshellDuck.rootUrl, file: ConfigAsset.paintedEggshellDuck.file };
    this._duckList = [];
    this._nameFunc = (name2) => {
      return name2;
    };
    this._scene = scene;
    this._emitter = emitter;
  }
  createNewDuck(scene, position, rotation, player, duckName, duckId, isFirstShow = false) {
    var _a2;
    this._scene = scene;
    const duckMaterial = createCaiDanYa(this._scene);
    const duck = (_a2 = this.duckAsset.asset) == null ? void 0 : _a2.instantiateModelsToScene(this._nameFunc);
    if (duck) {
      const mesh = BABYLON$1.MeshBuilder.CreateBox(duckName, { size: 1.5 }, this._scene);
      mesh.material = new BABYLON$1.StandardMaterial("PaintedEggshellDuckMaterial", this._scene);
      mesh.material.alpha = 0;
      mesh.position = new BABYLON$1.Vector3(position.x, 0, position.z);
      this._createInterface(player, mesh);
      this._duckList.push({ duckId, duckName, duckInterfaceMesh: mesh, duckNode: duck });
    }
    if (duck == null ? void 0 : duck.rootNodes[0]) {
      duck.rootNodes[0].position = position;
      duck.rootNodes[0].getChildMeshes()[0].material = duckMaterial;
      duck.rootNodes[0].rotationQuaternion = null;
      duck.rootNodes[0].rotation = new BABYLON$1.Vector3(0, -rotation.y - Math.PI / 2, 0);
      duck.rootNodes[0].name = String(duckId);
      if (isFirstShow) {
        SoundManager.getInstance().playDuckSoundEffect();
        CreateCaiDanYaBombParticle(this._scene, position);
        duck.animationGroups[0].play(false);
        duck.animationGroups[0].onAnimationGroupEndObservable.addOnce(() => {
          duck.animationGroups[1].play(true);
          this._emitter.emit(NjcbEventEnum.SHOW_DUCK_DIALOG, { id: duckId });
          this._emitter.emit(NjcbEventEnum.CAMERA_END, null);
        });
      } else {
        duck.animationGroups[1].play(true);
      }
    }
  }
  _createInterface(player, mesh) {
    var _a2;
    if (player.root.actionManager === null) {
      player.root.actionManager = new BABYLON$1.ActionManager(this._scene);
    }
    const enterAction = new BABYLON$1.ExecuteCodeAction({
      trigger: BABYLON$1.ActionManager.OnIntersectionEnterTrigger,
      parameter: mesh
    }, () => {
      var _a3;
      const duckInfo = this._duckList.find((duck) => duck.duckInterfaceMesh === mesh);
      if (duckInfo) {
        (_a3 = player.root.actionManager) == null ? void 0 : _a3.unregisterAction(enterAction);
        mesh.isVisible = false;
        this.duckIsMissCallback && this.duckIsMissCallback(false);
        console.warn("\u{1F680} ----------------------------------------------------------------\u89E6\u53D1\u78B0\u649E\u5F69\u86CB\u9E2D\u8BF7\u6C42");
        getDuckReward(duckInfo.duckName).then((data) => {
          console.warn("\u{1F680} ~ file: painted_eggshell_duck.ts ~ line 86 ~ PaintedEggshellDuck ~ getDuckReward ~ data", data);
          const duck = duckInfo == null ? void 0 : duckInfo.duckNode;
          duck == null ? void 0 : duck.animationGroups[2].play(false);
          duck == null ? void 0 : duck.animationGroups[2].onAnimationGroupEndObservable.addOnce(() => {
            this._emitter.emit(NjcbEventEnum.GET_DUCK, { id: data.dialogId, goodsId: data.goodsId });
            this.duckIsMissCallback && this.duckIsMissCallback(true);
            duck == null ? void 0 : duck.rootNodes[0].dispose();
            this._scene.removeMesh(mesh);
            this._duckList.splice(this._duckList.indexOf(duckInfo), 1);
          });
        });
      }
    });
    (_a2 = player.root.actionManager) == null ? void 0 : _a2.registerAction(enterAction);
  }
  _duckLookAtPlayer(scene, duckNode, player, hotspotDistance, callback) {
    const node = duckNode.rootNodes[0];
    const update2 = () => {
      const inHotspot = IsHotspot(duckNode.rootNodes[0].position, player.root.position, hotspotDistance);
      if (inHotspot && node) {
        node.lookAt(player.root.position);
        callback && callback(inHotspot);
      }
    };
    scene.registerAfterRender(update2);
  }
}
function endGuideAnimation(player, camera, controller, callBack) {
  camera.target.copyFrom(player.root.position);
  const origin2 = {
    cameraAlpha: camera.alpha,
    cameraRadius: camera.radius,
    cameraTarget: camera.target.clone()
  };
  const defaultDis = controller._controlAttribute.cameraDistDefault || 10;
  const target2 = {
    cameraAlpha: camera.alpha,
    cameraRadius: defaultDis,
    cameraTarget: player.root.position.add(new BABYLON$1.Vector3(0, 0, 0))
  };
  const tweenOut = new Tween(origin2);
  tweenOut.to(target2, 1500);
  tweenOut.easing(Easing.Quadratic.InOut);
  tweenOut.onUpdate((object) => {
    camera.alpha = object.cameraAlpha;
    camera.radius = object.cameraRadius || 0;
  });
  tweenOut.start();
  tweenOut.onComplete(() => {
    controller.attachControl({ camera: controller.getCameraState() });
    callBack && callBack();
  });
}
var StatMode = /* @__PURE__ */ ((StatMode2) => {
  StatMode2[StatMode2["ENGINE_MARK"] = 0] = "ENGINE_MARK";
  StatMode2[StatMode2["SCENE_BIND"] = 1] = "SCENE_BIND";
  return StatMode2;
})(StatMode || {});
const PERF_MARK_INTERVAL = 1e3;
const PERF_ARRAY_SIZE = 10;
const PUSH_DATA_DURATION = 6e4;
class StatReporter {
  constructor(roundId) {
    this._perfLastMarkTime = -1;
    this._lastPushTime = -1;
    this._perfArray = new Array();
    this._statArray = [];
    this._user = void 0;
    this._roundId = roundId;
  }
  setUser(user) {
    this._user = user;
  }
  fetchDataIfNeeded(fetch) {
    const now2 = Date.now();
    if (this._checkMarkInterval(now2)) {
      const data = fetch();
      this._perfArray.push(data);
      if (this.mergePerfDataIfNeeded(now2)) {
        this.pushStatDataIfNeeded(now2);
      }
    }
  }
  _checkMarkInterval(time) {
    if (time - this._perfLastMarkTime > PERF_MARK_INTERVAL) {
      this._perfLastMarkTime = time;
      return true;
    }
    return false;
  }
  buildPlatform() {
    return {
      os: PlatformUtil.getOS(),
      os_version: PlatformUtil.getOSVersion(),
      device: PlatformUtil.getDevice(),
      browser: PlatformUtil.getBrowser()
    };
  }
  buildPerfProperties() {
    return {
      round_id: this._roundId,
      platform: this.buildPlatform(),
      performance: this._perfArray
    };
  }
  mergePerfDataIfNeeded(time) {
    if (this._perfArray.length >= PERF_ARRAY_SIZE) {
      const perfP = this.buildPerfProperties();
      let userType = 0;
      let userId = "unknown";
      if (this._user) {
        userId = this._user;
        userType = 1;
      }
      const itemData = {
        app_key: "web3d",
        data_id: GUID.RandomId(),
        properties: perfP,
        user_id: userId,
        user_type: userType,
        slot: "unknown",
        event_id: "unknown",
        type: "3d_perf",
        ts: time
      };
      this._statArray.push(itemData);
      this._perfArray = [];
      return true;
    }
    return false;
  }
  pushStatDataIfNeeded(time) {
    if (this._lastPushTime < 0) {
      this._lastPushTime = time;
      return;
    }
    if (time - this._lastPushTime >= PUSH_DATA_DURATION) {
      let url = "https://api-gateway-pr79.gotin.top/web/report";
      axios.post(url, this._statArray).then(() => {
      }).catch(() => {
      });
      this._statArray = [];
      this._lastPushTime = -1;
    }
  }
}
const _StatUtil = class {
  static _traversalScene(scene) {
    let faceCount = 0;
    let collider = 0;
    for (let i = 0; i < scene.meshes.length; i++) {
      const mesh = scene.meshes[i];
      if (mesh instanceof BABYLON$1.Mesh) {
        if (mesh.checkCollisions) {
          collider++;
        }
        const geometry = mesh.geometry;
        if (geometry) {
          const indices = geometry.getIndices();
          if (indices) {
            faceCount += indices.length / 3;
          }
        }
      }
    }
    return { c: collider, f: faceCount };
  }
  static setUser(user) {
    var _a2;
    this._user = user;
    (_a2 = this._worker) == null ? void 0 : _a2.setUser(this._user);
  }
  static init() {
    this._statMode = StatMode.SCENE_BIND;
    this._roundId = BABYLON$1.RandomGUID();
    this._worker = new StatReporter(this._roundId);
    this._worker.setUser(this._user);
  }
  static clear() {
    this.unbind();
    this._roundId = void 0;
  }
  static bind(scene) {
    if (this._scene === void 0) {
      this._scene = scene;
      if (this._statMode === StatMode.SCENE_BIND) {
        this._scene.registerAfterRender(this._sceneUpdateHandler);
      }
    }
  }
  static unbind() {
    if (this._statMode === StatMode.SCENE_BIND) {
      if (this._scene) {
        this._scene.unregisterAfterRender(this._sceneUpdateHandler);
      }
    }
    this._scene = void 0;
  }
};
let StatUtil = _StatUtil;
StatUtil._statMode = StatMode.SCENE_BIND;
StatUtil._roundId = void 0;
StatUtil._worker = void 0;
StatUtil._scene = void 0;
StatUtil._user = "unknown";
StatUtil._sceneUpdateHandler = () => {
  var _a2;
  try {
    if (_StatUtil._worker && _StatUtil._scene) {
      const scene = _StatUtil._scene;
      (_a2 = _StatUtil._worker) == null ? void 0 : _a2.fetchDataIfNeeded(() => {
        scene.getEngine()._drawCalls.endMonitoring();
        const drawcall = Math.ceil(scene.getEngine()._drawCalls.lastSecAverage);
        const f = scene.getEngine().getFps();
        const fps = Math.ceil(Number.isFinite(f) ? f : -1);
        const material = scene.materials.length;
        const vertex = scene.getTotalVertices();
        const traversalResult = _StatUtil._traversalScene(scene);
        return {
          fps,
          drawcall,
          material,
          vertex,
          collider: traversalResult.c,
          face: traversalResult.f,
          ts: Date.now()
        };
      });
      _StatUtil._scene.getEngine()._drawCalls.beginMonitoring();
    }
  } catch (e) {
    console.error("Error: [Stat]", e);
  }
};
function ConvertNpcModel(npcModelInput) {
  const ret = new Array();
  if (npcModelInput instanceof Array) {
    npcModelInput.forEach((item) => {
      ret.push(ConvertNpcModelRow(item));
    });
  }
  return ret;
}
function ConvertNpcModelRow(rawData) {
  const id = rawData.id ? rawData.id : -1;
  const typeModel = rawData.typeModel ? rawData.typeModel : -1;
  const head = rawData.head ? rawData.head : -1;
  const upperBody = rawData.upperBody ? rawData.upperBody : -1;
  const lowerBody = rawData.lowerBody ? rawData.lowerBody : -1;
  return {
    id,
    typeModel,
    head,
    upperBody,
    lowerBody
  };
}
function ConvertNpcConfig(npcConfigInput) {
  const ret = new Array();
  if (npcConfigInput instanceof Array) {
    npcConfigInput.forEach((item) => {
      ret.push(ConvertNpcConfigRow(item));
    });
  }
  return ret;
}
function ConvertNpcConfigRow(rawData) {
  const id = rawData.id ? rawData.id : -1;
  const model = rawData.model ? rawData.model : "";
  const x = rawData.x ? rawData.x : -1;
  const y = rawData.y ? rawData.y : -1;
  const z = rawData.z ? rawData.z : -1;
  const orientation = rawData.orientation ? rawData.orientation : -1;
  const type = rawData.type ? rawData.type : -1;
  const imagePath = rawData.imagePath ? rawData.imagePath : "";
  const imageName = rawData.imageName ? rawData.imageName : "";
  const iconPath = rawData.iconPath ? rawData.iconPath : "";
  const iconName = rawData.iconName ? rawData.iconName : "";
  const npcName = rawData.npcName ? rawData.npcName : "";
  const bubble = rawData.bubble ? rawData.bubble : "";
  const npcBubble1 = rawData.npcBubble1 ? rawData.npcBubble1 : "";
  const npcBubble2 = rawData.npcBubble2 ? rawData.npcBubble2 : "";
  const ai = rawData.ai ? rawData.ai : -1;
  const ifInteractive = rawData.ifInteractive ? rawData.ifInteractive : -1;
  const typeHot = rawData.typeHot ? rawData.typeHot : -1;
  const rangeHot = rawData.rangeHot ? rawData.rangeHot : -1;
  const rangeCoo = rawData.rangeCoo ? rawData.rangeCoo : "";
  const interactiveType = rawData.interactiveType ? rawData.interactiveType : -1;
  const skipType = rawData.skipType ? rawData.skipType : -1;
  const skipTo = rawData.skipTo ? rawData.skipTo : "";
  const dialogueId1 = rawData.dialogueId1 ? rawData.dialogueId1 : -1;
  return {
    id,
    model,
    x,
    y,
    z,
    orientation,
    type,
    imagePath,
    imageName,
    iconPath,
    iconName,
    npcName,
    bubble,
    npcBubble1,
    npcBubble2,
    ai,
    ifInteractive,
    typeHot,
    rangeHot,
    rangeCoo,
    interactiveType,
    skipType,
    skipTo,
    dialogueId1
  };
}
function createSky(scene) {
  const skySphereMesh = MeshBuilder.CreateSphere("sky", { diameter: 500, segments: 16 });
  skySphereMesh.isPickable = false;
  const M_Sky = new NodeMaterial("M_Sky", scene, {
    emitComments: true
  });
  M_Sky.loadAsync("/game_njcb/scene/material/sky.json").then(() => {
    M_Sky.build(false);
    M_Sky.stencil.enabled = true;
    M_Sky.stencil.funcRef = 1;
    M_Sky.sideOrientation = 0;
    skySphereMesh.material = M_Sky;
  });
}
function createWater(scene, mesh, depthTex) {
  const M_FX_Water = new NodeMaterial("M_FX_Water", scene, {
    emitComments: true
  });
  M_FX_Water.loadAsync("/game_njcb/scene/material/water.json").then(() => {
    M_FX_Water.build(false);
    M_FX_Water.stencil.enabled = true;
    M_FX_Water.stencil.funcRef = 1;
    M_FX_Water.disableDepthWrite = true;
    const textureBlock = M_FX_Water.getBlockByName("DepthTexture");
    textureBlock.texture = depthTex;
    mesh.material = M_FX_Water;
    mesh.alphaIndex = 1.8;
  });
}
function createWaterfall(scene, waterfallMesh, rippleMesh) {
  const M_Waterfall = new NodeMaterial("M_Waterfall", scene, {
    emitComments: true
  });
  M_Waterfall.loadAsync("/game_njcb/scene/material/waterfall.json").then(() => {
    M_Waterfall.build(false);
    M_Waterfall.stencil.enabled = true;
    M_Waterfall.stencil.funcRef = 1;
    waterfallMesh.material = M_Waterfall;
  });
  const M_Ripple = new NodeMaterial("M_Ripple", scene, {
    emitComments: true
  });
  M_Ripple.loadAsync("/game_njcb/scene/material/ripple.json").then(() => {
    M_Ripple.build(false);
    M_Ripple.stencil.enabled = true;
    M_Ripple.stencil.funcRef = 1;
    M_Ripple.disableDepthWrite = true;
    rippleMesh.material = M_Ripple;
  });
}
function ChangeMaterial(scene) {
  const hdrTexture = CubeTexture.CreateFromPrefilteredData("https://meta.gotin.online/assets/game_porsche/scene/env/environmentSpecular.env", scene);
  scene.environmentTexture = hdrTexture;
  scene.environmentIntensity = 2;
  scene.imageProcessingConfiguration.contrast = 1.2;
  scene.imageProcessingConfiguration.exposure = 1.2;
  const camera = scene.getCameraById("camera");
  createSky(scene);
  const Scene_G = scene.getNodeById("Scene_G");
  Scene_G == null ? void 0 : Scene_G.getChildMeshes(false).forEach((mesh) => {
    mesh.isPickable = false;
  });
  const M_Ground = new StandardMaterial("M_Ground", scene);
  M_Ground.diffuseTexture = new Texture$1("game_njcb/scene/S_NanJingYinHangScene/T_Ground.jpg", scene, { invertY: false });
  M_Ground.specularColor = new Color3$1(0, 0, 0);
  scene.getMeshById("Ground").material = M_Ground;
  const M_House = new StandardMaterial("M_House", scene);
  M_House.diffuseTexture = new Texture$1("game_njcb/scene/S_NanJingYinHangScene/T_House.jpg", scene, { invertY: false });
  M_House.diffuseTexture.level = 1.26;
  M_House.specularColor = new Color3$1(0, 0, 0);
  scene.getMeshById("House").material = M_House;
  const M_YaMesh = new StandardMaterial("M_YaMesh", scene);
  M_YaMesh.diffuseTexture = new Texture$1("game_njcb/scene/S_NanJingYinHangScene/T_YaMesh.jpg", scene, { invertY: false });
  M_YaMesh.diffuseTexture.level = 1.26;
  M_YaMesh.specularColor = new Color3$1(0, 0, 0);
  const Obstache_G = scene.getNodeById("Obstache_G");
  Obstache_G == null ? void 0 : Obstache_G.getChildMeshes(false).forEach((mesh) => {
    if (mesh.id === "Ya_Mesh") {
      mesh.material = M_YaMesh;
    } else {
      mesh.material = M_House;
    }
  });
  const M_Alpha_YaZi = scene.getMaterialById("M_GuangGaoPai");
  M_Alpha_YaZi.metallic = 0.3;
  M_Alpha_YaZi.roughness = 0.3;
  M_Alpha_YaZi.transparencyMode = 1;
  M_Alpha_YaZi.backFaceCulling = false;
  const AN_GuangGao_Ya = scene.getAnimationGroupByName("GuangGao_Ya");
  AN_GuangGao_Ya.speedRatio = 0.25;
  const GuangGaoNode = scene.getNodeById("GuangGao");
  GuangGaoNode == null ? void 0 : GuangGaoNode.getChildMeshes(false).forEach((mesh) => {
    mesh.isPickable = false;
  });
  const depthRenderer = scene.enableDepthRenderer(camera, false);
  const depthTex = depthRenderer.getDepthMap();
  const ShuiDiNode = scene.getNodeById("ShuiDi");
  depthTex.renderList = [];
  ShuiDiNode == null ? void 0 : ShuiDiNode.getChildMeshes(false).forEach((mesh) => {
    var _a2;
    (_a2 = depthTex.renderList) == null ? void 0 : _a2.push(mesh);
  });
  const meshShuiMian = scene.getMeshById("ShuiMian");
  createWater(scene, meshShuiMian, depthTex);
  const waterfallMesh = scene.getMeshById("PuBu");
  const rippleMesh = scene.getMeshById("Ripple");
  createWaterfall(scene, waterfallMesh, rippleMesh);
  const cloud_grp = scene.getNodeById("_Cloud_grp");
  cloud_grp == null ? void 0 : cloud_grp.getChildMeshes(false).forEach((mesh) => {
    mesh.isPickable = false;
  });
  scene.autoClear = false;
  scene.autoClearDepthAndStencil = false;
  scene.blockMaterialDirtyMechanism = true;
  scene.materials.forEach((material) => {
  });
}
class Game {
  constructor(canvas, options) {
    this._isStarted = false;
    this._isAttached = false;
    this._isDebug = true;
    this._controllerAttribute = GetControlAttributeByConfig(ConfigController);
    this._config = {};
    this._guide = false;
    this._prevTime = Date.now();
    this._prevHeartTime = Date.now();
    this._eggDuckTime = Date.now();
    this._duckData = null;
    this._isFindDuckShow = false;
    this._duckPosition = BABYLON$1.Vector3.Zero();
    this._duckRotation = BABYLON$1.Vector3.Zero();
    this._renderLoopHandler = () => {
      this._eggDuckTime += this._scene.getEngine().getDeltaTime() / 1e3;
      if (this._eggDuckTime >= 1.5) {
        this._eggDuckTime = 0;
        this._timeCanNewDuck();
      }
      this._prevTime = this._scene.getEngine().getDeltaTime() / 1e3 + this._prevTime;
      if (this._prevTime > 1 && this._playerController) {
        this._prevTime = 0;
        const controller = this._playerController.getPointController();
        if (controller) {
          switch (controller.getPlayerState()) {
            case AVATAR_ANIMATION_ENUM.WALK:
              addSetpNumSocket(1);
              break;
            case AVATAR_ANIMATION_ENUM.RUN:
              addSetpNumSocket(2);
              break;
          }
        }
      }
      this._scene.render();
      update();
    };
    this._resizeHandler = () => {
      this._engine.resize();
    };
    if (options && options.token) {
      this._token = options.token;
    } else {
      this._token = "";
    }
    if (options && options.loginWss) {
      this._loginWss = options.loginWss;
    } else {
      this._loginWss = "";
    }
    localStorage.setItem("token", this._token);
    this._emitter = new Emitter(options && options.emitter ? options.emitter : void 0);
    ConfigHttpEmitter(this._emitter);
    this._engine = new BABYLON$1.Engine(canvas, true, void 0, true);
    const loaderPlugin = new GLTFFileLoaderExt();
    BABYLON$1.SceneLoader.RegisterPlugin(loaderPlugin);
    this._scene = new BABYLON$1.Scene(this._engine);
    this._patintedEggshellDuck = new PaintedEggshellDuck(this._scene, this._emitter);
    this._patintedEggshellDuck.duckIsMissCallback = (isMiss) => {
      if (isMiss) {
        this.attachControl();
      } else {
        this.detachControl();
      }
    };
    this._emitter.on(NjcbEventEnum.HIDE_DUCK_POPUP, () => {
      if (this._duckData) {
        this._createNewDuck(this._duckData);
        this._duckData = null;
        this._isFindDuckShow = false;
      }
    });
    this._emitter.on(NjcbEventEnum.HIDDEN_DUCK_DIALOG, () => {
      var _a2;
      this._emitter.emit(NjcbEventEnum.CAMERA_START, null);
      const start = {
        alpha: this._camera.alpha,
        beta: this._camera.beta,
        radius: this._camera.radius,
        target: this._camera.target.clone()
      };
      const end = {
        alpha: this._player.root.rotation.y - Math.PI * 0.5,
        beta: this._controllerAttribute.betaDefault,
        radius: this._controllerAttribute.cameraDistDefault,
        target: this._player.root.position.clone().addInPlace(new BABYLON$1.Vector3(0, this._controllerAttribute.yOffset, 0))
      };
      (_a2 = this._player) == null ? void 0 : _a2.root.setEnabled(true);
      CameraAnimationFromPointToPoint(this._camera, start, end, () => {
        this.attachControl();
        this._emitter.emit(NjcbEventEnum.CAMERA_END, null);
      });
    });
    this._scene.clearColor = new BABYLON$1.Color4(0.3, 0.3, 0.5, 1);
    this._camera = createCamera(this._scene);
    this._light = createLight(this._scene);
    this._ui = BABYLONGUI.AdvancedDynamicTexture.CreateFullscreenUI("maingui", true, this._scene);
    this._preload();
    StatUtil.init();
    this.start();
    window.addEventListener("resize", this._resizeHandler);
  }
  async _preload() {
    var _a2;
    BABYLON$1.DracoCompression.Configuration.decoder.wasmUrl = "https://meta.gotin.online/assets/game_porsche/draco/draco_wasm_wrapper_gltf.js";
    BABYLON$1.DracoCompression.Configuration.decoder.wasmBinaryUrl = "https://meta.gotin.online/assets/game_porsche/draco/draco_decoder_gltf.wasm";
    BABYLON$1.DracoCompression.Configuration.decoder.fallbackUrl = "https://meta.gotin.online/assets/game_porsche/draco/draco_decoder_gltf.js";
    this._manager = new Manager(() => {
    }, () => {
      this._emitter.emit(NjcbEventEnum.WRONG_NET_WORK, WrongNetwork.loadfailed);
    }, () => {
    });
    new AssetLoadingView(this._scene, this._ui, this._manager, ConfigAsset.loading, () => {
      var _a3;
      this._enter();
      (_a3 = this._emitter) == null ? void 0 : _a3.emit(NjcbEventEnum.SCENE_ENTER, { guide: this._guide, gatewayAddr: this._gatewayAddr, gatewaySslPort: this._gatewaySslPort });
    });
    if (this._loginWss === "") {
      this._emitter.emit(NjcbEventEnum.WRONG_NET_WORK, WrongNetwork.disconnection);
      return;
    }
    const { accountName, ticket, gatewayAddr, gatewayPort, gatewaySslPort } = await loginGame(this._loginWss, this._token, this._emitter);
    if (accountName === "" || ticket === "" || gatewayAddr === "" || gatewayPort === 0 || gatewaySslPort === 0) {
      this._emitter.emit(NjcbEventEnum.WRONG_NET_WORK, WrongNetwork.disconnection);
      return;
    }
    this._gatewayAddr = gatewayAddr;
    this._gatewaySslPort = gatewaySslPort;
    setUrlAndPort(gatewayAddr, gatewaySslPort);
    const { socket: socket2, player } = await gateWay(accountName, ticket, gatewayAddr, gatewayPort, this._token, this._emitter);
    this._palyerData = player.basic;
    this._engine.runRenderLoop(this.heartBeat.bind(this));
    StatUtil.setUser(accountName);
    notifyClientRefreshDuckSocket((data) => {
      this._duckData = data;
      this._calculateDuckPostion(data);
      this._eggDuckTime = 0;
      this._emitter.emit(NjcbEventEnum.CAMERA_START, null);
    });
    notifyRefreshDuckSocket((data) => {
      var _a3;
      const duckInfo = JSON.parse(data.duckStr);
      (_a3 = this._duckPond) == null ? void 0 : _a3.updateDucksInPond(duckInfo);
    });
    if (((_a2 = this._palyerData) == null ? void 0 : _a2.userState) === 0) {
      this._guide = true;
    } else {
      this._guide = false;
    }
    const assetLoaderInstance = assetLoader(this._scene);
    const assetTask = new Task(assetLoaderInstance);
    this._avatarAsset = { rootUrl: ConfigAsset.avatar.model.rootUrl, file: ConfigAsset.avatar.model.file };
    assetTask.add(this._avatarAsset);
    this._showGroundAsset = { rootUrl: ConfigAsset.showGround.rootUrl, file: ConfigAsset.showGround.file };
    assetTask.add(this._showGroundAsset);
    this._interactGroundAsset = { rootUrl: ConfigAsset.interactGround.rootUrl, file: ConfigAsset.interactGround.file };
    assetTask.add(this._interactGroundAsset);
    this._collisionGroundAsset = { rootUrl: ConfigAsset.collisionGround.rootUrl, file: ConfigAsset.collisionGround.file };
    assetTask.add(this._collisionGroundAsset);
    this._duckPolygonAsset = { rootUrl: ConfigAsset.pondDuck.model.rootUrl, file: ConfigAsset.pondDuck.model.file };
    assetTask.add(this._duckPolygonAsset);
    assetTask.add(this._patintedEggshellDuck.duckAsset);
    this._cloudsAsset = { rootUrl: ConfigAsset.clouds.rootUrl, file: ConfigAsset.clouds.file };
    assetTask.add(this._cloudsAsset);
    this._guangGaoYaAsset = { rootUrl: ConfigAsset.guangGaoYa.rootUrl, file: ConfigAsset.guangGaoYa.file };
    assetTask.add(this._guangGaoYaAsset);
    this._manager.add(assetTask);
    const configLoader = config_loader("https://meta.gotin.online/njyh/config/Client/", this._config);
    const configTask = new Task(configLoader);
    configTask.add("avatar.json");
    configTask.add("dialogue.json");
    configTask.add("model.json");
    configTask.add("npc.json");
    configTask.add("scattered.json");
    configTask.add("scattered1.json");
    configTask.add("voice.json");
    configTask.add("diary.json");
    configTask.add("exchange.json");
    configTask.add("goods.json");
    configTask.add("home.json");
    configTask.add("popUp.json");
    configTask.add("shop.json");
    configTask.add("task.json");
    configTask.add("tips.json");
    this._manager.add(configTask);
    const fnLoaderInstance = fnLoader();
    const fnLoaderTask = new Task(fnLoaderInstance);
    fnLoaderTask.add(() => {
      this._awake();
    });
    fnLoaderTask.add(() => {
      ChangeMaterial(this._scene);
      this._emitter.on(NjcbEventEnum.GET_CONFIG, (data) => {
        data.config = this._config;
      });
    });
    fnLoaderTask.add(() => {
      var _a3, _b2, _c2;
      const event = [];
      event.push({ type: 1, id: (_a3 = this._palyerData) == null ? void 0 : _a3.headImagId });
      event.push({ type: 2, id: (_b2 = this._palyerData) == null ? void 0 : _b2.coatImagId });
      event.push({ type: 3, id: (_c2 = this._palyerData) == null ? void 0 : _c2.trousersImagId });
      this._changRole(event);
    });
    this._manager.add(fnLoaderTask);
    this._manager.start();
  }
  _awake() {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j;
    ShowGround(this._scene, this._showGroundAsset);
    CollisionGround(this._scene, this._collisionGroundAsset);
    (_b2 = (_a2 = this._cloudsAsset) == null ? void 0 : _a2.asset) == null ? void 0 : _b2.addAllToScene();
    (_d = (_c2 = this._guangGaoYaAsset) == null ? void 0 : _c2.asset) == null ? void 0 : _d.addAllToScene();
    const avatarAsset = (_e = this._avatarAsset) == null ? void 0 : _e.asset;
    if (!avatarAsset) {
      return;
    }
    const avatar = new Avatar(this._scene, avatarAsset, ConfigAsset.avatar.texture);
    this._avatar = avatar;
    this._player = CreatePlayer(avatar);
    this._emitter.on(NjcbEventEnum.ChangeRole, (event) => {
      this._changRole(event);
    });
    const scattered = this._config.scattered || {};
    for (const key in scattered) {
      if (key === "offset") {
        scattered.x_offset = parseInt(scattered[key][1]) || 0;
        scattered.y_offset = parseInt(scattered[key][3]) || 0;
        scattered.z_offset = parseInt(scattered[key][5]) || 0;
      } else {
        scattered[key] = parseInt(scattered[key]);
      }
    }
    const config = __spreadValues(__spreadValues({}, ConfigController), this._config.scattered);
    this._controllerAttribute = GetControlAttributeByConfig(config);
    this._playerController = new Controller(this._scene, this._camera, this._player, this._controllerAttribute);
    this._camera.target.copyFrom(this._player.root.position.add(new BABYLON$1.Vector3(0, this._controllerAttribute.yOffset, 0)));
    this._camera.radius = 200;
    this._npcs = CreateNpc(this._scene, this._interactGroundAsset, this._player, avatar, ConvertNpcConfig(this._config.npc), ConvertNpcModel(this._config.model), this._config.avatar);
    const pathData = ((_f = ConfigNpc.find((n) => n.name === "N7")) == null ? void 0 : _f.pathData) || void 0;
    if (this._npcs["N7"].avatar) {
      let rangeHot = 5;
      if ((_g = this._npcs["N7"].npcConfig) == null ? void 0 : _g.rangeHot) {
        rangeHot = (_h = this._npcs["N7"].npcConfig) == null ? void 0 : _h.rangeHot;
      }
      new AiNpcMove(this._scene, this._camera, this._npcs["N7"].avatar, pathData, void 0, this._player, rangeHot);
    }
    this._raycast = new Raycast(this._emitter, this._scene, this._camera, this._player, this._playerController, this._npcs, this._controllerAttribute.lookSpeed);
    this._minimap = new Minimap(this._scene, this._ui, this._player);
    if (this._duckPolygonAsset && this._duckPolygonAsset.asset) {
      this._duckPond = new DuckPond(this._scene, this._duckPolygonAsset.asset, ((_i = this._palyerData) == null ? void 0 : _i.duckList) || []);
    }
    (_j = this._palyerData) == null ? void 0 : _j.noTouchDuckList.forEach((duckInfo) => {
      const duckPosition = new BABYLON$1.Vector3(duckInfo.x, 0.2, duckInfo.y);
      const duckRotation = new BABYLON$1.Vector3(0, duckInfo.direct, 0);
      this._patintedEggshellDuck.createNewDuck(this._scene, duckPosition, duckRotation, this._player, duckInfo.id, duckInfo.duckId);
    });
  }
  _testCaiDanYa() {
    window.setTimeout(() => {
      const data = { dialogId: 3005, duckid: "test" };
      this._duckData = data;
      this._calculateDuckPostion(data);
      this._eggDuckTime = 0;
    }, 1e4);
  }
  _updatePlayer() {
    if (this._player && this._currentAssetOption && this._avatar) {
      UpdateAvatarAssetOption("player", this._player, this._avatar, this._currentAssetOption);
    }
  }
  _enter() {
    var _a2;
    SoundManager.getInstance().loadAll(this._ui, this._config.voice);
    if (this._guide && this._npcs && this._npcs["N1"].avatar && this._player && this._playerController) {
      const targetPos = this._npcs["N1"].avatar.root.position;
      const start = {
        alpha: this._camera.alpha,
        beta: this._camera.beta,
        radius: this._camera.radius,
        target: targetPos.clone()
      };
      const end = {
        alpha: Math.PI * 0.5,
        beta: this._controllerAttribute.betaDefault,
        radius: 10,
        target: targetPos.clone()
      };
      CameraAnimationFlyToTarget(this._camera, start, end, () => {
        this._emitter.emit(NjcbEventEnum.START_GUID, {});
        this._emitter.on(NjcbEventEnum.END_GUID, ({ toAvatar }) => {
          var _a3;
          if (this._playerController && this._player) {
            if (toAvatar) {
              endGuideAnimation(this._player, this._camera, this._playerController, () => {
                this.attachControl();
              });
              const yOffset = this._playerController._controlAttribute.yOffset || 0;
              this._camera.target.y = this._player.root.position.y + yOffset;
              (_a3 = this._minimap) == null ? void 0 : _a3.animalShow();
              SoundManager.getInstance().showSoundIconAndPlay();
            } else {
              const start2 = {
                alpha: this._camera.alpha,
                beta: this._camera.beta,
                radius: this._camera.radius,
                target: this._camera.target.clone()
              };
              const end2 = {
                alpha: this._player.root.rotation.y - Math.PI * 0.5,
                beta: this._controllerAttribute.betaDefault,
                radius: this._controllerAttribute.cameraDistDefault,
                target: this._player.root.position.clone().addInPlace(new BABYLON$1.Vector3(0, this._controllerAttribute.yOffset, 0))
              };
              CameraAnimationFromPointToPoint(this._camera, start2, end2, () => {
                var _a4;
                SoundManager.getInstance().showSoundIconAndPlay();
                this.attachControl();
                (_a4 = this._minimap) == null ? void 0 : _a4.animalShow();
              });
            }
          }
        });
      });
    } else {
      const playerPos = (_a2 = this._player) == null ? void 0 : _a2.root.position;
      const offset = new BABYLON$1.Vector3(0, this._controllerAttribute.yOffset, 0);
      const targetPos = playerPos ? playerPos.add(offset) : new BABYLON$1.Vector3();
      const start = {
        alpha: this._camera.alpha,
        beta: this._camera.beta,
        radius: 120,
        target: targetPos
      };
      const end = {
        alpha: Math.PI * 0.5,
        beta: this._controllerAttribute.betaDefault,
        radius: this._controllerAttribute.cameraDistDefault,
        target: targetPos
      };
      CameraAnimationFromPointToPoint(this._camera, start, end, () => {
        var _a3;
        SoundManager.getInstance().showSoundIconAndPlay();
        this.attachControl();
        (_a3 = this._minimap) == null ? void 0 : _a3.animalShow();
      });
    }
  }
  dispose() {
    var _a2, _b2;
    (_a2 = this._minimap) == null ? void 0 : _a2.dispose();
    this._emitter.dispose();
    window.removeEventListener("resize", this._resizeHandler);
    (_b2 = this._playerController) == null ? void 0 : _b2.detachControl();
    SoundManager.getInstance().clear();
    StatUtil.clear();
    this._engine.dispose();
  }
  start() {
    if (this._isStarted) {
      return;
    }
    SoundManager.getInstance().resume();
    this._engine.runRenderLoop(this._renderLoopHandler);
    StatUtil.bind(this._scene);
    this._isStarted = true;
  }
  stop() {
    if (!this._isStarted) {
      return;
    }
    SoundManager.getInstance().rest();
    StatUtil.unbind();
    this._engine.stopRenderLoop(this._renderLoopHandler);
    this._isStarted = false;
  }
  attachControl(option = {}) {
    var _a2, _b2;
    if (this._isAttached) {
      return;
    }
    (_a2 = this._playerController) == null ? void 0 : _a2.attachControl(option);
    (_b2 = this._raycast) == null ? void 0 : _b2.attachControl();
    this._isAttached = true;
  }
  detachControl() {
    var _a2, _b2;
    if (!this._isAttached) {
      return;
    }
    (_a2 = this._playerController) == null ? void 0 : _a2.detachControl();
    (_b2 = this._raycast) == null ? void 0 : _b2.detachControl();
    this._isAttached = false;
  }
  _changRole(event) {
    const asset = ConvertEventIntoAvatarAsset(this._config.avatar, event);
    if (asset) {
      this._currentAssetOption = asset;
      this._updatePlayer();
    }
  }
  _timeCanNewDuck() {
    if (!this._isFindDuckShow && this._duckData) {
      this._emitter.emit(NjcbEventEnum.SHOW_DUCK_POPUP, { id: 20047 });
      this._isFindDuckShow = true;
    }
  }
  _calculateDuckPostion(data) {
    this.detachControl();
    if (this._player) {
      ChangeActiveImageVisible(this._player, true);
      let forward = this._player.root.forward.clone();
      const playerPosition = this._player.root.position.clone();
      const ray = new BABYLON$1.Ray(new BABYLON$1.Vector3(playerPosition.x, 0, playerPosition.z), BABYLON$1.Vector3.Zero(), 3);
      const playerForward = this._player.root.forward.clone();
      for (let i = 0; i < 8; i++) {
        const angleNumber = i * Math.PI / 4;
        const quaternion = BABYLON$1.Quaternion.RotationAxis(BABYLON$1.Axis.Y, angleNumber).normalize();
        const endPostion = playerForward.applyRotationQuaternion(quaternion).normalize();
        ray.direction = endPostion.clone();
        ray.origin = playerPosition.clone().add(endPostion.clone().scale(0.5));
        ray.origin.y = 0.5;
        const pickInfo = ray.intersectsMeshes(this._scene.meshes.filter((mesh) => mesh.checkCollisions));
        if (pickInfo.length === 0) {
          forward = endPostion.clone();
          break;
        }
      }
      const duckPostion = this._player.root.position.add(forward.clone().scale(3));
      duckPostion.y = 0.2;
      const duckForward = forward.clone().scale(-1);
      const angle = Math.atan2(duckForward.z, duckForward.x);
      const duckRotation = new BABYLON$1.Vector3(0, angle, 0);
      eggDuckUpdate({
        duckId: data.duckid,
        x: duckPostion.x,
        y: duckPostion.z,
        direction: duckRotation.y
      });
      this._duckPosition = duckPostion;
      this._duckRotation = duckRotation;
    }
  }
  _createNewDuck(data) {
    var _a2;
    ChangeActiveImageVisible(this._player, false);
    (_a2 = this._player) == null ? void 0 : _a2.root.setEnabled(false);
    const start = {
      alpha: this._camera.alpha,
      beta: this._camera.beta,
      radius: this._camera.radius,
      target: this._camera.target.clone()
    };
    const end = {
      alpha: this._duckRotation.y,
      beta: this._camera.beta,
      radius: 10,
      target: this._duckPosition.clone()
    };
    this._emitter.emit(NjcbEventEnum.CAMERA_START, null);
    CameraAnimationFromPointToPoint(this._camera, start, end, () => {
      this._patintedEggshellDuck.createNewDuck(this._scene, this._duckPosition.clone(), this._duckRotation.clone(), this._player, data.duckid, data.dialogId, true);
    }, 500);
  }
  heartBeat() {
    this._prevHeartTime = this._scene.getEngine().getDeltaTime() / 1e3 + this._prevHeartTime;
    if (this._prevHeartTime > 1) {
      this._prevHeartTime = 0;
      sendHeartBeat();
    }
  }
}
class AssetManager {
  constructor(scene, onError) {
    this.hasLoadingError = false;
    this.isSyncLoadingComplete = true;
    this.syncLoadingProgress = 1;
    this.isAsyncLoadingComplete = true;
    this.asyncLoadingProgress = 1;
    this.loadingTime = 0;
    this._syncAssetList = [];
    this._asyncAssetList = [];
    this._currentLoadingNumber = 0;
    this._scene = scene;
    this._onError = onError;
  }
  update() {
    if (this.isSyncLoadingComplete && this.isAsyncLoadingComplete) {
      return;
    }
    if (this.hasLoadingError) {
      console.error("asset loading error!");
      return;
    }
    this.loadingTime += this._scene.getEngine().getDeltaTime();
    if (this._currentLoadingNumber > 2) {
      return;
    }
    for (let i = 0; i < this._syncAssetList.length; i++) {
      if (!this._syncAssetList[i].asset && !this._syncAssetList[i].reload) {
        this._syncAssetList[i].reload = 1;
        this._updateLoadAsset(this._syncAssetList[i]);
        return;
      }
    }
    for (let i = 0; i < this._asyncAssetList.length; i++) {
      if (!this._asyncAssetList[i].asset && !this._asyncAssetList[i].reload) {
        this._asyncAssetList[i].reload = 1;
        this._updateLoadAsset(this._syncAssetList[i]);
        return;
      }
    }
  }
  addSyncAsset(asset) {
    this._syncAssetList.push(asset);
    this.isSyncLoadingComplete = false;
    this.syncLoadingProgress = this._getSyncLoadingProgress();
  }
  clearSyncAsset() {
    this._syncAssetList = [];
  }
  addAsyncAsset(asset, priority) {
    asset.priority = priority;
    this._asyncAssetList.push(asset);
    this.isAsyncLoadingComplete = false;
  }
  _updateLoadAsset(asset) {
    this._currentLoadingNumber++;
    BABYLON$1.SceneLoader.LoadAssetContainer(asset.rootUrl, asset.file, this._scene, (container) => {
      asset.asset = container;
      this.syncLoadingProgress = this._getSyncLoadingProgress();
      this.asyncLoadingProgress = this._getAsyncLoadingProgress();
      this._currentLoadingNumber--;
    }, null, () => {
      if (asset.reload === void 0) {
        asset.reload = 1;
      }
      if (asset.reload < 3) {
        asset.reload++;
        this._updateLoadAsset(asset);
      } else {
        this.hasLoadingError = true;
        this._onError && this._onError();
        this._onError = null;
      }
    });
  }
  _getSyncLoadingProgress() {
    const total = this._syncAssetList.length;
    if (total === 0) {
      return 1;
    }
    let totalComplete = 0;
    for (let i = 0; i < this._syncAssetList.length; i++) {
      if (this._syncAssetList[i].asset) {
        totalComplete++;
      }
    }
    if (total === totalComplete) {
      this.isSyncLoadingComplete = true;
    }
    return totalComplete / total;
  }
  _getAsyncLoadingProgress() {
    const total = this._asyncAssetList.length;
    if (total === 0) {
      return 1;
    }
    let totalComplete = 0;
    for (let i = 0; i < this._asyncAssetList.length; i++) {
      if (this._asyncAssetList[i].asset) {
        totalComplete++;
      }
    }
    if (total === totalComplete) {
      this.isAsyncLoadingComplete = true;
    }
    return totalComplete / total;
  }
  static loadAsset(scene, asset, onSuccess, onError) {
    BABYLON$1.SceneLoader.LoadAssetContainer(asset.rootUrl, asset.file, scene, (container) => {
      onSuccess && onSuccess(container);
    }, null, () => {
      onError && onError();
    });
  }
}
const DuckOffset = {
  litteDuck: {
    u: 0,
    v: 0.5
  },
  smallDuck: {
    u: 0.5,
    v: 0
  },
  matureDuck: {
    u: 0,
    v: 0
  }
};
class Duck {
  constructor(canvas, options) {
    this._isStart = false;
    this._currentGrowth = -1;
    this._hasLoaded = false;
    this._riseDuckListener = (event) => {
      console.warn("DuckGame recevie RiseDuck:", event);
      if (!(event instanceof Array)) {
        const growth = event.percentage;
        this._currentGrowth = growth;
        this._riseDuck(growth);
      }
    };
    this._changeDuckListener = (event) => {
      console.warn("DuckGame recevie ChangeDuck:", event);
      if (!(event instanceof Array)) {
        const growth = event.percentage;
        this._currentGrowth = growth;
        this._switchDuck(growth);
      }
    };
    this._nameFunc = (name2) => {
      return name2;
    };
    this._renderLoopHandler = () => {
      this._scene.render();
    };
    this._emitter = new Emitter(options && options.emitter ? options.emitter : void 0);
    this._engine = new BABYLON$1.Engine(canvas, true, void 0, true);
    this._scene = new BABYLON$1.Scene(this._engine);
    if (options == null ? void 0 : options.percentage) {
      this._currentGrowth = options.percentage;
    }
    const texture = new BABYLON$1.Texture(ConfigAsset.duck.texture, this._scene);
    texture.level = 1.1;
    texture.vScale = -1;
    this._material = new BABYLON$1.StandardMaterial("material_duck", this._scene);
    this._material.specularColor = BABYLON$1.Color3.Black();
    this._material.diffuseTexture = texture;
    this._createCamera(this._scene);
    const light1 = new BABYLON$1.HemisphericLight("light1", new BABYLON$1.Vector3(0, 1, 0), this._scene);
    light1.intensity = 1.2;
    const light2 = new BABYLON$1.HemisphericLight("light2", new BABYLON$1.Vector3(0, -1, 0), this._scene);
    light2.intensity = 1;
    this._scene.clearColor = new BABYLON$1.Color4(0, 0, 0, 0);
    this._initEmitter();
    this._preload();
    this.start();
  }
  _preload() {
    console.warn("DuckGame, loadAsset");
    AssetManager.loadAsset(this._scene, ConfigAsset.duck.model, (container) => {
      console.warn("DuckGame, loadAsset, done");
      this._originDuck = container;
      this._hasLoaded = true;
      this._switchDuck(this._currentGrowth);
    });
  }
  _getDuck(growth) {
    if (this._originDuck) {
      if (growth < 0) {
        return void 0;
      } else if (growth < 0.5) {
        if (this._litteDuck === void 0) {
          this._litteDuck = this._createDuck("litte_duck", 0.48, DuckOffset.litteDuck);
          this._litteDuck.rootNodes[0].setEnabled(false);
          this._lookAtCamera(this._litteDuck);
        }
        return this._litteDuck;
      } else if (growth < 1) {
        if (this._smallDuck === void 0) {
          this._smallDuck = this._createDuck("small_duck", 0.64, DuckOffset.smallDuck);
          this._smallDuck.rootNodes[0].setEnabled(false);
          this._lookAtCamera(this._smallDuck);
        }
        return this._smallDuck;
      } else {
        if (this._matureDuck === void 0) {
          this._matureDuck = this._createDuck("mature_duck", 0.8, DuckOffset.matureDuck);
          this._matureDuck.rootNodes[0].setEnabled(false);
          this._lookAtCamera(this._matureDuck);
        }
        return this._matureDuck;
      }
    }
    return void 0;
  }
  _createDuck(name2, scale, uv) {
    if (this._originDuck) {
      const duck = this._originDuck.instantiateModelsToScene(this._nameFunc, true);
      duck.rootNodes[0].scaling.set(scale, scale, scale);
      this._setDuckMaterial(name2, duck.rootNodes[0], uv);
      return duck;
    } else {
      throw new Error("Error: DuckGame, _creatDuck");
    }
  }
  _initEmitter() {
    this._emitter.on(NjcbEventEnum.RiseDuck, this._riseDuckListener);
    this._emitter.on(NjcbEventEnum.ChangeDuck, this._changeDuckListener);
  }
  _riseDuck(growth) {
    var _a2;
    if (!this._hasLoaded) {
      return;
    }
    const oldDuck = this._currentDuck;
    (_a2 = this._currentDuck) == null ? void 0 : _a2.rootNodes[0].setEnabled(false);
    this._currentDuck = this._getDuck(growth);
    if (this._currentDuck) {
      this._currentDuck.rootNodes[0].setEnabled(true);
      if (this._currentDuck !== oldDuck) {
        this._lookAtCamera(this._currentDuck);
      }
    }
    this._playDuckAnim("Duck_feeding");
  }
  _playDuckAnim(animalName, loop = false) {
    var _a2, _b2;
    if (!this._hasLoaded) {
      return;
    }
    (_a2 = this._currentDuck) == null ? void 0 : _a2.animationGroups.forEach((animal) => {
      animal.reset();
    });
    const anim = (_b2 = this._currentDuck) == null ? void 0 : _b2.animationGroups.find((ani) => {
      return (ani == null ? void 0 : ani.name) === animalName;
    });
    anim == null ? void 0 : anim.play(loop);
  }
  _switchDuck(growth) {
    var _a2;
    if (!this._hasLoaded) {
      return;
    }
    (_a2 = this._currentDuck) == null ? void 0 : _a2.rootNodes[0].setEnabled(false);
    this._currentDuck = this._getDuck(growth);
    if (this._currentDuck) {
      this._currentDuck.rootNodes[0].setEnabled(true);
      this._lookAtCamera(this._currentDuck);
    }
    this._playDuckAnim("Duck_idle", true);
  }
  _lookAtCamera(duck) {
    if (this._camera) {
      const postion = this._camera.position.clone();
      postion.y = 0;
      duck.rootNodes[0].lookAt(postion);
    }
  }
  _createCamera(scene) {
    const canvas = scene.getEngine().getRenderingCanvas();
    const camera = new BABYLON$1.ArcRotateCamera("camera", Math.PI * 0.5, 1, 5, BABYLON$1.Vector3.Zero(), scene);
    const input = camera.inputs.attached.pointers;
    input.buttons = [0];
    input.multiTouchPanning = false;
    input.multiTouchPanAndZoom = false;
    camera.attachControl(canvas, false);
    camera.target = new BABYLON$1.Vector3(0, 1, 0);
    camera.radius = 5;
    camera.upperRadiusLimit = camera.radius;
    camera.lowerRadiusLimit = camera.radius;
    camera.alpha = Math.PI * -0.5;
    camera.beta = Math.PI * 0.5;
    camera.lowerBetaLimit = camera.beta;
    camera.upperBetaLimit = camera.beta;
    camera.wheelPrecision = 50;
    this._camera = camera;
    return camera;
  }
  _setMaterial(name2, mesh, textureConfig) {
    mesh.material = this._material.clone(name2);
    (mesh == null ? void 0 : mesh.material).diffuseTexture.uOffset = textureConfig.u;
    (mesh == null ? void 0 : mesh.material).diffuseTexture.vOffset = textureConfig.v;
  }
  _setDuckMaterial(name2, node, config) {
    const meshes = node.getChildren()[0].getChildMeshes(void 0, (child) => {
      return child.name.startsWith("Duck_");
    });
    meshes.forEach((mesh) => {
      this._setMaterial(name2, mesh, config);
    });
  }
  dispose() {
    console.warn("DuckGame, dispose");
    this._emitter.off(NjcbEventEnum.ChangeDuck, this._riseDuckListener);
    this._emitter.off(NjcbEventEnum.RiseDuck, this._changeDuckListener);
    this._scene.dispose();
    this._engine.dispose();
    this._emitter.dispose();
  }
  start() {
    if (this._isStart) {
      return;
    }
    this._engine.runRenderLoop(this._renderLoopHandler);
    this._isStart = true;
  }
  stop() {
    if (!this._isStart) {
      return;
    }
    this._engine.stopRenderLoop(this._renderLoopHandler);
    this._isStart = false;
  }
  attachControl() {
  }
  detachControl() {
  }
}
class AvatarGame {
  constructor(canvas, options) {
    this._isStart = false;
    this._data = { config: {} };
    this._renderLoopHandler = () => {
      this._scene.render();
    };
    this._emitter = new Emitter(options && options.emitter ? options.emitter : void 0);
    this._emitter.emit(NjcbEventEnum.GET_CONFIG, this._data);
    this._engine = new BABYLON$1.Engine(canvas, true, void 0, true);
    this._scene = new BABYLON$1.Scene(this._engine);
    this._avatarAsset = { rootUrl: ConfigAsset.avatar.model.rootUrl, file: ConfigAsset.avatar.model.file };
    this._createCamera(this._scene);
    const light1 = new BABYLON$1.HemisphericLight("light1", new BABYLON$1.Vector3(0, 1, 0), this._scene);
    light1.intensity = 1.1;
    const light2 = new BABYLON$1.HemisphericLight("light2", new BABYLON$1.Vector3(0, -1, 0), this._scene);
    light2.intensity = 0.7;
    this._scene.clearColor = new BABYLON$1.Color4(0, 0, 0, 0);
    this._initEmitter();
    this._preload();
    this.start();
  }
  get _config() {
    return this._data.config;
  }
  _initEmitter() {
    this._emitter.on(NjcbEventEnum.ChangeRole, (event) => {
      console.warn("AvatarGame recevie ChangeRole:", event);
      const asset = ConvertEventIntoAvatarAsset(this._config.avatar, event);
      if (asset) {
        this._currentAssetOption = asset;
        this._createOrUpdatePlayer();
      }
    });
  }
  _createCamera(scene) {
    const canvas = scene.getEngine().getRenderingCanvas();
    const camera = new BABYLON$1.ArcRotateCamera("camera", Math.PI * 0.5, 1, 8, BABYLON$1.Vector3.Zero(), scene);
    const input = camera.inputs.attached.pointers;
    input.buttons = [0];
    input.multiTouchPanning = false;
    input.multiTouchPanAndZoom = false;
    camera.attachControl(canvas, false);
    camera.target = new BABYLON$1.Vector3(0, 0, 0);
    camera.radius = 4;
    camera.upperRadiusLimit = camera.radius;
    camera.lowerRadiusLimit = camera.radius;
    camera.alpha = 0;
    camera.beta = Math.PI / 2;
    camera.lowerBetaLimit = camera.beta;
    camera.upperBetaLimit = camera.beta;
    camera.wheelPrecision = 50;
    return camera;
  }
  _preload() {
    BABYLON$1.DracoCompression.Configuration.decoder.wasmUrl = "https://meta.gotin.online/assets/game_porsche/draco/draco_wasm_wrapper_gltf.js";
    BABYLON$1.DracoCompression.Configuration.decoder.wasmBinaryUrl = "https://meta.gotin.online/assets/game_porsche/draco/draco_decoder_gltf.wasm";
    BABYLON$1.DracoCompression.Configuration.decoder.fallbackUrl = "https://meta.gotin.online/assets/game_porsche/draco/draco_decoder_gltf.js";
    AssetManager.loadAsset(this._scene, this._avatarAsset, (container) => {
      this._avatarAsset.asset = container;
      const avatarAsset = this._avatarAsset.asset;
      const avatar = new Avatar(this._scene, avatarAsset, ConfigAsset.avatar.texture);
      this._avatar = avatar;
      this._createOrUpdatePlayer();
    });
  }
  _createOrUpdatePlayer() {
    if (this._avatar && this._currentAssetOption) {
      if (this._player) {
        UpdateAvatarAssetOption("player", this._player, this._avatar, this._currentAssetOption);
      } else {
        this._player = this._createPlayer(this._avatar);
      }
    }
  }
  _createPlayer(avatar) {
    const player = avatar.CreateAvatar("player", void 0, void 0, this._currentAssetOption);
    player.root.position.set(0, 0, 0);
    player.root.rotation.y = 0.5 * Math.PI;
    player.root.isPickable = false;
    player.root.checkCollisions = true;
    return player;
  }
  dispose() {
    console.warn("AvatarGame, dispose");
    this._scene.dispose();
    this._engine.dispose();
    this._emitter.dispose();
  }
  start() {
    if (this._isStart) {
      return;
    }
    this._engine.runRenderLoop(this._renderLoopHandler);
    this._isStart = true;
  }
  stop() {
    if (!this._isStart) {
      return;
    }
    this._engine.stopRenderLoop(this._renderLoopHandler);
    this._isStart = false;
  }
  attachControl() {
  }
  detachControl() {
  }
}
export { AvatarGame, Duck, Game };
